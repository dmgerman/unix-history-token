begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Bruce Simpson.  * Copyright (c) 2005 Robert N. M. Watson.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * IPv4 multicast socket, group, and socket option processing module.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp_var.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_IGMPV3
end_ifndef

begin_define
define|#
directive|define
name|KTR_IGMPV3
value|KTR_INET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__SOCKUNION_DECLARED
end_ifndef

begin_union
union|union
name|sockunion
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|sockunion
name|sockunion_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__SOCKUNION_DECLARED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SOCKUNION_DECLARED */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_INMFILTER
argument_list|,
literal|"in_mfilter"
argument_list|,
literal|"IPv4 multicast PCB-layer source filter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMADDR
argument_list|,
literal|"in_multi"
argument_list|,
literal|"IPv4 multicast group"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMOPTS
argument_list|,
literal|"ip_moptions"
argument_list|,
literal|"IPv4 multicast options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMSOURCE
argument_list|,
literal|"ip_msource"
argument_list|,
literal|"IPv4 multicast IGMP-layer source filter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Locking:  * - Lock order is: Giant, INP_WLOCK, IN_MULTI_LOCK, IGMP_LOCK, IF_ADDR_LOCK.  * - The IF_ADDR_LOCK is implicitly taken by inm_lookup() earlier, however  *   it can be taken by code in net/if.c also.  * - ip_moptions and in_mfilter are covered by the INP_WLOCK.  *  * struct in_multi is covered by IN_MULTI_LOCK. There isn't strictly  * any need for in_multi itself to be virtualized -- it is bound to an ifp  * anyway no matter what happens.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|in_multi_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|in_multi_mtx
argument_list|,
operator|&
name|in_multi_mtx
argument_list|,
literal|"in_multi_mtx"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Functions with non-static linkage defined in this file should be  * declared in in_var.h:  *  imo_multi_filter()  *  in_addmulti()  *  in_delmulti()  *  in_joingroup()  *  in_joingroup_locked()  *  in_leavegroup()  *  in_leavegroup_locked()  * and ip_var.h:  *  inp_freemoptions()  *  inp_getmoptions()  *  inp_setmoptions()  *  * XXX: Both carp and pf need to use the legacy (*,G) KPIs in_addmulti()  * and in_delmulti().  */
end_comment

begin_function_decl
specifier|static
name|void
name|imf_commit
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imf_get_source
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|psin
parameter_list|,
name|struct
name|in_msource
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|in_msource
modifier|*
name|imf_graft
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|,
specifier|const
name|uint8_t
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|imf_leave
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imf_prune
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|imf_purge
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|imf_rollback
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|imf_reap
parameter_list|(
name|struct
name|in_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imo_grow
parameter_list|(
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|imo_match_group
parameter_list|(
specifier|const
name|struct
name|ip_moptions
modifier|*
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|in_msource
modifier|*
name|imo_match_source
parameter_list|(
specifier|const
name|struct
name|ip_moptions
modifier|*
parameter_list|,
specifier|const
name|size_t
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ims_merge
parameter_list|(
name|struct
name|ip_msource
modifier|*
name|ims
parameter_list|,
specifier|const
name|struct
name|in_msource
modifier|*
name|lims
parameter_list|,
specifier|const
name|int
name|rollback
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|in_getmulti
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
parameter_list|,
name|struct
name|in_multi
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inm_get_source
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|in_addr_t
name|haddr
parameter_list|,
specifier|const
name|int
name|noalloc
parameter_list|,
name|struct
name|ip_msource
modifier|*
modifier|*
name|pims
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_function_decl
specifier|static
name|int
name|inm_is_ifp_detached
parameter_list|(
specifier|const
name|struct
name|in_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|inm_merge
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|,
comment|/*const*/
name|struct
name|in_mfilter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inm_purge
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inm_reap
parameter_list|(
name|struct
name|in_multi
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ip_moptions
modifier|*
name|inp_findmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inp_freemoptions_internal
parameter_list|(
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|inp_gcmoptions
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_get_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_join_group
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_leave_group
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ifnet
modifier|*
name|inp_lookup_mcast_ifp
parameter_list|(
specifier|const
name|struct
name|inpcb
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
specifier|const
name|struct
name|in_addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_block_unblock_source
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_set_multicast_if
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_set_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sysctl_ip_mcast_filters
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|mcast
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"IPv4 multicast"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|in_mcast_maxgrpsrc
init|=
name|IP_MAX_GROUP_SRC_FILTER
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_ip_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|maxgrpsrc
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|in_mcast_maxgrpsrc
argument_list|,
literal|0
argument_list|,
literal|"Max source filters per group"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"net.inet.ip.mcast.maxgrpsrc"
argument_list|,
operator|&
name|in_mcast_maxgrpsrc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|in_mcast_maxsocksrc
init|=
name|IP_MAX_SOCK_SRC_FILTER
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_ip_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|maxsocksrc
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|in_mcast_maxsocksrc
argument_list|,
literal|0
argument_list|,
literal|"Max source filters per socket"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_ULONG
argument_list|(
literal|"net.inet.ip.mcast.maxsocksrc"
argument_list|,
operator|&
name|in_mcast_maxsocksrc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|in_mcast_loop
init|=
name|IP_DEFAULT_MULTICAST_LOOP
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|loop
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
operator|&
name|in_mcast_loop
argument_list|,
literal|0
argument_list|,
literal|"Loopback multicast datagrams by default"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.inet.ip.mcast.loop"
argument_list|,
operator|&
name|in_mcast_loop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip_mcast
argument_list|,
name|OID_AUTO
argument_list|,
name|filters
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|sysctl_ip_mcast_filters
argument_list|,
literal|"Per-interface stack-wide source filters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|STAILQ_HEAD
argument_list|(
argument_list|,
argument|ip_moptions
argument_list|)
name|imo_gc_list
operator|=
name|STAILQ_HEAD_INITIALIZER
argument_list|(
name|imo_gc_list
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|imo_gc_task
init|=
name|TASK_INITIALIZER
argument_list|(
literal|0
argument_list|,
name|inp_gcmoptions
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_comment
comment|/*  * Inline function which wraps assertions for a valid ifp.  * The ifnet layer will set the ifma's ifp pointer to NULL if the ifp  * is detached.  */
end_comment

begin_function
specifier|static
name|int
name|__inline
name|inm_is_ifp_detached
parameter_list|(
specifier|const
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_ifma
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifma
operator|->
name|ifma_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sanity check that netinet's notion of ifp is the 		 * same as net's. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: bad ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ifp
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Initialize an in_mfilter structure to a known state at t0, t1  * with an empty source filter list.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|imf_init
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|int
name|st0
parameter_list|,
specifier|const
name|int
name|st1
parameter_list|)
block|{
name|memset
argument_list|(
name|imf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_mfilter
argument_list|)
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|=
name|st0
expr_stmt|;
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|=
name|st1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Function for looking up an in_multi record for an IPv4 multicast address  * on a given interface. ifp must be valid. If no record found, return NULL.  * The IN_MULTI_LOCK and IF_ADDR_LOCK on ifp must be held.  */
end_comment

begin_function
name|struct
name|in_multi
modifier|*
name|inm_lookup_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in_addr
name|ina
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IF_ADDR_LOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|inm
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&((ifp)->if_multiaddrs)
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_addr
operator|.
name|s_addr
operator|==
name|ina
operator|.
name|s_addr
condition|)
break|break;
name|inm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|inm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Wrapper for inm_lookup_locked().  * The IF_ADDR_LOCK will be taken on ifp and released on return.  */
end_comment

begin_function
name|struct
name|in_multi
modifier|*
name|inm_lookup
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in_addr
name|ina
parameter_list|)
block|{
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|inm
operator|=
name|inm_lookup_locked
argument_list|(
name|ifp
argument_list|,
name|ina
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resize the ip_moptions vector to the next power-of-two minus 1.  * May be called with locks held; do not sleep.  */
end_comment

begin_function
specifier|static
name|int
name|imo_grow
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|in_multi
modifier|*
modifier|*
name|nmships
decl_stmt|;
name|struct
name|in_multi
modifier|*
modifier|*
name|omships
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|nmfilters
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|omfilters
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|size_t
name|newmax
decl_stmt|;
name|size_t
name|oldmax
decl_stmt|;
name|nmships
operator|=
name|NULL
expr_stmt|;
name|nmfilters
operator|=
name|NULL
expr_stmt|;
name|omships
operator|=
name|imo
operator|->
name|imo_membership
expr_stmt|;
name|omfilters
operator|=
name|imo
operator|->
name|imo_mfilters
expr_stmt|;
name|oldmax
operator|=
name|imo
operator|->
name|imo_max_memberships
expr_stmt|;
name|newmax
operator|=
operator|(
operator|(
name|oldmax
operator|+
literal|1
operator|)
operator|*
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newmax
operator|<=
name|IP_MAX_MEMBERSHIPS
condition|)
block|{
name|nmships
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|omships
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_multi
operator|*
argument_list|)
operator|*
name|newmax
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|nmfilters
operator|=
operator|(
expr|struct
name|in_mfilter
operator|*
operator|)
name|realloc
argument_list|(
name|omfilters
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_mfilter
argument_list|)
operator|*
name|newmax
argument_list|,
name|M_INMFILTER
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmships
operator|!=
name|NULL
operator|&&
name|nmfilters
operator|!=
name|NULL
condition|)
block|{
comment|/* Initialize newly allocated source filter heads. */
for|for
control|(
name|idx
operator|=
name|oldmax
init|;
name|idx
operator|<
name|newmax
condition|;
name|idx
operator|++
control|)
block|{
name|imf_init
argument_list|(
operator|&
name|nmfilters
index|[
name|idx
index|]
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
block|}
name|imo
operator|->
name|imo_max_memberships
operator|=
name|newmax
expr_stmt|;
name|imo
operator|->
name|imo_membership
operator|=
name|nmships
expr_stmt|;
name|imo
operator|->
name|imo_mfilters
operator|=
name|nmfilters
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmships
operator|==
name|NULL
operator|||
name|nmfilters
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nmships
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nmships
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmfilters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nmfilters
argument_list|,
name|M_INMFILTER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETOOMANYREFS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an IPv4 multicast group entry for this ip_moptions instance  * which matches the specified group, and optionally an interface.  * Return its index into the array, or -1 if not found.  */
end_comment

begin_function
specifier|static
name|size_t
name|imo_match_group
parameter_list|(
specifier|const
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|group
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|gsin
decl_stmt|;
name|struct
name|in_multi
modifier|*
modifier|*
name|pinm
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|nmships
decl_stmt|;
name|gsin
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|group
expr_stmt|;
comment|/* The imo_membership array may be lazy allocated. */
if|if
condition|(
name|imo
operator|->
name|imo_membership
operator|==
name|NULL
operator|||
name|imo
operator|->
name|imo_num_memberships
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nmships
operator|=
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
name|pinm
operator|=
operator|&
name|imo
operator|->
name|imo_membership
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nmships
condition|;
name|idx
operator|++
operator|,
name|pinm
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pinm
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|*
name|pinm
operator|)
operator|->
name|inm_ifp
operator|==
name|ifp
operator|)
operator|)
operator|&&
name|in_hosteq
argument_list|(
operator|(
operator|*
name|pinm
operator|)
operator|->
name|inm_addr
argument_list|,
name|gsin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|>=
name|nmships
condition|)
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an IPv4 multicast source entry for this imo which matches  * the given group index for this socket, and source address.  *  * NOTE: This does not check if the entry is in-mode, merely if  * it exists, which may not be the desired behaviour.  */
end_comment

begin_function
specifier|static
name|struct
name|in_msource
modifier|*
name|imo_match_source
parameter_list|(
specifier|const
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
specifier|const
name|size_t
name|gidx
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|ip_msource
name|find
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
specifier|const
name|sockunion_t
modifier|*
name|psa
decl_stmt|;
name|KASSERT
argument_list|(
name|src
operator|->
name|sa_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: !AF_INET"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|gidx
operator|!=
operator|-
literal|1
operator|&&
name|gidx
operator|<
name|imo
operator|->
name|imo_num_memberships
argument_list|,
operator|(
literal|"%s: invalid index %d\n"
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|gidx
operator|)
argument_list|)
expr_stmt|;
comment|/* The imo_mfilters array may be lazy allocated. */
if|if
condition|(
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|gidx
index|]
expr_stmt|;
comment|/* Source trees are keyed in host byte order. */
name|psa
operator|=
operator|(
specifier|const
name|sockunion_t
operator|*
operator|)
name|src
expr_stmt|;
name|find
operator|.
name|ims_haddr
operator|=
name|ntohl
argument_list|(
name|psa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform filtering for multicast datagrams on a socket by group and source.  *  * Returns 0 if a datagram should be allowed through, or various error codes  * if the socket was not a member of the group, or the source was muted, etc.  */
end_comment

begin_function
name|int
name|imo_multi_filter
parameter_list|(
specifier|const
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
specifier|const
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|group
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|size_t
name|gidx
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|gidx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|gidx
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|MCAST_NOTGMEMBER
operator|)
return|;
comment|/* 	 * Check if the source was included in an (S,G) join. 	 * Allow reception on exclusive memberships by default, 	 * reject reception on inclusive memberships by default. 	 * Exclude source only if an in-mode exclude filter exists. 	 * Include source only if an in-mode include filter exists. 	 * NOTE: We are comparing group state here at IGMP t1 (now) 	 * with socket-layer t0 (since last downcall). 	 */
name|mode
operator|=
name|imo
operator|->
name|imo_mfilters
index|[
name|gidx
index|]
operator|.
name|imf_st
index|[
literal|1
index|]
expr_stmt|;
name|ims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|gidx
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ims
operator|==
name|NULL
operator|&&
name|mode
operator|==
name|MCAST_INCLUDE
operator|)
operator|||
operator|(
name|ims
operator|!=
name|NULL
operator|&&
name|ims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|!=
name|mode
operator|)
condition|)
return|return
operator|(
name|MCAST_NOTSMEMBER
operator|)
return|;
return|return
operator|(
name|MCAST_PASS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find and return a reference to an in_multi record for (ifp, group),  * and bump its reference count.  * If one does not exist, try to allocate it, and update link-layer multicast  * filters on ifp to listen for group.  * Assumes the IN_MULTI lock is held across the call.  * Return 0 if successful, otherwise return an appropriate error code.  */
end_comment

begin_function
specifier|static
name|int
name|in_getmulti
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
name|group
parameter_list|,
name|struct
name|in_multi
modifier|*
modifier|*
name|pinm
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|gsin
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in_ifinfo
modifier|*
name|ii
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|ii
operator|=
operator|(
expr|struct
name|in_ifinfo
operator|*
operator|)
name|ifp
operator|->
name|if_afdata
index|[
name|AF_INET
index|]
expr_stmt|;
name|inm
operator|=
name|inm_lookup
argument_list|(
name|ifp
argument_list|,
operator|*
name|group
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we already joined this group, just bump the 		 * refcount and return it. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: bad refcount %d"
operator|,
name|__func__
operator|,
name|inm
operator|->
name|inm_refcount
operator|)
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|inm_refcount
expr_stmt|;
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|gsin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gsin
argument_list|)
argument_list|)
expr_stmt|;
name|gsin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsin
operator|.
name|sin_addr
operator|=
operator|*
name|group
expr_stmt|;
comment|/* 	 * Check if a link-layer group is already associated 	 * with this network-layer group on the given ifnet. 	 */
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|gsin
argument_list|,
operator|&
name|ifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* XXX ifma_protospec must be covered by IF_ADDR_LOCK */
name|IF_ADDR_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * If something other than netinet is occupying the link-layer 	 * group, print a meaningful error message and back out of 	 * the allocation. 	 * Otherwise, bump the refcount on the existing network-layer 	 * group association and return it. 	 */
if|if
condition|(
name|ifma
operator|->
name|ifma_protospec
operator|!=
name|NULL
condition|)
block|{
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_addr
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma_addr"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: ifma not AF_INET"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma_protospec"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|->
name|inm_ifma
operator|!=
name|ifma
operator|||
name|inm
operator|->
name|inm_ifp
operator|!=
name|ifp
operator|||
operator|!
name|in_hosteq
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|,
operator|*
name|group
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: ifma %p is inconsistent with %p (%s)"
argument_list|,
name|__func__
argument_list|,
name|ifma
argument_list|,
name|inm
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|group
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|inm
operator|->
name|inm_refcount
expr_stmt|;
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|IF_ADDR_WLOCK_ASSERT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* 	 * A new in_multi record is needed; allocate and initialize it. 	 * We DO NOT perform an IGMP join as the in_ layer may need to 	 * push an initial source list down to IGMP to support SSM. 	 * 	 * The initial source filter state is INCLUDE, {} as per the RFC. 	 */
name|inm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|inm
argument_list|)
argument_list|,
name|M_IPMADDR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|==
name|NULL
condition|)
block|{
name|if_delmulti_ifma
argument_list|(
name|ifma
argument_list|)
expr_stmt|;
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|inm
operator|->
name|inm_addr
operator|=
operator|*
name|group
expr_stmt|;
name|inm
operator|->
name|inm_ifp
operator|=
name|ifp
expr_stmt|;
name|inm
operator|->
name|inm_igi
operator|=
name|ii
operator|->
name|ii_igmp
expr_stmt|;
name|inm
operator|->
name|inm_ifma
operator|=
name|ifma
expr_stmt|;
name|inm
operator|->
name|inm_refcount
operator|=
literal|1
expr_stmt|;
name|inm
operator|->
name|inm_state
operator|=
name|IGMP_NOT_MEMBER
expr_stmt|;
comment|/* 	 * Pending state-changes per group are subject to a bounds check. 	 */
name|IFQ_SET_MAXLEN
argument_list|(
operator|&
name|inm
operator|->
name|inm_scq
argument_list|,
name|IGMP_MAX_STATE_CHANGES
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|)
expr_stmt|;
name|ifma
operator|->
name|ifma_protospec
operator|=
name|inm
expr_stmt|;
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Drop a reference to an in_multi record.  *  * If the refcount drops to 0, free the in_multi record and  * delete the underlying link-layer membership.  */
end_comment

begin_function
name|void
name|inm_release_locked
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: refcount is %d"
argument_list|,
name|__func__
argument_list|,
name|inm
operator|->
name|inm_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|inm
operator|->
name|inm_refcount
operator|>
literal|0
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: refcount is now %d"
argument_list|,
name|__func__
argument_list|,
name|inm
operator|->
name|inm_refcount
argument_list|)
expr_stmt|;
return|return;
block|}
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: freeing inm %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|ifma
operator|=
name|inm
operator|->
name|inm_ifma
expr_stmt|;
comment|/* XXX this access is not covered by IF_ADDR_LOCK */
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: purging ifma %p"
argument_list|,
name|__func__
argument_list|,
name|ifma
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_protospec
operator|==
name|inm
argument_list|,
operator|(
literal|"%s: ifma_protospec != inm"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifma
operator|->
name|ifma_protospec
operator|=
name|NULL
expr_stmt|;
name|inm_purge
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inm
argument_list|,
name|M_IPMADDR
argument_list|)
expr_stmt|;
name|if_delmulti_ifma
argument_list|(
name|ifma
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear recorded source entries for a group.  * Used by the IGMP code. Caller must hold the IN_MULTI lock.  * FIXME: Should reap.  */
end_comment

begin_function
name|void
name|inm_clear_recorded
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&inm->inm_srcs
argument_list|)
block|{
if|if
condition|(
name|ims
operator|->
name|ims_stp
condition|)
block|{
name|ims
operator|->
name|ims_stp
operator|=
literal|0
expr_stmt|;
operator|--
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_rec
expr_stmt|;
block|}
block|}
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_rec
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: iss_rec %d not 0"
operator|,
name|__func__
operator|,
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_rec
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record a source as pending for a Source-Group IGMPv3 query.  * This lives here as it modifies the shared tree.  *  * inm is the group descriptor.  * naddr is the address of the source to record in network-byte order.  *  * If the net.inet.igmp.sgalloc sysctl is non-zero, we will  * lazy-allocate a source node in response to an SG query.  * Otherwise, no allocation is performed. This saves some memory  * with the trade-off that the source will not be reported to the  * router if joined in the window between the query response and  * the group actually being joined on the local host.  *  * VIMAGE: XXX: Currently the igmp_sgalloc feature has been removed.  * This turns off the allocation of a recorded source entry if  * the group has not been joined.  *  * Return 0 if the source didn't exist or was already marked as recorded.  * Return 1 if the source was marked as recorded by this function.  * Return<0 if any error occured (negated errno code).  */
end_comment

begin_function
name|int
name|inm_record_source
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|in_addr_t
name|naddr
parameter_list|)
block|{
name|struct
name|ip_msource
name|find
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|find
operator|.
name|ims_haddr
operator|=
name|ntohl
argument_list|(
name|naddr
argument_list|)
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|&&
name|ims
operator|->
name|ims_stp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|inm_nsrc
operator|==
name|in_mcast_maxgrpsrc
condition|)
return|return
operator|(
operator|-
name|ENOSPC
operator|)
return|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_msource
argument_list|)
argument_list|,
name|M_IPMSOURCE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
name|ENOMEM
operator|)
return|;
name|nims
operator|->
name|ims_haddr
operator|=
name|find
operator|.
name|ims_haddr
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|inm_nsrc
expr_stmt|;
name|ims
operator|=
name|nims
expr_stmt|;
block|}
comment|/* 	 * Mark the source as recorded and update the recorded 	 * source count. 	 */
operator|++
name|ims
operator|->
name|ims_stp
expr_stmt|;
operator|++
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_rec
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to an in_msource owned by an in_mfilter,  * given its source address.  * Lazy-allocate if needed. If this is a new entry its filter state is  * undefined at t0.  *  * imf is the filter set being modified.  * haddr is the source address in *host* byte-order.  *  * SMPng: May be called with locks held; malloc must not block.  */
end_comment

begin_function
specifier|static
name|int
name|imf_get_source
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|psin
parameter_list|,
name|struct
name|in_msource
modifier|*
modifier|*
name|plims
parameter_list|)
block|{
name|struct
name|ip_msource
name|find
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|ims
operator|=
name|NULL
expr_stmt|;
name|lims
operator|=
name|NULL
expr_stmt|;
comment|/* key is host byte order */
name|find
operator|.
name|ims_haddr
operator|=
name|ntohl
argument_list|(
name|psin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|imf
operator|->
name|imf_nsrc
operator|==
name|in_mcast_maxsocksrc
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_msource
argument_list|)
argument_list|,
name|M_INMFILTER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|nims
expr_stmt|;
name|lims
operator|->
name|ims_haddr
operator|=
name|find
operator|.
name|ims_haddr
expr_stmt|;
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|imf
operator|->
name|imf_nsrc
expr_stmt|;
block|}
operator|*
name|plims
operator|=
name|lims
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Graft a source entry into an existing socket-layer filter set,  * maintaining any required invariants and checking allocations.  *  * The source is marked as being in the new filter mode at t1.  *  * Return the pointer to the new node, otherwise return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|in_msource
modifier|*
name|imf_graft
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|uint8_t
name|st1
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|psin
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|nims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_msource
argument_list|)
argument_list|,
name|M_INMFILTER
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|nims
expr_stmt|;
name|lims
operator|->
name|ims_haddr
operator|=
name|ntohl
argument_list|(
name|psin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|=
name|st1
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|imf
operator|->
name|imf_nsrc
expr_stmt|;
return|return
operator|(
name|lims
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prune a source entry from an existing socket-layer filter set,  * maintaining any required invariants and checking allocations.  *  * The source is marked as being left at t1, it is not freed.  *  * Return 0 if no error occurred, otherwise return an errno value.  */
end_comment

begin_function
specifier|static
name|int
name|imf_prune
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|psin
parameter_list|)
block|{
name|struct
name|ip_msource
name|find
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
comment|/* key is host byte order */
name|find
operator|.
name|ims_haddr
operator|=
name|ntohl
argument_list|(
name|psin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Revert socket-layer filter set deltas at t1 to t0 state.  */
end_comment

begin_function
specifier|static
name|void
name|imf_rollback
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|tims
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
condition|)
block|{
comment|/* no change at t1 */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|!=
name|MCAST_UNDEFINED
condition|)
block|{
comment|/* revert change to existing source at t1 */
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|=
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* revert source added t1 */
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_INMFILTER
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsrc
operator|--
expr_stmt|;
block|}
block|}
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|=
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark socket-layer filter set as INCLUDE {} at t1.  */
end_comment

begin_function
specifier|static
name|void
name|imf_leave
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
block|}
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|=
name|MCAST_INCLUDE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark socket-layer filter set deltas as committed.  */
end_comment

begin_function
specifier|static
name|void
name|imf_commit
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|=
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
expr_stmt|;
block|}
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|=
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reap unreferenced sources from socket-layer filter set.  */
end_comment

begin_function
specifier|static
name|void
name|imf_reap
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|tims
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
operator|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|MCAST_UNDEFINED
operator|)
operator|&&
operator|(
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|==
name|MCAST_UNDEFINED
operator|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: free lims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_INMFILTER
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsrc
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Purge socket-layer filter set.  */
end_comment

begin_function
specifier|static
name|void
name|imf_purge
parameter_list|(
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|tims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_INMFILTER
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsrc
operator|--
expr_stmt|;
block|}
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|=
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_EMPTY
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|)
argument_list|,
operator|(
literal|"%s: imf_sources not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look up a source filter entry for a multicast group.  *  * inm is the group descriptor to work with.  * haddr is the host-byte-order IPv4 address to look up.  * noalloc may be non-zero to suppress allocation of sources.  * *pims will be set to the address of the retrieved or allocated source.  *  * SMPng: NOTE: may be called with locks held.  * Return 0 if successful, otherwise return a non-zero error code.  */
end_comment

begin_function
specifier|static
name|int
name|inm_get_source
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
specifier|const
name|in_addr_t
name|haddr
parameter_list|,
specifier|const
name|int
name|noalloc
parameter_list|,
name|struct
name|ip_msource
modifier|*
modifier|*
name|pims
parameter_list|)
block|{
name|struct
name|ip_msource
name|find
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|struct
name|in_addr
name|ia
decl_stmt|;
endif|#
directive|endif
name|find
operator|.
name|ims_haddr
operator|=
name|haddr
expr_stmt|;
name|ims
operator|=
name|RB_FIND
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|,
operator|&
name|find
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
operator|&&
operator|!
name|noalloc
condition|)
block|{
if|if
condition|(
name|inm
operator|->
name|inm_nsrc
operator|==
name|in_mcast_maxgrpsrc
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_msource
argument_list|)
argument_list|,
name|M_IPMSOURCE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|nims
operator|->
name|ims_haddr
operator|=
name|haddr
expr_stmt|;
name|RB_INSERT
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|,
name|nims
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|inm_nsrc
expr_stmt|;
name|ims
operator|=
name|nims
expr_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|ia
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|haddr
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: allocated %s as %p"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|,
name|ims
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|pims
operator|=
name|ims
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge socket-layer source into IGMP-layer source.  * If rollback is non-zero, perform the inverse of the merge.  */
end_comment

begin_function
specifier|static
name|void
name|ims_merge
parameter_list|(
name|struct
name|ip_msource
modifier|*
name|ims
parameter_list|,
specifier|const
name|struct
name|in_msource
modifier|*
name|lims
parameter_list|,
specifier|const
name|int
name|rollback
parameter_list|)
block|{
name|int
name|n
init|=
name|rollback
condition|?
operator|-
literal|1
else|:
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|KTR
name|struct
name|in_addr
name|ia
decl_stmt|;
name|ia
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: t1 ex -= %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
operator|.
name|ex
operator|-=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: t1 in -= %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
operator|.
name|in
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: t1 ex += %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
operator|.
name|ex
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: t1 in += %d on %s"
argument_list|,
name|__func__
argument_list|,
name|n
argument_list|,
name|inet_ntoa
argument_list|(
name|ia
argument_list|)
argument_list|)
expr_stmt|;
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
operator|.
name|in
operator|+=
name|n
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Atomically update the global in_multi state, when a membership's  * filter list is being updated in any way.  *  * imf is the per-inpcb-membership group filter pointer.  * A fake imf may be passed for in-kernel consumers.  *  * XXX This is a candidate for a set-symmetric-difference style loop  * which would eliminate the repeated lookup from root of ims nodes,  * as they share the same key space.  *  * If any error occurred this function will back out of refcounts  * and return a non-zero value.  */
end_comment

begin_function
specifier|static
name|int
name|inm_merge
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
comment|/*const*/
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|int
name|schanged
decl_stmt|,
name|error
decl_stmt|;
name|int
name|nsrc0
decl_stmt|,
name|nsrc1
decl_stmt|;
name|schanged
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nsrc1
operator|=
name|nsrc0
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Update the source filters first, as this may fail. 	 * Maintain count of in-mode filters at t0, t1. These are 	 * used to work out if we transition into ASM mode or not. 	 * Maintain a count of source filters whose state was 	 * actually modified by this operation. 	 */
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
condition|)
name|nsrc0
operator|++
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|==
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
condition|)
name|nsrc1
operator|++
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
condition|)
continue|continue;
name|error
operator|=
name|inm_get_source
argument_list|(
name|inm
argument_list|,
name|lims
operator|->
name|ims_haddr
argument_list|,
literal|0
argument_list|,
operator|&
name|nims
argument_list|)
expr_stmt|;
operator|++
name|schanged
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|ims_merge
argument_list|(
name|nims
argument_list|,
name|lims
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|struct
name|ip_msource
modifier|*
name|bims
decl_stmt|;
name|RB_FOREACH_REVERSE_FROM
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|nims
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
condition|)
continue|continue;
operator|(
name|void
operator|)
name|inm_get_source
argument_list|(
name|inm
argument_list|,
name|lims
operator|->
name|ims_haddr
argument_list|,
literal|1
argument_list|,
operator|&
name|bims
argument_list|)
expr_stmt|;
if|if
condition|(
name|bims
operator|==
name|NULL
condition|)
continue|continue;
name|ims_merge
argument_list|(
name|bims
argument_list|,
name|lims
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out_reap
goto|;
block|}
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: imf filters in-mode: %d at t0, %d at t1"
argument_list|,
name|__func__
argument_list|,
name|nsrc0
argument_list|,
name|nsrc1
argument_list|)
expr_stmt|;
comment|/* Handle transition between INCLUDE {n} and INCLUDE {} on socket. */
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|==
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|&&
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
if|if
condition|(
name|nsrc1
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: --in on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_in
expr_stmt|;
block|}
block|}
comment|/* Handle filter mode transition on socket. */
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|!=
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: imf transition %d to %d"
argument_list|,
name|__func__
argument_list|,
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
argument_list|,
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: --ex on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_ex
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|==
name|MCAST_INCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: --in on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_in
expr_stmt|;
block|}
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: ex++ on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_ex
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_INCLUDE
operator|&&
name|nsrc1
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: in++ on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_in
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Track inm filter state in terms of listener counts. 	 * If there are any exclusive listeners, stack-wide 	 * membership is exclusive. 	 * Otherwise, if only inclusive listeners, stack-wide is inclusive. 	 * If no listeners remain, state is undefined at t1, 	 * and the IGMP lifecycle for this group should finish. 	 */
if|if
condition|(
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_ex
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition to EX"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_EXCLUDE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_in
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition to IN"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_INCLUDE
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: transition to UNDEF"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
operator|=
name|MCAST_UNDEFINED
expr_stmt|;
block|}
comment|/* Decrement ASM listener count on transition out of ASM mode. */
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
operator|&&
name|nsrc0
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|!=
name|MCAST_EXCLUDE
operator|)
operator|||
operator|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
operator|&&
name|nsrc1
operator|>
literal|0
operator|)
condition|)
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: --asm on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
operator|--
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_asm
expr_stmt|;
block|}
comment|/* Increment ASM listener count on transition to ASM mode. */
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
operator|&&
name|nsrc1
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: asm++ on inm at t1"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_asm
operator|++
expr_stmt|;
block|}
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merged imf %p to inm %p"
argument_list|,
name|__func__
argument_list|,
name|imf
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|inm_print
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|out_reap
label|:
if|if
condition|(
name|schanged
operator|>
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: sources changed; reaping"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm_reap
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark an in_multi's filter set deltas as committed.  * Called by IGMP after a state change has been enqueued.  */
end_comment

begin_function
name|void
name|inm_commit
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: commit inm %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: pre commit:"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|inm_print
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&inm->inm_srcs
argument_list|)
block|{
name|ims
operator|->
name|ims_st
index|[
literal|0
index|]
operator|=
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
expr_stmt|;
block|}
name|inm
operator|->
name|inm_st
index|[
literal|0
index|]
operator|=
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reap unreferenced nodes from an in_multi's filter set.  */
end_comment

begin_function
specifier|static
name|void
name|inm_reap
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&inm->inm_srcs
argument_list|,
argument|tims
argument_list|)
block|{
if|if
condition|(
name|ims
operator|->
name|ims_st
index|[
literal|0
index|]
operator|.
name|ex
operator|>
literal|0
operator|||
name|ims
operator|->
name|ims_st
index|[
literal|0
index|]
operator|.
name|in
operator|>
literal|0
operator|||
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
operator|.
name|ex
operator|>
literal|0
operator|||
name|ims
operator|->
name|ims_st
index|[
literal|1
index|]
operator|.
name|in
operator|>
literal|0
operator|||
name|ims
operator|->
name|ims_stp
operator|!=
literal|0
condition|)
continue|continue;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_nsrc
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Purge all source nodes from an in_multi's filter set.  */
end_comment

begin_function
specifier|static
name|void
name|inm_purge
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|RB_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&inm->inm_srcs
argument_list|,
argument|tims
argument_list|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: free ims %p"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|ip_msource_tree
argument_list|,
operator|&
name|inm
operator|->
name|inm_srcs
argument_list|,
name|ims
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|inm
operator|->
name|inm_nsrc
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Join a multicast group; unlocked entry point.  *  * SMPng: XXX: in_joingroup() is called from in_control() when Giant  * is not held. Fortunately, ifp is unlikely to have been detached  * at this point, so we assume it's OK to recurse.  */
end_comment

begin_function
name|int
name|in_joingroup
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
name|gina
parameter_list|,
comment|/*const*/
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
name|struct
name|in_multi
modifier|*
modifier|*
name|pinm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|in_joingroup_locked
argument_list|(
name|ifp
argument_list|,
name|gina
argument_list|,
name|imf
argument_list|,
name|pinm
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join a multicast group; real entry point.  *  * Only preserves atomicity at inm level.  * NOTE: imf argument cannot be const due to sys/tree.h limitations.  *  * If the IGMP downcall fails, the group is not joined, and an error  * code is returned.  */
end_comment

begin_function
name|int
name|in_joingroup_locked
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|in_addr
modifier|*
name|gina
parameter_list|,
comment|/*const*/
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|,
name|struct
name|in_multi
modifier|*
modifier|*
name|pinm
parameter_list|)
block|{
name|struct
name|in_mfilter
name|timf
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: join %s on %p(%s))"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
name|gina
argument_list|)
argument_list|,
name|ifp
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|inm
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If no imf was specified (i.e. kernel consumer), 	 * fake one up and assume it is an ASM join. 	 */
if|if
condition|(
name|imf
operator|==
name|NULL
condition|)
block|{
name|imf_init
argument_list|(
operator|&
name|timf
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|timf
expr_stmt|;
block|}
name|error
operator|=
name|in_getmulti
argument_list|(
name|ifp
argument_list|,
name|gina
argument_list|,
operator|&
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: in_getmulti() failure"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|inm_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_inm_release
goto|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: doing igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_change_state
argument_list|(
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed to update source"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_inm_release
goto|;
block|}
name|out_inm_release
label|:
if|if
condition|(
name|error
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: dropping ref on %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|inm_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pinm
operator|=
name|inm
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave a multicast group; unlocked entry point.  */
end_comment

begin_function
name|int
name|in_leavegroup
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
comment|/*const*/
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|error
operator|=
name|in_leavegroup_locked
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave a multicast group; real entry point.  * All source filters will be expunged.  *  * Only preserves atomicity at inm level.  *  * Holding the write lock for the INP which contains imf  * is highly advisable. We can't assert for it as imf does not  * contain a back-pointer to the owning inp.  *  * Note: This is not the same as inm_release(*) as this function also  * makes a state change downcall into IGMP.  */
end_comment

begin_function
name|int
name|in_leavegroup_locked
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|,
comment|/*const*/
name|struct
name|in_mfilter
modifier|*
name|imf
parameter_list|)
block|{
name|struct
name|in_mfilter
name|timf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|CTR5
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: leave inm %p, %s/%s, imf %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
operator|(
name|inm_is_ifp_detached
argument_list|(
name|inm
argument_list|)
condition|?
literal|"null"
else|:
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
operator|)
argument_list|,
name|imf
argument_list|)
expr_stmt|;
comment|/* 	 * If no imf was specified (i.e. kernel consumer), 	 * fake one up and assume it is an ASM join. 	 */
if|if
condition|(
name|imf
operator|==
name|NULL
condition|)
block|{
name|imf_init
argument_list|(
operator|&
name|timf
argument_list|,
name|MCAST_EXCLUDE
argument_list|,
name|MCAST_UNDEFINED
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|timf
expr_stmt|;
block|}
comment|/* 	 * Begin state merge transaction at IGMP layer. 	 * 	 * As this particular invocation should not cause any memory 	 * to be allocated, and there is no opportunity to roll back 	 * the transaction, it MUST NOT fail. 	 */
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|inm_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: failed to merge inm state"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: doing igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|inm
operator|->
name|inm_ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_change_state
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: dropping ref on %p"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|inm_release_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*#ifndef BURN_BRIDGES*/
end_comment

begin_comment
comment|/*  * Join an IPv4 multicast group in (*,G) exclusive mode.  * The group must be a 224.0.0.0/24 link-scope group.  * This KPI is for legacy kernel consumers only.  */
end_comment

begin_function
name|struct
name|in_multi
modifier|*
name|in_addmulti
parameter_list|(
name|struct
name|in_addr
modifier|*
name|ap
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|in_multi
modifier|*
name|pinm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|IN_LOCAL_GROUP
argument_list|(
name|ntohl
argument_list|(
name|ap
operator|->
name|s_addr
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"%s: %s not in 224.0.0.0/24"
operator|,
name|__func__
operator|,
name|inet_ntoa
argument_list|(
operator|*
name|ap
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|in_joingroup
argument_list|(
name|ifp
argument_list|,
name|ap
argument_list|,
name|NULL
argument_list|,
operator|&
name|pinm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|pinm
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|pinm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave an IPv4 multicast group, assumed to be in exclusive (*,G) mode.  * This KPI is for legacy kernel consumers only.  */
end_comment

begin_function
name|void
name|in_delmulti
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
operator|(
name|void
operator|)
name|in_leavegroup
argument_list|(
name|inm
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*#endif*/
end_comment

begin_comment
comment|/*  * Block or unblock an ASM multicast source on an inpcb.  * This implements the delta-based API described in RFC 3678.  *  * The delta-based API applies only to exclusive-mode memberships.  * An IGMP downcall will be performed.  *  * SMPng: NOTE: Must take Giant as a join may create a new ifma.  *  * Return 0 if successful, otherwise return an appropriate error code.  */
end_comment

begin_function
specifier|static
name|int
name|inp_block_unblock_source
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|uint16_t
name|fmode
decl_stmt|;
name|int
name|error
decl_stmt|,
name|doblock
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|doblock
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_BLOCK_SOURCE
case|:
case|case
name|IP_UNBLOCK_SOURCE
case|:
block|{
name|struct
name|ip_mreq_source
name|mreqs
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_multiaddr
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
condition|)
name|INADDR_TO_IFP
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_BLOCK_SOURCE
condition|)
name|doblock
operator|=
literal|1
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: imr_interface = %s, ifp = %p"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_BLOCK_SOURCE
condition|)
name|doblock
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: unknown sopt_name %d"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Check if we are actually a member of this group. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: imo_mfilters not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|inm
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Attempting to use the delta-based API on an 	 * non exclusive-mode membership is an error. 	 */
name|fmode
operator|=
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|fmode
operator|!=
name|MCAST_EXCLUDE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
comment|/* 	 * Deal with error cases up-front: 	 *  Asked to block, but already blocked; or 	 *  Asked to unblock, but nothing to unblock. 	 * If adding a new block entry, allocate it. 	 */
name|ims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ims
operator|!=
name|NULL
operator|&&
name|doblock
operator|)
operator|||
operator|(
name|ims
operator|==
name|NULL
operator|&&
operator|!
name|doblock
operator|)
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: source %s %spresent"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|doblock
condition|?
literal|""
else|:
literal|"not "
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
if|if
condition|(
name|doblock
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"block"
argument_list|)
expr_stmt|;
name|ims
operator|=
name|imf_graft
argument_list|(
name|imf
argument_list|,
name|fmode
argument_list|,
operator|&
name|ssa
operator|->
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"allow"
argument_list|)
expr_stmt|;
name|error
operator|=
name|imf_prune
argument_list|(
name|imf
argument_list|,
operator|&
name|ssa
operator|->
name|sin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge imf state failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_imf_rollback
goto|;
block|}
comment|/* 	 * Begin state merge transaction at IGMP layer. 	 */
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|inm_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in_multi_locked
goto|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: doing igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_change_state
argument_list|(
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|out_in_multi_locked
label|:
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|out_imf_rollback
label|:
if|if
condition|(
name|error
condition|)
name|imf_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|imf_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|imf_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|out_inp_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an inpcb, return its multicast options structure pointer.  Accepts  * an unlocked inpcb pointer, but will return it locked.  May sleep.  *  * SMPng: NOTE: Potentially calls malloc(M_WAITOK) with Giant held.  * SMPng: NOTE: Returns with the INP write lock held.  */
end_comment

begin_function
specifier|static
name|struct
name|ip_moptions
modifier|*
name|inp_findmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_multi
modifier|*
modifier|*
name|immp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imfp
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_moptions
operator|!=
name|NULL
condition|)
return|return
operator|(
name|inp
operator|->
name|inp_moptions
operator|)
return|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|imo
argument_list|)
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|immp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|immp
argument_list|)
operator|*
name|IP_MIN_MEMBERSHIPS
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|imfp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_mfilter
argument_list|)
operator|*
name|IP_MIN_MEMBERSHIPS
argument_list|,
name|M_INMFILTER
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|NULL
expr_stmt|;
name|imo
operator|->
name|imo_multicast_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|imo
operator|->
name|imo_multicast_vif
operator|=
operator|-
literal|1
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|IP_DEFAULT_MULTICAST_TTL
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
name|in_mcast_loop
expr_stmt|;
name|imo
operator|->
name|imo_num_memberships
operator|=
literal|0
expr_stmt|;
name|imo
operator|->
name|imo_max_memberships
operator|=
name|IP_MIN_MEMBERSHIPS
expr_stmt|;
name|imo
operator|->
name|imo_membership
operator|=
name|immp
expr_stmt|;
comment|/* Initialize per-group source filters. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|IP_MIN_MEMBERSHIPS
condition|;
name|idx
operator|++
control|)
name|imf_init
argument_list|(
operator|&
name|imfp
index|[
name|idx
index|]
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_mfilters
operator|=
name|imfp
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_moptions
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|imfp
argument_list|,
name|M_INMFILTER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|immp
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|->
name|inp_moptions
operator|)
return|;
block|}
name|inp
operator|->
name|inp_moptions
operator|=
name|imo
expr_stmt|;
return|return
operator|(
name|imo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Discard the IP multicast options (and source filters).  To minimize  * the amount of work done while holding locks such as the INP's  * pcbinfo lock (which is used in the receive path), the free  * operation is performed asynchronously in a separate task.  *  * SMPng: NOTE: assumes INP write lock is held.  */
end_comment

begin_function
name|void
name|inp_freemoptions
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|imo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ip_moptions is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|STAILQ_INSERT_TAIL
argument_list|(
operator|&
name|imo_gc_list
argument_list|,
name|imo
argument_list|,
name|imo_link
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|imo_gc_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inp_freemoptions_internal
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|nmships
decl_stmt|;
name|nmships
operator|=
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nmships
condition|;
operator|++
name|idx
control|)
block|{
name|imf
operator|=
name|imo
operator|->
name|imo_mfilters
condition|?
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|imf
condition|)
name|imf_leave
argument_list|(
name|imf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|in_leavegroup
argument_list|(
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|imf
condition|)
name|imf_purge
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|imo
operator|->
name|imo_mfilters
condition|)
name|free
argument_list|(
name|imo
operator|->
name|imo_mfilters
argument_list|,
name|M_INMFILTER
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
operator|->
name|imo_membership
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|inp_gcmoptions
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|STAILQ_EMPTY
argument_list|(
operator|&
name|imo_gc_list
argument_list|)
condition|)
block|{
name|imo
operator|=
name|STAILQ_FIRST
argument_list|(
operator|&
name|imo_gc_list
argument_list|)
expr_stmt|;
name|STAILQ_REMOVE_HEAD
argument_list|(
operator|&
name|imo_gc_list
argument_list|,
name|imo_link
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|inp_freemoptions_internal
argument_list|(
name|imo
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
block|}
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Atomically get source filters on a socket for an IPv4 multicast group.  * Called with INP lock held; returns with lock released.  */
end_comment

begin_function
specifier|static
name|int
name|inp_get_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|__msfilterreq
name|msfr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|psin
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|ptss
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|tss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|nsrcs
decl_stmt|,
name|ncsrcs
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|inp
operator|->
name|inp_moptions
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ip_moptions"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_ifindex
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|msfr
operator|.
name|msfr_ifindex
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|msfr
operator|.
name|msfr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup group on the socket. 	 */
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|msfr
operator|.
name|msfr_group
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Ignore memberships which are in limbo. 	 */
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_UNDEFINED
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAGAIN
operator|)
return|;
block|}
name|msfr
operator|.
name|msfr_fmode
operator|=
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
expr_stmt|;
comment|/* 	 * If the user specified a buffer, copy out the source filter 	 * entries to userland gracefully. 	 * We only copy out the number of entries which userland 	 * has asked for, but we always tell userland how big the 	 * buffer really needs to be. 	 */
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
name|in_mcast_maxsocksrc
condition|)
name|msfr
operator|.
name|msfr_nsrcs
operator|=
name|in_mcast_maxsocksrc
expr_stmt|;
name|tss
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|msfr
operator|.
name|msfr_srcs
operator|!=
name|NULL
operator|&&
name|msfr
operator|.
name|msfr_nsrcs
operator|>
literal|0
condition|)
block|{
name|tss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tss
operator|==
name|NULL
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
comment|/* 	 * Count number of sources in-mode at t0. 	 * If buffer space exists and remains, copy out source entries. 	 */
name|nsrcs
operator|=
name|msfr
operator|.
name|msfr_nsrcs
expr_stmt|;
name|ncsrcs
operator|=
literal|0
expr_stmt|;
name|ptss
operator|=
name|tss
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&imf->imf_sources
argument_list|)
block|{
name|lims
operator|=
operator|(
expr|struct
name|in_msource
operator|*
operator|)
name|ims
expr_stmt|;
if|if
condition|(
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|==
name|MCAST_UNDEFINED
operator|||
name|lims
operator|->
name|imsl_st
index|[
literal|0
index|]
operator|!=
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
condition|)
continue|continue;
operator|++
name|ncsrcs
expr_stmt|;
if|if
condition|(
name|tss
operator|!=
name|NULL
operator|&&
name|nsrcs
operator|>
literal|0
condition|)
block|{
name|psin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ptss
expr_stmt|;
name|psin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|psin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|psin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|lims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
name|psin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
operator|++
name|ptss
expr_stmt|;
operator|--
name|nsrcs
expr_stmt|;
block|}
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tss
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|tss
argument_list|,
name|msfr
operator|.
name|msfr_srcs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|msfr
operator|.
name|msfr_nsrcs
operator|=
name|ncsrcs
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the IP multicast options in response to user getsockopt().  */
end_comment

begin_function
name|int
name|inp_getmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ip_mreqn
name|mreqn
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|u_char
name|coptval
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|inp
operator|->
name|inp_moptions
expr_stmt|;
comment|/* 	 * If socket is neither of type SOCK_RAW or SOCK_DGRAM, 	 * or is a divert socket, reject it. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_DIVERT
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
operator|&&
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_DGRAM
operator|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_MULTICAST_VIF
case|:
if|if
condition|(
name|imo
operator|!=
name|NULL
condition|)
name|optval
operator|=
name|imo
operator|->
name|imo_multicast_vif
expr_stmt|;
else|else
name|optval
operator|=
operator|-
literal|1
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MULTICAST_IF
case|:
name|memset
argument_list|(
operator|&
name|mreqn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imo
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|=
name|imo
operator|->
name|imo_multicast_ifp
expr_stmt|;
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|imo
operator|->
name|imo_multicast_addr
argument_list|)
condition|)
block|{
name|mreqn
operator|.
name|imr_address
operator|=
name|imo
operator|->
name|imo_multicast_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|mreqn
operator|.
name|imr_ifindex
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
block|{
name|mreqn
operator|.
name|imr_address
operator|=
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
condition|)
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqn
operator|.
name|imr_address
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IP_MULTICAST_TTL
case|:
if|if
condition|(
name|imo
operator|==
literal|0
condition|)
name|optval
operator|=
name|coptval
operator|=
name|IP_DEFAULT_MULTICAST_TTL
expr_stmt|;
else|else
name|optval
operator|=
name|coptval
operator|=
name|imo
operator|->
name|imo_multicast_ttl
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|coptval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MULTICAST_LOOP
case|:
if|if
condition|(
name|imo
operator|==
literal|0
condition|)
name|optval
operator|=
name|coptval
operator|=
name|IP_DEFAULT_MULTICAST_LOOP
expr_stmt|;
else|else
name|optval
operator|=
name|coptval
operator|=
name|imo
operator|->
name|imo_multicast_loop
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|coptval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MSFILTER
case|:
if|if
condition|(
name|imo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|inp_get_source_filters
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look up the ifnet to use for a multicast group membership,  * given the IPv4 address of an interface, and the IPv4 group address.  *  * This routine exists to support legacy multicast applications  * which do not understand that multicast memberships are scoped to  * specific physical links in the networking stack, or which need  * to join link-scope groups before IPv4 addresses are configured.  *  * If inp is non-NULL, use this socket's current FIB number for any  * required FIB lookup.  * If ina is INADDR_ANY, look up the group address in the unicast FIB,  * and use its ifp; usually, this points to the default next-hop.  *  * If the FIB lookup fails, attempt to use the first non-loopback  * interface with multicast capability in the system as a  * last resort. The legacy IPv4 ASM API requires that we do  * this in order to allow groups to be joined when the routing  * table has not yet been populated during boot.  *  * Returns NULL if no ifp could be found.  *  * SMPng: TODO: Acquire the appropriate locks for INADDR_TO_IFP.  * FUTURE: Implement IPv4 source-address selection.  */
end_comment

begin_function
specifier|static
name|struct
name|ifnet
modifier|*
name|inp_lookup_mcast_ifp
parameter_list|(
specifier|const
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|gsin
parameter_list|,
specifier|const
name|struct
name|in_addr
name|ina
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|gsin
operator|->
name|sin_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: not AF_INET"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|,
operator|(
literal|"%s: not multicast"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|ina
argument_list|)
condition|)
block|{
name|INADDR_TO_IFP
argument_list|(
name|ina
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|route
name|ro
decl_stmt|;
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|.
name|ro_dst
argument_list|,
name|gsin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|in_rtalloc_ign
argument_list|(
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|inp
condition|?
name|inp
operator|->
name|inp_inc
operator|.
name|inc_fibnum
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|mifp
decl_stmt|;
name|mifp
operator|=
name|NULL
expr_stmt|;
name|IN_IFADDR_RLOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ia
argument_list|,
argument|&V_in_ifaddrhead
argument_list|,
argument|ia_link
argument_list|)
block|{
name|mifp
operator|=
name|ia
operator|->
name|ia_ifp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|&&
operator|(
name|mifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
block|{
name|ifp
operator|=
name|mifp
expr_stmt|;
break|break;
block|}
block|}
name|IN_IFADDR_RUNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ifp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join an IPv4 multicast group, possibly with a source.  */
end_comment

begin_function
specifier|static
name|int
name|inp_join_group
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|is_new
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|imf
operator|=
name|NULL
expr_stmt|;
name|lims
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|is_new
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|gsa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_ADD_MEMBERSHIP
case|:
case|case
name|IP_ADD_SOURCE_MEMBERSHIP
case|:
block|{
name|struct
name|ip_mreq_source
name|mreqs
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_ADD_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Do argument switcharoo from ip_mreq into 			 * ip_mreq_source to avoid using two instances. 			 */
name|mreqs
operator|.
name|imr_interface
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
name|mreqs
operator|.
name|imr_sourceaddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_ADD_SOURCE_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_multiaddr
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_ADD_SOURCE_MEMBERSHIP
condition|)
block|{
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifp
operator|=
name|inp_lookup_mcast_ifp
argument_list|(
name|inp
argument_list|,
operator|&
name|gsa
operator|->
name|sin
argument_list|,
name|mreqs
operator|.
name|imr_interface
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: imr_interface = %s, ifp = %p"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_SOURCE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Overwrite the port field if present, as the sockaddr 		 * being copied in may be matched with a binary comparison. 		 */
name|gsa
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_SOURCE_GROUP
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ssa
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: unknown sopt_name %d"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|is_new
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|inm
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
comment|/* 			 * MCAST_JOIN_SOURCE_GROUP on an exclusive membership 			 * is an error. On an existing inclusive membership, 			 * it just adds the source to the filter list. 			 */
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|!=
name|MCAST_INCLUDE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
comment|/* 			 * Throw out duplicates. 			 * 			 * XXX FIXME: This makes a naive assumption that 			 * even if entries exist for *ssa in this imf, 			 * they will be rejected as dupes, even if they 			 * are not valid in the current mode (in-mode). 			 * 			 * in_msource is transactioned just as for anything 			 * else in SSM -- but note naive use of inm_graft() 			 * below for allocating new filter entries. 			 * 			 * This is only an issue if someone mixes the 			 * full-state SSM API with the delta-based API, 			 * which is discouraged in the relevant RFCs. 			 */
name|lims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|lims
operator|!=
name|NULL
comment|/*&& 			    lims->imsl_st[1] == MCAST_INCLUDE*/
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * MCAST_JOIN_GROUP on an existing exclusive 			 * membership is an error; return EADDRINUSE 			 * to preserve 4.4BSD API idempotence, and 			 * avoid tedious detour to code below. 			 * NOTE: This is bending RFC 3678 a bit. 			 * 			 * On an existing inclusive membership, this is also 			 * an error; if you want to change filter mode, 			 * you must use the userland API setsourcefilter(). 			 * XXX We don't reject this for imf in UNDEFINED 			 * state at t1, because allocation of a filter 			 * is atomic with allocation of a membership. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
block|}
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
block|{
if|if
condition|(
name|imo
operator|->
name|imo_num_memberships
operator|==
name|imo
operator|->
name|imo_max_memberships
condition|)
block|{
name|error
operator|=
name|imo_grow
argument_list|(
name|imo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_inp_locked
goto|;
block|}
comment|/* 		 * Allocate the new slot upfront so we can deal with 		 * grafting the new source filter in same code path 		 * as for join-source on existing membership. 		 */
name|idx
operator|=
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
name|imo
operator|->
name|imo_num_memberships
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: imf_mfilters vector was not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|RB_EMPTY
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|)
argument_list|,
operator|(
literal|"%s: imf_sources not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Graft new source into filter list for this inpcb's 	 * membership of the group. The in_multi may not have 	 * been allocated yet if this is a new membership, however, 	 * the in_mfilter slot will be allocated and must be initialized. 	 * 	 * Note: Grafting of exclusive mode filters doesn't happen 	 * in this path. 	 * XXX: Should check for non-NULL lims (node exists but may 	 * not be in-mode) for interop with full-state API. 	 */
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
comment|/* Membership starts in IN mode */
if|if
condition|(
name|is_new
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: new join w/source"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|imf_init
argument_list|(
name|imf
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_INCLUDE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"allow"
argument_list|)
expr_stmt|;
block|}
name|lims
operator|=
name|imf_graft
argument_list|(
name|imf
argument_list|,
name|MCAST_INCLUDE
argument_list|,
operator|&
name|ssa
operator|->
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|lims
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge imf state failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_imo_free
goto|;
block|}
block|}
else|else
block|{
comment|/* No address specified; Membership starts in EX mode */
if|if
condition|(
name|is_new
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: new join w/o source"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|imf_init
argument_list|(
name|imf
argument_list|,
name|MCAST_UNDEFINED
argument_list|,
name|MCAST_EXCLUDE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Begin state merge transaction at IGMP layer. 	 */
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
block|{
name|error
operator|=
name|in_joingroup_locked
argument_list|(
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|,
name|imf
argument_list|,
operator|&
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: in_joingroup_locked failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
goto|goto
name|out_imo_free
goto|;
block|}
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
operator|=
name|inm
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|inm_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in_multi_locked
goto|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: doing igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_change_state
argument_list|(
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in_multi_locked
goto|;
block|}
block|}
name|out_in_multi_locked
label|:
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|imf_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_new
condition|)
name|imf_purge
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|imf_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imf_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
name|out_imo_free
label|:
if|if
condition|(
name|error
operator|&&
name|is_new
condition|)
block|{
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
operator|--
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
block|}
name|out_inp_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave an IPv4 multicast group on an inpcb, possibly with a source.  */
end_comment

begin_function
specifier|static
name|int
name|inp_leave_group
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|struct
name|ip_mreq_source
name|mreqs
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|,
name|is_final
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|is_final
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|gsa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_DROP_MEMBERSHIP
case|:
case|case
name|IP_DROP_SOURCE_MEMBERSHIP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_DROP_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Swap interface and sourceaddr arguments, 			 * as ip_mreq and ip_mreq_source are laid 			 * out differently. 			 */
name|mreqs
operator|.
name|imr_interface
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
name|mreqs
operator|.
name|imr_sourceaddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_DROP_SOURCE_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_multiaddr
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_DROP_SOURCE_MEMBERSHIP
condition|)
block|{
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
block|}
comment|/* 		 * Attempt to look up hinted ifp from interface address. 		 * Fallthrough with null ifp iff lookup fails, to 		 * preserve 4.4BSD mcast API idempotence. 		 * XXX NOTE WELL: The RFC 3678 API is preferred because 		 * using an IPv4 address as a key is racy. 		 */
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
condition|)
name|INADDR_TO_IFP
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: imr_interface = %s, ifp = %p"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_SOURCE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_SOURCE_GROUP
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
break|break;
default|default:
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: unknown sopt_name %d"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Find the membership in the membership array. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
name|inm
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
name|is_final
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * If we were instructed only to leave a given source, do so. 	 * MCAST_LEAVE_SOURCE_GROUP is only valid for inclusive memberships. 	 */
if|if
condition|(
name|is_final
condition|)
block|{
name|imf_leave
argument_list|(
name|imf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|imf
operator|->
name|imf_st
index|[
literal|0
index|]
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
name|ims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
block|{
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: source %s %spresent"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
literal|"not "
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: %s source"
argument_list|,
name|__func__
argument_list|,
literal|"block"
argument_list|)
expr_stmt|;
name|error
operator|=
name|imf_prune
argument_list|(
name|imf
argument_list|,
operator|&
name|ssa
operator|->
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge imf state failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
block|}
comment|/* 	 * Begin state merge transaction at IGMP layer. 	 */
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|is_final
condition|)
block|{
comment|/* 		 * Give up the multicast address record to which 		 * the membership points. 		 */
operator|(
name|void
operator|)
name|in_leavegroup_locked
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|inm_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in_multi_locked
goto|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: doing igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_change_state
argument_list|(
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
name|out_in_multi_locked
label|:
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|imf_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|imf_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|imf_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_final
condition|)
block|{
comment|/* Remove the gap in the membership and filter array. */
for|for
control|(
operator|++
name|idx
init|;
name|idx
operator|<
name|imo
operator|->
name|imo_num_memberships
condition|;
operator|++
name|idx
control|)
block|{
name|imo
operator|->
name|imo_membership
index|[
name|idx
operator|-
literal|1
index|]
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
operator|-
literal|1
index|]
operator|=
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
block|}
name|imo
operator|->
name|imo_num_memberships
operator|--
expr_stmt|;
block|}
name|out_inp_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select the interface for transmitting IPv4 multicast datagrams.  *  * Either an instance of struct in_addr or an instance of struct ip_mreqn  * may be passed to this socket option. An address of INADDR_ANY or an  * interface index of 0 is used to remove a previous selection.  * When no interface is selected, one is chosen for every send.  */
end_comment

begin_function
specifier|static
name|int
name|inp_set_multicast_if
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
name|struct
name|ip_mreqn
name|mreqn
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
condition|)
block|{
comment|/* 		 * An interface index was specified using the 		 * Linux-derived ip_mreqn structure. 		 */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mreqn
operator|.
name|imr_ifindex
operator|<
literal|0
operator|||
name|V_if_index
operator|<
name|mreqn
operator|.
name|imr_ifindex
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mreqn
operator|.
name|imr_ifindex
operator|==
literal|0
condition|)
block|{
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|mreqn
operator|.
name|imr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * An interface was specified by IPv4 address. 		 * This is the traditional BSD usage. 		 */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|in_nullhost
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|INADDR_TO_IFP
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|CTR3
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: ifp = %p, addr = %s"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Reject interfaces which do not support multicast. */
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|ifp
expr_stmt|;
name|imo
operator|->
name|imo_multicast_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically set source filters on a socket for an IPv4 multicast group.  *  * SMPng: NOTE: Potentially calls malloc(M_WAITOK) with Giant held.  */
end_comment

begin_function
specifier|static
name|int
name|inp_set_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|__msfilterreq
name|msfr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
name|in_mcast_maxsocksrc
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
if|if
condition|(
operator|(
name|msfr
operator|.
name|msfr_fmode
operator|!=
name|MCAST_EXCLUDE
operator|&&
name|msfr
operator|.
name|msfr_fmode
operator|!=
name|MCAST_INCLUDE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_family
operator|!=
name|AF_INET
operator|||
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|msfr
operator|.
name|msfr_group
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* ignore port */
if|if
condition|(
name|msfr
operator|.
name|msfr_ifindex
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|msfr
operator|.
name|msfr_ifindex
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|msfr
operator|.
name|msfr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
comment|/* 	 * Take the INP write lock. 	 * Check if this socket is a member of this group. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_inp_locked
goto|;
block|}
name|inm
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * Begin state merge transaction at socket layer. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|=
name|msfr
operator|.
name|msfr_fmode
expr_stmt|;
comment|/* 	 * Apply any new source filters, if present. 	 * Make a copy of the user-space source vector so 	 * that we may copy them with a single copyin. This 	 * allows us to deal with page faults up-front. 	 */
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
literal|0
condition|)
block|{
name|struct
name|in_msource
modifier|*
name|lims
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|psin
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|kss
decl_stmt|,
modifier|*
name|pkss
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: loading %lu source list entries"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
name|kss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|msfr
operator|.
name|msfr_srcs
argument_list|,
name|kss
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * Mark all source filters as UNDEFINED at t1. 		 * Restore new group filter mode, as imf_leave() 		 * will set it to INCLUDE. 		 */
name|imf_leave
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
operator|=
name|msfr
operator|.
name|msfr_fmode
expr_stmt|;
comment|/* 		 * Update socket layer filters at t1, lazy-allocating 		 * new entries. This saves a bunch of memory at the 		 * cost of one RB_FIND() per source entry; duplicate 		 * entries in the msfr_nsrcs vector are ignored. 		 * If we encounter an error, rollback transaction. 		 * 		 * XXX This too could be replaced with a set-symmetric 		 * difference like loop to avoid walking from root 		 * every time, as the key space is common. 		 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|pkss
operator|=
name|kss
init|;
name|i
operator|<
name|msfr
operator|.
name|msfr_nsrcs
condition|;
name|i
operator|++
operator|,
name|pkss
operator|++
control|)
block|{
name|psin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|pkss
expr_stmt|;
if|if
condition|(
name|psin
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|psin
operator|->
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|imf_get_source
argument_list|(
name|imf
argument_list|,
name|psin
argument_list|,
operator|&
name|lims
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|lims
operator|->
name|imsl_st
index|[
literal|1
index|]
operator|=
name|imf
operator|->
name|imf_st
index|[
literal|1
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|out_imf_rollback
goto|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Begin state merge transaction at IGMP layer. 	 */
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|inm_merge
argument_list|(
name|inm
argument_list|,
name|imf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed to merge inm state"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|out_in_multi_locked
goto|;
block|}
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: doing igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|error
operator|=
name|igmp_change_state
argument_list|(
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: failed igmp downcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|out_in_multi_locked
label|:
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|out_imf_rollback
label|:
if|if
condition|(
name|error
condition|)
name|imf_rollback
argument_list|(
name|imf
argument_list|)
expr_stmt|;
else|else
name|imf_commit
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|imf_reap
argument_list|(
name|imf
argument_list|)
expr_stmt|;
name|out_inp_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the IP multicast options in response to user setsockopt().  *  * Many of the socket options handled in this function duplicate the  * functionality of socket options in the regular unicast API. However,  * it is not possible to merge the duplicate code, because the idempotence  * of the IPv4 multicast part of the BSD Sockets API must be preserved;  * the effects of these options must be treated as separate and distinct.  *  * SMPng: XXX: Unlocked read of inp_socket believed OK.  * FUTURE: The IP_MULTICAST_VIF option may be eliminated if MROUTING  * is refactored to no longer use vifs.  */
end_comment

begin_function
name|int
name|inp_setmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If socket is neither of type SOCK_RAW or SOCK_DGRAM, 	 * or is a divert socket, reject it. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_DIVERT
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
operator|&&
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_DGRAM
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_MULTICAST_VIF
case|:
block|{
name|int
name|vifi
decl_stmt|;
comment|/* 		 * Select a multicast VIF for transmission. 		 * Only useful if multicast forwarding is active. 		 */
if|if
condition|(
name|legal_vif_num
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|vifi
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|!
name|legal_vif_num
argument_list|(
name|vifi
argument_list|)
operator|&&
operator|(
name|vifi
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_vif
operator|=
name|vifi
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IP_MULTICAST_IF
case|:
name|error
operator|=
name|inp_set_multicast_if
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MULTICAST_TTL
case|:
block|{
name|u_char
name|ttl
decl_stmt|;
comment|/* 		 * Set the IP time-to-live for outgoing multicast packets. 		 * The original multicast API required a char argument, 		 * which is inconsistent with the rest of the socket API. 		 * We allow either a char or an int. 		 */
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
name|u_int
name|ittl
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|ittl
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ittl
operator|>
literal|255
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
operator|(
name|u_char
operator|)
name|ittl
expr_stmt|;
block|}
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|ttl
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IP_MULTICAST_LOOP
case|:
block|{
name|u_char
name|loop
decl_stmt|;
comment|/* 		 * Set the loopback flag for outgoing multicast packets. 		 * Must be zero or one.  The original multicast API required a 		 * char argument, which is inconsistent with the rest 		 * of the socket API.  We allow either a char or an int. 		 */
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|loop
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
name|u_int
name|iloop
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|iloop
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|loop
operator|=
operator|(
name|u_char
operator|)
name|iloop
expr_stmt|;
block|}
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
operator|!
operator|!
name|loop
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IP_ADD_MEMBERSHIP
case|:
case|case
name|IP_ADD_SOURCE_MEMBERSHIP
case|:
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
name|error
operator|=
name|inp_join_group
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_DROP_MEMBERSHIP
case|:
case|case
name|IP_DROP_SOURCE_MEMBERSHIP
case|:
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
name|error
operator|=
name|inp_leave_group
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_BLOCK_SOURCE
case|:
case|case
name|IP_UNBLOCK_SOURCE
case|:
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
name|error
operator|=
name|inp_block_unblock_source
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MSFILTER
case|:
name|error
operator|=
name|inp_set_source_filters
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Expose IGMP's multicast filter mode and source list(s) to userland,  * keyed by (ifindex, group).  * The filter mode is written out as a uint32_t, followed by  * 0..n of struct in_addr.  * For use by ifmcstat(8).  * SMPng: NOTE: unlocked read of ifindex space.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_ip_mcast_filters
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|in_addr
name|src
decl_stmt|,
name|group
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|struct
name|ip_msource
modifier|*
name|ims
decl_stmt|;
name|int
modifier|*
name|name
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|u_int
name|namelen
decl_stmt|;
name|uint32_t
name|fmode
decl_stmt|,
name|ifindex
decl_stmt|;
name|name
operator|=
operator|(
name|int
operator|*
operator|)
name|arg1
expr_stmt|;
name|namelen
operator|=
name|arg2
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|namelen
operator|!=
literal|2
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifindex
operator|=
name|name
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ifindex
operator|<=
literal|0
operator|||
name|ifindex
operator|>
name|V_if_index
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: ifindex %u out of range"
argument_list|,
name|__func__
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|group
operator|.
name|s_addr
operator|=
name|name
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|group
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: group %s is not multicast"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|group
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: no ifp for ifindex %u"
argument_list|,
name|__func__
argument_list|,
name|ifindex
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|retval
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
operator|(
name|in_mcast_maxgrpsrc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifma
argument_list|,
argument|&ifp->if_multiaddrs
argument_list|,
argument|ifma_link
argument_list|)
block|{
if|if
condition|(
name|ifma
operator|->
name|ifma_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|ifma
operator|->
name|ifma_protospec
operator|==
name|NULL
condition|)
continue|continue;
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
if|if
condition|(
operator|!
name|in_hosteq
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|,
name|group
argument_list|)
condition|)
continue|continue;
name|fmode
operator|=
name|inm
operator|->
name|inm_st
index|[
literal|1
index|]
operator|.
name|iss_fmode
expr_stmt|;
name|retval
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|fmode
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
name|RB_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|ip_msource_tree
argument_list|,
argument|&inm->inm_srcs
argument_list|)
block|{
ifdef|#
directive|ifdef
name|KTR
name|struct
name|in_addr
name|ina
decl_stmt|;
name|ina
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: visit node %s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|ina
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Only copy-out sources which are in-mode. 			 */
if|if
condition|(
name|fmode
operator|!=
name|ims_get_mode
argument_list|(
name|inm
argument_list|,
name|ims
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IGMPV3
argument_list|,
literal|"%s: skip non-in-mode"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|src
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|ims
operator|->
name|ims_haddr
argument_list|)
expr_stmt|;
name|retval
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
break|break;
block|}
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KTR
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|inm_modestrs
index|[]
init|=
block|{
literal|"un"
block|,
literal|"in"
block|,
literal|"ex"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|inm_mode_str
parameter_list|(
specifier|const
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|mode
operator|>=
name|MCAST_UNDEFINED
operator|&&
name|mode
operator|<=
name|MCAST_EXCLUDE
condition|)
return|return
operator|(
name|inm_modestrs
index|[
name|mode
index|]
operator|)
return|;
return|return
operator|(
literal|"??"
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|inm_statestrs
index|[]
init|=
block|{
literal|"not-member"
block|,
literal|"silent"
block|,
literal|"idle"
block|,
literal|"lazy"
block|,
literal|"sleeping"
block|,
literal|"awakening"
block|,
literal|"query-pending"
block|,
literal|"sg-query-pending"
block|,
literal|"leaving"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|inm_state_str
parameter_list|(
specifier|const
name|int
name|state
parameter_list|)
block|{
if|if
condition|(
name|state
operator|>=
name|IGMP_NOT_MEMBER
operator|&&
name|state
operator|<=
name|IGMP_LEAVING_MEMBER
condition|)
return|return
operator|(
name|inm_statestrs
index|[
name|state
index|]
operator|)
return|;
return|return
operator|(
literal|"??"
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump an in_multi structure to the console.  */
end_comment

begin_function
name|void
name|inm_print
parameter_list|(
specifier|const
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
if|if
condition|(
operator|(
name|ktr_mask
operator|&
name|KTR_IGMPV3
operator|)
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"%s: --- begin inm %p ---\n"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"addr %s ifp %p(%s) ifma %p\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|inm
operator|->
name|inm_addr
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_ifp
argument_list|,
name|inm
operator|->
name|inm_ifp
operator|->
name|if_xname
argument_list|,
name|inm
operator|->
name|inm_ifma
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timer %u state %s refcount %u scq.len %u\n"
argument_list|,
name|inm
operator|->
name|inm_timer
argument_list|,
name|inm_state_str
argument_list|(
name|inm
operator|->
name|inm_state
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_refcount
argument_list|,
name|inm
operator|->
name|inm_scq
operator|.
name|ifq_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"igi %p nsrc %lu sctimer %u scrv %u\n"
argument_list|,
name|inm
operator|->
name|inm_igi
argument_list|,
name|inm
operator|->
name|inm_nsrc
argument_list|,
name|inm
operator|->
name|inm_sctimer
argument_list|,
name|inm
operator|->
name|inm_scrv
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
literal|2
condition|;
name|t
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"t%d: fmode %s asm %u ex %u in %u rec %u\n"
argument_list|,
name|t
argument_list|,
name|inm_mode_str
argument_list|(
name|inm
operator|->
name|inm_st
index|[
name|t
index|]
operator|.
name|iss_fmode
argument_list|)
argument_list|,
name|inm
operator|->
name|inm_st
index|[
name|t
index|]
operator|.
name|iss_asm
argument_list|,
name|inm
operator|->
name|inm_st
index|[
name|t
index|]
operator|.
name|iss_ex
argument_list|,
name|inm
operator|->
name|inm_st
index|[
name|t
index|]
operator|.
name|iss_in
argument_list|,
name|inm
operator|->
name|inm_st
index|[
name|t
index|]
operator|.
name|iss_rec
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: --- end inm %p ---\n"
argument_list|,
name|__func__
argument_list|,
name|inm
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !KTR */
end_comment

begin_function
name|void
name|inm_print
parameter_list|(
specifier|const
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{  }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KTR */
end_comment

begin_expr_stmt
name|RB_GENERATE
argument_list|(
name|ip_msource_tree
argument_list|,
name|ip_msource
argument_list|,
name|ims_link
argument_list|,
name|ip_msource_cmp
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

