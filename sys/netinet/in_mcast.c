begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Bruce M. Simpson.  * Copyright (c) 2005 Robert N. M. Watson.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * IPv4 multicast socket, group, and socket option processing module.  * Until further notice, this file requires INET to compile.  * TODO: Make this infrastructure independent of address family.  * TODO: Teach netinet6 to use this code.  * TODO: Hook up SSM logic to IGMPv3/MLDv2.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_route.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vimage.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/vinet.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|__SOCKUNION_DECLARED
end_ifndef

begin_union
union|union
name|sockunion
block|{
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|sockunion
name|sockunion_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|__SOCKUNION_DECLARED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __SOCKUNION_DECLARED */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMADDR
argument_list|,
literal|"in_multi"
argument_list|,
literal|"IPv4 multicast group"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMOPTS
argument_list|,
literal|"ip_moptions"
argument_list|,
literal|"IPv4 multicast options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_IPMSOURCE
argument_list|,
literal|"in_msource"
argument_list|,
literal|"IPv4 multicast source filter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * The IPv4 multicast list (in_multihead and associated structures) are  * protected by the global in_multi_mtx.  See in_var.h for more details.  For  * now, in_multi_mtx is marked as recursible due to IGMP's calling back into  * ip_output() to send IGMP packets while holding the lock; this probably is  * not quite desirable.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE_GLOBALS
end_ifdef

begin_decl_stmt
name|struct
name|in_multihead
name|in_multihead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX BSS initialization */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|mtx
name|in_multi_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|in_multi_mtx
argument_list|,
operator|&
name|in_multi_mtx
argument_list|,
literal|"in_multi_mtx"
argument_list|,
name|MTX_DEF
operator||
name|MTX_RECURSE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Functions with non-static linkage defined in this file should be  * declared in in_var.h:  *  imo_match_group()  *  imo_match_source()  *  in_addmulti()  *  in_delmulti()  *  in_delmulti_locked()  * and ip_var.h:  *  inp_freemoptions()  *  inp_getmoptions()  *  inp_setmoptions()  */
end_comment

begin_function_decl
specifier|static
name|int
name|imo_grow
parameter_list|(
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imo_join_source
parameter_list|(
name|struct
name|ip_moptions
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|sockunion_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|imo_leave_source
parameter_list|(
name|struct
name|ip_moptions
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|sockunion_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_change_source_filter
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ip_moptions
modifier|*
name|inp_findmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_get_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_join_group
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_leave_group
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_set_multicast_if
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|inp_set_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Resize the ip_moptions vector to the next power-of-two minus 1.  * May be called with locks held; do not sleep.  */
end_comment

begin_function
specifier|static
name|int
name|imo_grow
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|in_multi
modifier|*
modifier|*
name|nmships
decl_stmt|;
name|struct
name|in_multi
modifier|*
modifier|*
name|omships
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|nmfilters
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|omfilters
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|size_t
name|newmax
decl_stmt|;
name|size_t
name|oldmax
decl_stmt|;
name|nmships
operator|=
name|NULL
expr_stmt|;
name|nmfilters
operator|=
name|NULL
expr_stmt|;
name|omships
operator|=
name|imo
operator|->
name|imo_membership
expr_stmt|;
name|omfilters
operator|=
name|imo
operator|->
name|imo_mfilters
expr_stmt|;
name|oldmax
operator|=
name|imo
operator|->
name|imo_max_memberships
expr_stmt|;
name|newmax
operator|=
operator|(
operator|(
name|oldmax
operator|+
literal|1
operator|)
operator|*
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|newmax
operator|<=
name|IP_MAX_MEMBERSHIPS
condition|)
block|{
name|nmships
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|omships
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_multi
operator|*
argument_list|)
operator|*
name|newmax
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|nmfilters
operator|=
operator|(
expr|struct
name|in_mfilter
operator|*
operator|)
name|realloc
argument_list|(
name|omfilters
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_mfilter
argument_list|)
operator|*
name|newmax
argument_list|,
name|M_IPMSOURCE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmships
operator|!=
name|NULL
operator|&&
name|nmfilters
operator|!=
name|NULL
condition|)
block|{
comment|/* Initialize newly allocated source filter heads. */
for|for
control|(
name|idx
operator|=
name|oldmax
init|;
name|idx
operator|<
name|newmax
condition|;
name|idx
operator|++
control|)
block|{
name|nmfilters
index|[
name|idx
index|]
operator|.
name|imf_fmode
operator|=
name|MCAST_EXCLUDE
expr_stmt|;
name|nmfilters
index|[
name|idx
index|]
operator|.
name|imf_nsources
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nmfilters
index|[
name|idx
index|]
operator|.
name|imf_sources
argument_list|)
expr_stmt|;
block|}
name|imo
operator|->
name|imo_max_memberships
operator|=
name|newmax
expr_stmt|;
name|imo
operator|->
name|imo_membership
operator|=
name|nmships
expr_stmt|;
name|imo
operator|->
name|imo_mfilters
operator|=
name|nmfilters
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nmships
operator|==
name|NULL
operator|||
name|nmfilters
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|nmships
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nmships
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmfilters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|nmfilters
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ETOOMANYREFS
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a source to a multicast filter list.  * Assumes the associated inpcb is locked.  */
end_comment

begin_function
specifier|static
name|int
name|imo_join_source
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
name|size_t
name|gidx
parameter_list|,
name|sockunion_t
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|nims
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|KASSERT
argument_list|(
name|src
operator|->
name|ss
operator|.
name|ss_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: !AF_INET"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: imo_mfilters vector not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|gidx
index|]
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|imf_nsources
operator|==
name|IP_MAX_SOURCE_FILTER
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|ims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|gidx
argument_list|,
operator|&
name|src
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
comment|/* Do not sleep with inp lock held. */
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_msource
argument_list|)
argument_list|,
name|M_IPMSOURCE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nims
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|nims
operator|->
name|ims_addr
operator|=
name|src
operator|->
name|ss
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|nims
argument_list|,
name|ims_next
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsources
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|imo_leave_source
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
name|size_t
name|gidx
parameter_list|,
name|sockunion_t
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|KASSERT
argument_list|(
name|src
operator|->
name|ss
operator|.
name|ss_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: !AF_INET"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: imo_mfilters vector not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|gidx
index|]
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|imf_nsources
operator|==
name|IP_MAX_SOURCE_FILTER
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|ims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|gidx
argument_list|,
operator|&
name|src
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|,
name|ims_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsources
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an IPv4 multicast group entry for this ip_moptions instance  * which matches the specified group, and optionally an interface.  * Return its index into the array, or -1 if not found.  */
end_comment

begin_function
name|size_t
name|imo_match_group
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|group
parameter_list|)
block|{
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|in_multi
modifier|*
modifier|*
name|pinm
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|int
name|nmships
decl_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
name|group
expr_stmt|;
comment|/* The imo_membership array may be lazy allocated. */
if|if
condition|(
name|imo
operator|->
name|imo_membership
operator|==
name|NULL
operator|||
name|imo
operator|->
name|imo_num_memberships
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|nmships
operator|=
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
name|pinm
operator|=
operator|&
name|imo
operator|->
name|imo_membership
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nmships
condition|;
name|idx
operator|++
operator|,
name|pinm
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|pinm
operator|==
name|NULL
condition|)
continue|continue;
if|#
directive|if
literal|0
block|printf("%s: trying ifp = %p, inaddr = %s ", __func__, 		    ifp, inet_ntoa(gsa->sin.sin_addr)); 		printf("against %p, %s\n", 		    (*pinm)->inm_ifp, inet_ntoa((*pinm)->inm_addr));
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
operator|(
operator|*
name|pinm
operator|)
operator|->
name|inm_ifp
operator|==
name|ifp
operator|)
operator|)
operator|&&
operator|(
operator|*
name|pinm
operator|)
operator|->
name|inm_addr
operator|.
name|s_addr
operator|==
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|idx
operator|>=
name|nmships
condition|)
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a multicast source entry for this imo which matches  * the given group index for this socket, and source address.  */
end_comment

begin_function
name|struct
name|in_msource
modifier|*
name|imo_match_source
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|,
name|size_t
name|gidx
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|pims
decl_stmt|;
name|KASSERT
argument_list|(
name|src
operator|->
name|sa_family
operator|==
name|AF_INET
argument_list|,
operator|(
literal|"%s: !AF_INET"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|gidx
operator|!=
operator|-
literal|1
operator|&&
name|gidx
operator|<
name|imo
operator|->
name|imo_num_memberships
argument_list|,
operator|(
literal|"%s: invalid index %d\n"
operator|,
name|__func__
operator|,
operator|(
name|int
operator|)
name|gidx
operator|)
argument_list|)
expr_stmt|;
comment|/* The imo_mfilters array may be lazy allocated. */
if|if
condition|(
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pims
operator|=
name|NULL
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|gidx
index|]
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|ims_next
argument_list|)
block|{
comment|/* 		 * Perform bitwise comparison of two IPv4 addresses. 		 * TODO: Do the same for IPv6. 		 * Do not use sa_equal() for this as it is not aware of 		 * deeper structure in sockaddr_in or sockaddr_in6. 		 */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ims
operator|->
name|ims_addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|pims
operator|=
name|ims
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|pims
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join an IPv4 multicast group.  */
end_comment

begin_function
name|struct
name|in_multi
modifier|*
name|in_addmulti
parameter_list|(
name|struct
name|in_addr
modifier|*
name|ap
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|INIT_VNET_INET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|inm
operator|=
name|NULL
expr_stmt|;
name|IFF_LOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|IN_LOOKUP_MULTI
argument_list|(
operator|*
name|ap
argument_list|,
name|ifp
argument_list|,
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we already joined this group, just bump the 		 * refcount and return it. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: bad refcount %d"
operator|,
name|__func__
operator|,
name|inm
operator|->
name|inm_refcount
operator|)
argument_list|)
expr_stmt|;
operator|++
name|inm
operator|->
name|inm_refcount
expr_stmt|;
block|}
else|else
do|do
block|{
name|sockunion_t
name|gsa
decl_stmt|;
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|ninm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|gsa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|gsa
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|.
name|sin
operator|.
name|sin_addr
operator|=
operator|*
name|ap
expr_stmt|;
comment|/* 		 * Check if a link-layer group is already associated 		 * with this network-layer group on the given ifnet. 		 * If so, bump the refcount on the existing network-layer 		 * group association and return it. 		 */
name|error
operator|=
name|if_addmulti
argument_list|(
name|ifp
argument_list|,
operator|&
name|gsa
operator|.
name|sa
argument_list|,
operator|&
name|ifma
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ifma
operator|->
name|ifma_protospec
operator|!=
name|NULL
condition|)
block|{
name|inm
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|)
name|ifma
operator|->
name|ifma_protospec
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|inm
operator|->
name|inm_ifma
operator|!=
name|ifma
operator|||
name|inm
operator|->
name|inm_ifp
operator|!=
name|ifp
operator|||
name|inm
operator|->
name|inm_addr
operator|.
name|s_addr
operator|!=
name|ap
operator|->
name|s_addr
condition|)
name|panic
argument_list|(
literal|"%s: ifma is inconsistent"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|++
name|inm
operator|->
name|inm_refcount
expr_stmt|;
break|break;
block|}
comment|/* 		 * A new membership is needed; construct it and 		 * perform the IGMP join. 		 */
name|ninm
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ninm
argument_list|)
argument_list|,
name|M_IPMADDR
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ninm
operator|==
name|NULL
condition|)
block|{
name|if_delmulti_ifma
argument_list|(
name|ifma
argument_list|)
expr_stmt|;
break|break;
block|}
name|ninm
operator|->
name|inm_addr
operator|=
operator|*
name|ap
expr_stmt|;
name|ninm
operator|->
name|inm_ifp
operator|=
name|ifp
expr_stmt|;
name|ninm
operator|->
name|inm_ifma
operator|=
name|ifma
expr_stmt|;
name|ninm
operator|->
name|inm_refcount
operator|=
literal|1
expr_stmt|;
name|ifma
operator|->
name|ifma_protospec
operator|=
name|ninm
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|V_in_multihead
argument_list|,
name|ninm
argument_list|,
name|inm_link
argument_list|)
expr_stmt|;
name|igmp_joingroup
argument_list|(
name|ninm
argument_list|)
expr_stmt|;
name|inm
operator|=
name|ninm
expr_stmt|;
block|}
do|while
condition|(
literal|0
condition|)
do|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
name|IFF_UNLOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave an IPv4 multicast group.  * It is OK to call this routine if the underlying ifnet went away.  *  * XXX: To deal with the ifp going away, we cheat; the link-layer code in net  * will set ifma_ifp to NULL when the associated ifnet instance is detached  * from the system.  *  * The only reason we need to violate layers and check ifma_ifp here at all  * is because certain hardware drivers still require Giant to be held,  * and it must always be taken before other locks.  */
end_comment

begin_function
name|void
name|in_delmulti
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inm is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_ifma
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: no ifma"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|inm
operator|->
name|inm_ifma
operator|->
name|ifma_ifp
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sanity check that netinet's notion of ifp is the 		 * same as net's. 		 */
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_ifp
operator|==
name|ifp
argument_list|,
operator|(
literal|"%s: bad ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IFF_LOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
name|IN_MULTI_LOCK
argument_list|()
expr_stmt|;
name|in_delmulti_locked
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|IN_MULTI_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
name|IFF_UNLOCKGIANT
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete a multicast address record, with locks held.  *  * It is OK to call this routine if the ifp went away.  * Assumes that caller holds the IN_MULTI lock, and that  * Giant was taken before other locks if required by the hardware.  */
end_comment

begin_function
name|void
name|in_delmulti_locked
parameter_list|(
name|struct
name|in_multi
modifier|*
name|inm
parameter_list|)
block|{
name|struct
name|ifmultiaddr
modifier|*
name|ifma
decl_stmt|;
name|IN_MULTI_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|KASSERT
argument_list|(
name|inm
operator|->
name|inm_refcount
operator|>=
literal|1
argument_list|,
operator|(
literal|"%s: freeing freed inm"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|inm
operator|->
name|inm_refcount
operator|==
literal|0
condition|)
block|{
name|igmp_leavegroup
argument_list|(
name|inm
argument_list|)
expr_stmt|;
name|ifma
operator|=
name|inm
operator|->
name|inm_ifma
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: purging ifma %p\n"
argument_list|,
name|__func__
argument_list|,
name|ifma
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|KASSERT
argument_list|(
name|ifma
operator|->
name|ifma_protospec
operator|==
name|inm
argument_list|,
operator|(
literal|"%s: ifma_protospec != inm"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|ifma
operator|->
name|ifma_protospec
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inm
argument_list|,
name|inm_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|inm
argument_list|,
name|M_IPMADDR
argument_list|)
expr_stmt|;
name|if_delmulti_ifma
argument_list|(
name|ifma
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Block or unblock an ASM/SSM multicast source on an inpcb.  */
end_comment

begin_function
specifier|static
name|int
name|inp_change_source_filter
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|INIT_VNET_INET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|block
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|block
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_BLOCK_SOURCE
case|:
case|case
name|IP_UNBLOCK_SOURCE
case|:
block|{
name|struct
name|ip_mreq_source
name|mreqs
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_multiaddr
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
if|if
condition|(
name|mreqs
operator|.
name|imr_interface
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
name|INADDR_TO_IFP
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_BLOCK_SOURCE
condition|)
name|block
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: imr_interface = %s, ifp = %p\n"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_BLOCK_SOURCE
condition|)
name|block
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unknown sopt_name %d\n"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
comment|/* XXX INET6 */
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Check if we are actually a member of this group. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: imo_mfilters not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * SSM multicast truth table for block/unblock operations. 	 * 	 * Operation   Filter Mode  Entry exists?   Action 	 * 	 * block       exclude      no              add source to filter 	 * unblock     include      no              add source to filter 	 * block       include      no              EINVAL 	 * unblock     exclude      no              EINVAL 	 * block       exclude      yes             EADDRNOTAVAIL 	 * unblock     include      yes             EADDRNOTAVAIL 	 * block       include      yes             remove source from filter 	 * unblock     exclude      yes             remove source from filter 	 * 	 * FreeBSD does not explicitly distinguish between ASM and SSM 	 * mode sockets; all sockets are assumed to have a filter list. 	 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: imf_fmode is %s\n"
argument_list|,
name|__func__
argument_list|,
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_INCLUDE
condition|?
literal|"include"
else|:
literal|"exclude"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ims
operator|=
name|imo_match_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
operator|&
name|ssa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ims
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|block
operator|==
literal|1
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_EXCLUDE
operator|)
operator|||
operator|(
name|block
operator|==
literal|0
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_INCLUDE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: adding %s to filter list\n"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|imo_join_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
name|ssa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|block
operator|==
literal|1
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_INCLUDE
operator|)
operator|||
operator|(
name|block
operator|==
literal|0
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_EXCLUDE
operator|)
condition|)
block|{
comment|/* 			 * If the socket is in inclusive mode: 			 *  the source is already blocked as it has no entry. 			 * If the socket is in exclusive mode: 			 *  the source is already unblocked as it has no entry. 			 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ims %p; %s already [un]blocked\n"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|,
name|inet_ntoa
argument_list|(
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|block
operator|==
literal|1
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_EXCLUDE
operator|)
operator|||
operator|(
name|block
operator|==
literal|0
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_INCLUDE
operator|)
condition|)
block|{
comment|/* 			 * If the socket is in exclusive mode: 			 *  the source is already blocked as it has an entry. 			 * If the socket is in inclusive mode: 			 *  the source is already unblocked as it has an entry. 			 */
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ims %p; %s already [un]blocked\n"
argument_list|,
name|__func__
argument_list|,
name|ims
argument_list|,
name|inet_ntoa
argument_list|(
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|block
operator|==
literal|1
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_INCLUDE
operator|)
operator|||
operator|(
name|block
operator|==
literal|0
operator|&&
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_EXCLUDE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: removing %s from filter list\n"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|error
operator|=
name|imo_leave_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
name|ssa
argument_list|)
expr_stmt|;
block|}
block|}
name|out_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given an inpcb, return its multicast options structure pointer.  Accepts  * an unlocked inpcb pointer, but will return it locked.  May sleep.  */
end_comment

begin_function
specifier|static
name|struct
name|ip_moptions
modifier|*
name|inp_findmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_multi
modifier|*
modifier|*
name|immp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imfp
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_moptions
operator|!=
name|NULL
condition|)
return|return
operator|(
name|inp
operator|->
name|inp_moptions
operator|)
return|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
operator|(
expr|struct
name|ip_moptions
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|imo
argument_list|)
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|immp
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|immp
argument_list|)
operator|*
name|IP_MIN_MEMBERSHIPS
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|imfp
operator|=
operator|(
expr|struct
name|in_mfilter
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_mfilter
argument_list|)
operator|*
name|IP_MIN_MEMBERSHIPS
argument_list|,
name|M_IPMSOURCE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|NULL
expr_stmt|;
name|imo
operator|->
name|imo_multicast_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|imo
operator|->
name|imo_multicast_vif
operator|=
operator|-
literal|1
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|IP_DEFAULT_MULTICAST_TTL
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
name|IP_DEFAULT_MULTICAST_LOOP
expr_stmt|;
name|imo
operator|->
name|imo_num_memberships
operator|=
literal|0
expr_stmt|;
name|imo
operator|->
name|imo_max_memberships
operator|=
name|IP_MIN_MEMBERSHIPS
expr_stmt|;
name|imo
operator|->
name|imo_membership
operator|=
name|immp
expr_stmt|;
comment|/* Initialize per-group source filters. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|IP_MIN_MEMBERSHIPS
condition|;
name|idx
operator|++
control|)
block|{
name|imfp
index|[
name|idx
index|]
operator|.
name|imf_fmode
operator|=
name|MCAST_EXCLUDE
expr_stmt|;
name|imfp
index|[
name|idx
index|]
operator|.
name|imf_nsources
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|imfp
index|[
name|idx
index|]
operator|.
name|imf_sources
argument_list|)
expr_stmt|;
block|}
name|imo
operator|->
name|imo_mfilters
operator|=
name|imfp
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_moptions
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|imfp
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|immp
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|->
name|inp_moptions
operator|)
return|;
block|}
name|inp
operator|->
name|inp_moptions
operator|=
name|imo
expr_stmt|;
return|return
operator|(
name|imo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Discard the IP multicast options (and source filters).  */
end_comment

begin_function
name|void
name|inp_freemoptions
parameter_list|(
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|nmships
decl_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: ip_moptions is NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|nmships
operator|=
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|nmships
condition|;
operator|++
name|idx
control|)
block|{
name|in_delmulti
argument_list|(
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
condition|)
block|{
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|ims_next
argument_list|,
argument|tims
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|,
name|ims_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsources
operator|--
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|imf
operator|->
name|imf_nsources
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: did not free all imf_nsources"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|imo
operator|->
name|imo_mfilters
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
operator|->
name|imo_membership
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Atomically get source filters on a socket for an IPv4 multicast group.  * Called with INP lock held; returns with lock released.  */
end_comment

begin_function
specifier|static
name|int
name|inp_get_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|__msfilterreq
name|msfr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|ptss
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|tss
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|inp
operator|->
name|inp_moptions
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ip_moptions"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_ifindex
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|msfr
operator|.
name|msfr_ifindex
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|msfr
operator|.
name|msfr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup group on the socket. 	 */
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|msfr
operator|.
name|msfr_group
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|msfr
operator|.
name|msfr_fmode
operator|=
name|imf
operator|->
name|imf_fmode
expr_stmt|;
name|msfr
operator|.
name|msfr_nsrcs
operator|=
name|imf
operator|->
name|imf_nsources
expr_stmt|;
comment|/* 	 * If the user specified a buffer, copy out the source filter 	 * entries to userland gracefully. 	 * msfr.msfr_nsrcs is always set to the total number of filter 	 * entries which the kernel currently has for this group. 	 */
name|tss
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|msfr
operator|.
name|msfr_srcs
operator|!=
name|NULL
operator|&&
name|msfr
operator|.
name|msfr_nsrcs
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Make a copy of the source vector so that we do not 		 * thrash the inpcb lock whilst copying it out. 		 * We only copy out the number of entries which userland 		 * has asked for, but we always tell userland how big the 		 * buffer really needs to be. 		 */
name|tss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tss
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
name|ptss
operator|=
name|tss
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ims
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|ims_next
argument_list|)
block|{
name|memcpy
argument_list|(
name|ptss
operator|++
argument_list|,
operator|&
name|ims
operator|->
name|ims_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tss
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|copyout
argument_list|(
name|tss
argument_list|,
name|msfr
operator|.
name|msfr_srcs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the IP multicast options in response to user getsockopt().  */
end_comment

begin_function
name|int
name|inp_getmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_INET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|ip_mreqn
name|mreqn
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|u_char
name|coptval
decl_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|=
name|inp
operator|->
name|inp_moptions
expr_stmt|;
comment|/* 	 * If socket is neither of type SOCK_RAW or SOCK_DGRAM, 	 * or is a divert socket, reject it. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_DIVERT
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
operator|&&
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_DGRAM
operator|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_MULTICAST_VIF
case|:
if|if
condition|(
name|imo
operator|!=
name|NULL
condition|)
name|optval
operator|=
name|imo
operator|->
name|imo_multicast_vif
expr_stmt|;
else|else
name|optval
operator|=
operator|-
literal|1
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MULTICAST_IF
case|:
name|memset
argument_list|(
operator|&
name|mreqn
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|imo
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|=
name|imo
operator|->
name|imo_multicast_ifp
expr_stmt|;
if|if
condition|(
name|imo
operator|->
name|imo_multicast_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|mreqn
operator|.
name|imr_address
operator|=
name|imo
operator|->
name|imo_multicast_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
name|mreqn
operator|.
name|imr_ifindex
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
name|IFP_TO_IA
argument_list|(
name|ifp
argument_list|,
name|ia
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
block|{
name|mreqn
operator|.
name|imr_address
operator|=
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
expr_stmt|;
block|}
block|}
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
condition|)
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqn
operator|.
name|imr_address
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IP_MULTICAST_TTL
case|:
if|if
condition|(
name|imo
operator|==
literal|0
condition|)
name|optval
operator|=
name|coptval
operator|=
name|IP_DEFAULT_MULTICAST_TTL
expr_stmt|;
else|else
name|optval
operator|=
name|coptval
operator|=
name|imo
operator|->
name|imo_multicast_ttl
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|coptval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MULTICAST_LOOP
case|:
if|if
condition|(
name|imo
operator|==
literal|0
condition|)
name|optval
operator|=
name|coptval
operator|=
name|IP_DEFAULT_MULTICAST_LOOP
expr_stmt|;
else|else
name|optval
operator|=
name|coptval
operator|=
name|imo
operator|->
name|imo_multicast_loop
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|coptval
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MSFILTER
case|:
if|if
condition|(
name|imo
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|inp_get_source_filters
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join an IPv4 multicast group, possibly with a source.  */
end_comment

begin_function
specifier|static
name|int
name|inp_join_group
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|INIT_VNET_INET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|gsa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_ADD_MEMBERSHIP
case|:
case|case
name|IP_ADD_SOURCE_MEMBERSHIP
case|:
block|{
name|struct
name|ip_mreq_source
name|mreqs
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_ADD_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Do argument switcharoo from ip_mreq into 			 * ip_mreq_source to avoid using two instances. 			 */
name|mreqs
operator|.
name|imr_interface
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
name|mreqs
operator|.
name|imr_sourceaddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_ADD_SOURCE_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_multiaddr
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_ADD_SOURCE_MEMBERSHIP
condition|)
block|{
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
block|}
comment|/* 		 * Obtain ifp. If no interface address was provided, 		 * use the interface of the route in the unicast FIB for 		 * the given multicast destination; usually, this is the 		 * default route. 		 * If this lookup fails, attempt to use the first non-loopback 		 * interface with multicast capability in the system as a 		 * last resort. The legacy IPv4 ASM API requires that we do 		 * this in order to allow groups to be joined when the routing 		 * table has not yet been populated during boot. 		 * If all of these conditions fail, return EADDRNOTAVAIL, and 		 * reject the IPv4 multicast join. 		 */
if|if
condition|(
name|mreqs
operator|.
name|imr_interface
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|INADDR_TO_IFP
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|route
name|ro
decl_stmt|;
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
operator|*
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
operator|=
name|gsa
operator|->
name|sin
expr_stmt|;
name|in_rtalloc_ign
argument_list|(
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|inp_inc
operator|.
name|inc_fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
name|ifp
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
name|KASSERT
argument_list|(
name|ifp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: null ifp"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|mfp
init|=
name|NULL
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ia
argument_list|,
argument|&V_in_ifaddrhead
argument_list|,
argument|ia_link
argument_list|)
block|{
name|mfp
operator|=
name|ia
operator|->
name|ia_ifp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|mfp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|&&
operator|(
name|mfp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
block|{
name|ifp
operator|=
name|mfp
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: imr_interface = %s, ifp = %p\n"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_SOURCE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 		 * Overwrite the port field if present, as the sockaddr 		 * being copied in may be matched with a binary comparison. 		 * XXX INET6 		 */
name|gsa
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_JOIN_SOURCE_GROUP
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ssa
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Obtain the ifp. 		 */
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unknown sopt_name %d\n"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ifp
operator|==
name|NULL
operator|||
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
comment|/* 	 * Check if we already hold membership of this group for this inpcb. 	 * If so, we do not need to perform the initial join. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
comment|/* 			 * Attempting to join an ASM group (when already 			 * an ASM or SSM member) is an error. 			 */
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
block|}
else|else
block|{
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
name|imf
operator|->
name|imf_nsources
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Attempting to join an SSM group (when 				 * already an ASM member) is an error. 				 */
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Attempting to join an SSM group (when 				 * already an SSM member) means "add this 				 * source to the inclusive filter list". 				 */
name|error
operator|=
name|imo_join_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
name|ssa
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|out_locked
goto|;
block|}
comment|/* 	 * Call imo_grow() to reallocate the membership and source filter 	 * vectors if they are full. If the size would exceed the hard limit, 	 * then we know we've really run out of entries. We keep the INP 	 * lock held to avoid introducing a race condition. 	 */
if|if
condition|(
name|imo
operator|->
name|imo_num_memberships
operator|==
name|imo
operator|->
name|imo_max_memberships
condition|)
block|{
name|error
operator|=
name|imo_grow
argument_list|(
name|imo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_locked
goto|;
block|}
comment|/* 	 * So far, so good: perform the layer 3 join, layer 2 join, 	 * and make an IGMP announcement if needed. 	 */
name|inm
operator|=
name|in_addmulti
argument_list|(
operator|&
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|idx
operator|=
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
operator|=
name|inm
expr_stmt|;
name|imo
operator|->
name|imo_num_memberships
operator|++
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: imf_mfilters vector was not allocated"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|)
argument_list|,
operator|(
literal|"%s: imf_sources not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a new SSM group join (i.e. a source was specified 	 * with this group), add this source to the filter list. 	 */
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
comment|/* 		 * An initial SSM join implies that this socket's membership 		 * of the multicast group is now in inclusive mode. 		 */
name|imf
operator|->
name|imf_fmode
operator|=
name|MCAST_INCLUDE
expr_stmt|;
name|error
operator|=
name|imo_join_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
name|ssa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * Drop inp lock before calling in_delmulti(), 			 * to prevent a lock order reversal. 			 */
operator|--
name|imo
operator|->
name|imo_num_memberships
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|in_delmulti
argument_list|(
name|inm
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|out_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave an IPv4 multicast group on an inpcb, possibly with a source.  */
end_comment

begin_function
specifier|static
name|int
name|inp_leave_group
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|INIT_VNET_INET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|group_source_req
name|gsr
decl_stmt|;
name|struct
name|ip_mreq_source
name|mreqs
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|,
modifier|*
name|ssa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ifp
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|gsr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_group
expr_stmt|;
name|gsa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|ssa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|gsr
operator|.
name|gsr_source
expr_stmt|;
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|=
name|AF_UNSPEC
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_DROP_MEMBERSHIP
case|:
case|case
name|IP_DROP_SOURCE_MEMBERSHIP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_DROP_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Swap interface and sourceaddr arguments, 			 * as ip_mreq and ip_mreq_source are laid 			 * out differently. 			 */
name|mreqs
operator|.
name|imr_interface
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
name|mreqs
operator|.
name|imr_sourceaddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_DROP_SOURCE_MEMBERSHIP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreq_source
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_multiaddr
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|IP_DROP_SOURCE_MEMBERSHIP
condition|)
block|{
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|ssa
operator|->
name|sin
operator|.
name|sin_addr
operator|=
name|mreqs
operator|.
name|imr_sourceaddr
expr_stmt|;
block|}
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
name|INADDR_TO_IFP
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: imr_interface = %s, ifp = %p\n"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mreqs
operator|.
name|imr_interface
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_SOURCE_GROUP
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|gsr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|group_source_req
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|gsa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|gsa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MCAST_LEAVE_SOURCE_GROUP
condition|)
block|{
if|if
condition|(
name|ssa
operator|->
name|sin
operator|.
name|sin_family
operator|!=
name|AF_INET
operator|||
name|ssa
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|gsr
operator|.
name|gsr_interface
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|gsr
operator|.
name|gsr_interface
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|gsr
operator|.
name|gsr_interface
argument_list|)
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: unknown sopt_name %d\n"
argument_list|,
name|__func__
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
break|break;
block|}
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* 	 * Find the membership in the membership array. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
comment|/* 	 * If we were instructed only to leave a given source, do so. 	 */
if|if
condition|(
name|ssa
operator|->
name|ss
operator|.
name|ss_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
name|imf
operator|->
name|imf_nsources
operator|==
literal|0
operator|||
name|imf
operator|->
name|imf_fmode
operator|==
name|MCAST_EXCLUDE
condition|)
block|{
comment|/* 			 * Attempting to SSM leave an ASM group 			 * is an error; should use *_BLOCK_SOURCE instead. 			 * Attempting to SSM leave a source in a group when 			 * the socket is in 'exclude mode' is also an error. 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|imo_leave_source
argument_list|(
name|imo
argument_list|,
name|idx
argument_list|,
name|ssa
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If an error occurred, or this source is not the last 		 * source in the group, do not leave the whole group. 		 */
if|if
condition|(
name|error
operator|||
name|imf
operator|->
name|imf_nsources
operator|>
literal|0
condition|)
goto|goto
name|out_locked
goto|;
block|}
comment|/* 	 * Give up the multicast address record to which the membership points. 	 */
name|inm
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
name|in_delmulti
argument_list|(
name|inm
argument_list|)
expr_stmt|;
comment|/* 	 * Free any source filters for this group if they exist. 	 * Revert inpcb to the default MCAST_EXCLUDE state. 	 */
if|if
condition|(
name|imo
operator|->
name|imo_mfilters
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|ims_next
argument_list|,
argument|tims
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|,
name|ims_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsources
operator|--
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|imf
operator|->
name|imf_nsources
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: imf_nsources not 0"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|)
argument_list|,
operator|(
literal|"%s: imf_sources not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_fmode
operator|=
name|MCAST_EXCLUDE
expr_stmt|;
block|}
comment|/* 	 * Remove the gap in the membership array. 	 */
for|for
control|(
operator|++
name|idx
init|;
name|idx
operator|<
name|imo
operator|->
name|imo_num_memberships
condition|;
operator|++
name|idx
control|)
name|imo
operator|->
name|imo_membership
index|[
name|idx
operator|-
literal|1
index|]
operator|=
name|imo
operator|->
name|imo_membership
index|[
name|idx
index|]
expr_stmt|;
name|imo
operator|->
name|imo_num_memberships
operator|--
expr_stmt|;
name|out_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Select the interface for transmitting IPv4 multicast datagrams.  *  * Either an instance of struct in_addr or an instance of struct ip_mreqn  * may be passed to this socket option. An address of INADDR_ANY or an  * interface index of 0 is used to remove a previous selection.  * When no interface is selected, one is chosen for every send.  */
end_comment

begin_function
specifier|static
name|int
name|inp_set_multicast_if
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|struct
name|ip_mreqn
name|mreqn
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
condition|)
block|{
comment|/* 		 * An interface index was specified using the 		 * Linux-derived ip_mreqn structure. 		 */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mreqn
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip_mreqn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|mreqn
operator|.
name|imr_ifindex
operator|<
literal|0
operator|||
name|V_if_index
operator|<
name|mreqn
operator|.
name|imr_ifindex
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|mreqn
operator|.
name|imr_ifindex
operator|==
literal|0
condition|)
block|{
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|mreqn
operator|.
name|imr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * An interface was specified by IPv4 address. 		 * This is the traditional BSD usage. 		 */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|INADDR_TO_IFP
argument_list|(
name|addr
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: ifp = %p, addr = %s\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX INET6 */
block|}
endif|#
directive|endif
block|}
comment|/* Reject interfaces which do not support multicast. */
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|ifp
expr_stmt|;
name|imo
operator|->
name|imo_multicast_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically set source filters on a socket for an IPv4 multicast group.  */
end_comment

begin_function
specifier|static
name|int
name|inp_set_source_filters
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|INIT_VNET_NET
argument_list|(
name|curvnet
argument_list|)
expr_stmt|;
name|struct
name|__msfilterreq
name|msfr
decl_stmt|;
name|sockunion_t
modifier|*
name|gsa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in_mfilter
modifier|*
name|imf
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|ims
decl_stmt|,
modifier|*
name|tims
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|msfr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|__msfilterreq
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
name|IP_MAX_SOURCE_FILTER
operator|||
operator|(
name|msfr
operator|.
name|msfr_fmode
operator|!=
name|MCAST_EXCLUDE
operator|&&
name|msfr
operator|.
name|msfr_fmode
operator|!=
name|MCAST_INCLUDE
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_family
operator|!=
name|AF_INET
operator|||
name|msfr
operator|.
name|msfr_group
operator|.
name|ss_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
operator|&
name|msfr
operator|.
name|msfr_group
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|gsa
operator|->
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|gsa
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* ignore port */
if|if
condition|(
name|msfr
operator|.
name|msfr_ifindex
operator|==
literal|0
operator|||
name|V_if_index
operator|<
name|msfr
operator|.
name|msfr_ifindex
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|ifp
operator|=
name|ifnet_byindex
argument_list|(
name|msfr
operator|.
name|msfr_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
comment|/* 	 * Take the INP lock. 	 * Check if this socket is a member of this group. 	 */
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|idx
operator|=
name|imo_match_group
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|&
name|gsa
operator|->
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
operator|==
operator|-
literal|1
operator|||
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out_locked
goto|;
block|}
name|imf
operator|=
operator|&
name|imo
operator|->
name|imo_mfilters
index|[
name|idx
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s: clearing source list\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Remove any existing source filters. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ims
argument_list|,
argument|&imf->imf_sources
argument_list|,
argument|ims_next
argument_list|,
argument|tims
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|ims
argument_list|,
name|ims_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ims
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsources
operator|--
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|imf
operator|->
name|imf_nsources
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: source list not cleared"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Apply any new source filters, if present. 	 */
if|if
condition|(
name|msfr
operator|.
name|msfr_nsrcs
operator|>
literal|0
condition|)
block|{
name|struct
name|in_msource
modifier|*
modifier|*
name|pnims
decl_stmt|;
name|struct
name|in_msource
modifier|*
name|nims
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|kss
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|pkss
decl_stmt|;
name|sockunion_t
modifier|*
name|psu
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* 		 * Drop the inp lock so we may sleep if we need to 		 * in order to satisfy a malloc request. 		 * We will re-take it before changing socket state. 		 */
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|bootverbose
condition|)
block|{
name|printf
argument_list|(
literal|"%s: loading %lu source list entries\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Make a copy of the user-space source vector so 		 * that we may copy them with a single copyin. This 		 * allows us to deal with page faults up-front. 		 */
name|kss
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|msfr
operator|.
name|msfr_srcs
argument_list|,
name|kss
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Perform argument checking on every sockaddr_storage 		 * structure in the vector provided to us. Overwrite 		 * fields which should not apply to source entries. 		 * TODO: Check for duplicate sources on this pass. 		 */
name|psu
operator|=
operator|(
name|sockunion_t
operator|*
operator|)
name|kss
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msfr
operator|.
name|msfr_nsrcs
condition|;
name|i
operator|++
operator|,
name|psu
operator|++
control|)
block|{
switch|switch
condition|(
name|psu
operator|->
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|psu
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|psu
operator|->
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|notyet
case|case
name|AF_INET6
empty_stmt|;
if|if
condition|(
name|psu
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|psu
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|psu
operator|->
name|sin6
operator|.
name|sin6_flowinfo
operator|=
literal|0
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Allocate a block to track all the in_msource 		 * entries we are about to allocate, in case we 		 * abruptly need to free them. 		 */
name|pnims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_msource
operator|*
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* 		 * Allocate up to nsrcs individual chunks. 		 * If we encounter an error, backtrack out of 		 * all allocations cleanly; updates must be atomic. 		 */
name|pkss
operator|=
name|kss
expr_stmt|;
name|nims
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msfr
operator|.
name|msfr_nsrcs
condition|;
name|i
operator|++
operator|,
name|pkss
operator|++
control|)
block|{
name|nims
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_msource
argument_list|)
operator|*
name|msfr
operator|.
name|msfr_nsrcs
argument_list|,
name|M_IPMSOURCE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pnims
index|[
name|i
index|]
operator|=
name|nims
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|msfr
operator|.
name|msfr_nsrcs
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pnims
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|pnims
index|[
name|j
index|]
argument_list|,
name|M_IPMSOURCE
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|pnims
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 		 * Finally, apply the filters to the socket. 		 * Re-take the inp lock; we are changing socket state. 		 */
name|pkss
operator|=
name|kss
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msfr
operator|.
name|msfr_nsrcs
condition|;
name|i
operator|++
operator|,
name|pkss
operator|++
control|)
block|{
name|memcpy
argument_list|(
operator|&
operator|(
name|pnims
index|[
name|i
index|]
operator|->
name|ims_addr
operator|)
argument_list|,
name|pkss
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|imf
operator|->
name|imf_sources
argument_list|,
name|pnims
index|[
name|i
index|]
argument_list|,
name|ims_next
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_nsources
operator|++
expr_stmt|;
block|}
name|free
argument_list|(
name|pnims
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kss
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Update the filter mode on the socket before releasing the inpcb. 	 */
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imf
operator|->
name|imf_fmode
operator|=
name|msfr
operator|.
name|msfr_fmode
expr_stmt|;
name|out_locked
label|:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the IP multicast options in response to user setsockopt().  *  * Many of the socket options handled in this function duplicate the  * functionality of socket options in the regular unicast API. However,  * it is not possible to merge the duplicate code, because the idempotence  * of the IPv4 multicast part of the BSD Sockets API must be preserved;  * the effects of these options must be treated as separate and distinct.  */
end_comment

begin_function
name|int
name|inp_setmoptions
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If socket is neither of type SOCK_RAW or SOCK_DGRAM, 	 * or is a divert socket, reject it. 	 * XXX Unlocked read of inp_socket believed OK. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_DIVERT
operator|||
operator|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_RAW
operator|&&
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_type
operator|!=
name|SOCK_DGRAM
operator|)
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|IP_MULTICAST_VIF
case|:
block|{
name|int
name|vifi
decl_stmt|;
comment|/* 		 * Select a multicast VIF for transmission. 		 * Only useful if multicast forwarding is active. 		 */
if|if
condition|(
name|legal_vif_num
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|vifi
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|!
name|legal_vif_num
argument_list|(
name|vifi
argument_list|)
operator|&&
operator|(
name|vifi
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_vif
operator|=
name|vifi
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IP_MULTICAST_IF
case|:
name|error
operator|=
name|inp_set_multicast_if
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MULTICAST_TTL
case|:
block|{
name|u_char
name|ttl
decl_stmt|;
comment|/* 		 * Set the IP time-to-live for outgoing multicast packets. 		 * The original multicast API required a char argument, 		 * which is inconsistent with the rest of the socket API. 		 * We allow either a char or an int. 		 */
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
name|u_int
name|ittl
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|ittl
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|ittl
operator|>
literal|255
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
operator|(
name|u_char
operator|)
name|ittl
expr_stmt|;
block|}
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|ttl
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IP_MULTICAST_LOOP
case|:
block|{
name|u_char
name|loop
decl_stmt|;
comment|/* 		 * Set the loopback flag for outgoing multicast packets. 		 * Must be zero or one.  The original multicast API required a 		 * char argument, which is inconsistent with the rest 		 * of the socket API.  We allow either a char or an int. 		 */
if|if
condition|(
name|sopt
operator|->
name|sopt_valsize
operator|==
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|loop
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
name|u_int
name|iloop
decl_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|iloop
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|loop
operator|=
operator|(
name|u_char
operator|)
name|iloop
expr_stmt|;
block|}
name|imo
operator|=
name|inp_findmoptions
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
operator|!
operator|!
name|loop
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IP_ADD_MEMBERSHIP
case|:
case|case
name|IP_ADD_SOURCE_MEMBERSHIP
case|:
case|case
name|MCAST_JOIN_GROUP
case|:
case|case
name|MCAST_JOIN_SOURCE_GROUP
case|:
name|error
operator|=
name|inp_join_group
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_DROP_MEMBERSHIP
case|:
case|case
name|IP_DROP_SOURCE_MEMBERSHIP
case|:
case|case
name|MCAST_LEAVE_GROUP
case|:
case|case
name|MCAST_LEAVE_SOURCE_GROUP
case|:
name|error
operator|=
name|inp_leave_group
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_BLOCK_SOURCE
case|:
case|case
name|IP_UNBLOCK_SOURCE
case|:
case|case
name|MCAST_BLOCK_SOURCE
case|:
case|case
name|MCAST_UNBLOCK_SOURCE
case|:
name|error
operator|=
name|inp_change_source_filter
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_MSFILTER
case|:
name|error
operator|=
name|inp_set_source_filters
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
name|INP_UNLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

