begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_pcb.c,v 1.38 2005/03/06 16:04:18 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_decl_stmt
name|struct
name|sctp_epinfo
name|sctppcbinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FIX: we don't handle multiple link local scopes */
end_comment

begin_comment
comment|/* "scopeless" replacement IN6_ARE_ADDR_EQUAL */
end_comment

begin_function
name|int
name|SCTP6_ARE_ADDR_EQUAL
parameter_list|(
name|struct
name|in6_addr
modifier|*
name|a
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|in6_addr
name|tmp_a
decl_stmt|,
name|tmp_b
decl_stmt|;
comment|/* use a copy of a and b */
name|tmp_a
operator|=
operator|*
name|a
expr_stmt|;
name|tmp_b
operator|=
operator|*
name|b
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|tmp_a
argument_list|)
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|tmp_b
argument_list|)
expr_stmt|;
return|return
operator|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|tmp_a
argument_list|,
operator|&
name|tmp_b
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_fill_pcbinfo
parameter_list|(
name|struct
name|sctp_pcbinfo
modifier|*
name|spcb
parameter_list|)
block|{
comment|/* 	 * We really don't need to lock this, but I will just because it 	 * does not hurt. 	 */
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|spcb
operator|->
name|ep_count
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_ep
expr_stmt|;
name|spcb
operator|->
name|asoc_count
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_asoc
expr_stmt|;
name|spcb
operator|->
name|laddr_count
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_laddr
expr_stmt|;
name|spcb
operator|->
name|raddr_count
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_raddr
expr_stmt|;
name|spcb
operator|->
name|chk_count
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_chunk
expr_stmt|;
name|spcb
operator|->
name|readq_count
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_readq
expr_stmt|;
name|spcb
operator|->
name|stream_oque
operator|=
name|sctppcbinfo
operator|.
name|ipi_count_strmoq
expr_stmt|;
name|spcb
operator|->
name|free_chunks
operator|=
name|sctppcbinfo
operator|.
name|ipi_free_chunks
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Addresses are added to VRF's (Virtual Router's). For BSD we  * have only the default VRF 0. We maintain a hash list of  * VRF's. Each VRF has its own list of sctp_ifn's. Each of  * these has a list of addresses. When we add a new address  * to a VRF we lookup the ifn/ifn_index, if the ifn does  * not exist we create it and add it to the list of IFN's  * within the VRF. Once we have the sctp_ifn, we add the  * address to the list. So we look something like:  *  * hash-vrf-table  *   vrf-> ifn-> ifn -> ifn  *   vrf    |  *    ...   +--ifa-> ifa -> ifa  *   vrf  *  * We keep these seperate lists since the SCTP subsystem will  * point to these from its source address selection nets structure.  * When an address is deleted it does not happen right away on  * the SCTP side, it gets scheduled. What we do when a  * delete happens is immediately remove the address from  * the master list and decrement the refcount. As our  * addip iterator works through and frees the src address  * selection pointing to the sctp_ifa, eventually the refcount  * will reach 0 and we will delete it. Note that it is assumed  * that any locking on system level ifn/ifa is done at the  * caller of these functions and these routines will only  * lock the SCTP structures as they add or delete things.  *  * Other notes on VRF concepts.  *  - An endpoint can be in multiple VRF's  *  - An association lives within a VRF and only one VRF.  *  - Any incoming packet we can deduce the VRF for by  *    looking at the mbuf/pak inbound (for BSD its VRF=0 :D)  *  - Any downward send call or connect call must supply the  *    VRF via ancillary data or via some sort of set default  *    VRF socket option call (again for BSD no brainer since  *    the VRF is always 0).  *  - An endpoint may add multiple VRF's to it.  *  - Listening sockets can accept associations in any  *    of the VRF's they are in but the assoc will end up  *    in only one VRF (gotten from the packet or connect/send).  *  */
end_comment

begin_function
name|struct
name|sctp_vrf
modifier|*
name|sctp_allocate_vrf
parameter_list|(
name|int
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_vrflist
modifier|*
name|bucket
decl_stmt|;
comment|/* First allocate the VRF structure */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
condition|)
block|{
comment|/* Already allocated */
return|return
operator|(
name|vrf
operator|)
return|;
block|}
name|SCTP_MALLOC
argument_list|(
name|vrf
argument_list|,
expr|struct
name|sctp_vrf
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_vrf
argument_list|)
argument_list|,
literal|"SCTP_VRF"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for VRF:%d"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* setup the VRF */
name|memset
argument_list|(
name|vrf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_vrf
argument_list|)
argument_list|)
expr_stmt|;
name|vrf
operator|->
name|vrf_id
operator|=
name|vrf_id
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vrf
operator|->
name|ifnlist
argument_list|)
expr_stmt|;
name|vrf
operator|->
name|total_ifa_count
operator|=
literal|0
expr_stmt|;
comment|/* Init the HASH of addresses */
name|vrf
operator|->
name|vrf_addr_hash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_VRF_ADDR_HASH_SIZE
argument_list|,
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|->
name|vrf_addr_hash
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for VRF:%d"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|vrf
operator|->
name|vrf_ifn_hash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_VRF_IFN_HASH_SIZE
argument_list|,
operator|&
name|vrf
operator|->
name|vrf_ifn_hashmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|->
name|vrf_ifn_hash
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for VRF:%d"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Add it to the hash table */
name|bucket
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_vrfhash
index|[
operator|(
name|vrf_id
operator|&
name|sctppcbinfo
operator|.
name|hashvrfmark
operator|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bucket
argument_list|,
name|vrf
argument_list|,
name|next_vrf
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|ipi_count_vrfs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|vrf
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_ifn
modifier|*
name|sctp_find_ifn
parameter_list|(
name|struct
name|sctp_vrf
modifier|*
name|vrf
parameter_list|,
name|void
modifier|*
name|ifn
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|struct
name|sctp_ifnlist
modifier|*
name|hash_ifn_head
decl_stmt|;
comment|/* 	 * We assume the lock is held for the addresses if thats wrong 	 * problems could occur :-) 	 */
name|hash_ifn_head
operator|=
operator|&
name|vrf
operator|->
name|vrf_ifn_hash
index|[
operator|(
name|ifn_index
operator|&
name|vrf
operator|->
name|vrf_ifn_hashmark
operator|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|hash_ifn_head
argument_list|,
argument|next_bucket
argument_list|)
block|{
if|if
condition|(
name|sctp_ifnp
operator|->
name|ifn_index
operator|==
name|ifn_index
condition|)
block|{
return|return
operator|(
name|sctp_ifnp
operator|)
return|;
block|}
if|if
condition|(
name|sctp_ifnp
operator|->
name|ifn_p
operator|&&
name|ifn
operator|&&
operator|(
name|sctp_ifnp
operator|->
name|ifn_p
operator|==
name|ifn
operator|)
condition|)
block|{
return|return
operator|(
name|sctp_ifnp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_vrf
modifier|*
name|sctp_find_vrf
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_vrflist
modifier|*
name|bucket
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|liste
decl_stmt|;
name|bucket
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_vrfhash
index|[
operator|(
name|vrf_id
operator|&
name|sctppcbinfo
operator|.
name|hashvrfmark
operator|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|liste
argument_list|,
argument|bucket
argument_list|,
argument|next_vrf
argument_list|)
block|{
if|if
condition|(
name|vrf_id
operator|==
name|liste
operator|->
name|vrf_id
condition|)
block|{
return|return
operator|(
name|liste
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_ifn
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|refcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* We zero'd the count */
name|SCTP_FREE
argument_list|(
name|sctp_ifnp
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|ipi_count_ifns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_update_ifn_mtu
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return;
name|sctp_ifnp
operator|=
name|sctp_find_ifn
argument_list|(
name|vrf
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifnp
operator|!=
name|NULL
condition|)
block|{
name|sctp_ifnp
operator|->
name|ifn_mtu
operator|=
name|mtu
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_free_ifa
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|refcount
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
block|{
comment|/* We zero'd the count */
name|SCTP_FREE
argument_list|(
name|sctp_ifap
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|ipi_count_ifas
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_delete_ifn
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
parameter_list|,
name|int
name|hold_addr_lock
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|found
decl_stmt|;
name|found
operator|=
name|sctp_find_ifn
argument_list|(
name|sctp_ifnp
operator|->
name|vrf
argument_list|,
name|sctp_ifnp
operator|->
name|ifn_p
argument_list|,
name|sctp_ifnp
operator|->
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
comment|/* Not in the list.. sorry */
return|return;
block|}
if|if
condition|(
name|hold_addr_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifnp
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifnp
argument_list|,
name|next_ifn
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold_addr_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Take away the reference, and possibly free it */
name|sctp_free_ifn
argument_list|(
name|sctp_ifnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_add_addr_to_vrf
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|void
modifier|*
name|ifn
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|,
name|uint32_t
name|ifn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|if_name
parameter_list|,
name|void
modifier|*
name|ifa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|ifa_flags
parameter_list|,
name|int
name|dynamic_add
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifalist
modifier|*
name|hash_addr_head
decl_stmt|;
name|struct
name|sctp_ifnlist
modifier|*
name|hash_ifn_head
decl_stmt|;
name|uint32_t
name|hash_of_addr
decl_stmt|;
comment|/* How granular do we need the locks to be here? */
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|vrf
operator|=
name|sctp_allocate_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|sctp_ifnp
operator|=
name|sctp_find_ifn
argument_list|(
name|vrf
argument_list|,
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifnp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * build one and add it, can't hold lock until after malloc 		 * done though. 		 */
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|sctp_ifnp
argument_list|,
expr|struct
name|sctp_ifn
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifn
argument_list|)
argument_list|,
literal|"SCTP_IFN"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifnp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for IFN:%u"
argument_list|,
name|sctp_ifnp
operator|->
name|ifn_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sctp_ifnp
operator|->
name|ifn_index
operator|=
name|ifn_index
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_p
operator|=
name|ifn
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_type
operator|=
name|ifn_type
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifa_count
operator|=
literal|0
expr_stmt|;
name|sctp_ifnp
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|sctp_ifnp
operator|->
name|vrf
operator|=
name|vrf
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_mtu
operator|=
name|SCTP_GATHER_MTU_FROM_IFN_INFO
argument_list|(
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_name
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_name
argument_list|,
name|if_name
argument_list|,
name|SCTP_IFNAMSIZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_name
argument_list|,
literal|"unknown"
argument_list|,
name|min
argument_list|(
literal|7
argument_list|,
name|SCTP_IFNAMSIZ
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hash_ifn_head
operator|=
operator|&
name|vrf
operator|->
name|vrf_ifn_hash
index|[
operator|(
name|ifn_index
operator|&
name|vrf
operator|->
name|vrf_ifn_hashmark
operator|)
index|]
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|ifalist
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hash_ifn_head
argument_list|,
name|sctp_ifnp
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vrf
operator|->
name|ifnlist
argument_list|,
name|sctp_ifnp
argument_list|,
name|next_ifn
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|ipi_count_ifns
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sctp_ifap
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf
operator|->
name|vrf_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
condition|)
block|{
comment|/* Hmm, it already exists? */
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|)
operator|&&
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
operator|==
name|ifn_index
operator|)
condition|)
block|{
if|if
condition|(
name|sctp_ifap
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
comment|/* easy to solve, just switch back to active */
name|sctp_ifap
operator|->
name|localifa_flags
operator|=
name|SCTP_ADDR_VALID
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|sctp_ifnp
expr_stmt|;
name|exit_stage_left
label|:
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sctp_ifap
operator|)
return|;
block|}
else|else
block|{
goto|goto
name|exit_stage_left
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
condition|)
block|{
comment|/* 				 * The first IFN gets the address, 				 * duplicates are ignored. 				 */
goto|goto
name|exit_stage_left
goto|;
block|}
else|else
block|{
comment|/* repair ifnp which was NULL ? */
name|sctp_ifap
operator|->
name|localifa_flags
operator|=
name|SCTP_ADDR_VALID
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|sctp_ifnp
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit_stage_left
goto|;
block|}
block|}
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|sctp_ifap
argument_list|,
expr|struct
name|sctp_ifa
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifa
argument_list|)
argument_list|,
literal|"SCTP_IFA"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for IFA"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|sctp_ifap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifa
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|sctp_ifnp
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|address
argument_list|,
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator|=
name|SCTP_ADDR_VALID
operator||
name|SCTP_ADDR_DEFER_USE
expr_stmt|;
name|sctp_ifap
operator|->
name|flags
operator|=
name|ifa_flags
expr_stmt|;
comment|/* Set scope */
if|if
condition|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
operator|||
operator|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_priv
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* ok to use deprecated addresses? */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
operator|||
operator|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_priv
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|hash_of_addr
operator|=
name|sctp_get_ifa_hash_val
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|src_is_priv
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_ifap
operator|->
name|src_is_loop
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_glob
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
name|hash_addr_head
operator|=
operator|&
name|vrf
operator|->
name|vrf_addr_hash
index|[
operator|(
name|hash_of_addr
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
operator|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hash_addr_head
argument_list|,
name|sctp_ifap
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|ifalist
argument_list|,
name|sctp_ifap
argument_list|,
name|next_ifa
argument_list|)
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifa_count
operator|++
expr_stmt|;
name|vrf
operator|->
name|total_ifa_count
operator|++
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|ipi_count_ifas
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynamic_add
condition|)
block|{
comment|/* 		 * Bump up the refcount so that when the timer completes it 		 * will drop back down. 		 */
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Gak, what can we do? We have lost an address 			 * change can you say HOSED? 			 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Lost and address change ???\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* Opps, must decrement the count */
name|sctp_del_addr_from_vrf
argument_list|(
name|vrf_id
argument_list|,
name|addr
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|sctp_ifap
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|SCTP_ADD_IP_ADDRESS
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
comment|/* 		 * Should this really be a tailq? As it is we will process 		 * the newest first :-0 		 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|addr_wq
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* it's ready for use */
name|sctp_ifap
operator|->
name|localifa_flags
operator|&=
operator|~
name|SCTP_ADDR_DEFER_USE
expr_stmt|;
block|}
return|return
operator|(
name|sctp_ifap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_del_addr_from_vrf
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
init|=
name|NULL
decl_stmt|;
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Can't find vrf_id:%d\n"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out_now
goto|;
block|}
name|sctp_ifap
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf
operator|->
name|vrf_id
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
condition|)
block|{
name|sctp_ifap
operator|->
name|localifa_flags
operator|&=
name|SCTP_ADDR_VALID
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator||=
name|SCTP_BEING_DELETED
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifa_count
operator|--
expr_stmt|;
name|vrf
operator|->
name|total_ifa_count
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifap
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifap
argument_list|,
name|next_ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
condition|)
block|{
if|if
condition|(
name|SCTP_LIST_EMPTY
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifalist
argument_list|)
condition|)
block|{
name|sctp_delete_ifn
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|sctp_free_ifn
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
else|else
block|{
name|printf
argument_list|(
literal|"Del Addr-ifn:%d Could not find address:"
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out_now
label|:
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sctp_ifap
condition|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Gak, what can we do? We have lost an address 			 * change can you say HOSED? 			 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Lost and address change ???\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* Opps, must decrement the count */
name|sctp_free_ifa
argument_list|(
name|sctp_ifap
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|sctp_ifap
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|SCTP_DEL_IP_ADDRESS
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
comment|/* 		 * Should this really be a tailq? As it is we will process 		 * the newest first :-0 		 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|addr_wq
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_tcb_special_locate
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/**** ASSUMSES THE CALLER holds the INP_INFO_RLOCK */
comment|/* 	 * If we support the TCP model, then we must now dig through to see 	 * if we can find our endpoint in the list of tcp ep's. 	 */
name|uint16_t
name|lport
decl_stmt|,
name|rport
decl_stmt|;
name|struct
name|sctppcbhead
modifier|*
name|ephead
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
if|if
condition|(
operator|(
name|to
operator|==
name|NULL
operator|)
operator|||
operator|(
name|from
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
name|from
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
operator|)
operator|->
name|sin_port
expr_stmt|;
name|rport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|from
operator|)
operator|->
name|sin_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|from
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
operator|)
operator|->
name|sin6_port
expr_stmt|;
name|rport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|from
operator|)
operator|->
name|sin6_port
expr_stmt|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
name|ephead
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_tcpephash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
operator|(
name|lport
operator|+
name|rport
operator|)
argument_list|,
name|sctppcbinfo
operator|.
name|hashtcpmark
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Ok now for each of the guys in this bucket we must look and see: 	 * - Does the remote port match. - Does there single association's 	 * addresses match this address (to). If so we update p_ep to point 	 * to this ep and return the tcb from it. 	 */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|ephead
argument_list|,
argument|sctp_hash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lport
operator|!=
name|inp
operator|->
name|sctp_lport
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|inp
operator|->
name|def_vrf_id
operator|!=
name|vrf_id
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check to see if the ep has one of the addresses */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We are NOT bound all, so look further */
name|int
name|match
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"An ounce of prevention is worth a pound of cure\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"ifa being deleted\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|to
operator|->
name|sa_family
condition|)
block|{
comment|/* see if it matches */
name|struct
name|sockaddr_in
modifier|*
name|intf_addr
decl_stmt|,
modifier|*
name|sin
decl_stmt|;
name|intf_addr
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
if|if
condition|(
name|from
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|intf_addr
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|intf_addr6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|intf_addr6
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|intf_addr6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
comment|/* This endpoint does not have this address */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Ok if we hit here the ep has the address, does it hold 		 * the tcb? 		 */
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* remote port does not match. */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Does this TCB have a matching address? */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|from
operator|->
name|sa_family
condition|)
block|{
comment|/* not the same family, can't be a match */
continue|continue;
block|}
if|if
condition|(
name|from
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|from
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
comment|/* Update the endpoint pointer */
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|from
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|rsin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
comment|/* Update the endpoint pointer */
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rules for use  *  * 1) If I return a NULL you must decrement any INP ref cnt. 2) If I find an  * stcb, both will be locked (locked_tcb and stcb) but decrement will be done  * (if locked == NULL). 3) Decrement happens on return ONLY if locked ==  * NULL.  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_ep_addr
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|remote
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|local
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|locked_tcb
parameter_list|)
block|{
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|uint16_t
name|rport
decl_stmt|;
name|inp
operator|=
operator|*
name|inp_p
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|rport
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|remote
operator|)
operator|->
name|sin_port
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|rport
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|remote
operator|)
operator|->
name|sin6_port
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
comment|/* 		 * UN-lock so we can do proper locking here this occurs when 		 * called from load_addresses_from_init. 		 */
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
comment|/*- 		 * Now either this guy is our listener or it's the 		 * connector. If it is the one that issued the connect, then 		 * it's only chance is to be the first TCB in the list. If 		 * it is the acceptor, then do the special_lookup to hash 		 * and find the real inp. 		 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_socket
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* to is peer addr, from is my addr */
name|stcb
operator|=
name|sctp_tcb_special_locate
argument_list|(
name|inp_p
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|netp
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|locked_tcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* we have a locked tcb, lower refcount */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|locked_tcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|locked_tcb
operator|!=
name|stcb
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|locked_tcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|locked_tcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* remote port does not match. */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|null_return
goto|;
block|}
comment|/* now look at the list of remote addresses */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|net
operator|==
operator|(
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Corrupt net list"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|remote
operator|->
name|sa_family
condition|)
block|{
comment|/* not the same family */
continue|continue;
block|}
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|rsin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|head
operator|=
operator|&
name|inp
operator|->
name|sctp_tcbhash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|rport
argument_list|,
name|inp
operator|->
name|sctp_hashmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_tcbhash
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* remote port does not match */
continue|continue;
block|}
comment|/* now look at the list of remote addresses */
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|net
operator|==
operator|(
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Corrupt net list"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|remote
operator|->
name|sa_family
condition|)
block|{
comment|/* not the same family */
continue|continue;
block|}
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|rsin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
name|null_return
label|:
comment|/* clean up for returning null */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an association for a specific endpoint using the association id given  * out in the COMM_UP notification  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_ep_asocid
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|sctp_assoc_t
name|asoc_id
parameter_list|,
name|int
name|want_lock
parameter_list|)
block|{
comment|/* 	 * Use my the assoc_id to find a endpoint 	 */
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
if|if
condition|(
name|asoc_id
operator|==
literal|0
operator|||
name|inp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|id
operator|=
operator|(
name|uint32_t
operator|)
name|asoc_id
expr_stmt|;
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_asochash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|id
argument_list|,
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
comment|/* invalid id TSNH */
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_asocs
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_id
operator|==
name|id
condition|)
block|{
comment|/* candidate */
if|if
condition|(
name|inp
operator|!=
name|stcb
operator|->
name|sctp_ep
condition|)
block|{
comment|/* 				 * some other guy has the same id active (id 				 * collision ??). 				 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|want_lock
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
comment|/* Ok if we missed here, lets try the restart hash */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_restarthash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|id
argument_list|,
name|sctppcbinfo
operator|.
name|hashrestartmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
comment|/* invalid id TSNH */
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_tcbrestarhash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_id
operator|==
name|id
condition|)
block|{
comment|/* candidate */
if|if
condition|(
name|inp
operator|!=
name|stcb
operator|->
name|sctp_ep
condition|)
block|{
comment|/* 				 * some other guy has the same id active (id 				 * collision ??). 				 */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_inpcb
modifier|*
name|sctp_endpoint_probe
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|sctppcbhead
modifier|*
name|head
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
decl_stmt|;
comment|/* 	 * Endpoing probe expects that the INP_INFO is locked. 	 */
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
name|sin6
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nam
expr_stmt|;
name|sin
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* unsupported family */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_lport
operator|==
name|lport
operator|)
condition|)
block|{
comment|/* got it */
if|if
condition|(
operator|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* IPv4 on a IPv6 socket with ONLY IPv6 set */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* A V6 address and the endpoint is NOT bound V6 */
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* does a VRF id match? */
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|def_vrf_id
operator|==
name|vrf_id
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
continue|continue;
return|return
operator|(
name|inp
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
comment|/* Can't hunt for one that has no address specified */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* Can't hunt for one that has no address specified */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * ok, not bound to all so see if we can find a EP bound to this 	 * address. 	 */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ok this could be a likely candidate, look at all of its 		 * addresses 		 */
if|if
condition|(
name|inp
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* does a VRF id match? */
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|def_vrf_id
operator|==
name|vrf_id
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"An ounce of prevention is worth a pound of cure\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Ok laddr->ifa:%p is possible, "
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Huh IFA being deleted\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|nam
operator|->
name|sa_family
condition|)
block|{
comment|/* possible, see if it matches */
name|struct
name|sockaddr_in
modifier|*
name|intf_addr
decl_stmt|;
name|intf_addr
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|intf_addr
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|intf_addr6
decl_stmt|;
name|intf_addr6
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|intf_addr6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|)
return|;
block|}
block|}
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_inpcb
modifier|*
name|sctp_pcb_findep
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|int
name|find_tcp_pool
parameter_list|,
name|int
name|have_lock
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/* 	 * First we check the hash table to see if someone has this port 	 * bound with just the port. 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|lport
decl_stmt|;
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
operator|)
operator|->
name|sin_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nam
expr_stmt|;
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nam
operator|)
operator|->
name|sin6_port
expr_stmt|;
block|}
else|else
block|{
comment|/* unsupported family */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * I could cheat here and just cast to one of the types but we will 	 * do it right. It also provides the check against an Unsupported 	 * type too. 	 */
comment|/* Find the head of the ALLADDR chain */
if|if
condition|(
name|have_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
block|}
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_ephash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|sctppcbinfo
operator|.
name|hashmark
argument_list|)
index|]
expr_stmt|;
name|inp
operator|=
name|sctp_endpoint_probe
argument_list|(
name|nam
argument_list|,
name|head
argument_list|,
name|lport
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
comment|/* 	 * If the TCP model exists it could be that the main listening 	 * endpoint is gone but there exists a connected socket for this guy 	 * yet. If so we can return the first one that we find. This may NOT 	 * be the correct one but the sctp_findassociation_ep_addr has 	 * further code to look at all TCP models. 	 */
if|if
condition|(
name|inp
operator|==
name|NULL
operator|&&
name|find_tcp_pool
condition|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctppcbinfo
operator|.
name|hashtblsize
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * This is real gross, but we do NOT have a remote 			 * port at this point depending on who is calling. 			 * We must therefore look for ANY one that matches 			 * our local port :/ 			 */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_tcpephash
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|LIST_FIRST
argument_list|(
name|head
argument_list|)
condition|)
block|{
name|inp
operator|=
name|sctp_endpoint_probe
argument_list|(
name|nam
argument_list|,
name|head
argument_list|,
name|lport
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
comment|/* Found one */
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|inp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an association for an endpoint with the pointer to whom you want to  * send to and the endpoint pointer. The address can be IPv4 or IPv6. We may  * need to change the *to to some other struct like a mbuf...  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_addr_sa
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
name|find_tcp_pool
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|retval
decl_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_tcp_pool
condition|)
block|{
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|sctp_tcb_special_locate
argument_list|(
name|inp_p
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|netp
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|sctp_tcb_special_locate
argument_list|(
operator|&
name|inp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|netp
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|inp
operator|=
name|sctp_pcb_findep
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * ok, we have an endpoint, now lets find the assoc for it (if any) 	 * we now place the source address or from in the to of the find 	 * endpoint call. Since in reality this chain is used from the 	 * inbound packet side. 	 */
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
name|from
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|from
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * This routine will grub through the mbuf that is a INIT or INIT-ACK and  * find all addresses that the sender has specified in any address list. Each  * address will be used to lookup the TCB and see if one exits.  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_special_addr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|sin4
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|parm_buf
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|retval
decl_stmt|;
name|uint32_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin4
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin4
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
expr_stmt|;
name|sin4
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin4
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|retval
operator|=
name|NULL
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
operator|!=
name|NULL
condition|)
block|{
comment|/* now we must see if we want the parameter */
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
operator|&&
name|plen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* Get the rest of the address */
name|struct
name|sctp_ipv4addr_param
name|ip4_parm
decl_stmt|,
modifier|*
name|p4
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|ip4_parm
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|ip4_parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin4
operator|.
name|sin_addr
argument_list|,
operator|&
name|p4
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p4
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look it up */
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin4
argument_list|,
name|netp
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
operator|&&
name|plen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* Get the rest of the address */
name|struct
name|sctp_ipv6addr_param
name|ip6_parm
decl_stmt|,
modifier|*
name|p6
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|ip6_parm
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6_parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p6
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look it up */
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|netp
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassoc_by_vtag
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint16_t
name|rport
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|int
name|skip_src_check
parameter_list|)
block|{
comment|/* 	 * Use my vtag to hash. If we find it we then verify the source addr 	 * is in the assoc. If all goes well we save a bit on rec of a 	 * packet. 	 */
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
operator|*
name|netp
operator|=
name|NULL
expr_stmt|;
operator|*
name|inp_p
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_asochash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|vtag
argument_list|,
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
comment|/* invalid vtag */
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_asocs
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|==
name|vtag
condition|)
block|{
comment|/* candidate */
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* 				 * we could remove this if vtags are unique 				 * across the system. 				 */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
comment|/* 				 * we could remove this if vtags are unique 				 * across the system. 				 */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|skip_src_check
condition|)
block|{
operator|*
name|netp
operator|=
name|NULL
expr_stmt|;
comment|/* unknown */
operator|*
name|inp_p
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* yep its him. */
operator|*
name|netp
operator|=
name|net
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_vtagexpress
argument_list|)
expr_stmt|;
operator|*
name|inp_p
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * not him, this should only happen in rare 				 * cases so I peg it. 				 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_vtagbogus
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an association with the pointer to the inbound IP packet. This can be  * a IPv4 or IPv6 packet.  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_addr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|int
name|find_tcp_pool
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|retval
decl_stmt|;
name|struct
name|sockaddr_storage
name|to_store
decl_stmt|,
name|from_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|to_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_store
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|from4
decl_stmt|;
name|from4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|from_store
expr_stmt|;
name|bzero
argument_list|(
name|from4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from4
argument_list|)
argument_list|)
expr_stmt|;
name|from4
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|from4
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|from4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|from4
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|from6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|from6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|from_store
expr_stmt|;
name|bzero
argument_list|(
name|from6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from6
argument_list|)
argument_list|)
expr_stmt|;
name|from6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|from6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|from6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|from6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
comment|/* Get the scopes in properly to the sin6 addr's */
comment|/* we probably don't need these operations */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|from6
argument_list|)
expr_stmt|;
name|sa6_embedscope
argument_list|(
name|from6
argument_list|,
name|ip6_use_defzone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Currently not supported. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sh
operator|->
name|v_tag
condition|)
block|{
comment|/* we only go down this path if vtag is non-zero */
name|retval
operator|=
name|sctp_findassoc_by_vtag
argument_list|(
name|from
argument_list|,
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
argument_list|,
name|inp_p
argument_list|,
name|netp
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
name|sh
operator|->
name|dest_port
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|to4
decl_stmt|;
name|to4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|to_store
expr_stmt|;
name|bzero
argument_list|(
name|to4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to4
argument_list|)
argument_list|)
expr_stmt|;
name|to4
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|to4
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|to4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|to4
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|to6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|to6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|to_store
expr_stmt|;
name|bzero
argument_list|(
name|to6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to6
argument_list|)
argument_list|)
expr_stmt|;
name|to6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|to6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|to6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|to6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
comment|/* Get the scopes in properly to the sin6 addr's */
comment|/* we probably don't need these operations */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|to6
argument_list|)
expr_stmt|;
name|sa6_embedscope
argument_list|(
name|to6
argument_list|,
name|ip6_use_defzone
argument_list|)
expr_stmt|;
block|}
name|find_tcp_pool
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION_ACK
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_COOKIE_ACK
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_COOKIE_ECHO
operator|)
condition|)
block|{
comment|/* Other chunk types go to the tcp pool. */
name|find_tcp_pool
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inp_p
condition|)
block|{
name|retval
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|inp_p
argument_list|,
name|netp
argument_list|,
name|find_tcp_pool
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|*
name|inp_p
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
operator|&
name|inp
argument_list|,
name|netp
argument_list|,
name|find_tcp_pool
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"retval:%p inp:%p\n"
argument_list|,
name|retval
argument_list|,
name|inp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|retval
operator|==
name|NULL
operator|&&
name|inp
condition|)
block|{
comment|/* Found a EP but not this address */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION_ACK
operator|)
condition|)
block|{
comment|/*- 			 * special hook, we do NOT return linp or an 			 * association that is linked to an existing 			 * association that is under the TCP pool (i.e. no 			 * listener exists). The endpoint finding routine 			 * will always find a listner before examining the 			 * TCP pool. 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
condition|)
block|{
if|if
condition|(
name|inp_p
condition|)
block|{
operator|*
name|inp_p
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|retval
operator|=
name|sctp_findassociation_special_addr
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
operator|&
name|inp
argument_list|,
name|netp
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"retval is %p\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lookup an association by an ASCONF lookup address.  * if the lookup address is 0.0.0.0 or ::0, use the vtag to do the lookup  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_ep_asconf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_storage
name|local_store
decl_stmt|,
name|remote_store
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctp_paramhdr
name|parm_buf
decl_stmt|,
modifier|*
name|phdr
decl_stmt|;
name|int
name|ptype
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|local_store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_store
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|remote_store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_store
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First get the destination address setup too. */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* its IPv4 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|local_store
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|local_store
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
block|}
else|else
block|{
return|return
name|NULL
return|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"findassociation_ep_asconf: failed to get asconf lookup addr\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
name|NULL
return|;
block|}
name|ptype
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get the correlation address */
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
comment|/* ipv6 address param */
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p6
decl_stmt|,
name|p6_buf
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
operator|&
name|p6_buf
operator|.
name|ph
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p6
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"findassociation_ep_asconf: failed to get asconf v6 lookup addr\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|remote_store
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
comment|/* ipv4 address param */
name|struct
name|sctp_ipv4addr_param
modifier|*
name|p4
decl_stmt|,
name|p4_buf
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
operator|&
name|p4_buf
operator|.
name|ph
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p4
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"findassociation_ep_asconf: failed to get asconf v4 lookup addr\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|remote_store
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
operator|&
name|p4
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid address param type */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|zero_address
condition|)
block|{
name|stcb
operator|=
name|sctp_findassoc_by_vtag
argument_list|(
name|NULL
argument_list|,
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
argument_list|,
name|inp_p
argument_list|,
name|netp
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
name|sh
operator|->
name|dest_port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * printf("findassociation_ep_asconf: zero lookup address 		 * finds stcb 0x%x\n", (uint32_t)stcb); 		 */
block|}
else|else
block|{
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote_store
argument_list|,
name|netp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|local_store
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocate a sctp_inpcb and setup a temporary binding to a port/all  * addresses. This way if we don't get a bind we by default pick a ephemeral  * port with all addresses bound.  */
end_comment

begin_function
name|int
name|sctp_inpcb_alloc
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
comment|/* 	 * we get called when a new endpoint starts up. We need to allocate 	 * the sctp_inpcb structure from the zone and init it. Mark it as 	 * unbound and find a port that we can use as an ephemeral with 	 * INADDR_ANY. If the user binds later no problem we can then add in 	 * the specific addresses. And setup the default parameters for the 	 * EP. 	 */
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_pcb
modifier|*
name|m
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|null_key
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|inp
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_ep
argument_list|,
expr|struct
name|sctp_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Out of SCTP-INPCB structures - no resources\n"
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* zap it */
name|bzero
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bump generations */
comment|/* setup socket pointers */
name|inp
operator|->
name|sctp_socket
operator|=
name|so
expr_stmt|;
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_socket
operator|=
name|so
expr_stmt|;
name|inp
operator|->
name|partial_delivery_point
operator|=
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
operator|>>
name|SCTP_PARTIAL_DELIVERY_SHIFT
expr_stmt|;
name|inp
operator|->
name|sctp_frag_point
operator|=
name|SCTP_DEFAULT_MAXSEGMENT
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
block|{
name|struct
name|inpcbpolicy
modifier|*
name|pcb_sp
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|ipsec_init_pcbpolicy
argument_list|(
name|so
argument_list|,
operator|&
name|pcb_sp
argument_list|)
expr_stmt|;
comment|/* Arrange to share the policy */
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_sp
operator|=
name|pcb_sp
expr_stmt|;
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|(
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|)
operator|)
operator|->
name|in6p_sp
operator|=
name|pcb_sp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_ep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
name|SCTP_INCR_EP_COUNT
argument_list|()
expr_stmt|;
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_ttl
operator|=
name|ip_defttl
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|inp
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_SO_TYPE
argument_list|(
name|so
argument_list|)
operator|==
name|SOCK_DGRAM
operator|)
operator|||
operator|(
name|SCTP_SO_TYPE
argument_list|(
name|so
argument_list|)
operator|==
name|SOCK_SEQPACKET
operator|)
condition|)
block|{
comment|/* UDP style socket */
name|inp
operator|->
name|sctp_flags
operator|=
operator|(
name|SCTP_PCB_FLAGS_UDPTYPE
operator||
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
expr_stmt|;
comment|/* Be sure it is NON-BLOCKING IO for UDP */
comment|/* SCTP_SET_SO_NBIO(so); */
block|}
elseif|else
if|if
condition|(
name|SCTP_SO_TYPE
argument_list|(
name|so
argument_list|)
operator|==
name|SOCK_STREAM
condition|)
block|{
comment|/* TCP style socket */
name|inp
operator|->
name|sctp_flags
operator|=
operator|(
name|SCTP_PCB_FLAGS_TCPTYPE
operator||
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
expr_stmt|;
comment|/* Be sure we have blocking IO by default */
name|SCTP_CLEAR_SO_NBIO
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * unsupported socket type (RAW, etc)- in case we missed it 		 * in protosw 		 */
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_ep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
name|inp
operator|->
name|sctp_tcbhash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|sctp_pcbtblsize
argument_list|,
operator|&
name|inp
operator|->
name|sctp_hashmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Out of SCTP-INPCB->hashinit - no resources\n"
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_ep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|inp
operator|->
name|def_vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
name|inp
operator|->
name|def_table_id
operator|=
name|SCTP_DEFAULT_TABLEID
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_LOCK_INIT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_INIT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK_INIT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* lock the new ep */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* add it to the info area */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|listhead
argument_list|,
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_TRACK_FREED_ASOCS
comment|/* TEMP CODE */
name|LIST_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_free_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Init the timer structure for signature change */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|type
operator|=
name|SCTP_TIMER_TYPE_NEWCOOKIE
expr_stmt|;
comment|/* now init the actual endpoint default data */
name|m
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
expr_stmt|;
comment|/* setup the base timeout information */
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_SEND
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_SEND_SEC
argument_list|)
expr_stmt|;
comment|/* needed ? */
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_INIT
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_INIT_SEC
argument_list|)
expr_stmt|;
comment|/* needed ? */
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|sctp_delayed_sack_time_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|sctp_heartbeat_interval_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_PMTU
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|sctp_pmtu_raise_time_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_MAXSHUTDOWN
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|sctp_shutdown_guard_time_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_SIGNATURE
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|sctp_secret_lifetime_default
argument_list|)
expr_stmt|;
comment|/* all max/min max are in ms */
name|m
operator|->
name|sctp_maxrto
operator|=
name|sctp_rto_max_default
expr_stmt|;
name|m
operator|->
name|sctp_minrto
operator|=
name|sctp_rto_min_default
expr_stmt|;
name|m
operator|->
name|initial_rto
operator|=
name|sctp_rto_initial_default
expr_stmt|;
name|m
operator|->
name|initial_init_rto_max
operator|=
name|sctp_init_rto_max_default
expr_stmt|;
name|m
operator|->
name|sctp_sack_freq
operator|=
name|sctp_sack_freq_default
expr_stmt|;
name|m
operator|->
name|max_open_streams_intome
operator|=
name|MAX_SCTP_STREAMS
expr_stmt|;
name|m
operator|->
name|max_init_times
operator|=
name|sctp_init_rtx_max_default
expr_stmt|;
name|m
operator|->
name|max_send_times
operator|=
name|sctp_assoc_rtx_max_default
expr_stmt|;
name|m
operator|->
name|def_net_failure
operator|=
name|sctp_path_rtx_max_default
expr_stmt|;
name|m
operator|->
name|sctp_sws_sender
operator|=
name|SCTP_SWS_SENDER_DEF
expr_stmt|;
name|m
operator|->
name|sctp_sws_receiver
operator|=
name|SCTP_SWS_RECEIVER_DEF
expr_stmt|;
name|m
operator|->
name|max_burst
operator|=
name|sctp_max_burst_default
expr_stmt|;
comment|/* number of streams to pre-open on a association */
name|m
operator|->
name|pre_open_stream_count
operator|=
name|sctp_nr_outgoing_streams_default
expr_stmt|;
comment|/* Add adaptation cookie */
name|m
operator|->
name|adaptation_layer_indicator
operator|=
literal|0x504C5253
expr_stmt|;
comment|/* seed random number generator */
name|m
operator|->
name|random_counter
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|store_at
operator|=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|SCTP_READ_RANDOM
argument_list|(
name|m
operator|->
name|random_numbers
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|random_numbers
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_fill_random_store
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Minimum cookie size */
name|m
operator|->
name|size_of_a_cookie
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_msg
argument_list|)
operator|*
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
expr_stmt|;
name|m
operator|->
name|size_of_a_cookie
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
comment|/* Setup the initial secret */
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|m
operator|->
name|time_of_secret_change
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_OF_SECRETS
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|->
name|secret_key
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|sctp_select_initial_TSN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_NEWCOOKIE
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* How long is a cookie good for ? */
name|m
operator|->
name|def_cookie_life
operator|=
name|sctp_valid_cookie_life_default
expr_stmt|;
comment|/* 	 * Initialize authentication parameters 	 */
name|m
operator|->
name|local_hmacs
operator|=
name|sctp_default_supported_hmaclist
argument_list|()
expr_stmt|;
name|m
operator|->
name|local_auth_chunks
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
name|sctp_auth_set_default_chunks
argument_list|(
name|m
operator|->
name|local_auth_chunks
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|m
operator|->
name|shared_keys
argument_list|)
expr_stmt|;
comment|/* add default NULL key as key id 0 */
name|null_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
name|sctp_insert_sharedkey
argument_list|(
operator|&
name|m
operator|->
name|shared_keys
argument_list|,
name|null_key
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_move_pcb_and_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|old_inp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|new_inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|uint16_t
name|lport
decl_stmt|,
name|rport
decl_stmt|;
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|oladdr
decl_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|time_of_secret_change
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|time_of_secret_change
expr_stmt|;
name|memcpy
argument_list|(
name|new_inp
operator|->
name|sctp_ep
operator|.
name|secret_key
argument_list|,
name|old_inp
operator|->
name|sctp_ep
operator|.
name|secret_key
argument_list|,
sizeof|sizeof
argument_list|(
name|old_inp
operator|->
name|sctp_ep
operator|.
name|secret_key
argument_list|)
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|last_secret_number
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|last_secret_number
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|size_of_a_cookie
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|size_of_a_cookie
expr_stmt|;
comment|/* make it so new data pours into the new socket */
name|stcb
operator|->
name|sctp_socket
operator|=
name|new_inp
operator|->
name|sctp_socket
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|=
name|new_inp
expr_stmt|;
comment|/* Copy the port across */
name|lport
operator|=
name|new_inp
operator|->
name|sctp_lport
operator|=
name|old_inp
operator|->
name|sctp_lport
expr_stmt|;
name|rport
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
comment|/* Pull the tcb from the old association */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbhash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
comment|/* Now insert the new_inp into the TCP connected hash */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_tcpephash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
operator|(
name|lport
operator|+
name|rport
operator|)
argument_list|,
name|sctppcbinfo
operator|.
name|hashtcpmark
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|new_inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
comment|/* Its safe to access */
name|new_inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_UNBOUND
expr_stmt|;
comment|/* Now move the tcb into the endpoint list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_inp
operator|->
name|sctp_asoc_list
argument_list|,
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
comment|/* 	 * Question, do we even need to worry about the ep-hash since we 	 * only have one connection? Probably not :> so lets get rid of it 	 * and not suck up any kernel memory in that. 	 */
comment|/* Ok. Let's restart timer. */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|new_inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_inp
operator|->
name|sctp_tcbhash
operator|!=
name|NULL
condition|)
block|{
name|SCTP_HASH_FREE
argument_list|(
name|new_inp
operator|->
name|sctp_tcbhash
argument_list|,
name|new_inp
operator|->
name|sctp_hashmark
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|sctp_tcbhash
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new_inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Subset bound, so copy in the laddr list from the old_inp */
name|LIST_FOREACH
argument_list|(
argument|oladdr
argument_list|,
argument|&old_inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|laddr
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|laddr
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Gak, what can we do? This assoc is really 				 * HOSED. We probably should send an abort 				 * here. 				 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Association hosed in TCP model, out of laddr memory\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
continue|continue;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|laddr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|ifa
operator|=
name|oladdr
operator|->
name|ifa
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_inp
operator|->
name|sctp_addr_list
argument_list|,
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|laddr_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Now any running timers need to be adjusted since we really don't 	 * care if they are running or not just blast in the new_inp into 	 * all of them. 	 */
name|stcb
operator|->
name|asoc
operator|.
name|hb_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|shut_guard_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|autoclose_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|delayed_event_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
comment|/* now what about the nets? */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|pmtu_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|net
operator|->
name|rxt_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|net
operator|->
name|fr_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_isport_inuse
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|t_inp
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_ephash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|sctppcbinfo
operator|.
name|hashmark
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|t_inp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
if|if
condition|(
name|t_inp
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
continue|continue;
block|}
comment|/* is it in the VRF in question */
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t_inp
operator|->
name|def_vrf_id
operator|==
name|vrf_id
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
continue|continue;
comment|/* This one is in use. */
comment|/* check the v6/v4 binding issue */
if|if
condition|(
operator|(
name|t_inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|t_inp
argument_list|)
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
comment|/* collision in V6 space */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* inp is BOUND_V4 no conflict */
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|t_inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
comment|/* t_inp is bound v4 and v6, conflict always */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* t_inp is bound only V4 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* no conflict */
continue|continue;
block|}
comment|/* else fall through to conflict */
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_inpcb_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
comment|/* bind a ep to a socket address */
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
name|inp_tmp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|ip_inp
decl_stmt|;
name|int
name|bindall
decl_stmt|;
name|uint16_t
name|lport
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|lport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|bindall
operator|=
literal|1
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|ip_inp
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
if|if
condition|(
name|addr
condition|)
block|{
name|printf
argument_list|(
literal|"Bind called port:%d\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Addr :"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* already did a bind, subsequent binds NOT allowed ! */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* IPV6_V6ONLY socket? */
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|ip_inp
argument_list|)
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
name|lport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|bindall
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* Only for pure IPv6 Address. (No IPv4 Mapped!) */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|lport
operator|=
name|sin6
operator|->
name|sin6_port
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|bindall
operator|=
literal|0
expr_stmt|;
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|ip6_use_defzone
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* this must be cleared for ifa_ifwithaddr() */
name|sin6
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
block|}
comment|/* 	 * Setup a vrf_id to be the default for the non-bind-all case. 	 */
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* increase our count due to the unlock we do */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lport
condition|)
block|{
comment|/* 		 * Did the caller specify a port? if so we must see if a ep 		 * already has this one bound. 		 */
comment|/* got to be root to get at low ports */
if|if
condition|(
name|ntohs
argument_list|(
name|lport
argument_list|)
operator|<
name|IPPORT_RESERVED
condition|)
block|{
if|if
condition|(
name|p
operator|&&
operator|(
name|error
operator|=
name|priv_check_cred
argument_list|(
name|p
operator|->
name|td_ucred
argument_list|,
name|PRIV_NETINET_RESERVEDPORT
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
operator|)
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindall
condition|)
block|{
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|inp_tmp
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_tmp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * lock guy returned and lower count note 				 * that we are not bound so inp_tmp should 				 * NEVER be inp. And it is this inp 				 * (inp_tmp) that gets the reference bump, 				 * so we must lower it. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp_tmp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* unlock info */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
else|else
block|{
name|inp_tmp
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_tmp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * lock guy returned and lower count note 				 * that we are not bound so inp_tmp should 				 * NEVER be inp. And it is this inp 				 * (inp_tmp) that gets the reference bump, 				 * so we must lower it. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp_tmp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* unlock info */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindall
condition|)
block|{
comment|/* verify that no lport is not used by a singleton */
if|if
condition|(
name|sctp_isport_inuse
argument_list|(
name|inp
argument_list|,
name|lport
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
comment|/* Sorry someone already has this one bound */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * get any port but lets make sure no one has any address 		 * with this port bound 		 */
comment|/* 		 * setup the inp to the top (I could use the union but this 		 * is just as easy 		 */
name|uint32_t
name|port_guess
decl_stmt|;
name|uint16_t
name|port_attempt
decl_stmt|;
name|int
name|not_done
init|=
literal|1
decl_stmt|;
name|int
name|not_found
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|not_done
condition|)
block|{
name|port_guess
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|port_attempt
operator|=
operator|(
name|port_guess
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
if|if
condition|(
name|port_attempt
operator|==
literal|0
condition|)
block|{
goto|goto
name|next_half
goto|;
block|}
if|if
condition|(
name|port_attempt
operator|<
name|IPPORT_RESERVED
condition|)
block|{
name|port_attempt
operator|+=
name|IPPORT_RESERVED
expr_stmt|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
if|if
condition|(
name|sctp_isport_inuse
argument_list|(
name|inp
argument_list|,
name|htons
argument_list|(
name|port_attempt
argument_list|)
argument_list|,
name|vrf_id
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* got a port we can use */
name|not_found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|not_found
operator|==
literal|1
condition|)
block|{
comment|/* We can use this port */
name|not_done
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* try upper half */
name|next_half
label|:
name|port_attempt
operator|=
operator|(
operator|(
name|port_guess
operator|>>
literal|16
operator|)
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
if|if
condition|(
name|port_attempt
operator|==
literal|0
condition|)
block|{
goto|goto
name|last_try
goto|;
block|}
if|if
condition|(
name|port_attempt
operator|<
name|IPPORT_RESERVED
condition|)
block|{
name|port_attempt
operator|+=
name|IPPORT_RESERVED
expr_stmt|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
if|if
condition|(
name|sctp_isport_inuse
argument_list|(
name|inp
argument_list|,
name|htons
argument_list|(
name|port_attempt
argument_list|)
argument_list|,
name|vrf_id
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* got a port we can use */
name|not_found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|not_found
operator|==
literal|1
condition|)
block|{
comment|/* We can use this port */
name|not_done
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* try two half's added together */
name|last_try
label|:
name|port_attempt
operator|=
operator|(
operator|(
operator|(
name|port_guess
operator|>>
literal|16
operator|)
operator|&
literal|0x0000ffff
operator|)
operator|+
operator|(
name|port_guess
operator|&
literal|0x0000ffff
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|port_attempt
operator|==
literal|0
condition|)
block|{
comment|/* get a new random number */
continue|continue;
block|}
if|if
condition|(
name|port_attempt
operator|<
name|IPPORT_RESERVED
condition|)
block|{
name|port_attempt
operator|+=
name|IPPORT_RESERVED
expr_stmt|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
if|if
condition|(
name|sctp_isport_inuse
argument_list|(
name|inp
argument_list|,
name|htons
argument_list|(
name|port_attempt
argument_list|)
argument_list|,
name|vrf_id
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* got a port we can use */
name|not_found
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|not_found
operator|==
literal|1
condition|)
block|{
comment|/* We can use this port */
name|not_done
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* we don't get out of the loop until we have a port */
name|lport
operator|=
name|htons
argument_list|(
name|port_attempt
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
operator|(
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
comment|/* 		 * this really should not happen. The guy did a non-blocking 		 * bind and then did a close at the same time. 		 */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* ok we look clear to give out this port, so lets setup the binding */
if|if
condition|(
name|bindall
condition|)
block|{
comment|/* binding to all addresses, so just set in the proper flags */
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_BOUNDALL
expr_stmt|;
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
expr_stmt|;
comment|/* set the automatic addr changes from kernel flag */
if|if
condition|(
name|sctp_auto_asconf
operator|==
literal|0
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * bind specific, make sure flags is off and add a new 		 * address structure to the sctp_addr_list inside the ep 		 * structure. 		 *  		 * We will need to allocate one and insert it at the head. The 		 * socketopt call can just insert new addresses in there as 		 * well. It will also have to do the embed scope kame hack 		 * too (before adding). 		 */
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_storage
name|store_sa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|store_sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store_sa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store_sa
expr_stmt|;
name|memcpy
argument_list|(
name|sin
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store_sa
expr_stmt|;
name|memcpy
argument_list|(
name|sin6
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * first find the interface with the bound address need to 		 * zero out the port to find the address! yuck! can't do 		 * this earlier since need port for sctp_pcb_findep() 		 */
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|store_sa
argument_list|,
name|vrf_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* Can't find an interface with that address */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* GAK, more FIXME IFA lock? */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
comment|/* Can't bind a non-existent addr. */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* we're not bound all */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_BOUNDALL
expr_stmt|;
comment|/* set the automatic addr changes from kernel flag */
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_auto_asconf
operator|==
literal|0
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * allow bindx() to send ASCONF's for binding 			 * changes 			 */
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
comment|/* add this address to the endpoint list */
name|error
operator|=
name|sctp_insert_laddr
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|,
name|ifa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|inp
operator|->
name|laddr_count
operator|++
expr_stmt|;
block|}
comment|/* find the bucket */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_ephash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|sctppcbinfo
operator|.
name|hashmark
argument_list|)
index|]
expr_stmt|;
comment|/* put it in the bucket */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Main hash to bind at head:%p, bound port:%d\n"
argument_list|,
name|head
argument_list|,
name|ntohs
argument_list|(
name|lport
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* set in the port */
name|inp
operator|->
name|sctp_lport
operator|=
name|lport
expr_stmt|;
comment|/* turn off just the unbound flag */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_UNBOUND
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_iterator_inp_being_freed
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp_next
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
decl_stmt|;
comment|/* 	 * We enter with the only the ITERATOR_LOCK in place and a write 	 * lock on the inp_info stuff. 	 */
comment|/* 	 * Go through all iterators, we must do this since it is possible 	 * that some iterator does NOT have the lock, but is waiting for it. 	 * And the one that had the lock has either moved in the last 	 * iteration or we just cleared it above. We need to find all of 	 * those guys. The list of iterators should never be very big 	 * though. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|it
argument_list|,
argument|&sctppcbinfo.iteratorhead
argument_list|,
argument|sctp_nxt_itr
argument_list|)
block|{
if|if
condition|(
name|it
operator|==
name|inp
operator|->
name|inp_starting_point_for_iterator
condition|)
comment|/* skip this guy, he's special */
continue|continue;
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|inp
condition|)
block|{
comment|/* 			 * This is tricky and we DON'T lock the iterator. 			 * Reason is he's running but waiting for me since 			 * inp->inp_starting_point_for_iterator has the lock 			 * on me (the guy above we skipped). This tells us 			 * its is not running but waiting for 			 * inp->inp_starting_point_for_iterator to be 			 * released by the guy that does have our INP in a 			 * lock. 			 */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
name|it
operator|->
name|stcb
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* set him up to do the next guy not me */
name|it
operator|->
name|inp
operator|=
name|inp_next
expr_stmt|;
name|it
operator|->
name|stcb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|it
operator|=
name|inp
operator|->
name|inp_starting_point_for_iterator
expr_stmt|;
if|if
condition|(
name|it
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|it
operator|->
name|inp
operator|=
name|inp_next
expr_stmt|;
block|}
name|it
operator|->
name|stcb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* release sctp_inpcb unbind the port */
end_comment

begin_function
name|void
name|sctp_inpcb_free
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|/* 	 * Here we free a endpoint. We must find it (if it is in the Hash 	 * table) and remove it from there. Then we must also find it in the 	 * overall list and remove it from there. After all removals are 	 * complete then any timer has to be stopped. Then start the actual 	 * freeing. a) Any local lists. b) Any associations. c) The hash of 	 * all associations. d) finally the ep itself. 	 */
name|struct
name|sctp_pcb
modifier|*
name|m
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp_save
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|asoc
decl_stmt|,
modifier|*
name|nasoc
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|nladdr
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|ip_pcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|sq
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|shared_key
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
comment|/* been here before.. eeks.. get out of here */
name|printf
argument_list|(
literal|"This conflict in free SHOULD not be happening!\n"
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * First time through we have the socket lock, after that no more. 	 */
if|if
condition|(
name|from
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Once we are in we can remove the flag from = 1 is only 		 * passed from the actual closing routines that are called 		 * via the sockets layer. 		 */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_CLOSE_IP
expr_stmt|;
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_NEWCOOKIE
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|inp
operator|->
name|control
argument_list|)
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|pkt
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|inp
operator|->
name|pkt
argument_list|)
expr_stmt|;
name|inp
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
expr_stmt|;
name|ip_pcb
operator|=
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
comment|/* we could just cast the main pointer 					 * here but I will be nice :> (i.e. 					 * ip_pcb = ep;) */
if|if
condition|(
name|immediate
operator|==
literal|0
condition|)
block|{
name|int
name|cnt_in_sd
decl_stmt|;
name|cnt_in_sd
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|asoc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
operator|)
init|;
name|asoc
operator|!=
name|NULL
condition|;
name|asoc
operator|=
name|nasoc
control|)
block|{
name|nasoc
operator|=
name|LIST_NEXT
argument_list|(
name|asoc
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* Skip guys being freed */
name|asoc
operator|->
name|sctp_socket
operator|=
name|NULL
expr_stmt|;
name|cnt_in_sd
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
comment|/* Just abandon things in the front states */
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|==
literal|0
condition|)
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_NOFORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
comment|/* Disconnect the socket please */
name|asoc
operator|->
name|sctp_socket
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_CLOSED_SOCKET
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|size_on_reasm_queue
operator|>
literal|0
operator|)
operator|||
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|control_pdapi
operator|)
operator|||
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|size_on_all_streams
operator|>
literal|0
operator|)
operator|||
operator|(
name|so
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Left with Data unread */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* Fill in the user initiated abort */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_3
expr_stmt|;
name|sctp_send_abort_tcb
argument_list|(
name|asoc
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_NOFORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* 					 * there is nothing queued to send, 					 * so I send shutdown 					 */
name|sctp_send_shutdown
argument_list|(
name|asoc
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|asoc
operator|->
name|sctp_ep
argument_list|,
name|asoc
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|asoc
operator|->
name|sctp_ep
argument_list|,
name|asoc
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_OUTPUT_FROM_SHUT_TMR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mark into shutdown pending */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|asoc
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|asoc
operator|->
name|sctp_ep
argument_list|,
name|asoc
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
condition|)
block|{
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error, sp is NULL, locked on sending is %p strm:%d\n"
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|->
name|stream_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_anyway
label|:
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_5
expr_stmt|;
name|sctp_send_abort_tcb
argument_list|(
name|asoc
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_NOFORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|cnt_in_sd
operator|++
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
block|}
comment|/* now is there some left in our SHUTDOWN state? */
if|if
condition|(
name|cnt_in_sd
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
block|}
name|inp
operator|->
name|sctp_socket
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|!=
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* 		 * ok, this guy has been bound. It's port is somewhere in 		 * the sctppcbinfo hash table. Remove it! 		 */
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_UNBOUND
expr_stmt|;
block|}
comment|/* 	 * If there is a timer running to kill us, forget it, since it may 	 * have a contest on the INP lock.. which would cause us to die ... 	 */
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|asoc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
operator|)
init|;
name|asoc
operator|!=
name|NULL
condition|;
name|asoc
operator|=
name|nasoc
control|)
block|{
name|nasoc
operator|=
name|LIST_NEXT
argument_list|(
name|asoc
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Free associations that are NOT killing us */
name|SCTP_TCB_LOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* Fill in the user initiated abort */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_7
expr_stmt|;
name|sctp_send_abort_tcb
argument_list|(
name|asoc
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_FORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
condition|)
block|{
comment|/* Ok we have someone out there that will kill us */
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|refcount
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
condition|)
block|{
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INPKILL
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|type
operator|=
name|SCTP_TIMER_TYPE_NONE
expr_stmt|;
comment|/* Clear the read queue */
while|while
condition|(
operator|(
name|sq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Its only abandoned if it had data left */
if|if
condition|(
name|sq
operator|->
name|length
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_left_abandon
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|sq
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|sq
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|-=
name|sq
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sq
operator|->
name|data
argument_list|)
expr_stmt|;
name|sq
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * no need to free the net count, since at this point all 		 * assoc's are gone. 		 */
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_readq
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
block|}
comment|/* Now the sctp_pcb things */
comment|/* 	 * free each asoc if it is not already closed/free. we can't use the 	 * macro here since le_next will get freed as part of the 	 * sctp_free_assoc() call. 	 */
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
ifdef|#
directive|ifdef
name|IPSEC
name|ipsec4_delete_pcbpolicy
argument_list|(
name|ip_pcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC */
comment|/* Unlocks not needed since the socket is gone now */
block|}
if|if
condition|(
name|ip_pcb
operator|->
name|inp_options
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_m_free
argument_list|(
name|ip_pcb
operator|->
name|inp_options
argument_list|)
expr_stmt|;
name|ip_pcb
operator|->
name|inp_options
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ip_pcb
operator|->
name|inp_moptions
condition|)
block|{
name|ip_freemoptions
argument_list|(
name|ip_pcb
operator|->
name|inp_moptions
argument_list|)
expr_stmt|;
name|ip_pcb
operator|->
name|inp_moptions
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ip_pcb
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
block|{
name|struct
name|in6pcb
modifier|*
name|in6p
decl_stmt|;
name|in6p
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
name|ip6_freepcbopts
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|ip_pcb
operator|->
name|inp_vflag
operator|=
literal|0
expr_stmt|;
comment|/* free up authentication fields */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
operator|!=
name|NULL
condition|)
name|sctp_free_chunklist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
name|sctp_free_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|shared_key
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|)
expr_stmt|;
while|while
condition|(
name|shared_key
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|shared_key
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|shared_key
argument_list|)
expr_stmt|;
name|shared_key
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|)
expr_stmt|;
block|}
name|inp_save
operator|=
name|LIST_NEXT
argument_list|(
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
comment|/* fix any iterators only after out of the list */
name|sctp_iterator_inp_being_freed
argument_list|(
name|inp
argument_list|,
name|inp_save
argument_list|)
expr_stmt|;
comment|/* 	 * if we have an address list the following will free the list of 	 * ifaddr's that are set into this ep. Again macro limitations here, 	 * since the LIST_FOREACH could be a bad idea. 	 */
for|for
control|(
operator|(
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
operator|)
init|;
name|laddr
operator|!=
name|NULL
condition|;
name|laddr
operator|=
name|nladdr
control|)
block|{
name|nladdr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_TRACK_FREED_ASOCS
comment|/* TEMP CODE */
for|for
control|(
operator|(
name|asoc
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_free_list
argument_list|)
operator|)
init|;
name|asoc
operator|!=
name|NULL
condition|;
name|asoc
operator|=
name|nasoc
control|)
block|{
name|nasoc
operator|=
name|LIST_NEXT
argument_list|(
name|asoc
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|asoc
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
block|}
comment|/* *** END TEMP CODE *** */
endif|#
directive|endif
comment|/* Now lets see about freeing the EP hash table. */
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
operator|!=
name|NULL
condition|)
block|{
name|SCTP_HASH_FREE
argument_list|(
name|inp
operator|->
name|sctp_tcbhash
argument_list|,
name|inp
operator|->
name|sctp_hashmark
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_tcbhash
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now we must put the ep memory back into the zone pool */
name|SCTP_INP_LOCK_DESTROY
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_DESTROY
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK_DESTROY
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_ep
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|SCTP_DECR_EP_COUNT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|sctp_nets
modifier|*
name|sctp_findnet
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* locate the address */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
condition|)
return|return
operator|(
name|net
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add's a remote endpoint address, done with the INIT/INIT-ACK as well as  * when a ASCONF arrives that adds it. It will also initialize all the cwnd  * stats of stuff.  */
end_comment

begin_function
name|int
name|sctp_is_address_on_local_host
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|sctp_ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifa
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_set_initial_cc_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|net
operator|->
name|cwnd
operator|=
name|min
argument_list|(
operator|(
name|net
operator|->
name|mtu
operator|*
literal|4
operator|)
argument_list|,
name|max
argument_list|(
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
argument_list|,
name|SCTP_INITIAL_CWND
argument_list|)
argument_list|)
expr_stmt|;
comment|/* we always get at LEAST 2 MTU's */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|net
operator|->
name|cwnd
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|ssthresh
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_add_remote_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|newaddr
parameter_list|,
name|int
name|set_scope
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|/* 	 * The following is redundant to the same lines in the 	 * sctp_aloc_assoc() but is needed since other's call the add 	 * address function 	 */
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|netfirst
decl_stmt|;
name|int
name|addr_inscope
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Adding an address (from:%d) to the peer: "
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|newaddr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|netfirst
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netfirst
condition|)
block|{
comment|/* 		 * Lie and return ok, we don't want to make the association 		 * go away for this behavior. It will happen in the TCP 		 * model in a connected socket. It does not reach the hash 		 * table until after the association is built so it can't be 		 * found. Mark as reachable, since the initial creation will 		 * have been cleared and the NOT_IN_ASSOC flag will have 		 * been added... and we don't want to end up removing it 		 * back out. 		 */
if|if
condition|(
name|netfirst
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|netfirst
operator|->
name|dest_state
operator|=
operator|(
name|SCTP_ADDR_REACHABLE
operator||
name|SCTP_ADDR_UNCONFIRMED
operator|)
expr_stmt|;
block|}
else|else
block|{
name|netfirst
operator|->
name|dest_state
operator|=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr_inscope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|newaddr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* Invalid address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* zero out the bzero area */
name|memset
argument_list|(
operator|&
name|sin
operator|->
name|sin_zero
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_zero
argument_list|)
argument_list|)
expr_stmt|;
comment|/* assure len is set */
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_scope
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DONT_DO_PRIVADDR_SCOPE
name|stcb
operator|->
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DONT_DO_PRIVADDR_SCOPE */
block|}
else|else
block|{
comment|/* Validate the address is in scope */
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|newaddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Invalid address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* assure len is set */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_scope
condition|)
block|{
if|if
condition|(
name|sctp_is_address_on_local_host
argument_list|(
name|newaddr
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 				 * If the new destination is a LINK_LOCAL we 				 * must have common site scope. Don't set 				 * the local scope since we may not share 				 * all links, only loopback can do this. 				 * Links on the local network would also be 				 * on our private network for v4 too. 				 */
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 				 * If the new destination is SITE_LOCAL then 				 * we must have site scope in common. 				 */
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Validate the address is in scope */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* not supported family type */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|net
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_net
argument_list|,
expr|struct
name|sctp_nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_INCR_RADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|net
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|net
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|newaddr
argument_list|,
name|newaddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
block|}
name|net
operator|->
name|addr_is_local
operator|=
name|sctp_is_address_on_local_host
argument_list|(
name|newaddr
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|addr_is_local
operator|&&
operator|(
operator|(
name|set_scope
operator|||
operator|(
name|from
operator|==
name|SCTP_ADDR_IS_CONFIRMED
operator|)
operator|)
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|addr_inscope
operator|=
literal|1
expr_stmt|;
block|}
name|net
operator|->
name|failure_threshold
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
expr_stmt|;
if|if
condition|(
name|addr_inscope
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|dest_state
operator|=
operator|(
name|SCTP_ADDR_REACHABLE
operator||
name|SCTP_ADDR_OUT_OF_SCOPE
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|from
operator|==
name|SCTP_ADDR_IS_CONFIRMED
condition|)
comment|/* SCTP_ADDR_IS_CONFIRMED is passed by connect_x */
name|net
operator|->
name|dest_state
operator|=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
else|else
name|net
operator|->
name|dest_state
operator|=
name|SCTP_ADDR_REACHABLE
operator||
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|++
expr_stmt|;
operator|*
operator|(
operator|&
name|net
operator|->
name|ref_count
operator|)
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|tos_flowlabel
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|net
operator|->
name|tos_flowlabel
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_tos
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
name|net
operator|->
name|tos_flowlabel
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
expr_stmt|;
endif|#
directive|endif
comment|/* Init the timer structure */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* Now generate a route for this guy */
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|ip6_use_defzone
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_RTALLOC
argument_list|(
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|table_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_ROUTE_HAS_VALID_IFN
argument_list|(
operator|&
name|net
operator|->
name|ro
argument_list|)
condition|)
block|{
comment|/* Get source address */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
comment|/* Now get the interface MTU */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|ifn_p
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|SCTP_GATHER_MTU_FROM_INTFC
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|ifn_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|mtu
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_PRINT_FOR_B_AND_M
name|printf
argument_list|(
literal|"We have found an interface mtu of %d\n"
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|net
operator|->
name|mtu
operator|==
literal|0
condition|)
block|{
comment|/* Huh ?? */
name|net
operator|->
name|mtu
operator|=
name|SCTP_DEFAULT_MTU
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|rmtu
decl_stmt|;
name|rmtu
operator|=
name|SCTP_GATHER_MTU_FROM_ROUTE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|,
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_PRINT_FOR_B_AND_M
name|printf
argument_list|(
literal|"The route mtu is %d\n"
argument_list|,
name|rmtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rmtu
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Start things off to match mtu of 				 * interface please. 				 */
name|SCTP_SET_MTU_OF_ROUTE
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|,
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * we take the route mtu over the interface, 				 * since the route may be leading out the 				 * loopback, or a different interface. 				 */
name|net
operator|->
name|mtu
operator|=
name|rmtu
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from
operator|==
name|SCTP_ALLOC_ASOC
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_PRINT_FOR_B_AND_M
name|printf
argument_list|(
literal|"New assoc sets mtu to :%d\n"
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|->
name|mtu
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_PRINT_FOR_B_AND_M
name|printf
argument_list|(
literal|"new address mtu:%d smaller than smallest:%d\n"
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
comment|/* 	 * We take the max of the burst limit times a MTU or the 	 * INITIAL_CWND. We then limit this to 4 MTU's of sending. 	 */
name|sctp_set_initial_cc_param
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_CWND_MONITOR
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_CWND_LOGGING
argument_list|)
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_INITIALIZATION
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * CMT: CUC algo - set find_pseudo_cumack to TRUE (1) at beginning 	 * of assoc (2005/06/27, iyengar@cis.udel.edu) 	 */
name|net
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
name|netfirst
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* Since we have no route put it at the back */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netfirst
operator|==
name|NULL
condition|)
block|{
comment|/* We are the first one in the pool. */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netfirst
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * First one has NO route. Place this one ahead of the first 		 * one. 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|!=
name|netfirst
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
condition|)
block|{
comment|/* 		 * This one has a different interface than the one at the 		 * top of the list. Place it ahead. 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Ok we have the same interface as the first one. Move 		 * forward until we find either a) one with a NULL route... 		 * insert ahead of that b) one with a different ifp.. insert 		 * after that. c) end of the list.. insert at the tail. 		 */
name|struct
name|sctp_nets
modifier|*
name|netlook
decl_stmt|;
do|do
block|{
name|netlook
operator|=
name|TAILQ_NEXT
argument_list|(
name|netfirst
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|netlook
operator|==
name|NULL
condition|)
block|{
comment|/* End of the list */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|netlook
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* next one has NO route */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|netfirst
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|netlook
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|!=
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|netlook
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Shift forward */
name|netfirst
operator|=
name|netlook
expr_stmt|;
block|}
do|while
condition|(
name|netlook
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* got to have a primary set */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|)
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* No route to current primary adopt new primary */
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* Validate primary is first */
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
condition|)
block|{
comment|/* 		 * first one on the list is NOT the primary sctp_cmpaddr() 		 * is much more efficent if the primary is the first on the 		 * list, make it so. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocate an association and add it to the endpoint. The caller must be  * careful to add all additional addresses once they are know right away or  * else the assoc will be may experience a blackout scenario.  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_aloc_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|firstaddr
parameter_list|,
name|int
name|for_a_init
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|uint32_t
name|override_tag
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|uint16_t
name|rport
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Assumption made here: Caller has done a 	 * sctp_findassociation_ep_addr(ep, addr's); to make sure the 	 * address does not exist already. 	 */
if|if
condition|(
name|sctppcbinfo
operator|.
name|ipi_count_asoc
operator|>=
name|SCTP_MAX_NUM_OF_ASOC
condition|)
block|{
comment|/* Hit max assoc, sorry no more */
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
condition|)
block|{
comment|/* 		 * If its in the TCP pool, its NOT allowed to create an 		 * association. The parent listener needs to call 		 * sctp_aloc_assoc.. or the one-2-many socket. If a peeled 		 * off, or connected one does this.. its an error. 		 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB3
condition|)
block|{
name|printf
argument_list|(
literal|"Allocate an association for peer:"
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstaddr
condition|)
name|sctp_print_address
argument_list|(
name|firstaddr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"None\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Port:%d\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|firstaddr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|firstaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|firstaddr
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|->
name|sin_port
operator|==
literal|0
operator|)
operator|||
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Invalid address */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|firstaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|firstaddr
expr_stmt|;
if|if
condition|(
operator|(
name|sin6
operator|->
name|sin6_port
operator|==
literal|0
operator|)
operator|||
operator|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* Invalid address */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rport
operator|=
name|sin6
operator|->
name|sin6_port
expr_stmt|;
block|}
else|else
block|{
comment|/* not supported family type */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* 		 * If you have not performed a bind, then we need to do the 		 * ephemerial bind for you. 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|sctp_inpcb_bind
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
operator|)
condition|)
block|{
comment|/* bind error, probably perm */
operator|*
name|error
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|stcb
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
expr|struct
name|sctp_tcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory? */
operator|*
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INCR_ASOC_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|stcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stcb
argument_list|)
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_INIT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_INIT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* setup back pointer's */
name|stcb
operator|->
name|sctp_ep
operator|=
name|inp
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sctp_init_asoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|for_a_init
argument_list|,
name|override_tag
argument_list|,
name|vrf_id
argument_list|)
operator|)
condition|)
block|{
comment|/* failed */
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
operator|*
name|error
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* and the port */
name|stcb
operator|->
name|rport
operator|=
name|rport
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
operator|(
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
comment|/* inpcb freed while alloc going on */
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* now that my_vtag is set, add it to the hash */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_asochash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|,
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
index|]
expr_stmt|;
comment|/* put it in the bucket in the vtag hash of assoc's for the system */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|firstaddr
argument_list|,
name|SCTP_DO_SETSCOPE
argument_list|,
name|SCTP_ALLOC_ASOC
argument_list|)
operator|)
condition|)
block|{
comment|/* failure.. memory error? */
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|mapping_array
condition|)
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Init all the timers */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|,
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
comment|/* now file the port under the hash as well */
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
name|inp
operator|->
name|sctp_tcbhash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|stcb
operator|->
name|rport
argument_list|,
name|inp
operator|->
name|sctp_hashmark
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_tcbhash
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Association %p now allocated\n"
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_remove_net
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|asoc
operator|->
name|numnets
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|asoc
operator|->
name|primary_destination
condition|)
block|{
comment|/* Reset primary */
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|lnet
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
comment|/* Try to find a confirmed primary */
name|asoc
operator|->
name|primary_destination
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|asoc
operator|->
name|last_data_chunk_from
condition|)
block|{
comment|/* Reset primary */
name|asoc
operator|->
name|last_data_chunk_from
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|asoc
operator|->
name|last_control_chunk_from
condition|)
block|{
comment|/* Clear net */
name|asoc
operator|->
name|last_control_chunk_from
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|net
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a remote endpoint address from an association, it will fail if the  * address does not exist.  */
end_comment

begin_function
name|int
name|sctp_del_remote_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|remaddr
parameter_list|)
block|{
comment|/* 	 * Here we need to remove a remote address. This is quite simple, we 	 * first find it in the list of address for the association 	 * (tasoc->asoc.nets) and then if it is there, we do a LIST_REMOVE 	 * on that item. Note we do not allow it to be removed if there are 	 * no other addresses. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|net_tmp
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* locate the address */
for|for
control|(
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
init|;
name|net
operator|!=
name|NULL
condition|;
name|net
operator|=
name|net_tmp
control|)
block|{
name|net_tmp
operator|=
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|remaddr
operator|->
name|sa_family
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|remaddr
argument_list|)
condition|)
block|{
comment|/* we found the guy */
if|if
condition|(
name|asoc
operator|->
name|numnets
operator|<
literal|2
condition|)
block|{
comment|/* Must have at LEAST two remote addresses */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|sctp_remove_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* not found. */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_add_vtag_to_timewait
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|uint32_t
name|time
parameter_list|)
block|{
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|set
decl_stmt|,
name|i
decl_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|chain
operator|=
operator|&
name|sctppcbinfo
operator|.
name|vtag_timewait
index|[
operator|(
name|tag
operator|%
name|SCTP_STACK_VTAG_HASH_SIZE
operator|)
index|]
expr_stmt|;
name|set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
comment|/* Block(s) present, lets find space, and expire on the fly */
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_IN_VTAG_BLOCK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
literal|0
operator|)
operator|&&
operator|!
name|set
condition|)
block|{
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|time
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
name|tag
expr_stmt|;
name|set
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|)
operator|&&
operator|(
operator|(
name|long
operator|)
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|>
name|now
operator|.
name|tv_sec
operator|)
condition|)
block|{
comment|/* Audit expires this guy */
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
condition|)
block|{
comment|/* Reuse it for my new tag */
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|tv_sec_at_expire
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|SCTP_TIME_WAIT
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|v_tag
operator|=
name|tag
expr_stmt|;
name|set
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|set
condition|)
block|{
comment|/* 				 * We only do up to the block where we can 				 * place our tag for audits 				 */
break|break;
block|}
block|}
block|}
comment|/* Need to add a new block to chain */
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|SCTP_MALLOC
argument_list|(
name|twait_block
argument_list|,
expr|struct
name|sctp_tagblock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tagblock
argument_list|)
argument_list|,
literal|"TimeWait"
argument_list|)
expr_stmt|;
if|if
condition|(
name|twait_block
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
name|twait_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tagblock
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|chain
argument_list|,
name|twait_block
argument_list|,
name|sctp_nxt_tagblock
argument_list|)
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|tv_sec_at_expire
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|SCTP_TIME_WAIT
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|v_tag
operator|=
name|tag
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_iterator_asoc_being_freed
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
decl_stmt|;
comment|/* 	 * Unlock the tcb lock we do this so we avoid a dead lock scenario 	 * where the iterator is waiting on the TCB lock and the TCB lock is 	 * waiting on the iterator lock. 	 */
name|it
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|stcb_starting_point_for_iterator
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|!=
name|stcb
operator|->
name|sctp_ep
condition|)
block|{
comment|/* hmm, focused on the wrong one? */
return|return;
block|}
if|if
condition|(
name|it
operator|->
name|stcb
operator|!=
name|stcb
condition|)
block|{
return|return;
block|}
name|it
operator|->
name|stcb
operator|=
name|LIST_NEXT
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* done with all asoc's in this assoc */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Free the association after un-hashing the remote port.  */
end_comment

begin_function
name|int
name|sctp_free_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|from_inpcbfree
parameter_list|,
name|int
name|from_location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aparam
decl_stmt|;
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|sq
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|shared_key
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|ccnt
init|=
literal|0
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* first, lets purge the entry from the hash table. */
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* there is no asoc, really TSNH :-0 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* TEMP CODE */
if|if
condition|(
name|stcb
operator|->
name|freed_from_where
operator|==
literal|0
condition|)
block|{
comment|/* Only record the first place free happened from */
name|stcb
operator|->
name|freed_from_where
operator|=
name|from_location
expr_stmt|;
block|}
comment|/* TEMP CODE */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
comment|/* nothing around */
name|so
operator|=
name|NULL
expr_stmt|;
else|else
name|so
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
comment|/* 	 * We used timer based freeing if a reader or writer is in the way. 	 * So we first check if we are actually being called from a timer, 	 * if so we abort early if a reader or writer is still in the way. 	 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|&&
operator|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
operator|)
condition|)
block|{
comment|/* 		 * is it the timer driving us? if so are the reader/writers 		 * gone? 		 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
condition|)
block|{
comment|/* nope, reader or writer in the way */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* no asoc destroyed */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* now clean up any other timers */
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|hb_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|dack_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/*- 	 * For stream reset we don't blast this unless 	 * it is a str-reset timer, it might be the 	 * free-asoc timer which we DON'T want to 	 * disturb. 	 */
if|if
condition|(
name|asoc
operator|->
name|strreset_timer
operator|.
name|type
operator|==
name|SCTP_TIMER_TYPE_STRRESET
condition|)
name|asoc
operator|->
name|strreset_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|asconf_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|autoclose_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|net
operator|->
name|fr_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|net
operator|->
name|rxt_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|net
operator|->
name|pmtu_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now the read queue needs to be cleaned up (only once) */
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_ABOUT_TO_BE_FREED
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sq
argument_list|,
argument|&inp->read_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|sq
operator|->
name|stcb
operator|==
name|stcb
condition|)
block|{
name|sq
operator|->
name|do_not_ref_stcb
operator|=
literal|1
expr_stmt|;
name|sq
operator|->
name|sinfo_cumtsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
comment|/* 				 * If there is no end, there never will be 				 * now. 				 */
if|if
condition|(
name|sq
operator|->
name|end_added
operator|==
literal|0
condition|)
block|{
comment|/* Held for PD-API clear that. */
name|sq
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|sq
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
condition|)
block|{
comment|/* 						 * Need to add a PD-API 						 * aborted indication. 						 * Setting the control_pdapi 						 * assures that it will be 						 * added right after this 						 * msg. 						 */
name|uint32_t
name|strseq
decl_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|sq
expr_stmt|;
name|strseq
operator|=
operator|(
name|sq
operator|->
name|sinfo_stream
operator|<<
literal|16
operator|)
operator||
name|sq
operator|->
name|sinfo_ssn
expr_stmt|;
name|sctp_notify_partial_delivery_indication
argument_list|(
name|stcb
argument_list|,
name|SCTP_PARTIAL_DELIVERY_ABORTED
argument_list|,
literal|1
argument_list|,
name|strseq
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Add an end to wake them */
name|sq
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|block_entry
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|->
name|error
operator|=
name|ECONNRESET
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|from_inpcbfree
operator|!=
name|SCTP_PCBFREE_FORCE
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
operator|)
condition|)
block|{
comment|/* 		 * reader or writer in the way, we have hopefully given him 		 * something to chew on above. 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
comment|/* nothing around */
name|so
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
comment|/* Wake any reader/writers */
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sctp_sowwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|9
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no asoc destroyed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * When I reach here, no others want to kill the assoc yet.. and I 	 * own the lock. Now its possible an abort comes in when I do the 	 * lock exchange below to grab all the locks to do the final take 	 * out. to prevent this we increment the count, which will start a 	 * timer and blow out above thus assuring us that we hold exclusive 	 * killing of the asoc. Note that after getting back the TCB lock we 	 * will go ahead and increment the counter back up and stop any 	 * timer a passing stranger may have started :-S 	 */
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* Double check the GONE flag */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
comment|/* nothing around */
name|so
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* 		 * For TCP type we need special handling when we are 		 * connected. We also include the peel'ed off ones to. 		 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_WAS_CONNECTED
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator||
name|SS_ISCONNECTED
operator|)
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sctp_sowwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SCTP_SOWAKEUP
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Make it invalid too, that way if its about to run it will abort 	 * and return. 	 */
name|sctp_iterator_asoc_being_freed
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
comment|/* re-increment the lock */
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbhash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|in_restart_hash
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbrestarhash
argument_list|)
expr_stmt|;
block|}
comment|/* Now lets remove it from the list of ALL associations in the EP */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
block|}
comment|/* pull from vtag hash */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|sctp_add_vtag_to_timewait
argument_list|(
name|inp
argument_list|,
name|asoc
operator|->
name|my_vtag
argument_list|,
name|SCTP_TIME_WAIT
argument_list|)
expr_stmt|;
comment|/* 	 * Now restop the timers to be sure - this is paranoia at is finest! 	 */
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|strreset_timer
operator|.
name|type
operator|=
name|SCTP_TIMER_TYPE_NONE
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The chunk lists and such SHOULD be empty but we check them just 	 * in case. 	 */
comment|/* anything on the wheel needs to be removed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|outs
operator|=
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
expr_stmt|;
comment|/* now clean up any chunks here */
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sctp_free_spbufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* Free the zone stuff  */
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_strmoq
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|SCTP_DECR_STRMOQ_COUNT
argument_list|()
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|liste
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|liste
argument_list|)
expr_stmt|;
block|}
name|sq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|sq
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|sq
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sq
operator|->
name|data
argument_list|)
expr_stmt|;
name|sq
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|sq
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sq
operator|->
name|whoFrom
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|stcb
operator|=
name|NULL
expr_stmt|;
comment|/* Free the ctl entry */
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_readq
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
name|sq
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
block|}
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|free_chunks
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|free_chunks
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|ccnt
operator|++
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_chunk
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|ipi_free_chunks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|free_chunk_cnt
operator|--
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|free_chunks
argument_list|)
expr_stmt|;
block|}
comment|/* pending send queue SHOULD be empty */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
condition|)
block|{
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|ccnt
operator|++
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_chunk
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*   if(ccnt) {   printf("Freed %d from send_queue\n", ccnt);   ccnt = 0;   } */
comment|/* sent queue SHOULD be empty */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|ccnt
operator|++
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_chunk
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*   if(ccnt) {   printf("Freed %d from sent_queue\n", ccnt);   ccnt = 0;   } */
comment|/* control queue MAY not be empty */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
condition|)
block|{
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|ccnt
operator|++
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_chunk
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*   if(ccnt) {   printf("Freed %d from ctrl_queue\n", ccnt);   ccnt = 0;   } */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|ccnt
operator|++
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_chunk
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*   if(ccnt) {   printf("Freed %d from reasm_queue\n", ccnt);   ccnt = 0;   } */
if|if
condition|(
name|asoc
operator|->
name|mapping_array
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* the stream outs */
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|streamoutcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmin
condition|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
condition|)
block|{
comment|/* We have somethings on the streamin queue */
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|ctl
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|ctl
operator|->
name|data
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 					 * We don't free the address here 					 * since all the net's were freed 					 * above. 					 */
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_readq
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmin
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmin
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|streamincnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
condition|)
block|{
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
comment|/* pull from list */
if|if
condition|(
operator|(
name|sctppcbinfo
operator|.
name|ipi_count_raddr
operator|==
literal|0
operator|)
operator|||
operator|(
name|prev
operator|==
name|net
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"no net's left alloc'ed, or list points to itself"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|prev
operator|=
name|net
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|net
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|SCTP_LIST_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sctp_restricted_addrs
argument_list|)
condition|)
block|{
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sctp_restricted_addrs
argument_list|)
expr_stmt|;
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
comment|/* pending asconf (address) parameters */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|)
condition|)
block|{
name|aparam
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|,
name|aparam
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|aparam
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|last_asconf_ack_sent
operator|!=
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|asoc
operator|->
name|last_asconf_ack_sent
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_asconf_ack_sent
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* clean up auth stuff */
if|if
condition|(
name|asoc
operator|->
name|local_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|asoc
operator|->
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|asoc
operator|->
name|peer_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|local_auth_chunks
condition|)
name|sctp_free_chunklist
argument_list|(
name|asoc
operator|->
name|local_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_auth_chunks
condition|)
name|sctp_free_chunklist
argument_list|(
name|asoc
operator|->
name|peer_auth_chunks
argument_list|)
expr_stmt|;
name|sctp_free_authinfo
argument_list|(
operator|&
name|asoc
operator|->
name|authinfo
argument_list|)
expr_stmt|;
name|shared_key
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|shared_keys
argument_list|)
expr_stmt|;
while|while
condition|(
name|shared_key
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|shared_key
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|shared_key
argument_list|)
expr_stmt|;
name|shared_key
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|shared_keys
argument_list|)
expr_stmt|;
block|}
comment|/* Insert new items here :> */
comment|/* Get rid of LOCK */
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_TRACK_FREED_ASOCS
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* now clean up the tasoc itself */
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_free_list
argument_list|,
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* 			 * If its NOT the inp_free calling us AND sctp_close 			 * as been called, we call back... 			 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 			 * This will start the kill timer (if we are the 			 * lastone) since we hold an increment yet. But this 			 * is the only safe way to do this since otherwise 			 * if the socket closes at the same time we are here 			 * we might collide in the cleanup. 			 */
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
else|else
block|{
comment|/* The socket is still open. */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|out_of
label|:
comment|/* destroyed the asoc */
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|11
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine if a destination is "reachable" based upon the addresses bound  * to the current endpoint (e.g. only v4 or v6 currently bound)  */
end_comment

begin_comment
comment|/*  * FIX: if we allow assoc-level bindx(), then this needs to be fixed to use  * assoc level v4/v6 flags, as the assoc *may* not have the same address  * types bound as its endpoint  */
end_comment

begin_function
name|int
name|sctp_destination_is_reachable
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|destaddr
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|answer
decl_stmt|;
comment|/* 	 * No locks here, the TCB, in all cases is already locked and an 	 * assoc is up. There is either a INP lock by the caller applied (in 	 * asconf case when deleting an address) or NOT in the HB case, 	 * however if HB then the INP increment is up and the INP will not 	 * be removed (on top of the fact that we have a TCB lock). So we 	 * only want to read the sctp_flags, which is either bound-all or 	 * not.. no protection needed since once an assoc is up you can't be 	 * changing your binding. 	 */
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* if bound all, destination is not restricted */
comment|/* 		 * RRS: Question during lock work: Is this correct? If you 		 * are bound-all you still might need to obey the V4--V6 		 * flags??? IMO this bound-all stuff needs to be removed! 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* NOTE: all "scope" checks are done when local addresses are added */
if|if
condition|(
name|destaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|answer
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator|&
name|INP_IPV6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|destaddr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|answer
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator|&
name|INP_IPV4
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid family, so it's unreachable */
name|answer
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update the inp_vflags on an endpoint  */
end_comment

begin_function
specifier|static
name|void
name|sctp_update_ep_vflag
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* first clear the flag */
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator|=
literal|0
expr_stmt|;
comment|/* set the flag based on addresses on the ep list */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"An ounce of prevention is worth a pound of cure\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add the address to the endpoint local address list There is nothing to be  * done if we are bound to all addresses  */
end_comment

begin_function
name|int
name|sctp_add_local_addr_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
decl_stmt|,
name|error
decl_stmt|;
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* You are already bound to all. You have it already */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
comment|/* Can't bind a non-useable addr. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* first, is it already present? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fnd
operator|==
literal|0
condition|)
block|{
comment|/* Not in the ep list */
name|error
operator|=
name|sctp_insert_laddr
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|,
name|ifa
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|inp
operator|->
name|laddr_count
operator|++
expr_stmt|;
comment|/* update inp_vflag flags */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * select a new (hopefully reachable) destination net (should only be used  * when we deleted an ep addr that is the only usable source address to reach  * the destination net)  */
end_comment

begin_function
specifier|static
name|void
name|sctp_select_primary_destination
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* for now, we'll just pick the first reachable one we find */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
continue|continue;
if|if
condition|(
name|sctp_destination_is_reachable
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
condition|)
block|{
comment|/* found a reachable destination */
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
block|}
block|}
comment|/* I can't there from here! ...we're gonna die shortly... */
block|}
end_function

begin_comment
comment|/*  * Delete the address from the endpoint local address list There is nothing  * to be done if we are bound to all addresses  */
end_comment

begin_function
name|int
name|sctp_del_local_addr_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* You are already bound to all. You have it already */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fnd
operator|&&
operator|(
name|inp
operator|->
name|laddr_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* can't delete unless there are at LEAST 2 addresses */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fnd
condition|)
block|{
comment|/* 		 * clean up any use of this address go through our 		 * associations and clear any last_used_address that match 		 * this one for each assoc, see if a new primary_destination 		 * is needed 		 */
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
comment|/* clean up "next_addr_touse" */
if|if
condition|(
name|inp
operator|->
name|next_addr_touse
operator|==
name|laddr
condition|)
comment|/* delete this address */
name|inp
operator|->
name|next_addr_touse
operator|=
name|NULL
expr_stmt|;
comment|/* clean up "last_used_address" */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|laddr
condition|)
comment|/* delete this address */
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Now spin through all the nets and purge any ref 			 * to laddr 			 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|ifa
operator|==
name|laddr
operator|->
name|ifa
operator|)
condition|)
block|{
comment|/* Yep, purge src address selected */
name|sctp_rtentry_t
modifier|*
name|rt
decl_stmt|;
comment|/* delete this address if cached */
name|rt
operator|=
name|net
operator|->
name|ro
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* for each tcb */
comment|/* remove it from the ep list */
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
name|inp
operator|->
name|laddr_count
operator|--
expr_stmt|;
comment|/* update inp_vflag flags */
name|sctp_update_ep_vflag
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the addr to the TCB local address list For the BOUNDALL or dynamic  * case, this is a "pending" address list (eg. addresses waiting for an  * ASCONF-ACK response) For the subset binding, static case, this is a  * "valid" address list  */
end_comment

begin_function
name|int
name|sctp_add_local_addr_assoc
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|int
name|restricted_list
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sctpladdr
modifier|*
name|list
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Assumes TCB is locked.. and possibly the INP. May need to 	 * confirm/fix that if we need it and is not the case. 	 */
name|list
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sctp_restricted_addrs
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
comment|/* Can't bind a non-existent addr. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* does the address already exist? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* add to the list */
name|error
operator|=
name|sctp_insert_laddr
argument_list|(
name|list
argument_list|,
name|ifa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * insert an laddr entry with the given ifa for the desired list  */
end_comment

begin_function
name|int
name|sctp_insert_laddr
parameter_list|(
name|struct
name|sctpladdr
modifier|*
name|list
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint32_t
name|act
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|laddr
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|laddr
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory? */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|laddr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|laddr
operator|->
name|action
operator|=
name|act
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert it */
name|LIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an laddr entry from the local address list (on an assoc)  */
end_comment

begin_function
name|void
name|sctp_remove_laddr
parameter_list|(
name|struct
name|sctp_laddr
modifier|*
name|laddr
parameter_list|)
block|{
comment|/* remove from the list */
name|LIST_REMOVE
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|,
name|laddr
argument_list|)
expr_stmt|;
name|SCTP_DECR_LADDR_COUNT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an address from the TCB local address list  */
end_comment

begin_function
name|int
name|sctp_del_local_addr_assoc
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* 	 * This is called by asconf work. It is assumed that a) The TCB is 	 * locked and b) The INP is locked. This is true in as much as I can 	 * trace through the entry asconf code where I did these locks. 	 * Again, the ASCONF code is a bit different in that it does lock 	 * the INP during its work often times. This must be since we don't 	 * want other proc's looking up things while what they are looking 	 * up is changing :-D 	 */
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
comment|/* if subset bound and don't allow ASCONF's, can't delete last */
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|<
literal|2
condition|)
block|{
comment|/* can't delete last address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_restricted_addrs
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
comment|/* remove the address if it exists */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* address not found! */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|sctp_pcb_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Temporarily remove for __APPLE__ until we use the Tiger equivalents  */
end_comment

begin_comment
comment|/* sysctl */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sctp_max_number_of_assoc
init|=
name|SCTP_MAX_NUM_OF_ASOC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sctp_scale_up_for_address
init|=
name|SCTP_SCALE_FOR_ADDR
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_pcb_init
parameter_list|()
block|{
comment|/* 	 * SCTP initialization for the PCB structures should be called by 	 * the sctp_init() funciton. 	 */
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sctp_pcb_initialized
operator|!=
literal|0
condition|)
block|{
comment|/* error I was called twice */
return|return;
block|}
name|sctp_pcb_initialized
operator|=
literal|1
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sctpstat
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctpstat
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sctpstat
operator|.
name|sctps_discontinuitytime
argument_list|)
expr_stmt|;
comment|/* init the empty list of (All) Endpoints */
name|LIST_INIT
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|listhead
argument_list|)
expr_stmt|;
comment|/* init the iterator head */
name|TAILQ_INIT
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|iteratorhead
argument_list|)
expr_stmt|;
comment|/* init the hash table of endpoints */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.inet.sctp.tcbhashsize"
argument_list|,
operator|&
name|sctp_hashtblsize
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.inet.sctp.pcbhashsize"
argument_list|,
operator|&
name|sctp_pcbtblsize
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.inet.sctp.chunkscale"
argument_list|,
operator|&
name|sctp_chunkscale
argument_list|)
expr_stmt|;
name|sctppcbinfo
operator|.
name|sctp_asochash
operator|=
name|SCTP_HASH_INIT
argument_list|(
operator|(
name|sctp_hashtblsize
operator|*
literal|31
operator|)
argument_list|,
operator|&
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
expr_stmt|;
name|sctppcbinfo
operator|.
name|sctp_ephash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|sctp_hashtblsize
argument_list|,
operator|&
name|sctppcbinfo
operator|.
name|hashmark
argument_list|)
expr_stmt|;
name|sctppcbinfo
operator|.
name|sctp_tcpephash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|sctp_hashtblsize
argument_list|,
operator|&
name|sctppcbinfo
operator|.
name|hashtcpmark
argument_list|)
expr_stmt|;
name|sctppcbinfo
operator|.
name|hashtblsize
operator|=
name|sctp_hashtblsize
expr_stmt|;
comment|/* init the small hash table we use to track restarted asoc's */
name|sctppcbinfo
operator|.
name|sctp_restarthash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_STACK_VTAG_HASH_SIZE
argument_list|,
operator|&
name|sctppcbinfo
operator|.
name|hashrestartmark
argument_list|)
expr_stmt|;
name|sctppcbinfo
operator|.
name|sctp_vrfhash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_SIZE_OF_VRF_HASH
argument_list|,
operator|&
name|sctppcbinfo
operator|.
name|hashvrfmark
argument_list|)
expr_stmt|;
comment|/* init the zones */
comment|/* 	 * FIX ME: Should check for NULL returns, but if it does fail we are 	 * doomed to panic anyways... add later maybe. 	 */
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_ep
argument_list|,
literal|"sctp_ep"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_inpcb
argument_list|)
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_asoc
argument_list|,
literal|"sctp_asoc"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tcb
argument_list|)
argument_list|,
name|sctp_max_number_of_assoc
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|,
literal|"sctp_laddr"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_laddr
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_scale_up_for_address
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_net
argument_list|,
literal|"sctp_raddr"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nets
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_scale_up_for_address
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_chunk
argument_list|,
literal|"sctp_chunk"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tmit_chunk
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_chunkscale
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_readq
argument_list|,
literal|"sctp_readq"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_queued_to_read
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_chunkscale
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_strmoq
argument_list|,
literal|"sctp_stream_msg_out"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_queue_pending
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_chunkscale
operator|)
argument_list|)
expr_stmt|;
comment|/* Master Lock INIT for info structure */
name|SCTP_INP_INFO_LOCK_INIT
argument_list|()
expr_stmt|;
name|SCTP_STATLOG_INIT_LOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_LOCK_INIT
argument_list|()
expr_stmt|;
name|SCTP_IPI_COUNT_INIT
argument_list|()
expr_stmt|;
name|SCTP_IPI_ADDR_INIT
argument_list|()
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_INIT
argument_list|()
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|addr_wq
argument_list|)
expr_stmt|;
comment|/* not sure if we need all the counts */
name|sctppcbinfo
operator|.
name|ipi_count_ep
operator|=
literal|0
expr_stmt|;
comment|/* assoc/tcb zone info */
name|sctppcbinfo
operator|.
name|ipi_count_asoc
operator|=
literal|0
expr_stmt|;
comment|/* local addrlist zone info */
name|sctppcbinfo
operator|.
name|ipi_count_laddr
operator|=
literal|0
expr_stmt|;
comment|/* remote addrlist zone info */
name|sctppcbinfo
operator|.
name|ipi_count_raddr
operator|=
literal|0
expr_stmt|;
comment|/* chunk info */
name|sctppcbinfo
operator|.
name|ipi_count_chunk
operator|=
literal|0
expr_stmt|;
comment|/* socket queue zone info */
name|sctppcbinfo
operator|.
name|ipi_count_readq
operator|=
literal|0
expr_stmt|;
comment|/* stream out queue cont */
name|sctppcbinfo
operator|.
name|ipi_count_strmoq
operator|=
literal|0
expr_stmt|;
name|sctppcbinfo
operator|.
name|ipi_free_strmoq
operator|=
literal|0
expr_stmt|;
name|sctppcbinfo
operator|.
name|ipi_free_chunks
operator|=
literal|0
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|addr_wq_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* Init the TIMEWAIT list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_STACK_VTAG_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|vtag_timewait
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCTP_USE_THREAD_BASED_ITERATOR
argument_list|)
name|sctppcbinfo
operator|.
name|iterator_running
operator|=
literal|0
expr_stmt|;
name|sctp_startup_iterator
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * INIT the default VRF which for BSD is the only one, other O/S's 	 * may have more. But initially they must start with one and then 	 * add the VRF's as addresses are added. 	 */
name|sctp_init_vrf_list
argument_list|(
name|SCTP_DEFAULT_VRF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_load_addresses_from_init
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|altsa
parameter_list|)
block|{
comment|/* 	 * grub through the INIT pulling addresses and loading them to the 	 * nets structure in the asoc. The from address in the mbuf should 	 * also be loaded (if it is not already). This routine can be called 	 * with either INIT or INIT-ACK's as long as the m points to the IP 	 * packet and the offset points to the beginning of the parameters. 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
name|l_inp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|net_tmp
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|parm_buf
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb_tmp
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_storage
name|dest_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|local_sa
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest_store
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|uint8_t
name|random_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_random
modifier|*
name|p_random
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|random_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hmacs_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|hmacs_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|chunks_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|num_chunks
init|=
literal|0
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint32_t
name|keylen
decl_stmt|;
name|int
name|got_random
init|=
literal|0
decl_stmt|,
name|got_hmacs
init|=
literal|0
decl_stmt|,
name|got_chklist
init|=
literal|0
decl_stmt|;
comment|/* First get the destination address setup too. */
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
if|if
condition|(
name|altsa
operator|==
name|NULL
condition|)
block|{
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|sin_2
decl_stmt|;
name|sin_2
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|local_sa
operator|)
expr_stmt|;
name|memset
argument_list|(
name|sin_2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin_2
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin_2
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin_2
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin_2
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|iph
operator|->
name|ip_src
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6_2
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6_2
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|local_sa
operator|)
expr_stmt|;
name|memset
argument_list|(
name|sin6_2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6_2
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6_2
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6_2
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * For cookies we use the src address NOT from the packet 		 * but from the original INIT 		 */
name|sa
operator|=
name|altsa
expr_stmt|;
block|}
comment|/* Turn off ECN until we get through all params */
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* mark all addresses that we have currently on the list */
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
comment|/* does the source address already exist? if so skip it */
name|l_inp
operator|=
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb_tmp
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net_tmp
argument_list|,
name|local_sa
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb_tmp
operator|==
name|NULL
operator|&&
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
operator|)
operator|||
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* we must add the source address */
comment|/* no scope set here since we have a tcb already. */
if|if
condition|(
operator|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_addr_legal
operator|)
condition|)
block|{
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_2
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv6_addr_legal
operator|)
condition|)
block|{
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_3
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|net_tmp
operator|!=
name|NULL
operator|&&
name|stcb_tmp
operator|==
name|stcb
condition|)
block|{
name|net_tmp
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb_tmp
operator|!=
name|stcb
condition|)
block|{
comment|/* It belongs to another association? */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb_tmp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
comment|/* now we must go through each of the params. */
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
comment|/* 		 * printf("ptype => %0x, plen => %d\n", (uint32_t)ptype, 		 * (int)plen); 		 */
if|if
condition|(
name|offset
operator|+
name|plen
operator|>
name|limit
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|p4
decl_stmt|,
name|p4_buf
decl_stmt|;
comment|/* ok get the v4 address and check/add */
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p4_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p4_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|p4
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
condition|)
block|{
comment|/* Skip multi-cast addresses */
goto|goto
name|next_param
goto|;
block|}
if|if
condition|(
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
goto|goto
name|next_param
goto|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb_tmp
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|local_sa
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb_tmp
operator|==
name|NULL
operator|&&
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
operator|)
operator|||
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* we must add the source address */
comment|/* 					 * no scope set since we have a tcb 					 * already 					 */
comment|/* 					 * we must validate the state again 					 * here 					 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|7
operator|)
return|;
block|}
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_4
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stcb_tmp
operator|==
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|10
operator|)
return|;
block|}
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* clear flag */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 					 * strange, address is in another 					 * assoc? straighten out locks. 					 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|12
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv6_addr_legal
condition|)
block|{
comment|/* ok get the v6 address and check/add */
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p6
decl_stmt|,
name|p6_buf
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p6_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p6_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|14
operator|)
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p6
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Skip multi-cast addresses */
goto|goto
name|next_param
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * Link local make no sense without 					 * scope 					 */
goto|goto
name|next_param
goto|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb_tmp
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|local_sa
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb_tmp
operator|==
name|NULL
operator|&&
operator|(
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
operator|||
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 					 * we must validate the state again 					 * here 					 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|16
operator|)
return|;
block|}
comment|/* 					 * we must add the address, no scope 					 * set 					 */
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_5
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|17
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stcb_tmp
operator|==
name|stcb
condition|)
block|{
comment|/* 					 * we must validate the state again 					 * here 					 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|19
operator|)
return|;
block|}
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* clear flag */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 					 * strange, address is in another 					 * assoc? straighten out locks. 					 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|21
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|22
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_ECN_CAPABLE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_ULP_ADAPTATION
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|!=
name|SCTP_STATE_OPEN
condition|)
block|{
name|struct
name|sctp_adaptation_layer_indication
name|ai
decl_stmt|,
modifier|*
name|aip
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|aip
operator|=
operator|(
expr|struct
name|sctp_adaptation_layer_indication
operator|*
operator|)
name|phdr
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ADAPTATION_INDICATION
argument_list|,
name|stcb
argument_list|,
name|ntohl
argument_list|(
name|aip
operator|->
name|indication
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_SET_PRIM_ADDR
condition|)
block|{
name|struct
name|sctp_asconf_addr_param
name|lstore
decl_stmt|,
modifier|*
name|fee
decl_stmt|;
name|struct
name|sctp_asconf_addrv4_param
modifier|*
name|fii
decl_stmt|;
name|int
name|lptype
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|lsa
init|=
name|NULL
decl_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|lstore
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|23
operator|)
return|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|lstore
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|lstore
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|24
operator|)
return|;
block|}
name|fee
operator|=
operator|(
expr|struct
name|sctp_asconf_addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|lptype
operator|=
name|ntohs
argument_list|(
name|fee
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|lptype
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Sizeof setprim in init/init ack not %d but %d - ignored\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fii
operator|=
operator|(
expr|struct
name|sctp_asconf_addrv4_param
operator|*
operator|)
name|fee
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|fii
operator|->
name|addrp
operator|.
name|addr
expr_stmt|;
name|lsa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lptype
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Sizeof setprim (v6) in init/init ack not %d but %d - ignored\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|fee
operator|->
name|addrp
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fee
operator|->
name|addrp
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|lsa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lsa
condition|)
block|{
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_PRSCTP_SUPPORTED
condition|)
block|{
comment|/* Peer supports pr-sctp */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_SUPPORTED_CHUNK_EXT
condition|)
block|{
comment|/* A supported extension chunk */
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|uint8_t
name|local_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|num_ent
decl_stmt|,
name|i
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|local_store
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|local_store
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|25
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_pktdrop
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|0
expr_stmt|;
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_ent
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ent
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pr_supported
operator|->
name|chunk_types
index|[
name|i
index|]
condition|)
block|{
case|case
name|SCTP_ASCONF
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_PACKET_DROPPED
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_pktdrop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_STREAM_RESET
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHENTICATION
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* one I have not learned yet */
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_ECN_NONCE_SUPPORTED
condition|)
block|{
comment|/* Peer supports ECN-nonce */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_ecn_nonce
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ecn_nonce_allowed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_RANDOM
condition|)
block|{
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
condition|)
break|break;
if|if
condition|(
name|got_random
condition|)
block|{
comment|/* already processed a RANDOM */
goto|goto
name|next_param
goto|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|random_store
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|26
operator|)
return|;
name|p_random
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
name|phdr
expr_stmt|;
name|random_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
expr_stmt|;
comment|/* enforce the random length */
if|if
condition|(
name|random_len
operator|!=
name|SCTP_AUTH_RANDOM_SIZE_REQUIRED
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"SCTP: invalid RANDOM len\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|27
operator|)
return|;
block|}
name|got_random
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HMAC_LIST
condition|)
block|{
name|int
name|num_hmacs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
condition|)
break|break;
if|if
condition|(
name|got_hmacs
condition|)
block|{
comment|/* already processed a HMAC list */
goto|goto
name|next_param
goto|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|hmacs_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|28
operator|)
return|;
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
name|phdr
expr_stmt|;
name|hmacs_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
expr_stmt|;
name|num_hmacs
operator|=
name|hmacs_len
operator|/
sizeof|sizeof
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* validate the hmac list */
if|if
condition|(
name|sctp_verify_hmac_param
argument_list|(
name|hmacs
argument_list|,
name|num_hmacs
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|29
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
operator|!=
name|NULL
condition|)
name|sctp_free_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|num_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hmacs
condition|;
name|i
operator|++
control|)
block|{
name|sctp_auth_add_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|,
name|ntohs
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|got_hmacs
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_CHUNK_LIST
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
condition|)
break|break;
if|if
condition|(
name|got_chklist
condition|)
block|{
comment|/* already processed a Chunks list */
goto|goto
name|next_param
goto|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|chunks_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|30
operator|)
return|;
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_chunks
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
operator|!=
name|NULL
condition|)
name|sctp_clear_chunklist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
expr_stmt|;
else|else
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
name|sctp_auth_add_chunk
argument_list|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
expr_stmt|;
block|}
name|got_chklist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ptype
operator|==
name|SCTP_HEARTBEAT_INFO
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_STATE_COOKIE
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_UNRECOG_PARAM
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_COOKIE_PRESERVE
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_SUPPORTED_ADDRTYPE
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_ERROR_CAUSE_IND
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_SUCCESS_REPORT
operator|)
condition|)
block|{
comment|/* don't care */
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ptype
operator|&
literal|0x8000
operator|)
operator|==
literal|0x0000
condition|)
block|{
comment|/* 				 * must stop processing the rest of the 				 * param's. Any report bits were handled 				 * with the call to 				 * sctp_arethere_unrecognized_parameters() 				 * when the INIT or INIT-ACK was first seen. 				 */
break|break;
block|}
block|}
name|next_param
label|:
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now check to see if we need to purge any addresses */
for|for
control|(
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
init|;
name|net
operator|!=
name|NULL
condition|;
name|net
operator|=
name|net_tmp
control|)
block|{
name|net_tmp
operator|=
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_IN_ASSOC
operator|)
operator|==
name|SCTP_ADDR_NOT_IN_ASSOC
condition|)
block|{
comment|/* This address has been removed from the asoc */
comment|/* remove and free it */
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|NULL
expr_stmt|;
name|sctp_select_primary_destination
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* validate authentication required parameters */
if|if
condition|(
name|got_random
operator|&&
name|got_hmacs
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|&&
name|got_chklist
condition|)
block|{
comment|/* peer does not support auth but sent a chunks list? */
return|return
operator|(
operator|-
literal|31
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|sctp_asconf_auth_nochk
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
condition|)
block|{
comment|/* peer supports asconf but not auth? */
return|return
operator|(
operator|-
literal|32
operator|)
return|;
block|}
comment|/* concatenate the full random key */
ifdef|#
directive|ifdef
name|SCTP_AUTH_DRAFT_04
name|keylen
operator|=
name|random_len
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
comment|/* copy in the RANDOM */
if|if
condition|(
name|p_random
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|p_random
operator|->
name|random_data
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|random_len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
comment|/* copy in the RANDOM */
if|if
condition|(
name|p_random
operator|!=
name|NULL
condition|)
block|{
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|bcopy
argument_list|(
name|p_random
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
block|}
comment|/* append in the AUTH chunks */
if|if
condition|(
name|chunks
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|chunks
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
expr_stmt|;
block|}
comment|/* append in the HMACs */
if|if
condition|(
name|hmacs
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|hmacs
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
else|else
block|{
comment|/* failed to get memory for the key */
return|return
operator|(
operator|-
literal|33
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
operator|=
name|new_key
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUTH_DRAFT_04
comment|/* don't include the chunks and hmacs for draft -04 */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
operator|->
name|keylen
operator|=
name|random_len
expr_stmt|;
endif|#
directive|endif
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_set_primary_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* make sure the requested primary address exists in the assoc */
if|if
condition|(
name|net
operator|==
name|NULL
operator|&&
name|sa
condition|)
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* didn't find the requested primary address! */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* set the primary address */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* Must be confirmed, so queue to set */
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REQ_PRIMARY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_WAS_PRIMARY
expr_stmt|;
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* 			 * first one on the list is NOT the primary 			 * sctp_cmpaddr() is much more efficent if the 			 * primary is the first on the list, make it so. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_is_vtag_good
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
comment|/* 	 * This function serves two purposes. It will see if a TAG can be 	 * re-used and return 1 for yes it is ok and 0 for don't use that 	 * tag. A secondary function it will do is purge out old tags that 	 * can be removed. 	 */
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|chain
operator|=
operator|&
name|sctppcbinfo
operator|.
name|vtag_timewait
index|[
operator|(
name|tag
operator|%
name|SCTP_STACK_VTAG_HASH_SIZE
operator|)
index|]
expr_stmt|;
comment|/* First is the vtag in use ? */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_asochash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|tag
argument_list|,
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
goto|goto
name|check_restart
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_asocs
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|==
name|tag
condition|)
block|{
comment|/* 			 * We should remove this if and return 0 always if 			 * we want vtags unique across all endpoints. For 			 * now within a endpoint is ok. 			 */
if|if
condition|(
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
condition|)
block|{
comment|/* bad tag, in use */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|check_restart
label|:
comment|/* Now lets check the restart hash */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_restarthash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|tag
argument_list|,
name|sctppcbinfo
operator|.
name|hashrestartmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
goto|goto
name|check_time_wait
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_tcbrestarhash
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_id
operator|==
name|tag
condition|)
block|{
comment|/* candidate */
if|if
condition|(
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
condition|)
block|{
comment|/* bad tag, in use */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|check_time_wait
label|:
comment|/* Now what about timed wait ? */
if|if
condition|(
operator|!
name|SCTP_LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
comment|/* 		 * Block(s) are present, lets see if we have this tag in the 		 * list 		 */
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_IN_VTAG_BLOCK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
literal|0
condition|)
block|{
comment|/* not used */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|>
name|now
operator|->
name|tv_sec
condition|)
block|{
comment|/* Audit expires this guy */
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
name|tag
condition|)
block|{
comment|/* Bad tag, sorry :< */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* Not found, ok to use the tag */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|sctp_assoc_t
name|reneged_asoc_ids
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|reneged_at
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_drain_mbufs
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* 	 * We must hunt this association for MBUF's past the cumack (i.e. 	 * out of order data that we can renege on). 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|uint32_t
name|cumulative_tsn_p1
decl_stmt|,
name|tsn
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|strmat
decl_stmt|,
name|gap
decl_stmt|;
comment|/* We look for anything larger than the cum-ack + 1 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_protocol_drain_calls
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_do_drain
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|asoc
operator|->
name|highest_tsn_inside_map
condition|)
block|{
comment|/* none we can reneg on. */
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_protocol_drains_done
argument_list|)
expr_stmt|;
name|cumulative_tsn_p1
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* First look in the re-assembly queue */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
comment|/* Get the next one */
name|nchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cumulative_tsn_p1
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* Yep it is above cum-ack */
name|cnt
operator|++
expr_stmt|;
name|tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
if|if
condition|(
name|tsn
operator|>=
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|gap
operator|=
name|tsn
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|gap
operator|=
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
name|tsn
operator|+
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|,
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|SCTP_UNSET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
name|chk
operator|=
name|nchk
expr_stmt|;
block|}
comment|/* Ok that was fun, now we will drain all the inbound streams? */
for|for
control|(
name|strmat
operator|=
literal|0
init|;
name|strmat
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|strmat
operator|++
control|)
block|{
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|strmat
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|ctl
operator|->
name|sinfo_tsn
argument_list|,
name|cumulative_tsn_p1
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* Yep it is above cum-ack */
name|cnt
operator|++
expr_stmt|;
name|tsn
operator|=
name|ctl
operator|->
name|sinfo_tsn
expr_stmt|;
if|if
condition|(
name|tsn
operator|>=
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|gap
operator|=
name|tsn
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|gap
operator|=
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
name|tsn
operator|+
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|size_on_all_streams
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|ctl
operator|->
name|length
argument_list|)
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|SCTP_UNSET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|strmat
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|ctl
operator|->
name|data
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|ctl
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_readq
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
block|}
name|ctl
operator|=
name|nctl
expr_stmt|;
block|}
block|}
comment|/* 	 * Question, should we go through the delivery queue? The only 	 * reason things are on here is the app not reading OR a p-d-api up. 	 * An attacker COULD send enough in to initiate the PD-API and then 	 * send a bunch of stuff to other streams... these would wind up on 	 * the delivery queue.. and then we would not get to them. But in 	 * order to do this I then have to back-track and un-deliver 	 * sequence numbers in streams.. el-yucko. I think for now we will 	 * NOT look at the delivery queue and leave it to be something to 	 * consider later. An alternative would be to abort the P-D-API with 	 * a notification and then deliver the data.... Or another method 	 * might be to keep track of how many times the situation occurs and 	 * if we see a possible attack underway just abort the association. 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
if|if
condition|(
name|cnt
condition|)
block|{
name|printf
argument_list|(
literal|"Freed %d chunks from reneg harvest\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|cnt
condition|)
block|{
comment|/* 		 * Now do we need to find a new 		 * asoc->highest_tsn_inside_map? 		 */
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|>=
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|gap
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|gap
operator|=
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|>=
operator|(
name|asoc
operator|->
name|mapping_array_size
operator|<<
literal|3
operator|)
condition|)
block|{
comment|/* 			 * Something bad happened or cum-ack and high were 			 * behind the base, but if so earlier checks should 			 * have found NO data... wierd... we will start at 			 * end of mapping array. 			 */
name|printf
argument_list|(
literal|"Gap was larger than array?? %d set to max:%d maparraymax:%x\n"
argument_list|,
operator|(
name|int
operator|)
name|gap
argument_list|,
call|(
name|int
call|)
argument_list|(
name|asoc
operator|->
name|mapping_array_size
operator|<<
literal|3
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
expr_stmt|;
name|gap
operator|=
name|asoc
operator|->
name|mapping_array_size
operator|<<
literal|3
expr_stmt|;
block|}
while|while
condition|(
name|gap
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
condition|)
block|{
comment|/* found the new highest */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
name|gap
expr_stmt|;
break|break;
block|}
name|gap
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|==
literal|0
condition|)
block|{
comment|/* Nothing left in map */
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
name|asoc
operator|->
name|last_revoke_count
operator|=
name|cnt
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_DRAIN
argument_list|)
expr_stmt|;
name|reneged_asoc_ids
index|[
name|reneged_at
index|]
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|reneged_at
operator|++
expr_stmt|;
block|}
comment|/* 	 * Another issue, in un-setting the TSN's in the mapping array we 	 * DID NOT adjust the higest_tsn marker.  This will cause one of two 	 * things to occur. It may cause us to do extra work in checking for 	 * our mapping array movement. More importantly it may cause us to 	 * SACK every datagram. This may not be a bad thing though since we 	 * will recover once we get our cum-ack above and all this stuff we 	 * dumped recovered. 	 */
block|}
end_function

begin_function
name|void
name|sctp_drain
parameter_list|()
block|{
comment|/* 	 * We must walk the PCB lists for ALL associations here. The system 	 * is LOW on MBUF's and needs help. This is where reneging will 	 * occur. We really hope this does NOT happen! 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|&sctppcbinfo.listhead
argument_list|,
argument|sctp_list
argument_list|)
block|{
comment|/* For each endpoint */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
comment|/* For each association */
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_drain_mbufs
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start a new iterator  * iterates through all endpoints and associations based on the pcb_state  * flags and asoc_state.  "af" (mandatory) is executed for all matching  * assocs and "ef" (optional) is executed when the iterator completes.  * "inpf" (optional) is executed for each new endpoint as it is being  * iterated through. inpe (optional) is called when the inp completes  * its way through all the stcbs.  */
end_comment

begin_function
name|int
name|sctp_initiate_iterator
parameter_list|(
name|inp_func
name|inpf
parameter_list|,
name|asoc_func
name|af
parameter_list|,
name|inp_func
name|inpe
parameter_list|,
name|uint32_t
name|pcb_state
parameter_list|,
name|uint32_t
name|pcb_features
parameter_list|,
name|uint32_t
name|asoc_state
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|uint32_t
name|argi
parameter_list|,
name|end_func
name|ef
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|s_inp
parameter_list|,
name|uint8_t
name|chunk_output_off
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_MALLOC
argument_list|(
name|it
argument_list|,
expr|struct
name|sctp_iterator
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_iterator
argument_list|)
argument_list|,
literal|"Iterator"
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|it
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|function_assoc
operator|=
name|af
expr_stmt|;
name|it
operator|->
name|function_inp
operator|=
name|inpf
expr_stmt|;
if|if
condition|(
name|inpf
condition|)
name|it
operator|->
name|done_current_ep
operator|=
literal|0
expr_stmt|;
else|else
name|it
operator|->
name|done_current_ep
operator|=
literal|1
expr_stmt|;
name|it
operator|->
name|function_atend
operator|=
name|ef
expr_stmt|;
name|it
operator|->
name|pointer
operator|=
name|argp
expr_stmt|;
name|it
operator|->
name|val
operator|=
name|argi
expr_stmt|;
name|it
operator|->
name|pcb_flags
operator|=
name|pcb_state
expr_stmt|;
name|it
operator|->
name|pcb_features
operator|=
name|pcb_features
expr_stmt|;
name|it
operator|->
name|asoc_state
operator|=
name|asoc_state
expr_stmt|;
name|it
operator|->
name|function_inp_end
operator|=
name|inpe
expr_stmt|;
name|it
operator|->
name|no_chunk_output
operator|=
name|chunk_output_off
expr_stmt|;
if|if
condition|(
name|s_inp
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|s_inp
expr_stmt|;
name|it
operator|->
name|iterator_flags
operator|=
name|SCTP_ITERATOR_DO_SINGLE_INP
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|it
operator|->
name|inp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|listhead
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
name|it
operator|->
name|iterator_flags
operator|=
name|SCTP_ITERATOR_DO_ALL_INP
expr_stmt|;
block|}
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
condition|)
name|SCTP_INP_INCR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_USE_THREAD_BASED_ITERATOR
argument_list|)
if|if
condition|(
name|sctppcbinfo
operator|.
name|iterator_running
operator|==
literal|0
condition|)
block|{
name|sctp_wakeup_iterator
argument_list|()
expr_stmt|;
block|}
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|it
operator|->
name|inp
condition|)
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Init the timer */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|it
operator|->
name|tmr
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* add to the list of all iterators */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ITERATOR
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|it
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

