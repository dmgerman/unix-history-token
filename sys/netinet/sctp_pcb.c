begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2011, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2011, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_pcb.c,v 1.38 2005/03/06 16:04:18 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_dtrace_define.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|sctp_base_info
argument_list|,
name|system_base_info
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* FIX: we don't handle multiple link local scopes */
end_comment

begin_comment
comment|/* "scopeless" replacement IN6_ARE_ADDR_EQUAL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|SCTP6_ARE_ADDR_EQUAL
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|a
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|b
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|tmp_a
decl_stmt|,
name|tmp_b
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp_a
argument_list|,
name|a
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa6_embedscope
argument_list|(
operator|&
name|tmp_a
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|tmp_b
argument_list|,
name|b
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa6_embedscope
argument_list|(
operator|&
name|tmp_b
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
return|return
operator|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|tmp_a
operator|.
name|sin6_addr
argument_list|,
operator|&
name|tmp_b
operator|.
name|sin6_addr
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_fill_pcbinfo
parameter_list|(
name|struct
name|sctp_pcbinfo
modifier|*
name|spcb
parameter_list|)
block|{
comment|/* 	 * We really don't need to lock this, but I will just because it 	 * does not hurt. 	 */
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|spcb
operator|->
name|ep_count
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_ep
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|asoc_count
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_asoc
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|laddr_count
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_laddr
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|raddr_count
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_raddr
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|chk_count
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_chunk
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|readq_count
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_readq
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|stream_oque
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_strmoq
argument_list|)
expr_stmt|;
name|spcb
operator|->
name|free_chunks
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|ipi_free_chunks
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Addresses are added to VRF's (Virtual Router's). For BSD we  * have only the default VRF 0. We maintain a hash list of  * VRF's. Each VRF has its own list of sctp_ifn's. Each of  * these has a list of addresses. When we add a new address  * to a VRF we lookup the ifn/ifn_index, if the ifn does  * not exist we create it and add it to the list of IFN's  * within the VRF. Once we have the sctp_ifn, we add the  * address to the list. So we look something like:  *  * hash-vrf-table  *   vrf-> ifn-> ifn -> ifn  *   vrf    |  *    ...   +--ifa-> ifa -> ifa  *   vrf  *  * We keep these separate lists since the SCTP subsystem will  * point to these from its source address selection nets structure.  * When an address is deleted it does not happen right away on  * the SCTP side, it gets scheduled. What we do when a  * delete happens is immediately remove the address from  * the master list and decrement the refcount. As our  * addip iterator works through and frees the src address  * selection pointing to the sctp_ifa, eventually the refcount  * will reach 0 and we will delete it. Note that it is assumed  * that any locking on system level ifn/ifa is done at the  * caller of these functions and these routines will only  * lock the SCTP structures as they add or delete things.  *  * Other notes on VRF concepts.  *  - An endpoint can be in multiple VRF's  *  - An association lives within a VRF and only one VRF.  *  - Any incoming packet we can deduce the VRF for by  *    looking at the mbuf/pak inbound (for BSD its VRF=0 :D)  *  - Any downward send call or connect call must supply the  *    VRF via ancillary data or via some sort of set default  *    VRF socket option call (again for BSD no brainer since  *    the VRF is always 0).  *  - An endpoint may add multiple VRF's to it.  *  - Listening sockets can accept associations in any  *    of the VRF's they are in but the assoc will end up  *    in only one VRF (gotten from the packet or connect/send).  *  */
end_comment

begin_function
name|struct
name|sctp_vrf
modifier|*
name|sctp_allocate_vrf
parameter_list|(
name|int
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_vrflist
modifier|*
name|bucket
decl_stmt|;
comment|/* First allocate the VRF structure */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
condition|)
block|{
comment|/* Already allocated */
return|return
operator|(
name|vrf
operator|)
return|;
block|}
name|SCTP_MALLOC
argument_list|(
name|vrf
argument_list|,
expr|struct
name|sctp_vrf
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_vrf
argument_list|)
argument_list|,
name|SCTP_M_VRF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for VRF:%d"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* setup the VRF */
name|memset
argument_list|(
name|vrf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_vrf
argument_list|)
argument_list|)
expr_stmt|;
name|vrf
operator|->
name|vrf_id
operator|=
name|vrf_id
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|vrf
operator|->
name|ifnlist
argument_list|)
expr_stmt|;
name|vrf
operator|->
name|total_ifa_count
operator|=
literal|0
expr_stmt|;
name|vrf
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
comment|/* now also setup table ids */
name|SCTP_INIT_VRF_TABLEID
argument_list|(
name|vrf
argument_list|)
expr_stmt|;
comment|/* Init the HASH of addresses */
name|vrf
operator|->
name|vrf_addr_hash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_VRF_ADDR_HASH_SIZE
argument_list|,
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|->
name|vrf_addr_hash
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for VRF:%d"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_FREE
argument_list|(
name|vrf
argument_list|,
name|SCTP_M_VRF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Add it to the hash table */
name|bucket
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_vrfhash
argument_list|)
index|[
operator|(
name|vrf_id
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashvrfmark
argument_list|)
operator|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|bucket
argument_list|,
name|vrf
argument_list|,
name|next_vrf
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_vrfs
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|vrf
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_ifn
modifier|*
name|sctp_find_ifn
parameter_list|(
name|void
modifier|*
name|ifn
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|struct
name|sctp_ifnlist
modifier|*
name|hash_ifn_head
decl_stmt|;
comment|/* 	 * We assume the lock is held for the addresses if that's wrong 	 * problems could occur :-) 	 */
name|hash_ifn_head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hash
argument_list|)
index|[
operator|(
name|ifn_index
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hashmark
argument_list|)
operator|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|hash_ifn_head
argument_list|,
argument|next_bucket
argument_list|)
block|{
if|if
condition|(
name|sctp_ifnp
operator|->
name|ifn_index
operator|==
name|ifn_index
condition|)
block|{
return|return
operator|(
name|sctp_ifnp
operator|)
return|;
block|}
if|if
condition|(
name|sctp_ifnp
operator|->
name|ifn_p
operator|&&
name|ifn
operator|&&
operator|(
name|sctp_ifnp
operator|->
name|ifn_p
operator|==
name|ifn
operator|)
condition|)
block|{
return|return
operator|(
name|sctp_ifnp
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_vrf
modifier|*
name|sctp_find_vrf
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_vrflist
modifier|*
name|bucket
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|liste
decl_stmt|;
name|bucket
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_vrfhash
argument_list|)
index|[
operator|(
name|vrf_id
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashvrfmark
argument_list|)
operator|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|liste
argument_list|,
argument|bucket
argument_list|,
argument|next_vrf
argument_list|)
block|{
if|if
condition|(
name|vrf_id
operator|==
name|liste
operator|->
name|vrf_id
condition|)
block|{
return|return
operator|(
name|liste
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_vrf
parameter_list|(
name|struct
name|sctp_vrf
modifier|*
name|vrf
parameter_list|)
block|{
if|if
condition|(
name|SCTP_DECREMENT_AND_CHECK_REFCOUNT
argument_list|(
operator|&
name|vrf
operator|->
name|refcount
argument_list|)
condition|)
block|{
if|if
condition|(
name|vrf
operator|->
name|vrf_addr_hash
condition|)
block|{
name|SCTP_HASH_FREE
argument_list|(
name|vrf
operator|->
name|vrf_addr_hash
argument_list|,
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|)
expr_stmt|;
name|vrf
operator|->
name|vrf_addr_hash
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* We zero'd the count */
name|LIST_REMOVE
argument_list|(
name|vrf
argument_list|,
name|next_vrf
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|vrf
argument_list|,
name|SCTP_M_VRF
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_vrfs
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_free_ifn
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
parameter_list|)
block|{
if|if
condition|(
name|SCTP_DECREMENT_AND_CHECK_REFCOUNT
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|refcount
argument_list|)
condition|)
block|{
comment|/* We zero'd the count */
if|if
condition|(
name|sctp_ifnp
operator|->
name|vrf
condition|)
block|{
name|sctp_free_vrf
argument_list|(
name|sctp_ifnp
operator|->
name|vrf
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|sctp_ifnp
argument_list|,
name|SCTP_M_IFN
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_ifns
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_update_ifn_mtu
parameter_list|(
name|uint32_t
name|ifn_index
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|sctp_ifnp
operator|=
name|sctp_find_ifn
argument_list|(
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifnp
operator|!=
name|NULL
condition|)
block|{
name|sctp_ifnp
operator|->
name|ifn_mtu
operator|=
name|mtu
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_free_ifa
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
parameter_list|)
block|{
if|if
condition|(
name|SCTP_DECREMENT_AND_CHECK_REFCOUNT
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|refcount
argument_list|)
condition|)
block|{
comment|/* We zero'd the count */
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
condition|)
block|{
name|sctp_free_ifn
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|sctp_ifap
argument_list|,
name|SCTP_M_IFA
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_ifas
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_delete_ifn
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
parameter_list|,
name|int
name|hold_addr_lock
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|found
decl_stmt|;
name|found
operator|=
name|sctp_find_ifn
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_p
argument_list|,
name|sctp_ifnp
operator|->
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
condition|)
block|{
comment|/* Not in the list.. sorry */
return|return;
block|}
if|if
condition|(
name|hold_addr_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_WLOCK
argument_list|()
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifnp
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifnp
argument_list|,
name|next_ifn
argument_list|)
expr_stmt|;
name|SCTP_DEREGISTER_INTERFACE
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_index
argument_list|,
name|sctp_ifnp
operator|->
name|registered_af
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold_addr_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* Take away the reference, and possibly free it */
name|sctp_free_ifn
argument_list|(
name|sctp_ifnp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_mark_ifa_addr_down
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|if_name
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
init|=
name|NULL
decl_stmt|;
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Can't find vrf_id 0x%x\n"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sctp_ifap
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf
operator|->
name|vrf_id
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Can't find sctp_ifap for address\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFA has no IFN - can't mark unuseable\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|if_name
condition|)
block|{
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|len1
operator|=
name|strlen
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFN of ifa names different length %d vs %d - ignored\n"
argument_list|,
name|len1
argument_list|,
name|len2
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|if_name
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|len1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFN %s of IFA not the same as %s\n"
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|if_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
operator|!=
name|ifn_index
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFA owned by ifn_index:%d down command for ifn_index:%d - ignored\n"
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|sctp_ifap
operator|->
name|localifa_flags
operator|&=
operator|(
operator|~
name|SCTP_ADDR_VALID
operator|)
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator||=
name|SCTP_ADDR_IFA_UNUSEABLE
expr_stmt|;
name|out
label|:
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_mark_ifa_addr_up
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|if_name
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
init|=
name|NULL
decl_stmt|;
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Can't find vrf_id 0x%x\n"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sctp_ifap
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf
operator|->
name|vrf_id
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Can't find sctp_ifap for address\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFA has no IFN - can't mark unuseable\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|if_name
condition|)
block|{
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|len1
operator|=
name|strlen
argument_list|(
name|if_name
argument_list|)
expr_stmt|;
name|len2
operator|=
name|strlen
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
operator|!=
name|len2
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFN of ifa names different length %d vs %d - ignored\n"
argument_list|,
name|len1
argument_list|,
name|len2
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|if_name
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|len1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFN %s of IFA not the same as %s\n"
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|if_name
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
operator|!=
name|ifn_index
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"IFA owned by ifn_index:%d down command for ifn_index:%d - ignored\n"
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|sctp_ifap
operator|->
name|localifa_flags
operator|&=
operator|(
operator|~
name|SCTP_ADDR_IFA_UNUSEABLE
operator|)
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator||=
name|SCTP_ADDR_VALID
expr_stmt|;
name|out
label|:
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * Add an ifa to an ifn.  * Register the interface as necessary.  * NOTE: ADDR write lock MUST be held.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_add_ifa_to_ifn
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
parameter_list|)
block|{
name|int
name|ifa_af
decl_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|ifalist
argument_list|,
name|sctp_ifap
argument_list|,
name|next_ifa
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|sctp_ifnp
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* update address counts */
name|sctp_ifnp
operator|->
name|ifa_count
operator|++
expr_stmt|;
name|ifa_af
operator|=
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
switch|switch
condition|(
name|ifa_af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sctp_ifnp
operator|->
name|num_v4
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sctp_ifnp
operator|->
name|num_v6
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|sctp_ifnp
operator|->
name|ifa_count
operator|==
literal|1
condition|)
block|{
comment|/* register the new interface */
name|SCTP_REGISTER_INTERFACE
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_index
argument_list|,
name|ifa_af
argument_list|)
expr_stmt|;
name|sctp_ifnp
operator|->
name|registered_af
operator|=
name|ifa_af
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * Remove an ifa from its ifn.  * If no more addresses exist, remove the ifn too. Otherwise, re-register  * the interface based on the remaining address families left.  * NOTE: ADDR write lock MUST be held.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_remove_ifa_from_ifn
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
parameter_list|)
block|{
name|uint32_t
name|ifn_index
decl_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifap
argument_list|,
name|next_ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
condition|)
block|{
comment|/* update address counts */
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifa_count
operator|--
expr_stmt|;
switch|switch
condition|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|num_v4
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|num_v6
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|ifn_index
operator|=
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifalist
argument_list|)
condition|)
block|{
comment|/* remove the ifn, possibly freeing it */
name|sctp_delete_ifn
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* re-register address family type, if needed */
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|num_v6
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|registered_af
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|SCTP_DEREGISTER_INTERFACE
argument_list|(
name|ifn_index
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|SCTP_REGISTER_INTERFACE
argument_list|(
name|ifn_index
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|registered_af
operator|=
name|AF_INET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|num_v4
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|registered_af
operator|==
name|AF_INET
operator|)
condition|)
block|{
name|SCTP_DEREGISTER_INTERFACE
argument_list|(
name|ifn_index
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|SCTP_REGISTER_INTERFACE
argument_list|(
name|ifn_index
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|registered_af
operator|=
name|AF_INET6
expr_stmt|;
block|}
comment|/* free the ifn refcount */
name|sctp_free_ifn
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
expr_stmt|;
block|}
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_add_addr_to_vrf
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|void
modifier|*
name|ifn
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|,
name|uint32_t
name|ifn_type
parameter_list|,
specifier|const
name|char
modifier|*
name|if_name
parameter_list|,
name|void
modifier|*
name|ifa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|ifa_flags
parameter_list|,
name|int
name|dynamic_add
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifalist
modifier|*
name|hash_addr_head
decl_stmt|;
name|struct
name|sctp_ifnlist
modifier|*
name|hash_ifn_head
decl_stmt|;
name|uint32_t
name|hash_of_addr
decl_stmt|;
name|int
name|new_ifn_af
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"vrf_id 0x%x: adding address: "
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_IPI_ADDR_WLOCK
argument_list|()
expr_stmt|;
name|sctp_ifnp
operator|=
name|sctp_find_ifn
argument_list|(
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifnp
condition|)
block|{
name|vrf
operator|=
name|sctp_ifnp
operator|->
name|vrf
expr_stmt|;
block|}
else|else
block|{
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|vrf
operator|=
name|sctp_allocate_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|sctp_ifnp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * build one and add it, can't hold lock until after malloc 		 * done though. 		 */
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|sctp_ifnp
argument_list|,
expr|struct
name|sctp_ifn
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifn
argument_list|)
argument_list|,
name|SCTP_M_IFN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifnp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for IFN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|sctp_ifnp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifn
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_index
operator|=
name|ifn_index
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_p
operator|=
name|ifn
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_type
operator|=
name|ifn_type
expr_stmt|;
name|sctp_ifnp
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|sctp_ifnp
operator|->
name|vrf
operator|=
name|vrf
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|vrf
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifn_mtu
operator|=
name|SCTP_GATHER_MTU_FROM_IFN_INFO
argument_list|(
name|ifn
argument_list|,
name|ifn_index
argument_list|,
name|addr
operator|->
name|sa_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_name
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_name
argument_list|,
name|if_name
argument_list|,
name|SCTP_IFNAMSIZ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|sctp_ifnp
operator|->
name|ifn_name
argument_list|,
literal|"unknown"
argument_list|,
name|min
argument_list|(
literal|7
argument_list|,
name|SCTP_IFNAMSIZ
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hash_ifn_head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hash
argument_list|)
index|[
operator|(
name|ifn_index
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hashmark
argument_list|)
operator|)
index|]
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|ifalist
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_WLOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hash_ifn_head
argument_list|,
name|sctp_ifnp
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|vrf
operator|->
name|ifnlist
argument_list|,
name|sctp_ifnp
argument_list|,
name|next_ifn
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_ifns
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_ifn_af
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_ifap
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf
operator|->
name|vrf_id
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
condition|)
block|{
comment|/* Hmm, it already exists? */
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|)
operator|&&
operator|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
operator|==
name|ifn_index
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Using existing ifn %s (0x%x) for ifa %p\n"
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|ifn_index
argument_list|,
name|sctp_ifap
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ifn_af
condition|)
block|{
comment|/* Remove the created one that we don't want */
name|sctp_delete_ifn
argument_list|(
name|sctp_ifnp
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_ifap
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
comment|/* easy to solve, just switch back to active */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Clearing deleted ifa flag\n"
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator|=
name|SCTP_ADDR_VALID
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|sctp_ifnp
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit_stage_left
label|:
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sctp_ifap
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
condition|)
block|{
comment|/* 				 * The last IFN gets the address, remove the 				 * old one 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Moving ifa %p from %s (0x%x) to %s (0x%x)\n"
argument_list|,
name|sctp_ifap
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
argument_list|,
name|if_name
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
comment|/* remove the address from the old ifn */
name|sctp_remove_ifa_from_ifn
argument_list|(
name|sctp_ifap
argument_list|)
expr_stmt|;
comment|/* move the address over to the new ifn */
name|sctp_add_ifa_to_ifn
argument_list|(
name|sctp_ifnp
argument_list|,
name|sctp_ifap
argument_list|)
expr_stmt|;
goto|goto
name|exit_stage_left
goto|;
block|}
else|else
block|{
comment|/* repair ifnp which was NULL ? */
name|sctp_ifap
operator|->
name|localifa_flags
operator|=
name|SCTP_ADDR_VALID
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Repairing ifn %p for ifa %p\n"
argument_list|,
name|sctp_ifnp
argument_list|,
name|sctp_ifap
argument_list|)
expr_stmt|;
name|sctp_add_ifa_to_ifn
argument_list|(
name|sctp_ifnp
argument_list|,
name|sctp_ifap
argument_list|)
expr_stmt|;
block|}
goto|goto
name|exit_stage_left
goto|;
block|}
block|}
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|sctp_ifap
argument_list|,
expr|struct
name|sctp_ifa
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifa
argument_list|)
argument_list|,
name|SCTP_M_IFA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"No memory for IFA"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|sctp_ifap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ifa
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|ifn_p
operator|=
name|sctp_ifnp
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|vrf_id
operator|=
name|vrf_id
expr_stmt|;
name|sctp_ifap
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|address
argument_list|,
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator|=
name|SCTP_ADDR_VALID
operator||
name|SCTP_ADDR_DEFER_USE
expr_stmt|;
name|sctp_ifap
operator|->
name|flags
operator|=
name|ifa_flags
expr_stmt|;
comment|/* Set scope */
switch|switch
condition|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
operator|||
operator|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_priv
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_ifnp
operator|->
name|num_v4
operator|++
expr_stmt|;
if|if
condition|(
name|new_ifn_af
condition|)
name|new_ifn_af
operator|=
name|AF_INET
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* ok to use deprecated addresses? */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
argument_list|)
operator|||
operator|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_priv
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_ifnp
operator|->
name|num_v6
operator|++
expr_stmt|;
if|if
condition|(
name|new_ifn_af
condition|)
name|new_ifn_af
operator|=
name|AF_INET6
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|new_ifn_af
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|hash_of_addr
operator|=
name|sctp_get_ifa_hash_val
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|src_is_priv
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_ifap
operator|->
name|src_is_loop
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_ifap
operator|->
name|src_is_glob
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_IPI_ADDR_WLOCK
argument_list|()
expr_stmt|;
name|hash_addr_head
operator|=
operator|&
name|vrf
operator|->
name|vrf_addr_hash
index|[
operator|(
name|hash_of_addr
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
operator|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|hash_addr_head
argument_list|,
name|sctp_ifap
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctp_ifnp
operator|->
name|ifalist
argument_list|,
name|sctp_ifap
argument_list|,
name|next_ifa
argument_list|)
expr_stmt|;
name|sctp_ifnp
operator|->
name|ifa_count
operator|++
expr_stmt|;
name|vrf
operator|->
name|total_ifa_count
operator|++
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_ifas
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ifn_af
condition|)
block|{
name|SCTP_REGISTER_INTERFACE
argument_list|(
name|ifn_index
argument_list|,
name|new_ifn_af
argument_list|)
expr_stmt|;
name|sctp_ifnp
operator|->
name|registered_af
operator|=
name|new_ifn_af
expr_stmt|;
block|}
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|dynamic_add
condition|)
block|{
comment|/* 		 * Bump up the refcount so that when the timer completes it 		 * will drop back down. 		 */
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifap
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Gak, what can we do? We have lost an address 			 * change can you say HOSED? 			 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Lost an address change?\n"
argument_list|)
expr_stmt|;
comment|/* Opps, must decrement the count */
name|sctp_del_addr_from_vrf
argument_list|(
name|vrf_id
argument_list|,
name|addr
argument_list|,
name|ifn_index
argument_list|,
name|if_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|wi
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|sctp_ifap
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|SCTP_ADD_IP_ADDRESS
expr_stmt|;
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq
argument_list|)
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's ready for use */
name|sctp_ifap
operator|->
name|localifa_flags
operator|&=
operator|~
name|SCTP_ADDR_DEFER_USE
expr_stmt|;
block|}
return|return
operator|(
name|sctp_ifap
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_del_addr_from_vrf
parameter_list|(
name|uint32_t
name|vrf_id
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|ifn_index
parameter_list|,
specifier|const
name|char
modifier|*
name|if_name
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
init|=
name|NULL
decl_stmt|;
name|SCTP_IPI_ADDR_WLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Can't find vrf_id 0x%x\n"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"vrf_id 0x%x: deleting address:"
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_ifap
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf
operator|->
name|vrf_id
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifap
condition|)
block|{
comment|/* Validate the delete */
if|if
condition|(
name|sctp_ifap
operator|->
name|ifn_p
condition|)
block|{
name|int
name|valid
init|=
literal|0
decl_stmt|;
comment|/*- 			 * The name has priority over the ifn_index 			 * if its given. We do this especially for 			 * panda who might recycle indexes fast. 			 */
if|if
condition|(
name|if_name
condition|)
block|{
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
name|len1
operator|=
name|min
argument_list|(
name|SCTP_IFNAMSIZ
argument_list|,
name|strlen
argument_list|(
name|if_name
argument_list|)
argument_list|)
expr_stmt|;
name|len2
operator|=
name|min
argument_list|(
name|SCTP_IFNAMSIZ
argument_list|,
name|strlen
argument_list|(
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len1
operator|&&
name|len2
operator|&&
operator|(
name|len1
operator|==
name|len2
operator|)
condition|)
block|{
comment|/* we can compare them */
if|if
condition|(
name|strncmp
argument_list|(
name|if_name
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 						 * They match its a correct 						 * delete 						 */
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
comment|/* last ditch check ifn_index */
if|if
condition|(
name|ifn_index
operator|==
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
condition|)
block|{
name|valid
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|valid
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"ifn:%d ifname:%s does not match addresses\n"
argument_list|,
name|ifn_index
argument_list|,
operator|(
operator|(
name|if_name
operator|==
name|NULL
operator|)
condition|?
literal|"NULL"
else|:
name|if_name
operator|)
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"ifn:%d ifname:%s - ignoring delete\n"
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_index
argument_list|,
name|sctp_ifap
operator|->
name|ifn_p
operator|->
name|ifn_name
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Deleting ifa %p\n"
argument_list|,
name|sctp_ifap
argument_list|)
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator|&=
name|SCTP_ADDR_VALID
expr_stmt|;
name|sctp_ifap
operator|->
name|localifa_flags
operator||=
name|SCTP_BEING_DELETED
expr_stmt|;
name|vrf
operator|->
name|total_ifa_count
operator|--
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sctp_ifap
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|sctp_remove_ifa_from_ifn
argument_list|(
name|sctp_ifap
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
else|else
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Del Addr-ifn:%d Could not find address:"
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out_now
label|:
name|SCTP_IPI_ADDR_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sctp_ifap
condition|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Gak, what can we do? We have lost an address 			 * change can you say HOSED? 			 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB4
argument_list|,
literal|"Lost an address change?\n"
argument_list|)
expr_stmt|;
comment|/* Oops, must decrement the count */
name|sctp_free_ifa
argument_list|(
name|sctp_ifap
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|wi
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|sctp_ifap
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|SCTP_DEL_IP_ADDRESS
expr_stmt|;
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
comment|/* 		 * Should this really be a tailq? As it is we will process 		 * the newest first :-0 		 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq
argument_list|)
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_tcb_special_locate
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/**** ASSUMES THE CALLER holds the INP_INFO_RLOCK */
comment|/* 	 * If we support the TCP model, then we must now dig through to see 	 * if we can find our endpoint in the list of tcp ep's. 	 */
name|uint16_t
name|lport
decl_stmt|,
name|rport
decl_stmt|;
name|struct
name|sctppcbhead
modifier|*
name|ephead
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
if|if
condition|(
operator|(
name|to
operator|==
name|NULL
operator|)
operator|||
operator|(
name|from
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|to
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|from
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
operator|)
operator|->
name|sin_port
expr_stmt|;
name|rport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|from
operator|)
operator|->
name|sin_port
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|from
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
operator|)
operator|->
name|sin6_port
expr_stmt|;
name|rport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|from
operator|)
operator|->
name|sin6_port
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ephead
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
operator|(
name|lport
operator||
name|rport
operator|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * Ok now for each of the guys in this bucket we must look and see: 	 * - Does the remote port match. - Does there single association's 	 * addresses match this address (to). If so we update p_ep to point 	 * to this ep and return the tcb from it. 	 */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|ephead
argument_list|,
argument|sctp_hash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|lport
operator|!=
name|inp
operator|->
name|sctp_lport
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|inp
operator|->
name|def_vrf_id
operator|!=
name|vrf_id
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check to see if the ep has one of the addresses */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* We are NOT bound all, so look further */
name|int
name|match
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"%s: NULL ifa\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"ifa being deleted\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|to
operator|->
name|sa_family
condition|)
block|{
comment|/* see if it matches */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|from
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|intf_addr
decl_stmt|,
modifier|*
name|sin
decl_stmt|;
name|intf_addr
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|intf_addr
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|from
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|intf_addr6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|intf_addr6
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|intf_addr6
argument_list|)
condition|)
block|{
name|match
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|match
operator|==
literal|0
condition|)
block|{
comment|/* This endpoint does not have this address */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 		 * Ok if we hit here the ep has the address, does it hold 		 * the tcb? 		 */
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* remote port does not match. */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Does this TCB have a matching address? */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|from
operator|->
name|sa_family
condition|)
block|{
comment|/* not the same family, can't be a match */
continue|continue;
block|}
switch|switch
condition|(
name|from
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|from
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
comment|/* 						 * Update the endpoint 						 * pointer 						 */
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|from
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|rsin6
argument_list|)
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
comment|/* 						 * Update the endpoint 						 * pointer 						 */
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_does_stcb_own_this_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|)
block|{
name|int
name|loopback_scope
decl_stmt|,
name|ipv4_local_scope
decl_stmt|,
name|local_scope
decl_stmt|,
name|site_scope
decl_stmt|;
name|int
name|ipv4_addr_legal
decl_stmt|,
name|ipv6_addr_legal
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|loopback_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
expr_stmt|;
name|ipv4_local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
expr_stmt|;
name|local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
expr_stmt|;
name|site_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
expr_stmt|;
name|ipv4_addr_legal
operator|=
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
comment|/* no vrf, no addresses */
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We allow pending addresses, where 					 * we have sent an asconf-add to be 					 * considered valid. 					 */
continue|continue;
block|}
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_scope
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|rsin6
argument_list|)
condition|)
block|{
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * We allow pending addresses, where we have 				 * sent an asconf-add to be considered 				 * valid. 				 */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|to
operator|->
name|sa_family
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|to
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|rsin6
argument_list|)
condition|)
block|{
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
block|}
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rules for use  *  * 1) If I return a NULL you must decrement any INP ref cnt. 2) If I find an  * stcb, both will be locked (locked_tcb and stcb) but decrement will be done  * (if locked == NULL). 3) Decrement happens on return ONLY if locked ==  * NULL.  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_ep_addr
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|remote
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|local
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|locked_tcb
parameter_list|)
block|{
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|uint16_t
name|rport
decl_stmt|;
name|inp
operator|=
operator|*
name|inp_p
expr_stmt|;
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|rport
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|remote
operator|)
operator|->
name|sin_port
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|remote
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|rport
operator|=
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|remote
operator|)
operator|->
name|sin6_port
operator|)
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
comment|/* 		 * UN-lock so we can do proper locking here this occurs when 		 * called from load_addresses_from_init. 		 */
name|atomic_add_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
comment|/*- 		 * Now either this guy is our listener or it's the 		 * connector. If it is the one that issued the connect, then 		 * it's only chance is to be the first TCB in the list. If 		 * it is the acceptor, then do the special_lookup to hash 		 * and find the real inp. 		 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_socket
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* to is peer addr, from is my addr */
name|stcb
operator|=
name|sctp_tcb_special_locate
argument_list|(
name|inp_p
argument_list|,
name|remote
argument_list|,
name|local
argument_list|,
name|netp
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|locked_tcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* we have a locked tcb, lower refcount */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|locked_tcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|locked_tcb
operator|!=
name|stcb
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|locked_tcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|locked_tcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* remote port does not match. */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|null_return
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|null_return
goto|;
block|}
if|if
condition|(
name|local
operator|&&
operator|!
name|sctp_does_stcb_own_this_addr
argument_list|(
name|stcb
argument_list|,
name|local
argument_list|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|null_return
goto|;
block|}
comment|/* now look at the list of remote addresses */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|net
operator|==
operator|(
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Corrupt net list"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|remote
operator|->
name|sa_family
condition|)
block|{
comment|/* not the same family */
continue|continue;
block|}
switch|switch
condition|(
name|remote
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|rsin6
argument_list|)
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|head
operator|=
operator|&
name|inp
operator|->
name|sctp_tcbhash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|rport
argument_list|,
name|inp
operator|->
name|sctp_hashmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
goto|goto
name|null_return
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_tcbhash
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
comment|/* remote port does not match */
continue|continue;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|local
operator|&&
operator|!
name|sctp_does_stcb_own_this_addr
argument_list|(
name|stcb
argument_list|,
name|local
argument_list|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* now look at the list of remote addresses */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|net
operator|==
operator|(
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Corrupt net list"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|remote
operator|->
name|sa_family
condition|)
block|{
comment|/* not the same family */
continue|continue;
block|}
switch|switch
condition|(
name|remote
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|rsin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|rsin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|rsin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|rsin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|remote
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|rsin6
argument_list|)
condition|)
block|{
comment|/* found it */
if|if
condition|(
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|locked_tcb
operator|!=
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
name|null_return
label|:
comment|/* clean up for returning null */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|locked_tcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
comment|/* not found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an association for a specific endpoint using the association id given  * out in the COMM_UP notification  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findasoc_ep_asocid_locked
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|sctp_assoc_t
name|asoc_id
parameter_list|,
name|int
name|want_lock
parameter_list|)
block|{
comment|/* 	 * Use my the assoc_id to find a endpoint 	 */
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|uint32_t
name|id
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSNH ep_associd\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSNH ep_associd0\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|id
operator|=
operator|(
name|uint32_t
operator|)
name|asoc_id
expr_stmt|;
name|head
operator|=
operator|&
name|inp
operator|->
name|sctp_asocidhash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|id
argument_list|,
name|inp
operator|->
name|hashasocidmark
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
comment|/* invalid id TSNH */
name|SCTP_PRINTF
argument_list|(
literal|"TSNH ep_associd1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_tcbasocidhash
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_id
operator|==
name|id
condition|)
block|{
if|if
condition|(
name|inp
operator|!=
name|stcb
operator|->
name|sctp_ep
condition|)
block|{
comment|/* 				 * some other guy has the same id active (id 				 * collision ??). 				 */
name|SCTP_PRINTF
argument_list|(
literal|"TSNH ep_associd2\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|want_lock
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_ep_asocid
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|sctp_assoc_t
name|asoc_id
parameter_list|,
name|int
name|want_lock
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findasoc_ep_asocid_locked
argument_list|(
name|inp
argument_list|,
name|asoc_id
argument_list|,
name|want_lock
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_inpcb
modifier|*
name|sctp_endpoint_probe
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|sctppcbhead
modifier|*
name|head
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|intf_addr6
decl_stmt|;
endif|#
directive|endif
name|int
name|fnd
decl_stmt|;
comment|/* 	 * Endpoint probe expects that the INP_INFO is locked. 	 */
ifdef|#
directive|ifdef
name|INET
name|sin
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|sin6
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|nam
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nam
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* unsupported family */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_lport
operator|==
name|lport
operator|)
condition|)
block|{
comment|/* got it */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* IPv4 on a IPv6 socket with ONLY IPv6 set */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
comment|/* A V6 address and the endpoint is NOT bound V6 */
if|if
condition|(
name|nam
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* does a VRF id match? */
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|def_vrf_id
operator|==
name|vrf_id
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
continue|continue;
return|return
operator|(
name|inp
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|nam
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
comment|/* Can't hunt for one that has no address specified */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Can't hunt for one that has no address specified */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* 	 * ok, not bound to all so see if we can find a EP bound to this 	 * address. 	 */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Ok this could be a likely candidate, look at all of its 		 * addresses 		 */
if|if
condition|(
name|inp
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* does a VRF id match? */
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|def_vrf_id
operator|==
name|vrf_id
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"%s: NULL ifa\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Ok laddr->ifa:%p is possible, "
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Huh IFA being deleted\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|nam
operator|->
name|sa_family
condition|)
block|{
comment|/* possible, see if it matches */
switch|switch
condition|(
name|nam
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|intf_addr6
operator|=
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6
argument_list|,
name|intf_addr6
argument_list|)
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
block|}
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_inpcb
modifier|*
name|sctp_isport_inuse
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|t_inp
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|t_inp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
if|if
condition|(
name|t_inp
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
continue|continue;
block|}
comment|/* is it in the VRF in question */
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t_inp
operator|->
name|def_vrf_id
operator|==
name|vrf_id
condition|)
name|fnd
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
continue|continue;
comment|/* This one is in use. */
comment|/* check the v6/v4 binding issue */
if|if
condition|(
operator|(
name|t_inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|t_inp
argument_list|)
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
comment|/* collision in V6 space */
return|return
operator|(
name|t_inp
operator|)
return|;
block|}
else|else
block|{
comment|/* inp is BOUND_V4 no conflict */
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|t_inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
comment|/* t_inp is bound v4 and v6, conflict always */
return|return
operator|(
name|t_inp
operator|)
return|;
block|}
else|else
block|{
comment|/* t_inp is bound only V4 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* no conflict */
continue|continue;
block|}
comment|/* else fall through to conflict */
block|}
return|return
operator|(
name|t_inp
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_swap_inpcb_for_listen
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* For 1-2-1 with port reuse */
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|tinp
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
condition|)
block|{
comment|/* only works with port reuse on */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|inp
operator|->
name|sctp_lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* Kick out all non-listeners to the TCP hash */
name|LIST_FOREACH
argument_list|(
argument|tinp
argument_list|,
argument|head
argument_list|,
argument|sctp_hash
argument_list|)
block|{
if|if
condition|(
name|tinp
operator|->
name|sctp_lport
operator|!=
name|inp
operator|->
name|sctp_lport
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tinp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tinp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tinp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
condition|)
block|{
continue|continue;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|tinp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|tinp
operator|->
name|sctp_lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|tinp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_IN_TCPPOOL
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|tinp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Pull from where he was */
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_IN_TCPPOOL
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|inp
operator|->
name|sctp_lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_inpcb
modifier|*
name|sctp_pcb_findep
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|int
name|find_tcp_pool
parameter_list|,
name|int
name|have_lock
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/* 	 * First we check the hash table to see if someone has this port 	 * bound with just the port. 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|int
name|lport
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|nam
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
operator|)
operator|->
name|sin_port
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nam
expr_stmt|;
name|lport
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|nam
operator|)
operator|->
name|sin6_port
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * I could cheat here and just cast to one of the types but we will 	 * do it right. It also provides the check against an Unsupported 	 * type too. 	 */
comment|/* Find the head of the ALLADDR chain */
if|if
condition|(
name|have_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
block|}
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|inp
operator|=
name|sctp_endpoint_probe
argument_list|(
name|nam
argument_list|,
name|head
argument_list|,
name|lport
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
comment|/* 	 * If the TCP model exists it could be that the main listening 	 * endpoint is gone but there still exists a connected socket for 	 * this guy. If so we can return the first one that we find. This 	 * may NOT be the correct one so the caller should be wary on the 	 * returned INP. Currently the only caller that sets find_tcp_pool 	 * is in bindx where we are verifying that a user CAN bind the 	 * address. He either has bound it already, or someone else has, or 	 * its open to bind, so this is good enough. 	 */
if|if
condition|(
name|inp
operator|==
name|NULL
operator|&&
name|find_tcp_pool
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
index|[
name|i
index|]
expr_stmt|;
name|inp
operator|=
name|sctp_endpoint_probe
argument_list|(
name|nam
argument_list|,
name|head
argument_list|,
name|lport
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|inp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an association for an endpoint with the pointer to whom you want to  * send to and the endpoint pointer. The address can be IPv4 or IPv6. We may  * need to change the *to to some other struct like a mbuf...  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_addr_sa
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
name|find_tcp_pool
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|retval
decl_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|find_tcp_pool
condition|)
block|{
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|sctp_tcb_special_locate
argument_list|(
name|inp_p
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|netp
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|sctp_tcb_special_locate
argument_list|(
operator|&
name|inp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|netp
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|inp
operator|=
name|sctp_pcb_findep
argument_list|(
name|to
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * ok, we have an endpoint, now lets find the assoc for it (if any) 	 * we now place the source address or from in the to of the find 	 * endpoint call. Since in reality this chain is used from the 	 * inbound packet side. 	 */
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
name|from
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|from
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * This routine will grub through the mbuf that is a INIT or INIT-ACK and  * find all addresses that the sender has specified in any address list. Each  * address will be used to lookup the TCB and see if one exits.  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_special_addr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dest
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|parm_buf
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|retval
decl_stmt|;
name|uint32_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin4
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|memset
argument_list|(
operator|&
name|sin4
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
argument_list|)
expr_stmt|;
name|sin4
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
expr_stmt|;
name|sin4
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin4
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
endif|#
directive|endif
name|retval
operator|=
name|NULL
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
operator|!=
name|NULL
condition|)
block|{
comment|/* now we must see if we want the parameter */
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
break|break;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
operator|&&
name|plen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* Get the rest of the address */
name|struct
name|sctp_ipv4addr_param
name|ip4_parm
decl_stmt|,
modifier|*
name|p4
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|ip4_parm
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|ip4_parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin4
operator|.
name|sin_addr
argument_list|,
operator|&
name|p4
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p4
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look it up */
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin4
argument_list|,
name|netp
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
operator|&&
name|plen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* Get the rest of the address */
name|struct
name|sctp_ipv6addr_param
name|ip6_parm
decl_stmt|,
modifier|*
name|p6
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|ip6_parm
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6_parm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p6
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look it up */
name|retval
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|netp
argument_list|,
name|dest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassoc_by_vtag
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint16_t
name|rport
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|int
name|skip_src_check
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint32_t
name|remote_tag
parameter_list|)
block|{
comment|/* 	 * Use my vtag to hash. If we find it we then verify the source addr 	 * is in the assoc. If all goes well we save a bit on rec of a 	 * packet. 	 */
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
operator|*
name|netp
operator|=
name|NULL
expr_stmt|;
operator|*
name|inp_p
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|vtag
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
comment|/* invalid vtag */
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_asocs
argument_list|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|==
name|vtag
condition|)
block|{
comment|/* candidate */
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* RRS:Need toaddr check here */
if|if
condition|(
name|sctp_does_stcb_own_this_addr
argument_list|(
name|stcb
argument_list|,
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Endpoint does not own this address */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|remote_tag
condition|)
block|{
comment|/* 				 * If we have both vtags that's all we match 				 * on 				 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|==
name|remote_tag
condition|)
block|{
comment|/* 					 * If both tags match we consider it 					 * conclusive and check NO 					 * source/destination addresses 					 */
goto|goto
name|conclusive
goto|;
block|}
block|}
if|if
condition|(
name|skip_src_check
condition|)
block|{
name|conclusive
label|:
if|if
condition|(
name|from
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|netp
operator|=
name|NULL
expr_stmt|;
comment|/* unknown */
block|}
if|if
condition|(
name|inp_p
condition|)
operator|*
name|inp_p
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* yep its him. */
operator|*
name|netp
operator|=
name|net
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_vtagexpress
argument_list|)
expr_stmt|;
operator|*
name|inp_p
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
comment|/* 				 * not him, this should only happen in rare 				 * cases so I peg it. 				 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_vtagbogus
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find an association with the pointer to the inbound IP packet. This can be  * a IPv4 or IPv6 packet.  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_addr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|int
name|find_tcp_pool
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|retval
decl_stmt|;
name|struct
name|sockaddr_storage
name|to_store
decl_stmt|,
name|from_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|to_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_store
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPVERSION
case|:
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|from4
decl_stmt|;
name|from4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|from_store
expr_stmt|;
name|bzero
argument_list|(
name|from4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from4
argument_list|)
argument_list|)
expr_stmt|;
name|from4
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|from4
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|from4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|from4
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|from6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|from6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|from_store
expr_stmt|;
name|bzero
argument_list|(
name|from6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from6
argument_list|)
argument_list|)
expr_stmt|;
name|from6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|from6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|from6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|from6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
comment|/* Get the scopes in properly to the sin6 addr's */
comment|/* we probably don't need these operations */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|from6
argument_list|)
expr_stmt|;
name|sa6_embedscope
argument_list|(
name|from6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* Currently not supported. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPVERSION
case|:
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|to4
decl_stmt|;
name|to4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|to_store
expr_stmt|;
name|bzero
argument_list|(
name|to4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to4
argument_list|)
argument_list|)
expr_stmt|;
name|to4
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|to4
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|to4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|to4
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|to6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|to6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|to_store
expr_stmt|;
name|bzero
argument_list|(
name|to6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|to6
argument_list|)
argument_list|)
expr_stmt|;
name|to6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|to6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|to6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|to6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
comment|/* Get the scopes in properly to the sin6 addr's */
comment|/* we probably don't need these operations */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|to6
argument_list|)
expr_stmt|;
name|sa6_embedscope
argument_list|(
name|to6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
if|if
condition|(
name|sh
operator|->
name|v_tag
condition|)
block|{
comment|/* we only go down this path if vtag is non-zero */
name|retval
operator|=
name|sctp_findassoc_by_vtag
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
argument_list|,
name|inp_p
argument_list|,
name|netp
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
name|sh
operator|->
name|dest_port
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
name|find_tcp_pool
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION_ACK
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_COOKIE_ACK
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_COOKIE_ECHO
operator|)
condition|)
block|{
comment|/* Other chunk types go to the tcp pool. */
name|find_tcp_pool
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inp_p
condition|)
block|{
name|retval
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|inp_p
argument_list|,
name|netp
argument_list|,
name|find_tcp_pool
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|*
name|inp_p
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
operator|&
name|inp
argument_list|,
name|netp
argument_list|,
name|find_tcp_pool
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"retval:%p inp:%p\n"
argument_list|,
name|retval
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|NULL
operator|&&
name|inp
condition|)
block|{
comment|/* Found a EP but not this address */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION_ACK
operator|)
condition|)
block|{
comment|/*- 			 * special hook, we do NOT return linp or an 			 * association that is linked to an existing 			 * association that is under the TCP pool (i.e. no 			 * listener exists). The endpoint finding routine 			 * will always find a listener before examining the 			 * TCP pool. 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
condition|)
block|{
if|if
condition|(
name|inp_p
condition|)
block|{
operator|*
name|inp_p
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|retval
operator|=
name|sctp_findassociation_special_addr
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
operator|&
name|inp
argument_list|,
name|netp
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
block|}
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"retval is %p\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lookup an association by an ASCONF lookup address.  * if the lookup address is 0.0.0.0 or ::0, use the vtag to do the lookup  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_ep_asconf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr_storage
name|local_store
decl_stmt|,
name|remote_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|to
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctp_paramhdr
name|parm_buf
decl_stmt|,
modifier|*
name|phdr
decl_stmt|;
name|int
name|ptype
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|local_store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|local_store
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|remote_store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|remote_store
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|local_store
expr_stmt|;
comment|/* First get the destination address setup too. */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPVERSION
case|:
comment|/* its IPv4 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|local_store
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
comment|/* its IPv6 */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|local_store
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
name|NULL
return|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"%s: failed to get asconf lookup addr\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ptype
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|uint32_t
operator|)
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get the correlation address */
switch|switch
condition|(
name|ptype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
block|{
comment|/* ipv6 address param */
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p6
decl_stmt|,
name|p6_buf
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
operator|&
name|p6_buf
operator|.
name|ph
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p6
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"%s: failed to get asconf v6 lookup addr\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|remote_store
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
block|{
comment|/* ipv4 address param */
name|struct
name|sctp_ipv4addr_param
modifier|*
name|p4
decl_stmt|,
name|p4_buf
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
return|return
name|NULL
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
operator|&
name|p4_buf
operator|.
name|ph
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p4
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p4
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"%s: failed to get asconf v4 lookup addr\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|remote_store
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
operator|&
name|p4
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* invalid address param type */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|zero_address
condition|)
block|{
name|stcb
operator|=
name|sctp_findassoc_by_vtag
argument_list|(
name|NULL
argument_list|,
name|to
argument_list|,
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
argument_list|,
name|inp_p
argument_list|,
name|netp
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
name|sh
operator|->
name|dest_port
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * printf("findassociation_ep_asconf: zero lookup address 		 * finds stcb 0x%x\n", (uint32_t)stcb); 		 */
block|}
else|else
block|{
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|remote_store
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocate a sctp_inpcb and setup a temporary binding to a port/all  * addresses. This way if we don't get a bind we by default pick a ephemeral  * port with all addresses bound.  */
end_comment

begin_function
name|int
name|sctp_inpcb_alloc
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/* 	 * we get called when a new endpoint starts up. We need to allocate 	 * the sctp_inpcb structure from the zone and init it. Mark it as 	 * unbound and find a port that we can use as an ephemeral with 	 * INADDR_ANY. If the user binds later no problem we can then add in 	 * the specific addresses. And setup the default parameters for the 	 * EP. 	 */
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_pcb
modifier|*
name|m
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|null_key
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|inp
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
expr|struct
name|sctp_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Out of SCTP-INPCB structures - no resources\n"
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* zap it */
name|bzero
argument_list|(
name|inp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bump generations */
comment|/* setup socket pointers */
name|inp
operator|->
name|sctp_socket
operator|=
name|so
expr_stmt|;
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_socket
operator|=
name|so
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|MODULE_GLOBAL
argument_list|(
name|ip6_auto_flowlabel
argument_list|)
condition|)
block|{
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_flags
operator||=
name|IN6P_AUTOFLOWLABEL
expr_stmt|;
block|}
endif|#
directive|endif
name|inp
operator|->
name|sctp_associd_counter
operator|=
literal|1
expr_stmt|;
name|inp
operator|->
name|partial_delivery_point
operator|=
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
operator|>>
name|SCTP_PARTIAL_DELIVERY_SHIFT
expr_stmt|;
name|inp
operator|->
name|sctp_frag_point
operator|=
name|SCTP_DEFAULT_MAXSEGMENT
expr_stmt|;
name|inp
operator|->
name|sctp_cmt_on_off
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ecn_enable
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_ecn_enable
argument_list|)
expr_stmt|;
comment|/* init the small hash table we use to track asocid<-> tcb */
name|inp
operator|->
name|sctp_asocidhash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_STACK_VTAG_HASH_SIZE
argument_list|,
operator|&
name|inp
operator|->
name|hashasocidmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_asocidhash
operator|==
name|NULL
condition|)
block|{
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
block|{
name|struct
name|inpcbpolicy
modifier|*
name|pcb_sp
init|=
name|NULL
decl_stmt|;
name|error
operator|=
name|ipsec_init_policy
argument_list|(
name|so
argument_list|,
operator|&
name|pcb_sp
argument_list|)
expr_stmt|;
comment|/* Arrange to share the policy */
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_sp
operator|=
name|pcb_sp
expr_stmt|;
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|(
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|)
operator|)
operator|->
name|in6p_sp
operator|=
name|pcb_sp
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
name|SCTP_INCR_EP_COUNT
argument_list|()
expr_stmt|;
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_ttl
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ip_defttl
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
operator|(
name|caddr_t
operator|)
name|inp
expr_stmt|;
if|if
condition|(
name|SCTP_SO_TYPE
argument_list|(
name|so
argument_list|)
operator|==
name|SOCK_SEQPACKET
condition|)
block|{
comment|/* UDP style socket */
name|inp
operator|->
name|sctp_flags
operator|=
operator|(
name|SCTP_PCB_FLAGS_UDPTYPE
operator||
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
expr_stmt|;
comment|/* Be sure it is NON-BLOCKING IO for UDP */
comment|/* SCTP_SET_SO_NBIO(so); */
block|}
elseif|else
if|if
condition|(
name|SCTP_SO_TYPE
argument_list|(
name|so
argument_list|)
operator|==
name|SOCK_STREAM
condition|)
block|{
comment|/* TCP style socket */
name|inp
operator|->
name|sctp_flags
operator|=
operator|(
name|SCTP_PCB_FLAGS_TCPTYPE
operator||
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
expr_stmt|;
comment|/* Be sure we have blocking IO by default */
name|SCTP_CLEAR_SO_NBIO
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * unsupported socket type (RAW, etc)- in case we missed it 		 * in protosw 		 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_default_frag_interleave
argument_list|)
operator|==
name|SCTP_FRAG_LEVEL_1
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_default_frag_interleave
argument_list|)
operator|==
name|SCTP_FRAG_LEVEL_2
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_default_frag_interleave
argument_list|)
operator|==
name|SCTP_FRAG_LEVEL_0
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
expr_stmt|;
block|}
name|inp
operator|->
name|sctp_tcbhash
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_pcbtblsize
argument_list|)
argument_list|,
operator|&
name|inp
operator|->
name|sctp_hashmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Out of SCTP-INPCB->hashinit - no resources\n"
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|inp
operator|->
name|def_vrf_id
operator|=
name|vrf_id
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_LOCK_INIT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_LOCK_INIT
argument_list|(
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
argument_list|,
literal|"inp"
argument_list|,
literal|"sctpinp"
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_INIT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK_INIT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* lock the new ep */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* add it to the info area */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|listhead
argument_list|)
argument_list|,
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_TRACK_FREED_ASOCS
comment|/* TEMP CODE */
name|LIST_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_free_list
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Init the timer structure for signature change */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|type
operator|=
name|SCTP_TIMER_TYPE_NEWCOOKIE
expr_stmt|;
comment|/* now init the actual endpoint default data */
name|m
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
expr_stmt|;
comment|/* setup the base timeout information */
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_SEND
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_SEND_SEC
argument_list|)
expr_stmt|;
comment|/* needed ? */
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_INIT
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_INIT_SEC
argument_list|)
expr_stmt|;
comment|/* needed ? */
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_delayed_sack_time_default
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_heartbeat_interval_default
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_PMTU
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_pmtu_raise_time_default
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_MAXSHUTDOWN
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_shutdown_guard_time_default
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_SIGNATURE
index|]
operator|=
name|SEC_TO_TICKS
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_secret_lifetime_default
argument_list|)
argument_list|)
expr_stmt|;
comment|/* all max/min max are in ms */
name|m
operator|->
name|sctp_maxrto
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_rto_max_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_minrto
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_rto_min_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|initial_rto
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_rto_initial_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|initial_init_rto_max
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_init_rto_max_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_sack_freq
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_sack_freq_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|max_open_streams_intome
operator|=
name|MAX_SCTP_STREAMS
expr_stmt|;
name|m
operator|->
name|max_init_times
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_init_rtx_max_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|max_send_times
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_assoc_rtx_max_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|def_net_failure
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_path_rtx_max_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|def_net_pf_threshold
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_path_pf_threshold
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_sws_sender
operator|=
name|SCTP_SWS_SENDER_DEF
expr_stmt|;
name|m
operator|->
name|sctp_sws_receiver
operator|=
name|SCTP_SWS_RECEIVER_DEF
expr_stmt|;
name|m
operator|->
name|max_burst
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_burst_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|fr_max_burst
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_fr_max_burst_default
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_default_cc_module
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_default_cc_module
argument_list|)
expr_stmt|;
name|m
operator|->
name|sctp_default_ss_module
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_default_ss_module
argument_list|)
expr_stmt|;
comment|/* number of streams to pre-open on a association */
name|m
operator|->
name|pre_open_stream_count
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_outgoing_streams_default
argument_list|)
expr_stmt|;
comment|/* Add adaptation cookie */
name|m
operator|->
name|adaptation_layer_indicator
operator|=
literal|0x504C5253
expr_stmt|;
comment|/* seed random number generator */
name|m
operator|->
name|random_counter
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|store_at
operator|=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|SCTP_READ_RANDOM
argument_list|(
name|m
operator|->
name|random_numbers
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|random_numbers
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_fill_random_store
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* Minimum cookie size */
name|m
operator|->
name|size_of_a_cookie
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_msg
argument_list|)
operator|*
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
expr_stmt|;
name|m
operator|->
name|size_of_a_cookie
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
comment|/* Setup the initial secret */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|time
argument_list|)
expr_stmt|;
name|m
operator|->
name|time_of_secret_change
operator|=
name|time
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_OF_SECRETS
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|->
name|secret_key
index|[
literal|0
index|]
index|[
name|i
index|]
operator|=
name|sctp_select_initial_TSN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_NEWCOOKIE
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* How long is a cookie good for ? */
name|m
operator|->
name|def_cookie_life
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_valid_cookie_life_default
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize authentication parameters 	 */
name|m
operator|->
name|local_hmacs
operator|=
name|sctp_default_supported_hmaclist
argument_list|()
expr_stmt|;
name|m
operator|->
name|local_auth_chunks
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
name|m
operator|->
name|default_dscp
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|m
operator|->
name|default_flowlabel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|sctp_auth_set_default_chunks
argument_list|(
name|m
operator|->
name|local_auth_chunks
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|m
operator|->
name|shared_keys
argument_list|)
expr_stmt|;
comment|/* add default NULL key as key id 0 */
name|null_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
name|sctp_insert_sharedkey
argument_list|(
operator|&
name|m
operator|->
name|shared_keys
argument_list|,
name|null_key
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|12
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_move_pcb_and_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|old_inp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|new_inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|uint16_t
name|lport
decl_stmt|,
name|rport
decl_stmt|;
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|oladdr
decl_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|time_of_secret_change
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|time_of_secret_change
expr_stmt|;
name|memcpy
argument_list|(
name|new_inp
operator|->
name|sctp_ep
operator|.
name|secret_key
argument_list|,
name|old_inp
operator|->
name|sctp_ep
operator|.
name|secret_key
argument_list|,
sizeof|sizeof
argument_list|(
name|old_inp
operator|->
name|sctp_ep
operator|.
name|secret_key
argument_list|)
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|last_secret_number
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|last_secret_number
expr_stmt|;
name|new_inp
operator|->
name|sctp_ep
operator|.
name|size_of_a_cookie
operator|=
name|old_inp
operator|->
name|sctp_ep
operator|.
name|size_of_a_cookie
expr_stmt|;
comment|/* make it so new data pours into the new socket */
name|stcb
operator|->
name|sctp_socket
operator|=
name|new_inp
operator|->
name|sctp_socket
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|=
name|new_inp
expr_stmt|;
comment|/* Copy the port across */
name|lport
operator|=
name|new_inp
operator|->
name|sctp_lport
operator|=
name|old_inp
operator|->
name|sctp_lport
expr_stmt|;
name|rport
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
comment|/* Pull the tcb from the old association */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbhash
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|in_asocid_hash
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
block|}
comment|/* Now insert the new_inp into the TCP connected hash */
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
operator|(
name|lport
operator||
name|rport
operator|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|new_inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
comment|/* Its safe to access */
name|new_inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_UNBOUND
expr_stmt|;
comment|/* Now move the tcb into the endpoint list */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_inp
operator|->
name|sctp_asoc_list
argument_list|,
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
comment|/* 	 * Question, do we even need to worry about the ep-hash since we 	 * only have one connection? Probably not :> so lets get rid of it 	 * and not suck up any kernel memory in that. 	 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|in_asocid_hash
condition|)
block|{
name|struct
name|sctpasochead
modifier|*
name|lhd
decl_stmt|;
name|lhd
operator|=
operator|&
name|new_inp
operator|->
name|sctp_asocidhash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_id
argument_list|,
name|new_inp
operator|->
name|hashasocidmark
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|lhd
argument_list|,
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
block|}
comment|/* Ok. Let's restart timer. */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|new_inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_inp
operator|->
name|sctp_tcbhash
operator|!=
name|NULL
condition|)
block|{
name|SCTP_HASH_FREE
argument_list|(
name|new_inp
operator|->
name|sctp_tcbhash
argument_list|,
name|new_inp
operator|->
name|sctp_hashmark
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|sctp_tcbhash
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|new_inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Subset bound, so copy in the laddr list from the old_inp */
name|LIST_FOREACH
argument_list|(
argument|oladdr
argument_list|,
argument|&old_inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|laddr
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|laddr
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Gak, what can we do? This assoc is really 				 * HOSED. We probably should send an abort 				 * here. 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Association hosed in TCP model, out of laddr memory\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|laddr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|laddr
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|ifa
operator|=
name|oladdr
operator|->
name|ifa
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|new_inp
operator|->
name|sctp_addr_list
argument_list|,
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|new_inp
operator|->
name|laddr_count
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Now any running timers need to be adjusted since we really don't 	 * care if they are running or not just blast in the new_inp into 	 * all of them. 	 */
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|shut_guard_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|autoclose_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|delayed_event_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|delete_prim_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
comment|/* now what about the nets? */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|pmtu_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
name|net
operator|->
name|rxt_timer
operator|.
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|new_inp
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sctp_ifap is used to bypass normal local address validation checks */
end_comment

begin_function
name|int
name|sctp_inpcb_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
comment|/* bind a ep to a socket address */
name|struct
name|sctppcbhead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
name|inp_tmp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|ip_inp
decl_stmt|;
name|int
name|port_reuse_active
init|=
literal|0
decl_stmt|;
name|int
name|bindall
decl_stmt|;
name|uint16_t
name|lport
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|lport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|bindall
operator|=
literal|1
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|ip_inp
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|addr
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Bind called port:%d\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Addr :"
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* already did a bind, subsequent binds NOT allowed ! */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"null proc/thread"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* IPV6_V6ONLY socket? */
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|ip_inp
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
name|lport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
comment|/* 				 * For LOOPBACK the prison_local_ip4() call 				 * will transmute the ip address to the 				 * proper value. 				 */
if|if
condition|(
name|p
operator|&&
operator|(
name|error
operator|=
name|prison_local_ip4
argument_list|(
name|p
operator|->
name|td_ucred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|bindall
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* 				 * Only for pure IPv6 Address. (No IPv4 				 * Mapped!) 				 */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|lport
operator|=
name|sin6
operator|->
name|sin6_port
expr_stmt|;
comment|/* 				 * For LOOPBACK the prison_local_ip6() call 				 * will transmute the ipv6 address to the 				 * proper value. 				 */
if|if
condition|(
name|p
operator|&&
operator|(
name|error
operator|=
name|prison_local_ip6
argument_list|(
name|p
operator|->
name|td_ucred
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
operator|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|bindall
operator|=
literal|0
expr_stmt|;
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
comment|/* this must be cleared for ifa_ifwithaddr() */
name|sin6
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
block|}
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Setup a vrf_id to be the default for the non-bind-all case. */
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
comment|/* increase our count due to the unlock we do */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lport
condition|)
block|{
comment|/* 		 * Did the caller specify a port? if so we must see if a ep 		 * already has this one bound. 		 */
comment|/* got to be root to get at low ports */
if|if
condition|(
name|ntohs
argument_list|(
name|lport
argument_list|)
operator|<
name|IPPORT_RESERVED
condition|)
block|{
if|if
condition|(
name|p
operator|&&
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|p
argument_list|,
name|PRIV_NETINET_RESERVEDPORT
argument_list|)
operator|)
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindall
condition|)
block|{
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|inp_tmp
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_tmp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * lock guy returned and lower count note 				 * that we are not bound so inp_tmp should 				 * NEVER be inp. And it is this inp 				 * (inp_tmp) that gets the reference bump, 				 * so we must lower it. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp_tmp
argument_list|)
expr_stmt|;
comment|/* unlock info */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp_tmp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * Ok, must be one-2-one and 					 * allowing port re-use 					 */
name|port_reuse_active
operator|=
literal|1
expr_stmt|;
goto|goto
name|continue_anyway
goto|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
block|}
else|else
block|{
name|inp_tmp
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_tmp
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * lock guy returned and lower count note 				 * that we are not bound so inp_tmp should 				 * NEVER be inp. And it is this inp 				 * (inp_tmp) that gets the reference bump, 				 * so we must lower it. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp_tmp
argument_list|)
expr_stmt|;
comment|/* unlock info */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp_tmp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * Ok, must be one-2-one and 					 * allowing port re-use 					 */
name|port_reuse_active
operator|=
literal|1
expr_stmt|;
goto|goto
name|continue_anyway
goto|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
block|}
name|continue_anyway
label|:
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bindall
condition|)
block|{
comment|/* verify that no lport is not used by a singleton */
if|if
condition|(
operator|(
name|port_reuse_active
operator|==
literal|0
operator|)
operator|&&
operator|(
name|inp_tmp
operator|=
name|sctp_isport_inuse
argument_list|(
name|inp
argument_list|,
name|lport
argument_list|,
name|vrf_id
argument_list|)
operator|)
condition|)
block|{
comment|/* Sorry someone already has this one bound */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp_tmp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
condition|)
block|{
name|port_reuse_active
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
block|}
block|}
block|}
else|else
block|{
name|uint16_t
name|first
decl_stmt|,
name|last
decl_stmt|,
name|candidate
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
name|int
name|done
decl_stmt|;
if|if
condition|(
name|ip_inp
operator|->
name|inp_flags
operator|&
name|INP_HIGHPORT
condition|)
block|{
name|first
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ipport_hifirstauto
argument_list|)
expr_stmt|;
name|last
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ipport_hilastauto
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip_inp
operator|->
name|inp_flags
operator|&
name|INP_LOWPORT
condition|)
block|{
if|if
condition|(
name|p
operator|&&
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|p
argument_list|,
name|PRIV_NETINET_RESERVEDPORT
argument_list|)
operator|)
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|first
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ipport_lowfirstauto
argument_list|)
expr_stmt|;
name|last
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ipport_lowlastauto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|first
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ipport_firstauto
argument_list|)
expr_stmt|;
name|last
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ipport_lastauto
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|>
name|last
condition|)
block|{
name|uint16_t
name|temp
decl_stmt|;
name|temp
operator|=
name|first
expr_stmt|;
name|first
operator|=
name|last
expr_stmt|;
name|last
operator|=
name|temp
expr_stmt|;
block|}
name|count
operator|=
name|last
operator|-
name|first
operator|+
literal|1
expr_stmt|;
comment|/* number of candidates */
name|candidate
operator|=
name|first
operator|+
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
operator|%
operator|(
name|count
operator|)
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
name|sctp_isport_inuse
argument_list|(
name|inp
argument_list|,
name|htons
argument_list|(
name|candidate
argument_list|)
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|done
condition|)
block|{
if|if
condition|(
operator|--
name|count
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
if|if
condition|(
name|candidate
operator|==
name|last
condition|)
name|candidate
operator|=
name|first
expr_stmt|;
else|else
name|candidate
operator|=
name|candidate
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|lport
operator|=
name|htons
argument_list|(
name|candidate
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
operator|(
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
comment|/* 		 * this really should not happen. The guy did a non-blocking 		 * bind and then did a close at the same time. 		 */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* ok we look clear to give out this port, so lets setup the binding */
if|if
condition|(
name|bindall
condition|)
block|{
comment|/* binding to all addresses, so just set in the proper flags */
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_BOUNDALL
expr_stmt|;
comment|/* set the automatic addr changes from kernel flag */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auto_asconf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
expr_stmt|;
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_multiple_asconfs
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_MULTIPLE_ASCONFS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_MULTIPLE_ASCONFS
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * set the automatic mobility_base from kernel flag (by 		 * micchie) 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_mobility_base
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
expr_stmt|;
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_mobility_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
expr_stmt|;
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * set the automatic mobility_fasthandoff from kernel flag 		 * (by micchie) 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_mobility_fasthandoff
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
expr_stmt|;
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_mobility_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
expr_stmt|;
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * bind specific, make sure flags is off and add a new 		 * address structure to the sctp_addr_list inside the ep 		 * structure. 		 *  		 * We will need to allocate one and insert it at the head. The 		 * socketopt call can just insert new addresses in there as 		 * well. It will also have to do the embed scope kame hack 		 * too (before adding). 		 */
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_storage
name|store_sa
decl_stmt|;
name|memset
argument_list|(
operator|&
name|store_sa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store_sa
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store_sa
expr_stmt|;
name|memcpy
argument_list|(
name|sin
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store_sa
expr_stmt|;
name|memcpy
argument_list|(
name|sin6
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
break|break;
block|}
default|default:
break|break;
block|}
comment|/* 		 * first find the interface with the bound address need to 		 * zero out the port to find the address! yuck! can't do 		 * this earlier since need port for sctp_pcb_findep() 		 */
if|if
condition|(
name|sctp_ifap
operator|!=
name|NULL
condition|)
name|ifa
operator|=
name|sctp_ifap
expr_stmt|;
else|else
block|{
comment|/* 			 * Note for BSD we hit here always other O/S's will 			 * pass things in via the sctp_ifap argument 			 * (Panda). 			 */
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|store_sa
argument_list|,
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* Can't find an interface with that address */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EADDRNOTAVAIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* GAK, more FIXME IFA lock? */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
comment|/* Can't bind a non-existent addr. */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* we're not bound all */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_BOUNDALL
expr_stmt|;
comment|/* allow bindx() to send ASCONF's for binding changes */
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
expr_stmt|;
comment|/* clear automatic addr changes from kernel flag */
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
comment|/* add this address to the endpoint list */
name|error
operator|=
name|sctp_insert_laddr
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|,
name|ifa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|inp
operator|->
name|laddr_count
operator|++
expr_stmt|;
block|}
comment|/* find the bucket */
if|if
condition|(
name|port_reuse_active
condition|)
block|{
comment|/* Put it into tcp 1-2-1 hash */
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_IN_TCPPOOL
expr_stmt|;
block|}
else|else
block|{
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|lport
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
block|}
comment|/* put it in the bucket */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Main hash to bind at head:%p, bound port:%d - in tcp_pool=%d\n"
argument_list|,
name|head
argument_list|,
name|ntohs
argument_list|(
name|lport
argument_list|)
argument_list|,
name|port_reuse_active
argument_list|)
expr_stmt|;
comment|/* set in the port */
name|inp
operator|->
name|sctp_lport
operator|=
name|lport
expr_stmt|;
comment|/* turn off just the unbound flag */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_UNBOUND
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_iterator_inp_being_freed
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
decl_stmt|,
modifier|*
name|nit
decl_stmt|;
comment|/* 	 * We enter with the only the ITERATOR_LOCK in place and a write 	 * lock on the inp_info stuff. 	 */
name|it
operator|=
name|sctp_it_ctl
operator|.
name|cur_it
expr_stmt|;
if|if
condition|(
name|it
operator|&&
operator|(
name|it
operator|->
name|vn
operator|!=
name|curvnet
operator|)
condition|)
block|{
comment|/* Its not looking at our VNET */
return|return;
block|}
if|if
condition|(
name|it
operator|&&
operator|(
name|it
operator|->
name|inp
operator|==
name|inp
operator|)
condition|)
block|{
comment|/* 		 * This is tricky and we hold the iterator lock, but when it 		 * returns and gets the lock (when we release it) the 		 * iterator will try to operate on inp. We need to stop that 		 * from happening. But of course the iterator has a 		 * reference on the stcb and inp. We can mark it and it will 		 * stop. 		 *  		 * If its a single iterator situation, we set the end iterator 		 * flag. Otherwise we set the iterator to go to the next 		 * inp. 		 *  		 */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator||=
name|SCTP_ITERATOR_STOP_CUR_IT
expr_stmt|;
block|}
else|else
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator||=
name|SCTP_ITERATOR_STOP_CUR_INP
expr_stmt|;
block|}
block|}
comment|/* 	 * Now go through and remove any single reference to our inp that 	 * may be still pending on the list 	 */
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|it
argument_list|,
argument|&sctp_it_ctl.iteratorhead
argument_list|,
argument|sctp_nxt_itr
argument_list|,
argument|nit
argument_list|)
block|{
if|if
condition|(
name|it
operator|->
name|vn
operator|!=
name|curvnet
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|inp
condition|)
block|{
comment|/* This one points to me is it inp specific? */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
comment|/* Remove and free this one */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sctp_it_ctl
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|function_atend
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|it
operator|->
name|function_atend
call|)
argument_list|(
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|it
argument_list|,
name|SCTP_M_ITER
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * When its put in the refcnt is incremented so decr 			 * it 			 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* release sctp_inpcb unbind the port */
end_comment

begin_function
name|void
name|sctp_inpcb_free
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|int
name|immediate
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|/* 	 * Here we free a endpoint. We must find it (if it is in the Hash 	 * table) and remove it from there. Then we must also find it in the 	 * overall list and remove it from there. After all removals are 	 * complete then any timer has to be stopped. Then start the actual 	 * freeing. a) Any local lists. b) Any associations. c) The hash of 	 * all associations. d) finally the ep itself. 	 */
name|struct
name|sctp_pcb
modifier|*
name|m
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|asoc
decl_stmt|,
modifier|*
name|nasoc
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|nladdr
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|ip_pcb
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|being_refed
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|sq
decl_stmt|,
modifier|*
name|nsq
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|shared_key
decl_stmt|,
modifier|*
name|nshared_key
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
comment|/* mark any iterators on the list or being processed */
name|sctp_iterator_inp_being_freed
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
comment|/* been here before.. eeks.. get out of here */
name|SCTP_PRINTF
argument_list|(
literal|"This conflict in free SHOULD not be happening! from %d, imm %d\n"
argument_list|,
name|from
argument_list|,
name|immediate
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|SCTP_CALLED_AFTER_CMPSET_OFCLOSE
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_CLOSE_IP
expr_stmt|;
comment|/* socket is gone, so no more wakeups allowed */
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_DONT_WAKE
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAKEINPUT
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAKEOUTPUT
expr_stmt|;
block|}
comment|/* First time through we have the socket lock, after that no more. */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_NEWCOOKIE
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|inp
operator|->
name|control
argument_list|)
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|pkt
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|inp
operator|->
name|pkt
argument_list|)
expr_stmt|;
name|inp
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
block|}
name|m
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
expr_stmt|;
name|ip_pcb
operator|=
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
comment|/* we could just cast the main pointer 					 * here but I will be nice :> (i.e. 					 * ip_pcb = ep;) */
if|if
condition|(
name|immediate
operator|==
name|SCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE
condition|)
block|{
name|int
name|cnt_in_sd
decl_stmt|;
name|cnt_in_sd
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|asoc
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|,
argument|nasoc
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* Skip guys being freed */
name|cnt_in_sd
operator|++
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_IN_ACCEPT_QUEUE
condition|)
block|{
comment|/* 					 * Special case - we did not start a 					 * kill timer on the asoc due to it 					 * was not closed. So go ahead and 					 * start it now. 					 */
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&=
operator|~
name|SCTP_STATE_IN_ACCEPT_QUEUE
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|asoc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * If we have data in queue, we don't want 				 * to just free since the app may have done, 				 * send()/close or connect/send/close. And 				 * it wants the data to get across first. 				 */
comment|/* Just abandon things in the front states */
if|if
condition|(
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_NOFORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cnt_in_sd
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* Disconnect the socket please */
name|asoc
operator|->
name|sctp_socket
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_CLOSED_SOCKET
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|size_on_reasm_queue
operator|>
literal|0
operator|)
operator|||
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|control_pdapi
operator|)
operator|||
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|size_on_all_streams
operator|>
literal|0
operator|)
operator|||
operator|(
name|so
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* Left with Data unread */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* Fill in the user initiated abort */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_3
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"inpcb_free does an abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_send_abort_tcb
argument_list|(
name|asoc
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_NOFORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cnt_in_sd
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|asoc
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
comment|/* 					 * there is nothing queued to send, 					 * so I send shutdown 					 */
name|sctp_send_shutdown
argument_list|(
name|asoc
argument_list|,
name|netp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|asoc
operator|->
name|sctp_ep
argument_list|,
name|asoc
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|asoc
operator|->
name|sctp_ep
argument_list|,
name|asoc
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_OUTPUT_FROM_SHUT_TMR
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* mark into shutdown pending */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|asoc
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|asoc
operator|->
name|sctp_ep
argument_list|,
name|asoc
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
condition|)
block|{
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Error, sp is NULL, locked on sending is %p strm:%d\n"
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
argument_list|,
name|asoc
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|->
name|stream_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_anyway
label|:
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_5
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"inpcb_free does an abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_send_abort_tcb
argument_list|(
name|asoc
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_NOFORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cnt_in_sd
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_OUTPUT_FROM_CLOSING
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|cnt_in_sd
operator|++
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
block|}
comment|/* now is there some left in our SHUTDOWN state? */
if|if
condition|(
name|cnt_in_sd
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|inp
operator|->
name|sctp_socket
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|inp
operator|->
name|sctp_socket
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|!=
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* 		 * ok, this guy has been bound. It's port is somewhere in 		 * the SCTP_BASE_INFO(hash table). Remove it! 		 */
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|sctp_hash
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_UNBOUND
expr_stmt|;
block|}
comment|/* 	 * If there is a timer running to kill us, forget it, since it may 	 * have a contest on the INP lock.. which would cause us to die ... 	 */
name|cnt
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|asoc
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|,
argument|nasoc
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_IN_ACCEPT_QUEUE
condition|)
block|{
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&=
operator|~
name|SCTP_STATE_IN_ACCEPT_QUEUE
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|asoc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|++
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Free associations that are NOT killing us */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* Fill in the user initiated abort */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_7
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"inpcb_free does an abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_send_abort_tcb
argument_list|(
name|asoc
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|asoc
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|asoc
argument_list|,
name|SCTP_PCBFREE_FORCE
argument_list|,
name|SCTP_FROM_SCTP_PCB
operator|+
name|SCTP_LOC_8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
condition|)
block|{
comment|/* Ok we have someone out there that will kill us */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SCTP_INP_LOCK_CONTENDED
argument_list|(
name|inp
argument_list|)
condition|)
name|being_refed
operator|++
expr_stmt|;
if|if
condition|(
name|SCTP_INP_READ_CONTENDED
argument_list|(
name|inp
argument_list|)
condition|)
name|being_refed
operator|++
expr_stmt|;
if|if
condition|(
name|SCTP_ASOC_CREATE_LOCK_CONTENDED
argument_list|(
name|inp
argument_list|)
condition|)
name|being_refed
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|refcount
operator|)
operator|||
operator|(
name|being_refed
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|4
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INPKILL
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|type
operator|=
literal|0
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
expr_stmt|;
comment|/* 	 * Remove it from the list .. last thing we need a lock for. 	 */
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Now we release all locks. Since this INP cannot be found anymore 	 * except possibly by the kill timer that might be running. We call 	 * the drain function here. It should hit the case were it sees the 	 * ACTIVE flag cleared and exit out freeing us to proceed and 	 * destroy everything. 	 */
if|if
condition|(
name|from
operator|!=
name|SCTP_CALLED_FROM_INPKILL_TIMER
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP_DRAIN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Probably un-needed */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|5
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_asocidhash
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SCTP_HASH_FREE
argument_list|(
name|inp
operator|->
name|sctp_asocidhash
argument_list|,
name|inp
operator|->
name|hashasocidmark
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_asocidhash
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sq
argument_list|,
argument|&inp->read_queue
argument_list|,
argument|next
argument_list|,
argument|nsq
argument_list|)
block|{
comment|/* Its only abandoned if it had data left */
if|if
condition|(
name|sq
operator|->
name|length
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_left_abandon
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|sq
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|sq
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
condition|)
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|-=
name|sq
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sq
operator|->
name|data
argument_list|)
expr_stmt|;
name|sq
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * no need to free the net count, since at this point all 		 * assoc's are gone. 		 */
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
block|}
comment|/* Now the sctp_pcb things */
comment|/* 	 * free each asoc if it is not already closed/free. we can't use the 	 * macro here since le_next will get freed as part of the 	 * sctp_free_assoc() call. 	 */
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
ifdef|#
directive|ifdef
name|IPSEC
name|ipsec_delete_pcbpolicy
argument_list|(
name|ip_pcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC */
comment|/* Unlocks not needed since the socket is gone now */
block|}
if|if
condition|(
name|ip_pcb
operator|->
name|inp_options
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_m_free
argument_list|(
name|ip_pcb
operator|->
name|inp_options
argument_list|)
expr_stmt|;
name|ip_pcb
operator|->
name|inp_options
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ip_pcb
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
block|{
name|struct
name|in6pcb
modifier|*
name|in6p
decl_stmt|;
name|in6p
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
name|ip6_freepcbopts
argument_list|(
name|in6p
operator|->
name|in6p_outputopts
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|ip_pcb
operator|->
name|inp_vflag
operator|=
literal|0
expr_stmt|;
comment|/* free up authentication fields */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
operator|!=
name|NULL
condition|)
name|sctp_free_chunklist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
name|sctp_free_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|shared_key
argument_list|,
argument|&inp->sctp_ep.shared_keys
argument_list|,
argument|next
argument_list|,
argument|nshared_key
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|shared_key
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|shared_key
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* 	 * if we have an address list the following will free the list of 	 * ifaddr's that are set into this ep. Again macro limitations here, 	 * since the LIST_FOREACH could be a bad idea. 	 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nladdr
argument_list|)
block|{
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_TRACK_FREED_ASOCS
comment|/* TEMP CODE */
name|LIST_FOREACH_SAFE
argument_list|(
argument|asoc
argument_list|,
argument|&inp->sctp_asoc_free_list
argument_list|,
argument|sctp_tcblist
argument_list|,
argument|nasoc
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|asoc
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
block|}
comment|/* *** END TEMP CODE *** */
endif|#
directive|endif
comment|/* Now lets see about freeing the EP hash table. */
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
operator|!=
name|NULL
condition|)
block|{
name|SCTP_HASH_FREE
argument_list|(
name|inp
operator|->
name|sctp_tcbhash
argument_list|,
name|inp
operator|->
name|sctp_hashmark
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_tcbhash
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now we must put the ep memory back into the zone pool */
name|INP_LOCK_DESTROY
argument_list|(
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_LOCK_DESTROY
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_DESTROY
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK_DESTROY
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
name|inp
argument_list|)
expr_stmt|;
name|SCTP_DECR_EP_COUNT
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|sctp_nets
modifier|*
name|sctp_findnet
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* locate the address */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
condition|)
return|return
operator|(
name|net
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_is_address_on_local_host
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|sctp_ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|addr
argument_list|,
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifa
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * add's a remote endpoint address, done with the INIT/INIT-ACK as well as  * when a ASCONF arrives that adds it. It will also initialize all the cwnd  * stats of stuff.  */
end_comment

begin_function
name|int
name|sctp_add_remote_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|newaddr
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
name|set_scope
parameter_list|,
name|int
name|from
parameter_list|)
block|{
comment|/* 	 * The following is redundant to the same lines in the 	 * sctp_aloc_assoc() but is needed since others call the add address 	 * function 	 */
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|netfirst
decl_stmt|;
name|int
name|addr_inscope
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Adding an address (from:%d) to the peer: "
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
name|netfirst
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|newaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|netfirst
condition|)
block|{
comment|/* 		 * Lie and return ok, we don't want to make the association 		 * go away for this behavior. It will happen in the TCP 		 * model in a connected socket. It does not reach the hash 		 * table until after the association is built so it can't be 		 * found. Mark as reachable, since the initial creation will 		 * have been cleared and the NOT_IN_ASSOC flag will have 		 * been added... and we don't want to end up removing it 		 * back out. 		 */
if|if
condition|(
name|netfirst
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|netfirst
operator|->
name|dest_state
operator|=
operator|(
name|SCTP_ADDR_REACHABLE
operator||
name|SCTP_ADDR_UNCONFIRMED
operator|)
expr_stmt|;
block|}
else|else
block|{
name|netfirst
operator|->
name|dest_state
operator|=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|addr_inscope
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|newaddr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|newaddr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* Invalid address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* zero out the bzero area */
name|memset
argument_list|(
operator|&
name|sin
operator|->
name|sin_zero
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_zero
argument_list|)
argument_list|)
expr_stmt|;
comment|/* assure len is set */
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_scope
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DONT_DO_PRIVADDR_SCOPE
name|stcb
operator|->
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DONT_DO_PRIVADDR_SCOPE */
block|}
else|else
block|{
comment|/* Validate the address is in scope */
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|newaddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Invalid address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* assure len is set */
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|set_scope
condition|)
block|{
if|if
condition|(
name|sctp_is_address_on_local_host
argument_list|(
name|newaddr
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * If the new destination is a 					 * LINK_LOCAL we must have common 					 * site scope. Don't set the local 					 * scope since we may not share all 					 * links, only loopback can do this. 					 * Links on the local network would 					 * also be on our private network 					 * for v4 too. 					 */
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * If the new destination is 					 * SITE_LOCAL then we must have site 					 * scope in common. 					 */
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Validate the address is in scope */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|addr_inscope
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* not supported family type */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|net
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_net
argument_list|)
argument_list|,
expr|struct
name|sctp_nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_INCR_RADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|net
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nets
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|newaddr
argument_list|,
name|newaddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|newaddr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|net
operator|->
name|addr_is_local
operator|=
name|sctp_is_address_on_local_host
argument_list|(
name|newaddr
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|addr_is_local
operator|&&
operator|(
operator|(
name|set_scope
operator|||
operator|(
name|from
operator|==
name|SCTP_ADDR_IS_CONFIRMED
operator|)
operator|)
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|addr_inscope
operator|=
literal|1
expr_stmt|;
block|}
name|net
operator|->
name|failure_threshold
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
expr_stmt|;
name|net
operator|->
name|pf_threshold
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_pf_threshold
expr_stmt|;
if|if
condition|(
name|addr_inscope
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|dest_state
operator|=
operator|(
name|SCTP_ADDR_REACHABLE
operator||
name|SCTP_ADDR_OUT_OF_SCOPE
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|from
operator|==
name|SCTP_ADDR_IS_CONFIRMED
condition|)
comment|/* SCTP_ADDR_IS_CONFIRMED is passed by connect_x */
name|net
operator|->
name|dest_state
operator|=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
else|else
name|net
operator|->
name|dest_state
operator|=
name|SCTP_ADDR_REACHABLE
operator||
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
comment|/* 	 * We set this to 0, the timer code knows that this means its an 	 * initial value 	 */
name|net
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|RTO
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|RTO_measured
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|++
expr_stmt|;
operator|*
operator|(
operator|&
name|net
operator|->
name|ref_count
operator|)
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|cwr_window_tsn
operator|=
name|net
operator|->
name|last_cwr_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_for_client_enable
argument_list|)
condition|)
block|{
name|net
operator|->
name|port
operator|=
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|port
operator|=
literal|0
expr_stmt|;
block|}
name|net
operator|->
name|dscp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_dscp
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|net
operator|->
name|flowlabel
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
name|net
operator|->
name|heart_beat_delay
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
expr_stmt|;
comment|/* Init the timer structure */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|net
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* Now generate a route for this guy */
ifdef|#
directive|ifdef
name|INET6
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_RTALLOC
argument_list|(
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_ROUTE_HAS_VALID_IFN
argument_list|(
operator|&
name|net
operator|->
name|ro
argument_list|)
condition|)
block|{
comment|/* Get source address */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
comment|/* Now get the interface MTU */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|ifn_p
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|SCTP_GATHER_MTU_FROM_INTFC
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|ifn_p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|mtu
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|mtu
operator|==
literal|0
condition|)
block|{
comment|/* Huh ?? */
name|net
operator|->
name|mtu
operator|=
name|SCTP_DEFAULT_MTU
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|rmtu
decl_stmt|;
name|rmtu
operator|=
name|SCTP_GATHER_MTU_FROM_ROUTE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|,
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmtu
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Start things off to match mtu of 				 * interface please. 				 */
name|SCTP_SET_MTU_OF_ROUTE
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|,
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * we take the route mtu over the interface, 				 * since the route may be leading out the 				 * loopback, or a different interface. 				 */
name|net
operator|->
name|mtu
operator|=
name|rmtu
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from
operator|==
name|SCTP_ALLOC_ASOC
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|->
name|mtu
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|newaddr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|->
name|port
condition|)
block|{
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
comment|/* JRS - Use the congestion control given in the CC module */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 	 * CMT: CUC algo - set find_pseudo_cumack to TRUE (1) at beginning 	 * of assoc (2005/06/27, iyengar@cis.udel.edu) 	 */
name|net
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
comment|/* Choose an initial flowid. */
name|net
operator|->
name|flowid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|^
name|ntohs
argument_list|(
name|stcb
operator|->
name|rport
argument_list|)
operator|^
name|ntohs
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|net
operator|->
name|flowidset
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|netfirst
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* Since we have no route put it at the back */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netfirst
operator|==
name|NULL
condition|)
block|{
comment|/* We are the first one in the pool. */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|netfirst
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * First one has NO route. Place this one ahead of the first 		 * one. 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|!=
name|netfirst
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
condition|)
block|{
comment|/* 		 * This one has a different interface than the one at the 		 * top of the list. Place it ahead. 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Ok we have the same interface as the first one. Move 		 * forward until we find either a) one with a NULL route... 		 * insert ahead of that b) one with a different ifp.. insert 		 * after that. c) end of the list.. insert at the tail. 		 */
name|struct
name|sctp_nets
modifier|*
name|netlook
decl_stmt|;
do|do
block|{
name|netlook
operator|=
name|TAILQ_NEXT
argument_list|(
name|netfirst
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|netlook
operator|==
name|NULL
condition|)
block|{
comment|/* End of the list */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|netlook
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* next one has NO route */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|netfirst
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|netlook
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|!=
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
condition|)
block|{
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|netlook
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Shift forward */
name|netfirst
operator|=
name|netlook
expr_stmt|;
block|}
do|while
condition|(
name|netlook
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* got to have a primary set */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|)
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* No route to current primary adopt new primary */
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
block|}
comment|/* Validate primary is first */
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
condition|)
block|{
comment|/* 		 * first one on the list is NOT the primary sctp_cmpaddr() 		 * is much more efficient if the primary is the first on the 		 * list, make it so. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netp
condition|)
block|{
operator|*
name|netp
operator|=
name|net
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|sctp_aloc_a_assoc_id
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|uint32_t
name|id
decl_stmt|;
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|lstcb
decl_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|try_again
label|:
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
comment|/* TSNH */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * We don't allow assoc id to be one of SCTP_FUTURE_ASSOC, 	 * SCTP_CURRENT_ASSOC and SCTP_ALL_ASSOC. 	 */
if|if
condition|(
name|inp
operator|->
name|sctp_associd_counter
operator|<=
name|SCTP_ALL_ASSOC
condition|)
block|{
name|inp
operator|->
name|sctp_associd_counter
operator|=
name|SCTP_ALL_ASSOC
operator|+
literal|1
expr_stmt|;
block|}
name|id
operator|=
name|inp
operator|->
name|sctp_associd_counter
expr_stmt|;
name|inp
operator|->
name|sctp_associd_counter
operator|++
expr_stmt|;
name|lstcb
operator|=
name|sctp_findasoc_ep_asocid_locked
argument_list|(
name|inp
argument_list|,
operator|(
name|sctp_assoc_t
operator|)
name|id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lstcb
condition|)
block|{
goto|goto
name|try_again
goto|;
block|}
name|head
operator|=
operator|&
name|inp
operator|->
name|sctp_asocidhash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|id
argument_list|,
name|inp
operator|->
name|hashasocidmark
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|in_asocid_hash
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|id
return|;
block|}
end_function

begin_comment
comment|/*  * allocate an association and add it to the endpoint. The caller must be  * careful to add all additional addresses once they are know right away or  * else the assoc will be may experience a blackout scenario.  */
end_comment

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_aloc_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|firstaddr
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|uint32_t
name|override_tag
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
comment|/* note the p argument is only valid in unbound sockets */
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|uint16_t
name|rport
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Assumption made here: Caller has done a 	 * sctp_findassociation_ep_addr(ep, addr's); to make sure the 	 * address does not exist already. 	 */
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_asoc
argument_list|)
operator|>=
name|SCTP_MAX_NUM_OF_ASOC
condition|)
block|{
comment|/* Hit max assoc, sorry no more */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|firstaddr
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|&&
operator|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|)
condition|)
block|{
comment|/* 		 * If its in the TCP pool, its NOT allowed to create an 		 * association. The parent listener needs to call 		 * sctp_aloc_assoc.. or the one-2-many socket. If a peeled 		 * off, or connected one does this.. its an error. 		 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB3
argument_list|,
literal|"Allocate an association for peer:"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|firstaddr
condition|)
block|{
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_PCB3
argument_list|,
name|firstaddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|firstaddr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB3
argument_list|,
literal|"Port:%d\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|firstaddr
operator|)
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB3
argument_list|,
literal|"Port:%d\n"
argument_list|,
name|ntohs
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|firstaddr
operator|)
operator|->
name|sin6_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
else|else
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB3
argument_list|,
literal|"None\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
switch|switch
condition|(
name|firstaddr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|firstaddr
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|->
name|sin_port
operator|==
literal|0
operator|)
operator|||
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Invalid address */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|firstaddr
expr_stmt|;
if|if
condition|(
operator|(
name|sin6
operator|->
name|sin6_port
operator|==
literal|0
operator|)
operator|||
operator|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* Invalid address */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rport
operator|=
name|sin6
operator|->
name|sin6_port
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* not supported family type */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* 		 * If you have not performed a bind, then we need to do the 		 * ephemeral bind for you. 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|sctp_inpcb_bind
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_ifa
operator|*
operator|)
name|NULL
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
comment|/* bind error, probably perm */
operator|*
name|error
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|stcb
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
expr|struct
name|sctp_tcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INCR_ASOC_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|stcb
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stcb
argument_list|)
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|asoc
operator|->
name|assoc_id
operator|=
name|sctp_aloc_a_assoc_id
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK_INIT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_INIT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|rport
operator|=
name|rport
expr_stmt|;
comment|/* setup back pointer's */
name|stcb
operator|->
name|sctp_ep
operator|=
name|inp
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sctp_init_asoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|override_tag
argument_list|,
name|vrf_id
argument_list|)
operator|)
condition|)
block|{
comment|/* failed */
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
operator|*
name|error
operator|=
name|err
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* and the port */
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
operator|(
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
comment|/* inpcb freed while alloc going on */
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* now that my_vtag is set, add it to the hash */
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* put it in the bucket in the vtag hash of assoc's for the system */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|firstaddr
argument_list|,
name|NULL
argument_list|,
name|SCTP_DO_SETSCOPE
argument_list|,
name|SCTP_ALLOC_ASOC
argument_list|)
operator|)
condition|)
block|{
comment|/* failure.. memory error? */
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|mapping_array
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Init all the timers */
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|delete_prim_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|,
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
comment|/* now file the port under the hash as well */
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
operator|&
name|inp
operator|->
name|sctp_tcbhash
index|[
name|SCTP_PCBHASH_ALLADDR
argument_list|(
name|stcb
operator|->
name|rport
argument_list|,
name|inp
operator|->
name|sctp_hashmark
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_tcbhash
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Association %p now allocated\n"
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_remove_net
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|asoc
operator|->
name|numnets
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|asoc
operator|->
name|primary_destination
condition|)
block|{
comment|/* Reset primary */
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|lnet
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
comment|/* 		 * Mobility adaptation Ideally, if deleted destination is 		 * the primary, it becomes a fast retransmission trigger by 		 * the subsequent SET PRIMARY. (by micchie) 		 */
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
operator|||
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"remove_net: primary dst is deleting\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|deleted_primary
operator|!=
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"remove_net: deleted primary may be already stored\n"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|asoc
operator|->
name|deleted_primary
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|net
operator|->
name|lastsa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|net
operator|->
name|lastsa
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|net
operator|->
name|lastsv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|net
operator|->
name|lastsv
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PRIM_DELETED
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* Try to find a confirmed primary */
name|asoc
operator|->
name|primary_destination
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|asoc
operator|->
name|last_data_chunk_from
condition|)
block|{
comment|/* Reset primary */
name|asoc
operator|->
name|last_data_chunk_from
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|asoc
operator|->
name|last_control_chunk_from
condition|)
block|{
comment|/* Clear net */
name|asoc
operator|->
name|last_control_chunk_from
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|net
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove a remote endpoint address from an association, it will fail if the  * address does not exist.  */
end_comment

begin_function
name|int
name|sctp_del_remote_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|remaddr
parameter_list|)
block|{
comment|/* 	 * Here we need to remove a remote address. This is quite simple, we 	 * first find it in the list of address for the association 	 * (tasoc->asoc.nets) and then if it is there, we do a LIST_REMOVE 	 * on that item. Note we do not allow it to be removed if there are 	 * no other addresses. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|nnet
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* locate the address */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|,
argument|nnet
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|remaddr
operator|->
name|sa_family
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|remaddr
argument_list|)
condition|)
block|{
comment|/* we found the guy */
if|if
condition|(
name|asoc
operator|->
name|numnets
operator|<
literal|2
condition|)
block|{
comment|/* Must have at LEAST two remote addresses */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|sctp_remove_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* not found. */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_delete_from_timewait
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint16_t
name|rport
parameter_list|)
block|{
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|chain
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vtag_timewait
argument_list|)
index|[
operator|(
name|tag
operator|%
name|SCTP_STACK_VTAG_HASH_SIZE
operator|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_IN_VTAG_BLOCK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
name|tag
operator|)
operator|&&
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|==
name|lport
operator|)
operator|&&
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|==
name|rport
operator|)
condition|)
block|{
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_is_in_timewait
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint16_t
name|rport
parameter_list|)
block|{
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|chain
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vtag_timewait
argument_list|)
index|[
operator|(
name|tag
operator|%
name|SCTP_STACK_VTAG_HASH_SIZE
operator|)
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_IN_VTAG_BLOCK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
name|tag
operator|)
operator|&&
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|==
name|lport
operator|)
operator|&&
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|==
name|rport
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
break|break;
block|}
block|}
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_add_vtag_to_timewait
parameter_list|(
name|uint32_t
name|tag
parameter_list|,
name|uint32_t
name|time
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint16_t
name|rport
parameter_list|)
block|{
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|set
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|time
operator|==
literal|0
condition|)
block|{
comment|/* Its disabled */
return|return;
block|}
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|chain
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vtag_timewait
argument_list|)
index|[
operator|(
name|tag
operator|%
name|SCTP_STACK_VTAG_HASH_SIZE
operator|)
index|]
expr_stmt|;
name|set
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
comment|/* Block(s) present, lets find space, and expire on the fly */
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_IN_VTAG_BLOCK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
literal|0
operator|)
operator|&&
operator|!
name|set
condition|)
block|{
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|time
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
name|tag
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|=
name|lport
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|=
name|rport
expr_stmt|;
name|set
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|)
operator|&&
operator|(
operator|(
name|long
operator|)
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|<
name|now
operator|.
name|tv_sec
operator|)
condition|)
block|{
comment|/* Audit expires this guy */
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
condition|)
block|{
comment|/* Reuse it for my new tag */
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|time
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
name|tag
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|=
name|lport
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|=
name|rport
expr_stmt|;
name|set
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|set
condition|)
block|{
comment|/* 				 * We only do up to the block where we can 				 * place our tag for audits 				 */
break|break;
block|}
block|}
block|}
comment|/* Need to add a new block to chain */
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|SCTP_MALLOC
argument_list|(
name|twait_block
argument_list|,
expr|struct
name|sctp_tagblock
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tagblock
argument_list|)
argument_list|,
name|SCTP_M_TIMW
argument_list|)
expr_stmt|;
if|if
condition|(
name|twait_block
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Can not alloc tagblock"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|memset
argument_list|(
name|twait_block
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tagblock
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|chain
argument_list|,
name|twait_block
argument_list|,
name|sctp_nxt_tagblock
argument_list|)
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|tv_sec_at_expire
operator|=
name|now
operator|.
name|tv_sec
operator|+
name|time
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|v_tag
operator|=
name|tag
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|lport
operator|=
name|lport
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
literal|0
index|]
operator|.
name|rport
operator|=
name|rport
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * Free the association after un-hashing the remote port. This  * function ALWAYS returns holding NO LOCK on the stcb. It DOES  * expect that the input to this function IS a locked TCB.  * It will return 0, if it did NOT destroy the association (instead  * it unlocks it. It will return NON-zero if it either destroyed the  * association OR the association is already destroyed.  */
end_comment

begin_function
name|int
name|sctp_free_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|from_inpcbfree
parameter_list|,
name|int
name|from_location
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|nnet
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|naddr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aparam
decl_stmt|,
modifier|*
name|naparam
decl_stmt|;
name|struct
name|sctp_asconf_ack
modifier|*
name|aack
decl_stmt|,
modifier|*
name|naack
decl_stmt|;
name|struct
name|sctp_stream_reset_list
modifier|*
name|strrst
decl_stmt|,
modifier|*
name|nstrrst
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|sq
decl_stmt|,
modifier|*
name|nsq
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|shared_key
decl_stmt|,
modifier|*
name|nshared_key
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
comment|/* first, lets purge the entry from the hash table. */
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|6
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|7
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* there is no asoc, really TSNH :-0 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* TEMP CODE */
if|if
condition|(
name|stcb
operator|->
name|freed_from_where
operator|==
literal|0
condition|)
block|{
comment|/* Only record the first place free happened from */
name|stcb
operator|->
name|freed_from_where
operator|=
name|from_location
expr_stmt|;
block|}
comment|/* TEMP CODE */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
comment|/* nothing around */
name|so
operator|=
name|NULL
expr_stmt|;
else|else
name|so
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
comment|/* 	 * We used timer based freeing if a reader or writer is in the way. 	 * So we first check if we are actually being called from a timer, 	 * if so we abort early if a reader or writer is still in the way. 	 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|&&
operator|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
operator|)
condition|)
block|{
comment|/* 		 * is it the timer driving us? if so are the reader/writers 		 * gone? 		 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
condition|)
block|{
comment|/* nope, reader or writer in the way */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* no asoc destroyed */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|8
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* now clean up any other timers */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|dack_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/*- 	 * For stream reset we don't blast this unless 	 * it is a str-reset timer, it might be the 	 * free-asoc timer which we DON'T want to 	 * disturb. 	 */
if|if
condition|(
name|asoc
operator|->
name|strreset_timer
operator|.
name|type
operator|==
name|SCTP_TIMER_TYPE_STRRESET
condition|)
name|asoc
operator|->
name|strreset_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|asconf_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|autoclose_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
comment|/* Mobility adaptation */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delete_prim_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|delete_prim_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|net
operator|->
name|rxt_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|net
operator|->
name|pmtu_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|net
operator|->
name|hb_timer
operator|.
name|self
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now the read queue needs to be cleaned up (only once) */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_ABOUT_TO_BE_FREED
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sq
argument_list|,
argument|&inp->read_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|sq
operator|->
name|stcb
operator|==
name|stcb
condition|)
block|{
name|sq
operator|->
name|do_not_ref_stcb
operator|=
literal|1
expr_stmt|;
name|sq
operator|->
name|sinfo_cumtsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
comment|/* 				 * If there is no end, there never will be 				 * now. 				 */
if|if
condition|(
name|sq
operator|->
name|end_added
operator|==
literal|0
condition|)
block|{
comment|/* Held for PD-API clear that. */
name|sq
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|sq
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
operator|&&
operator|(
name|so
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 						 * Need to add a PD-API 						 * aborted indication. 						 * Setting the control_pdapi 						 * assures that it will be 						 * added right after this 						 * msg. 						 */
name|uint32_t
name|strseq
decl_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|sq
expr_stmt|;
name|strseq
operator|=
operator|(
name|sq
operator|->
name|sinfo_stream
operator|<<
literal|16
operator|)
operator||
name|sq
operator|->
name|sinfo_ssn
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
argument_list|,
name|stcb
argument_list|,
name|SCTP_PARTIAL_DELIVERY_ABORTED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|strseq
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Add an end to wake them */
name|sq
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|block_entry
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|->
name|error
operator|=
name|ECONNRESET
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_IN_ACCEPT_QUEUE
operator|)
condition|)
block|{
comment|/* 		 * Someone holds a reference OR the socket is unaccepted 		 * yet. 		 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&=
operator|~
name|SCTP_STATE_IN_ACCEPT_QUEUE
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
comment|/* nothing around */
name|so
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
comment|/* Wake any reader/writers */
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sctp_sowwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|9
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no asoc destroyed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
literal|10
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * When I reach here, no others want to kill the assoc yet.. and I 	 * own the lock. Now its possible an abort comes in when I do the 	 * lock exchange below to grab all the locks to do the final take 	 * out. to prevent this we increment the count, which will start a 	 * timer and blow out above thus assuring us that we hold exclusive 	 * killing of the asoc. Note that after getting back the TCB lock we 	 * will go ahead and increment the counter back up and stop any 	 * timer a passing stranger may have started :-S 	 */
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* Double check the GONE flag */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
comment|/* nothing around */
name|so
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* 		 * For TCP type we need special handling when we are 		 * connected. We also include the peel'ed off ones to. 		 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_WAS_CONNECTED
expr_stmt|;
if|if
condition|(
name|so
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator||
name|SS_ISCONNECTED
operator|)
expr_stmt|;
block|}
name|socantrcvmore_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|sctp_sowwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|SCTP_SOWAKEUP
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Make it invalid too, that way if its about to run it will abort 	 * and return. 	 */
comment|/* re-increment the lock */
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&=
operator|~
name|SCTP_STATE_IN_ACCEPT_QUEUE
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|asoc
operator|->
name|state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_tcbhash
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbhash
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|in_asocid_hash
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcbasocidhash
argument_list|)
expr_stmt|;
block|}
comment|/* Now lets remove it from the list of ALL associations in the EP */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* pull from vtag hash */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|sctp_add_vtag_to_timewait
argument_list|(
name|asoc
operator|->
name|my_vtag
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_vtag_time_wait
argument_list|)
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|)
expr_stmt|;
comment|/* 	 * Now restop the timers to be sure this is paranoia at is finest! 	 */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|shut_guard_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|strreset_timer
operator|.
name|type
operator|=
name|SCTP_TIMER_TYPE_NONE
expr_stmt|;
comment|/* 	 * The chunk lists and such SHOULD be empty but we check them just 	 * in case. 	 */
comment|/* anything on the wheel needs to be removed */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|outs
operator|=
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
expr_stmt|;
comment|/* now clean up any chunks here */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&outs->outqueue
argument_list|,
argument|next
argument_list|,
argument|nsp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
if|if
condition|(
name|so
condition|)
block|{
comment|/* Still an open socket - report */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_UNSENT
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sp
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_spbufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
comment|/* Free the zone stuff  */
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_strmoq
argument_list|)
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|SCTP_DECR_STRMOQ_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
block|}
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|strrst
argument_list|,
argument|&asoc->resetHead
argument_list|,
argument|next_resp
argument_list|,
argument|nstrrst
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|strrst
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|strrst
argument_list|,
name|SCTP_M_STRESET
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sq
argument_list|,
argument|&asoc->pending_reply_queue
argument_list|,
argument|next
argument_list|,
argument|nsq
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|sq
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sq
operator|->
name|data
argument_list|)
expr_stmt|;
name|sq
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|sq
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sq
operator|->
name|whoFrom
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|stcb
operator|=
name|NULL
expr_stmt|;
comment|/* Free the ctl entry */
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
name|sq
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->free_chunks
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|free_chunks
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_free_chunks
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|free_chunk_cnt
operator|--
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* pending send queue SHOULD be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
if|if
condition|(
name|so
condition|)
block|{
comment|/* Still a socket? */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_UNSENT
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* sent queue SHOULD be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
if|if
condition|(
name|so
condition|)
block|{
comment|/* Still a socket? */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_SENT
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* control queue MAY not be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* ASCONF queue MAY not be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->asconf_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->reasmqueue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|holds_key_ref
condition|)
name|sctp_auth_key_release
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|SCTP_DECR_CHK_COUNT
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
if|if
condition|(
name|asoc
operator|->
name|mapping_array
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* the stream outs */
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|strm_realoutsize
operator|=
name|asoc
operator|->
name|streamoutcnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmin
condition|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ctl
argument_list|,
argument|&asoc->strmin[i].inqueue
argument_list|,
argument|next
argument_list|,
argument|nctl
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|ctl
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|ctl
operator|->
name|data
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 				 * We don't free the address here since all 				 * the net's were freed above. 				 */
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
block|}
block|}
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmin
argument_list|,
name|SCTP_M_STRMI
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmin
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|streamincnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|,
argument|nnet
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_raddr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"no net's left alloc'ed, or list points to itself"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|net
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH_SAFE
argument_list|(
argument|laddr
argument_list|,
argument|&asoc->sctp_restricted_addrs
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|naddr
argument_list|)
block|{
comment|/* sa_ignore FREED_MEMORY */
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
comment|/* pending asconf (address) parameters */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|aparam
argument_list|,
argument|&asoc->asconf_queue
argument_list|,
argument|next
argument_list|,
argument|naparam
argument_list|)
block|{
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|,
name|aparam
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|aparam
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|aack
argument_list|,
argument|&asoc->asconf_ack_sent
argument_list|,
argument|next
argument_list|,
argument|naack
argument_list|)
block|{
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_ack_sent
argument_list|,
name|aack
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|aack
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|aack
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf_ack
argument_list|)
argument_list|,
name|aack
argument_list|)
expr_stmt|;
block|}
comment|/* clean up auth stuff */
if|if
condition|(
name|asoc
operator|->
name|local_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|asoc
operator|->
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|asoc
operator|->
name|peer_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|local_auth_chunks
condition|)
name|sctp_free_chunklist
argument_list|(
name|asoc
operator|->
name|local_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_auth_chunks
condition|)
name|sctp_free_chunklist
argument_list|(
name|asoc
operator|->
name|peer_auth_chunks
argument_list|)
expr_stmt|;
name|sctp_free_authinfo
argument_list|(
operator|&
name|asoc
operator|->
name|authinfo
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|shared_key
argument_list|,
argument|&asoc->shared_keys
argument_list|,
argument|next
argument_list|,
argument|nshared_key
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|shared_key
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|shared_key
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* Insert new items here :> */
comment|/* Get rid of LOCK */
name|SCTP_TCB_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_LOCK_DESTROY
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_TRACK_FREED_ASOCS
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* now clean up the tasoc itself */
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_free_list
argument_list|,
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_DECR_ASOC_COUNT
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* 			 * If its NOT the inp_free calling us AND sctp_close 			 * as been called, we call back... 			 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 			 * This will start the kill timer (if we are the 			 * last one) since we hold an increment yet. But 			 * this is the only safe way to do this since 			 * otherwise if the socket closes at the same time 			 * we are here we might collide in the cleanup. 			 */
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE
argument_list|,
name|SCTP_CALLED_DIRECTLY_NOCMPSET
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
else|else
block|{
comment|/* The socket is still open. */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|from_inpcbfree
operator|==
name|SCTP_NORMAL_PROC
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|out_of
label|:
comment|/* destroyed the asoc */
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|11
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * determine if a destination is "reachable" based upon the addresses bound  * to the current endpoint (e.g. only v4 or v6 currently bound)  */
end_comment

begin_comment
comment|/*  * FIX: if we allow assoc-level bindx(), then this needs to be fixed to use  * assoc level v4/v6 flags, as the assoc *may* not have the same address  * types bound as its endpoint  */
end_comment

begin_function
name|int
name|sctp_destination_is_reachable
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|destaddr
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|answer
decl_stmt|;
comment|/* 	 * No locks here, the TCB, in all cases is already locked and an 	 * assoc is up. There is either a INP lock by the caller applied (in 	 * asconf case when deleting an address) or NOT in the HB case, 	 * however if HB then the INP increment is up and the INP will not 	 * be removed (on top of the fact that we have a TCB lock). So we 	 * only want to read the sctp_flags, which is either bound-all or 	 * not.. no protection needed since once an assoc is up you can't be 	 * changing your binding. 	 */
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* if bound all, destination is not restricted */
comment|/* 		 * RRS: Question during lock work: Is this correct? If you 		 * are bound-all you still might need to obey the V4--V6 		 * flags??? IMO this bound-all stuff needs to be removed! 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* NOTE: all "scope" checks are done when local addresses are added */
switch|switch
condition|(
name|destaddr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET6
case|:
name|answer
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator|&
name|INP_IPV6
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
name|answer
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator|&
name|INP_IPV4
expr_stmt|;
break|break;
default|default:
comment|/* invalid family, so it's unreachable */
name|answer
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update the inp_vflags on an endpoint  */
end_comment

begin_function
specifier|static
name|void
name|sctp_update_ep_vflag
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* first clear the flag */
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator|=
literal|0
expr_stmt|;
comment|/* set the flag based on addresses on the ep list */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"%s: NULL ifa\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add the address to the endpoint local address list There is nothing to be  * done if we are bound to all addresses  */
end_comment

begin_function
name|void
name|sctp_add_local_addr_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint32_t
name|action
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* You are already bound to all. You have it already */
return|return;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
comment|/* Can't bind a non-useable addr. */
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* first, is it already present? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fnd
operator|==
literal|0
condition|)
block|{
comment|/* Not in the ep list */
name|error
operator|=
name|sctp_insert_laddr
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|,
name|ifa
argument_list|,
name|action
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return;
name|inp
operator|->
name|laddr_count
operator|++
expr_stmt|;
comment|/* update inp_vflag flags */
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET
case|:
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * select a new (hopefully reachable) destination net (should only be used  * when we deleted an ep addr that is the only usable source address to reach  * the destination net)  */
end_comment

begin_function
specifier|static
name|void
name|sctp_select_primary_destination
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* for now, we'll just pick the first reachable one we find */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
continue|continue;
if|if
condition|(
name|sctp_destination_is_reachable
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
condition|)
block|{
comment|/* found a reachable destination */
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
block|}
block|}
comment|/* I can't there from here! ...we're gonna die shortly... */
block|}
end_function

begin_comment
comment|/*  * Delete the address from the endpoint local address list There is nothing  * to be done if we are bound to all addresses  */
end_comment

begin_function
name|void
name|sctp_del_local_addr_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|fnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* You are already bound to all. You have it already */
return|return;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|fnd
operator|&&
operator|(
name|inp
operator|->
name|laddr_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* can't delete unless there are at LEAST 2 addresses */
return|return;
block|}
if|if
condition|(
name|fnd
condition|)
block|{
comment|/* 		 * clean up any use of this address go through our 		 * associations and clear any last_used_address that match 		 * this one for each assoc, see if a new primary_destination 		 * is needed 		 */
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
comment|/* clean up "next_addr_touse" */
if|if
condition|(
name|inp
operator|->
name|next_addr_touse
operator|==
name|laddr
condition|)
comment|/* delete this address */
name|inp
operator|->
name|next_addr_touse
operator|=
name|NULL
expr_stmt|;
comment|/* clean up "last_used_address" */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|laddr
condition|)
comment|/* delete this address */
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * Now spin through all the nets and purge any ref 			 * to laddr 			 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|ifa
operator|==
name|laddr
operator|->
name|ifa
operator|)
condition|)
block|{
comment|/* Yep, purge src address selected */
name|sctp_rtentry_t
modifier|*
name|rt
decl_stmt|;
comment|/* delete this address if cached */
name|rt
operator|=
name|net
operator|->
name|ro
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* for each tcb */
comment|/* remove it from the ep list */
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
name|inp
operator|->
name|laddr_count
operator|--
expr_stmt|;
comment|/* update inp_vflag flags */
name|sctp_update_ep_vflag
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Add the address to the TCB local address restricted list.  * This is a "pending" address list (eg. addresses waiting for an  * ASCONF-ACK response) and cannot be used as a valid source address.  */
end_comment

begin_function
name|void
name|sctp_add_local_addr_restricted
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sctpladdr
modifier|*
name|list
decl_stmt|;
comment|/* 	 * Assumes TCB is locked.. and possibly the INP. May need to 	 * confirm/fix that if we need it and is not the case. 	 */
name|list
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sctp_restricted_addrs
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
comment|/* Can't bind a non-existent addr. */
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* does the address already exist? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
return|return;
block|}
block|}
comment|/* add to the list */
operator|(
name|void
operator|)
name|sctp_insert_laddr
argument_list|(
name|list
argument_list|,
name|ifa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * insert an laddr entry with the given ifa for the desired list  */
end_comment

begin_function
name|int
name|sctp_insert_laddr
parameter_list|(
name|struct
name|sctpladdr
modifier|*
name|list
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint32_t
name|act
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|laddr
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|laddr
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|laddr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|laddr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|laddr
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|laddr
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|laddr
operator|->
name|action
operator|=
name|act
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* insert it */
name|LIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an laddr entry from the local address list (on an assoc)  */
end_comment

begin_function
name|void
name|sctp_remove_laddr
parameter_list|(
name|struct
name|sctp_laddr
modifier|*
name|laddr
parameter_list|)
block|{
comment|/* remove from the list */
name|LIST_REMOVE
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
name|laddr
argument_list|)
expr_stmt|;
name|SCTP_DECR_LADDR_COUNT
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a local address from the TCB local address restricted list  */
end_comment

begin_function
name|void
name|sctp_del_local_addr_restricted
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* 	 * This is called by asconf work. It is assumed that a) The TCB is 	 * locked and b) The INP is locked. This is true in as much as I can 	 * trace through the entry asconf code where I did these locks. 	 * Again, the ASCONF code is a bit different in that it does lock 	 * the INP during its work often times. This must be since we don't 	 * want other proc's looking up things while what they are looking 	 * up is changing :-D 	 */
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
comment|/* if subset bound and don't allow ASCONF's, can't delete last */
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|laddr_count
operator|<
literal|2
condition|)
block|{
comment|/* can't delete last address */
return|return;
block|}
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_restricted_addrs
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
comment|/* remove the address if it exists */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* address not found! */
return|return;
block|}
end_function

begin_comment
comment|/*  * Temporarily remove for __APPLE__ until we use the Tiger equivalents  */
end_comment

begin_comment
comment|/* sysctl */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sctp_max_number_of_assoc
init|=
name|SCTP_MAX_NUM_OF_ASOC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sctp_scale_up_for_address
init|=
name|SCTP_SCALE_FOR_ADDR
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_MCORE_INPUT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
end_if

begin_decl_stmt
name|struct
name|sctp_mcore_ctrl
modifier|*
name|sctp_mcore_workers
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|sctp_cpuarry
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_queue_to_mcore
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|cpu_to_use
parameter_list|)
block|{
comment|/* Queue a packet to a processor for the specified core */
name|struct
name|sctp_mcore_queue
modifier|*
name|qent
decl_stmt|;
name|struct
name|sctp_mcore_ctrl
modifier|*
name|wkq
decl_stmt|;
name|int
name|need_wake
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sctp_mcore_workers
operator|==
name|NULL
condition|)
block|{
comment|/* Something went way bad during setup */
name|sctp_input_with_port
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_MALLOC
argument_list|(
name|qent
argument_list|,
expr|struct
name|sctp_mcore_queue
operator|*
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_mcore_queue
argument_list|)
operator|)
argument_list|,
name|SCTP_M_MCORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|qent
operator|==
name|NULL
condition|)
block|{
comment|/* This is trouble  */
name|sctp_input_with_port
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|qent
operator|->
name|vn
operator|=
name|curvnet
expr_stmt|;
name|qent
operator|->
name|m
operator|=
name|m
expr_stmt|;
name|qent
operator|->
name|off
operator|=
name|off
expr_stmt|;
name|qent
operator|->
name|v6
operator|=
literal|0
expr_stmt|;
name|wkq
operator|=
operator|&
name|sctp_mcore_workers
index|[
name|cpu_to_use
index|]
expr_stmt|;
name|SCTP_MCORE_QLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|wkq
operator|->
name|que
argument_list|,
name|qent
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|wkq
operator|->
name|running
operator|==
literal|0
condition|)
block|{
name|need_wake
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_MCORE_QUNLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_wake
condition|)
block|{
name|wakeup
argument_list|(
operator|&
name|wkq
operator|->
name|running
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_mcore_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sctp_mcore_ctrl
modifier|*
name|wkq
decl_stmt|;
name|struct
name|sctp_mcore_queue
modifier|*
name|qent
decl_stmt|;
name|wkq
operator|=
operator|(
expr|struct
name|sctp_mcore_ctrl
operator|*
operator|)
name|arg
expr_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|,
name|v6
decl_stmt|;
comment|/* Wait for first tickle */
name|SCTP_MCORE_LOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
name|wkq
operator|->
name|running
operator|=
literal|0
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|wkq
operator|->
name|running
argument_list|,
operator|&
name|wkq
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|,
literal|"wait for pkt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_MCORE_UNLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
comment|/* Bind to our cpu */
name|thread_lock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|wkq
operator|->
name|cpuid
argument_list|)
expr_stmt|;
name|thread_unlock
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
comment|/* Now lets start working */
name|SCTP_MCORE_LOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
comment|/* Now grab lock and go */
while|while
condition|(
literal|1
condition|)
block|{
name|SCTP_MCORE_QLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
name|skip_sleep
label|:
name|wkq
operator|->
name|running
operator|=
literal|1
expr_stmt|;
name|qent
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|wkq
operator|->
name|que
argument_list|)
expr_stmt|;
if|if
condition|(
name|qent
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|wkq
operator|->
name|que
argument_list|,
name|qent
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCTP_MCORE_QUNLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|qent
operator|->
name|vn
argument_list|)
expr_stmt|;
name|m
operator|=
name|qent
operator|->
name|m
expr_stmt|;
name|off
operator|=
name|qent
operator|->
name|off
expr_stmt|;
name|v6
operator|=
name|qent
operator|->
name|v6
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|qent
argument_list|,
name|SCTP_M_MCORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|v6
operator|==
literal|0
condition|)
block|{
name|sctp_input_with_port
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"V6 not yet supported\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|SCTP_MCORE_QLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
block|}
name|wkq
operator|->
name|running
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|wkq
operator|->
name|que
argument_list|)
condition|)
block|{
goto|goto
name|skip_sleep
goto|;
block|}
name|SCTP_MCORE_QUNLOCK
argument_list|(
name|wkq
argument_list|)
expr_stmt|;
name|msleep
argument_list|(
operator|&
name|wkq
operator|->
name|running
argument_list|,
operator|&
name|wkq
operator|->
name|core_mtx
argument_list|,
literal|0
argument_list|,
literal|"wait for pkt"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_startup_mcore_threads
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|cpu
decl_stmt|;
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
return|return;
if|if
condition|(
name|sctp_mcore_workers
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Already been here in some previous vnet? 		 */
return|return;
block|}
name|SCTP_MALLOC
argument_list|(
name|sctp_mcore_workers
argument_list|,
expr|struct
name|sctp_mcore_ctrl
operator|*
argument_list|,
operator|(
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_mcore_ctrl
argument_list|)
operator|)
argument_list|,
name|SCTP_M_MCORE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_mcore_workers
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH I hope */
return|return;
block|}
name|memset
argument_list|(
name|sctp_mcore_workers
argument_list|,
literal|0
argument_list|,
operator|(
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_mcore_ctrl
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Init the structures */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|sctp_mcore_workers
index|[
name|i
index|]
operator|.
name|que
argument_list|)
expr_stmt|;
name|SCTP_MCORE_LOCK_INIT
argument_list|(
operator|&
name|sctp_mcore_workers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SCTP_MCORE_QLOCK_INIT
argument_list|(
operator|&
name|sctp_mcore_workers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sctp_mcore_workers
index|[
name|i
index|]
operator|.
name|cpuid
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|sctp_cpuarry
operator|==
name|NULL
condition|)
block|{
name|SCTP_MALLOC
argument_list|(
name|sctp_cpuarry
argument_list|,
name|int
operator|*
argument_list|,
operator|(
name|mp_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|,
name|SCTP_M_MCORE
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
name|sctp_cpuarry
index|[
name|i
index|]
operator|=
name|cpu
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* Now start them all */
name|CPU_FOREACH
argument_list|(
argument|cpu
argument_list|)
block|{
operator|(
name|void
operator|)
name|kproc_create
argument_list|(
name|sctp_mcore_thread
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sctp_mcore_workers
index|[
name|cpu
index|]
argument_list|,
operator|&
name|sctp_mcore_workers
index|[
name|cpu
index|]
operator|.
name|thread_proc
argument_list|,
name|RFPROC
argument_list|,
name|SCTP_KTHREAD_PAGES
argument_list|,
name|SCTP_MCORE_NAME
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_pcb_init
parameter_list|()
block|{
comment|/* 	 * SCTP initialization for the PCB structures should be called by 	 * the sctp_init() funciton. 	 */
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|SCTP_BASE_VAR
argument_list|(
name|sctp_pcb_initialized
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* error I was called twice */
return|return;
block|}
name|SCTP_BASE_VAR
argument_list|(
name|sctp_pcb_initialized
argument_list|)
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_LOCAL_TRACE_BUF
argument_list|)
name|bzero
argument_list|(
operator|&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_log
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_USE_PERCPU_STAT
argument_list|)
name|SCTP_MALLOC
argument_list|(
name|SCTP_BASE_STATS
argument_list|,
expr|struct
name|sctpstat
operator|*
argument_list|,
operator|(
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctpstat
argument_list|)
operator|)
argument_list|,
name|SCTP_M_MCORE
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_USE_PERCPU_STAT
argument_list|)
name|bzero
argument_list|(
name|SCTP_BASE_STATS
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctpstat
argument_list|)
operator|*
operator|(
name|mp_maxid
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_STATS
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|sctps_discontinuitytime
operator|.
name|tv_sec
operator|=
operator|(
name|uint32_t
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|SCTP_BASE_STATS
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|.
name|sctps_discontinuitytime
operator|.
name|tv_usec
operator|=
operator|(
name|uint32_t
operator|)
name|tv
operator|.
name|tv_usec
expr_stmt|;
else|#
directive|else
name|bzero
argument_list|(
operator|&
name|SCTP_BASE_STATS
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctpstat
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_STAT
argument_list|(
name|sctps_discontinuitytime
argument_list|)
operator|.
name|tv_sec
operator|=
operator|(
name|uint32_t
operator|)
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|SCTP_BASE_STAT
argument_list|(
name|sctps_discontinuitytime
argument_list|)
operator|.
name|tv_usec
operator|=
operator|(
name|uint32_t
operator|)
name|tv
operator|.
name|tv_usec
expr_stmt|;
endif|#
directive|endif
comment|/* init the empty list of (All) Endpoints */
name|LIST_INIT
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|listhead
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init the hash table of endpoints */
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.inet.sctp.tcbhashsize"
argument_list|,
operator|&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hashtblsize
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.inet.sctp.pcbhashsize"
argument_list|,
operator|&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_pcbtblsize
argument_list|)
argument_list|)
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"net.inet.sctp.chunkscale"
argument_list|,
operator|&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_chunkscale
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
operator|=
name|SCTP_HASH_INIT
argument_list|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hashtblsize
argument_list|)
operator|*
literal|31
operator|)
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hashtblsize
argument_list|)
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hashtblsize
argument_list|)
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|hashtblsize
argument_list|)
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hashtblsize
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|sctp_vrfhash
argument_list|)
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_SIZE_OF_VRF_HASH
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashvrfmark
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hash
argument_list|)
operator|=
name|SCTP_HASH_INIT
argument_list|(
name|SCTP_VRF_IFN_HASH_SIZE
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hashmark
argument_list|)
argument_list|)
expr_stmt|;
comment|/* init the zones */
comment|/* 	 * FIX ME: Should check for NULL returns, but if it does fail we are 	 * doomed to panic anyways... add later maybe. 	 */
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|,
literal|"sctp_ep"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_inpcb
argument_list|)
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|,
literal|"sctp_asoc"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tcb
argument_list|)
argument_list|,
name|sctp_max_number_of_assoc
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
literal|"sctp_laddr"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_laddr
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_scale_up_for_address
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_net
argument_list|)
argument_list|,
literal|"sctp_raddr"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nets
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|sctp_scale_up_for_address
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|,
literal|"sctp_chunk"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_tmit_chunk
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_chunkscale
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
literal|"sctp_readq"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_queued_to_read
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_chunkscale
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_strmoq
argument_list|)
argument_list|,
literal|"sctp_stream_msg_out"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_queue_pending
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_chunkscale
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf
argument_list|)
argument_list|,
literal|"sctp_asconf"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_chunkscale
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_INIT
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf_ack
argument_list|)
argument_list|,
literal|"sctp_asconf_ack"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack
argument_list|)
argument_list|,
operator|(
name|sctp_max_number_of_assoc
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_chunkscale
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Master Lock INIT for info structure */
name|SCTP_INP_INFO_LOCK_INIT
argument_list|()
expr_stmt|;
name|SCTP_STATLOG_INIT_LOCK
argument_list|()
expr_stmt|;
name|SCTP_IPI_COUNT_INIT
argument_list|()
expr_stmt|;
name|SCTP_IPI_ADDR_INIT
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
name|SCTP_IP_PKTLOG_INIT
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|LIST_INIT
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_WQ_ADDR_INIT
argument_list|()
expr_stmt|;
comment|/* not sure if we need all the counts */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_ep
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* assoc/tcb zone info */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_asoc
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* local addrlist zone info */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_laddr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* remote addrlist zone info */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_raddr
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* chunk info */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_chunk
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* socket queue zone info */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_readq
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* stream out queue cont */
name|SCTP_BASE_INFO
argument_list|(
name|ipi_count_strmoq
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|ipi_free_strmoq
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|ipi_free_chunks
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_OS_TIMER_INIT
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq_timer
operator|.
name|timer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init the TIMEWAIT list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_STACK_VTAG_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|LIST_INIT
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vtag_timewait
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|sctp_startup_iterator
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_MCORE_INPUT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
name|sctp_startup_mcore_threads
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * INIT the default VRF which for BSD is the only one, other O/S's 	 * may have more. But initially they must start with one and then 	 * add the VRF's as addresses are added. 	 */
name|sctp_init_vrf_list
argument_list|(
name|SCTP_DEFAULT_VRF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Assumes that the SCTP_BASE_INFO() lock is NOT held.  */
end_comment

begin_function
name|void
name|sctp_pcb_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sctp_vrflist
modifier|*
name|vrf_bucket
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|,
modifier|*
name|nvrf
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|ifn
decl_stmt|,
modifier|*
name|nifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|nifa
decl_stmt|;
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|,
modifier|*
name|prev_twait_block
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|,
modifier|*
name|nwi
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Free BSD the it thread never exits but we do clean up. The only 	 * way freebsd reaches here if we have VRF's but we still add the 	 * ifdef to make it compile on old versions. 	 */
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
decl_stmt|,
modifier|*
name|nit
decl_stmt|;
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|it
argument_list|,
argument|&sctp_it_ctl.iteratorhead
argument_list|,
argument|sctp_nxt_itr
argument_list|,
argument|nit
argument_list|)
block|{
if|if
condition|(
name|it
operator|->
name|vn
operator|!=
name|curvnet
condition|)
block|{
continue|continue;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sctp_it_ctl
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|function_atend
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|it
operator|->
name|function_atend
call|)
argument_list|(
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|it
argument_list|,
name|SCTP_M_ITER
argument_list|)
expr_stmt|;
block|}
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_it_ctl
operator|.
name|cur_it
operator|)
operator|&&
operator|(
name|sctp_it_ctl
operator|.
name|cur_it
operator|->
name|vn
operator|==
name|curvnet
operator|)
condition|)
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator||=
name|SCTP_ITERATOR_STOP_CUR_IT
expr_stmt|;
block|}
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
block|}
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq_timer
operator|.
name|timer
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|wi
argument_list|,
argument|&SCTP_BASE_INFO(addr_wq)
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nwi
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|SCTP_DECR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
name|wi
argument_list|)
expr_stmt|;
block|}
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * free the vrf/ifn/ifa lists and hashes (be sure address monitor is 	 * destroyed first). 	 */
name|vrf_bucket
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_vrfhash
argument_list|)
index|[
operator|(
name|SCTP_DEFAULT_VRFID
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|hashvrfmark
argument_list|)
operator|)
index|]
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|vrf
argument_list|,
argument|vrf_bucket
argument_list|,
argument|next_vrf
argument_list|,
argument|nvrf
argument_list|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|,
argument|nifn
argument_list|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|,
argument|nifa
argument_list|)
block|{
comment|/* free the ifa */
name|LIST_REMOVE
argument_list|(
name|ifa
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ifa
argument_list|,
name|next_ifa
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|ifa
argument_list|,
name|SCTP_M_IFA
argument_list|)
expr_stmt|;
block|}
comment|/* free the ifn */
name|LIST_REMOVE
argument_list|(
name|ifn
argument_list|,
name|next_bucket
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ifn
argument_list|,
name|next_ifn
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|ifn
argument_list|,
name|SCTP_M_IFN
argument_list|)
expr_stmt|;
block|}
name|SCTP_HASH_FREE
argument_list|(
name|vrf
operator|->
name|vrf_addr_hash
argument_list|,
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|)
expr_stmt|;
comment|/* free the vrf */
name|LIST_REMOVE
argument_list|(
name|vrf
argument_list|,
name|next_vrf
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|vrf
argument_list|,
name|SCTP_M_VRF
argument_list|)
expr_stmt|;
block|}
comment|/* free the vrf hashes */
name|SCTP_HASH_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_vrfhash
argument_list|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashvrfmark
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_HASH_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hash
argument_list|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|vrf_ifn_hashmark
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * free the TIMEWAIT list elements malloc'd in the function 	 * sctp_add_vtag_to_timewait()... 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_STACK_VTAG_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|chain
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vtag_timewait
argument_list|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
name|prev_twait_block
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
if|if
condition|(
name|prev_twait_block
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|prev_twait_block
argument_list|,
name|SCTP_M_TIMW
argument_list|)
expr_stmt|;
block|}
name|prev_twait_block
operator|=
name|twait_block
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|prev_twait_block
argument_list|,
name|SCTP_M_TIMW
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* free the locks and mutexes */
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
name|SCTP_IP_PKTLOG_DESTROY
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|SCTP_IPI_ADDR_DESTROY
argument_list|()
expr_stmt|;
name|SCTP_STATLOG_DESTROY
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|SCTP_WQ_ADDR_DESTROY
argument_list|()
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_ep
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asoc
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_net
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_strmoq
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_ZONE_DESTROY
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf_ack
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get rid of other stuff to */
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_ephash
argument_list|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashmark
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|sctp_tcpephash
argument_list|)
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashtcpmark
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_USE_PERCPU_STAT
argument_list|)
name|SCTP_FREE
argument_list|(
name|SCTP_BASE_STATS
argument_list|,
name|SCTP_M_MCORE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|sctp_load_addresses_from_init
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|altsa
parameter_list|)
block|{
comment|/* 	 * grub through the INIT pulling addresses and loading them to the 	 * nets structure in the asoc. The from address in the mbuf should 	 * also be loaded (if it is not already). This routine can be called 	 * with either INIT or INIT-ACK's as long as the m points to the IP 	 * packet and the offset points to the beginning of the parameters. 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
name|l_inp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|nnet
decl_stmt|,
modifier|*
name|net_tmp
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|parm_buf
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb_tmp
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_storage
name|dest_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|local_sa
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest_store
decl_stmt|;
name|uint8_t
name|random_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_random
modifier|*
name|p_random
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|random_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hmacs_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|hmacs_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|saw_asconf
init|=
literal|0
decl_stmt|;
name|uint8_t
name|saw_asconf_ack
init|=
literal|0
decl_stmt|;
name|uint8_t
name|chunks_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|num_chunks
init|=
literal|0
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint32_t
name|keylen
decl_stmt|;
name|int
name|got_random
init|=
literal|0
decl_stmt|,
name|got_hmacs
init|=
literal|0
decl_stmt|,
name|got_chklist
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ecn_allowed
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
comment|/* First get the destination address setup too. */
ifdef|#
directive|ifdef
name|INET
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|altsa
operator|==
name|NULL
condition|)
block|{
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPVERSION
case|:
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|sin_2
decl_stmt|;
name|sin_2
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|local_sa
operator|)
expr_stmt|;
name|memset
argument_list|(
name|sin_2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin_2
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin_2
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin_2
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin_2
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|iph
operator|->
name|ip_src
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6_2
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6_2
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|local_sa
operator|)
expr_stmt|;
name|memset
argument_list|(
name|sin6_2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6_2
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6_2
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6_2
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * For cookies we use the src address NOT from the packet 		 * but from the original INIT 		 */
name|sa
operator|=
name|altsa
expr_stmt|;
block|}
comment|/* Turn off ECN until we get through all params */
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* mark all addresses that we have currently on the list */
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
comment|/* does the source address already exist? if so skip it */
name|l_inp
operator|=
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb_tmp
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net_tmp
argument_list|,
name|local_sa
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb_tmp
operator|==
name|NULL
operator|&&
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
operator|)
operator|||
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* we must add the source address */
comment|/* no scope set here since we have a tcb already. */
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_addr_legal
condition|)
block|{
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_2
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv6_addr_legal
condition|)
block|{
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_3
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net_tmp
operator|!=
name|NULL
operator|&&
name|stcb_tmp
operator|==
name|stcb
condition|)
block|{
name|net_tmp
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb_tmp
operator|!=
name|stcb
condition|)
block|{
comment|/* It belongs to another association? */
if|if
condition|(
name|stcb_tmp
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb_tmp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|4
operator|)
return|;
block|}
comment|/* 	 * peer must explicitly turn this on. This may have been initialized 	 * to be "on" in order to allow local addr changes while INIT's are 	 * in flight. 	 */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
comment|/* now we must go through each of the params. */
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
comment|/* 		 * printf("ptype => %0x, plen => %d\n", (uint32_t)ptype, 		 * (int)plen); 		 */
if|if
condition|(
name|offset
operator|+
name|plen
operator|>
name|limit
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
break|break;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|p4
decl_stmt|,
name|p4_buf
decl_stmt|;
comment|/* ok get the v4 address and check/add */
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p4_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p4_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|p4
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
comment|/* Skip multi-cast addresses */
goto|goto
name|next_param
goto|;
block|}
if|if
condition|(
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
goto|goto
name|next_param
goto|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb_tmp
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|local_sa
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb_tmp
operator|==
name|NULL
operator|&&
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
operator|)
operator|||
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* we must add the source address */
comment|/* 					 * no scope set since we have a tcb 					 * already 					 */
comment|/* 					 * we must validate the state again 					 * here 					 */
name|add_it_now
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|7
operator|)
return|;
block|}
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_4
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|8
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stcb_tmp
operator|==
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|10
operator|)
return|;
block|}
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* clear flag */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 					 * strange, address is in another 					 * assoc? straighten out locks. 					 */
if|if
condition|(
name|stcb_tmp
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb_tmp
operator|->
name|asoc
argument_list|)
operator|&
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
comment|/* 							 * in setup state we 							 * abort this guy 							 */
name|sctp_abort_an_association
argument_list|(
name|stcb_tmp
operator|->
name|sctp_ep
argument_list|,
name|stcb_tmp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|add_it_now
goto|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb_tmp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|12
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|13
operator|)
return|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv6_addr_legal
condition|)
block|{
comment|/* ok get the v6 address and check/add */
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p6
decl_stmt|,
name|p6_buf
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p6_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p6_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|14
operator|)
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p6
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Skip multi-cast addresses */
goto|goto
name|next_param
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * Link local make no sense without 					 * scope 					 */
goto|goto
name|next_param
goto|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb_tmp
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|local_sa
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb_tmp
operator|==
name|NULL
operator|&&
operator|(
name|inp
operator|==
name|stcb
operator|->
name|sctp_ep
operator|||
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 					 * we must validate the state again 					 * here 					 */
name|add_it_now6
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|16
operator|)
return|;
block|}
comment|/* 					 * we must add the address, no scope 					 * set 					 */
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_LOAD_ADDR_5
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|17
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|stcb_tmp
operator|==
name|stcb
condition|)
block|{
comment|/* 					 * we must validate the state again 					 * here 					 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|19
operator|)
return|;
block|}
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* clear flag */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_IN_ASSOC
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 					 * strange, address is in another 					 * assoc? straighten out locks. 					 */
if|if
condition|(
name|stcb_tmp
condition|)
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb_tmp
operator|->
name|asoc
argument_list|)
operator|&
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
comment|/* 							 * in setup state we 							 * abort this guy 							 */
name|sctp_abort_an_association
argument_list|(
name|stcb_tmp
operator|->
name|sctp_ep
argument_list|,
name|stcb_tmp
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|add_it_now6
goto|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
comment|/* the assoc was freed? */
return|return
operator|(
operator|-
literal|21
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|22
operator|)
return|;
block|}
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|ptype
operator|==
name|SCTP_ECN_CAPABLE
condition|)
block|{
name|ecn_allowed
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_ULP_ADAPTATION
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|!=
name|SCTP_STATE_OPEN
condition|)
block|{
name|struct
name|sctp_adaptation_layer_indication
name|ai
decl_stmt|,
modifier|*
name|aip
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|ai
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|aip
operator|=
operator|(
expr|struct
name|sctp_adaptation_layer_indication
operator|*
operator|)
name|phdr
expr_stmt|;
if|if
condition|(
name|aip
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peers_adaptation
operator|=
name|ntohl
argument_list|(
name|aip
operator|->
name|indication
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|adaptation_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_SET_PRIM_ADDR
condition|)
block|{
name|struct
name|sctp_asconf_addr_param
name|lstore
decl_stmt|,
modifier|*
name|fee
decl_stmt|;
name|int
name|lptype
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|lsa
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sctp_asconf_addrv4_param
modifier|*
name|fii
decl_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|lstore
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|23
operator|)
return|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|lstore
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|lstore
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|24
operator|)
return|;
block|}
name|fee
operator|=
operator|(
expr|struct
name|sctp_asconf_addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|lptype
operator|=
name|ntohs
argument_list|(
name|fee
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lptype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Sizeof setprim in init/init ack not %d but %d - ignored\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fii
operator|=
operator|(
expr|struct
name|sctp_asconf_addrv4_param
operator|*
operator|)
name|fee
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|fii
operator|->
name|addrp
operator|.
name|addr
expr_stmt|;
name|lsa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Sizeof setprim (v6) in init/init ack not %d but %d - ignored\n"
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|fee
operator|->
name|addrp
operator|.
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|fee
operator|->
name|addrp
operator|.
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|lsa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|if
condition|(
name|lsa
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HAS_NAT_SUPPORT
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nat
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_PRSCTP_SUPPORTED
condition|)
block|{
comment|/* Peer supports pr-sctp */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_SUPPORTED_CHUNK_EXT
condition|)
block|{
comment|/* A supported extension chunk */
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|uint8_t
name|local_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|num_ent
decl_stmt|,
name|i
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|local_store
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|local_store
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|25
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_pktdrop
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nr_sack
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|0
expr_stmt|;
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_ent
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ent
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pr_supported
operator|->
name|chunk_types
index|[
name|i
index|]
condition|)
block|{
case|case
name|SCTP_ASCONF
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_PACKET_DROPPED
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_pktdrop
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_NR_SELECTIVE_ACK
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nr_sack
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_STREAM_RESET
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHENTICATION
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* one I have not learned yet */
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_RANDOM
condition|)
block|{
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
condition|)
break|break;
if|if
condition|(
name|got_random
condition|)
block|{
comment|/* already processed a RANDOM */
goto|goto
name|next_param
goto|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|random_store
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|26
operator|)
return|;
name|p_random
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
name|phdr
expr_stmt|;
name|random_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
expr_stmt|;
comment|/* enforce the random length */
if|if
condition|(
name|random_len
operator|!=
name|SCTP_AUTH_RANDOM_SIZE_REQUIRED
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: invalid RANDOM len\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|27
operator|)
return|;
block|}
name|got_random
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HMAC_LIST
condition|)
block|{
name|int
name|num_hmacs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
condition|)
break|break;
if|if
condition|(
name|got_hmacs
condition|)
block|{
comment|/* already processed a HMAC list */
goto|goto
name|next_param
goto|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|hmacs_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|28
operator|)
return|;
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
name|phdr
expr_stmt|;
name|hmacs_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
expr_stmt|;
name|num_hmacs
operator|=
name|hmacs_len
operator|/
sizeof|sizeof
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* validate the hmac list */
if|if
condition|(
name|sctp_verify_hmac_param
argument_list|(
name|hmacs
argument_list|,
name|num_hmacs
argument_list|)
condition|)
block|{
return|return
operator|(
operator|-
literal|29
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
operator|!=
name|NULL
condition|)
name|sctp_free_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|num_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hmacs
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sctp_auth_add_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|,
name|ntohs
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|got_hmacs
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_CHUNK_LIST
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
condition|)
break|break;
if|if
condition|(
name|got_chklist
condition|)
block|{
comment|/* already processed a Chunks list */
goto|goto
name|next_param
goto|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|chunks_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|30
operator|)
return|;
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_chunks
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
operator|!=
name|NULL
condition|)
name|sctp_clear_chunklist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
expr_stmt|;
else|else
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sctp_auth_add_chunk
argument_list|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
expr_stmt|;
comment|/* record asconf/asconf-ack if listed */
if|if
condition|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
operator|==
name|SCTP_ASCONF
condition|)
name|saw_asconf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
operator|==
name|SCTP_ASCONF_ACK
condition|)
name|saw_asconf_ack
operator|=
literal|1
expr_stmt|;
block|}
name|got_chklist
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ptype
operator|==
name|SCTP_HEARTBEAT_INFO
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_STATE_COOKIE
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_UNRECOG_PARAM
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_COOKIE_PRESERVE
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_SUPPORTED_ADDRTYPE
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_ERROR_CAUSE_IND
operator|)
operator|||
operator|(
name|ptype
operator|==
name|SCTP_SUCCESS_REPORT
operator|)
condition|)
block|{
comment|/* don't care */
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ptype
operator|&
literal|0x8000
operator|)
operator|==
literal|0x0000
condition|)
block|{
comment|/* 				 * must stop processing the rest of the 				 * param's. Any report bits were handled 				 * with the call to 				 * sctp_arethere_unrecognized_parameters() 				 * when the INIT or INIT-ACK was first seen. 				 */
break|break;
block|}
block|}
name|next_param
label|:
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now check to see if we need to purge any addresses */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|,
argument|nnet
argument_list|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_IN_ASSOC
operator|)
operator|==
name|SCTP_ADDR_NOT_IN_ASSOC
condition|)
block|{
comment|/* This address has been removed from the asoc */
comment|/* remove and free it */
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|NULL
expr_stmt|;
name|sctp_select_primary_destination
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|ecn_allowed
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* validate authentication required parameters */
if|if
condition|(
name|got_random
operator|&&
name|got_hmacs
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|&&
name|got_chklist
condition|)
block|{
comment|/* peer does not support auth but sent a chunks list? */
return|return
operator|(
operator|-
literal|31
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_asconf_auth_nochk
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
condition|)
block|{
comment|/* peer supports asconf but not auth? */
return|return
operator|(
operator|-
literal|32
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|)
operator|&&
operator|(
operator|(
name|saw_asconf
operator|==
literal|0
operator|)
operator|||
operator|(
name|saw_asconf_ack
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|33
operator|)
return|;
block|}
comment|/* concatenate the full random key */
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
expr_stmt|;
if|if
condition|(
name|chunks
operator|!=
name|NULL
condition|)
block|{
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
expr_stmt|;
block|}
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
comment|/* copy in the RANDOM */
if|if
condition|(
name|p_random
operator|!=
name|NULL
condition|)
block|{
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|bcopy
argument_list|(
name|p_random
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
block|}
comment|/* append in the AUTH chunks */
if|if
condition|(
name|chunks
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|chunks
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
expr_stmt|;
block|}
comment|/* append in the HMACs */
if|if
condition|(
name|hmacs
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|hmacs
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* failed to get memory for the key */
return|return
operator|(
operator|-
literal|34
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
operator|=
name|new_key
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_set_primary_addr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* make sure the requested primary address exists in the assoc */
if|if
condition|(
name|net
operator|==
name|NULL
operator|&&
name|sa
condition|)
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* didn't find the requested primary address! */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* set the primary address */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* Must be confirmed, so queue to set */
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REQ_PRIMARY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|net
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* 			 * first one on the list is NOT the primary 			 * sctp_cmpaddr() is much more efficient if the 			 * primary is the first on the list, make it so. 			 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_is_vtag_good
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|tag
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint16_t
name|rport
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
name|save_in_twait
parameter_list|)
block|{
comment|/* 	 * This function serves two purposes. It will see if a TAG can be 	 * re-used and return 1 for yes it is ok and 0 for don't use that 	 * tag. A secondary function it will do is purge out old tags that 	 * can be removed. 	 */
name|struct
name|sctpvtaghead
modifier|*
name|chain
decl_stmt|;
name|struct
name|sctp_tagblock
modifier|*
name|twait_block
decl_stmt|;
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|tag
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
block|{
comment|/* invalid vtag */
goto|goto
name|skip_vtag_check
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|head
argument_list|,
argument|sctp_asocs
argument_list|)
block|{
comment|/* 		 * We choose not to lock anything here. TCB's can't be 		 * removed since we have the read lock, so they can't be 		 * freed on us, same thing for the INP. I may be wrong with 		 * this assumption, but we will go with it for now :-) 		 */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|==
name|tag
condition|)
block|{
comment|/* candidate */
if|if
condition|(
name|stcb
operator|->
name|rport
operator|!=
name|rport
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
operator|!=
name|lport
condition|)
block|{
continue|continue;
block|}
comment|/* Its a used tag set */
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|skip_vtag_check
label|:
name|chain
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|vtag_timewait
argument_list|)
index|[
operator|(
name|tag
operator|%
name|SCTP_STACK_VTAG_HASH_SIZE
operator|)
index|]
expr_stmt|;
comment|/* Now what about timed wait ? */
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
name|chain
argument_list|)
condition|)
block|{
comment|/* 		 * Block(s) are present, lets see if we have this tag in the 		 * list 		 */
name|LIST_FOREACH
argument_list|(
argument|twait_block
argument_list|,
argument|chain
argument_list|,
argument|sctp_nxt_tagblock
argument_list|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_IN_VTAG_BLOCK
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
literal|0
condition|)
block|{
comment|/* not used */
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|<
name|now
operator|->
name|tv_sec
condition|)
block|{
comment|/* Audit expires this guy */
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|tv_sec_at_expire
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|=
literal|0
expr_stmt|;
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|v_tag
operator|==
name|tag
operator|)
operator|&&
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|lport
operator|==
name|lport
operator|)
operator|&&
operator|(
name|twait_block
operator|->
name|vtag_block
index|[
name|i
index|]
operator|.
name|rport
operator|==
name|rport
operator|)
condition|)
block|{
comment|/* Bad tag, sorry :< */
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|sctp_assoc_t
name|reneged_asoc_ids
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|reneged_at
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_drain_mbufs
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* 	 * We must hunt this association for MBUF's past the cumack (i.e. 	 * out of order data that we can renege on). 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|uint32_t
name|cumulative_tsn_p1
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|strmat
decl_stmt|;
name|uint32_t
name|gap
decl_stmt|,
name|i
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
comment|/* We look for anything larger than the cum-ack + 1 */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|asoc
operator|->
name|highest_tsn_inside_map
condition|)
block|{
comment|/* none we can reneg on. */
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_protocol_drains_done
argument_list|)
expr_stmt|;
name|cumulative_tsn_p1
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
comment|/* First look in the re-assembly queue */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->reasmqueue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cumulative_tsn_p1
argument_list|)
condition|)
block|{
comment|/* Yep it is above cum-ack */
name|cnt
operator|++
expr_stmt|;
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|,
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|SCTP_UNSET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Ok that was fun, now we will drain all the inbound streams? */
for|for
control|(
name|strmat
operator|=
literal|0
init|;
name|strmat
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|strmat
operator|++
control|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ctl
argument_list|,
argument|&asoc->strmin[strmat].inqueue
argument_list|,
argument|next
argument_list|,
argument|nctl
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|ctl
operator|->
name|sinfo_tsn
argument_list|,
name|cumulative_tsn_p1
argument_list|)
condition|)
block|{
comment|/* Yep it is above cum-ack */
name|cnt
operator|++
expr_stmt|;
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|ctl
operator|->
name|sinfo_tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|ctl
operator|->
name|length
argument_list|)
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|SCTP_UNSET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|strmat
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|ctl
operator|->
name|data
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|ctl
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|SCTP_DECR_READQ_COUNT
argument_list|()
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|cnt
condition|)
block|{
comment|/* We must back down to see what the new highest is */
for|for
control|(
name|i
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
init|;
name|SCTP_TSN_GE
argument_list|(
name|i
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|i
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|i
expr_stmt|;
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 		 * Question, should we go through the delivery queue? The 		 * only reason things are on here is the app not reading OR 		 * a p-d-api up. An attacker COULD send enough in to 		 * initiate the PD-API and then send a bunch of stuff to 		 * other streams... these would wind up on the delivery 		 * queue.. and then we would not get to them. But in order 		 * to do this I then have to back-track and un-deliver 		 * sequence numbers in streams.. el-yucko. I think for now 		 * we will NOT look at the delivery queue and leave it to be 		 * something to consider later. An alternative would be to 		 * abort the P-D-API with a notification and then deliver 		 * the data.... Or another method might be to keep track of 		 * how many times the situation occurs and if we see a 		 * possible attack underway just abort the association. 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Freed %d chunks from reneg harvest\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Now do we need to find a new 		 * asoc->highest_tsn_inside_map? 		 */
name|asoc
operator|->
name|last_revoke_count
operator|=
name|cnt
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_DRAIN
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|reneged_asoc_ids
index|[
name|reneged_at
index|]
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|reneged_at
operator|++
expr_stmt|;
block|}
comment|/* 	 * Another issue, in un-setting the TSN's in the mapping array we 	 * DID NOT adjust the highest_tsn marker.  This will cause one of 	 * two things to occur. It may cause us to do extra work in checking 	 * for our mapping array movement. More importantly it may cause us 	 * to SACK every datagram. This may not be a bad thing though since 	 * we will recover once we get our cum-ack above and all this stuff 	 * we dumped recovered. 	 */
block|}
end_function

begin_function
name|void
name|sctp_drain
parameter_list|()
block|{
comment|/* 	 * We must walk the PCB lists for ALL associations here. The system 	 * is LOW on MBUF's and needs help. This is where reneging will 	 * occur. We really hope this does NOT happen! 	 */
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_protocol_drain_calls
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_do_drain
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|VIMAGE
continue|continue;
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|&SCTP_BASE_INFO(listhead)
argument_list|,
argument|sctp_list
argument_list|)
block|{
comment|/* For each endpoint */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
comment|/* For each association */
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_drain_mbufs
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * start a new iterator  * iterates through all endpoints and associations based on the pcb_state  * flags and asoc_state.  "af" (mandatory) is executed for all matching  * assocs and "ef" (optional) is executed when the iterator completes.  * "inpf" (optional) is executed for each new endpoint as it is being  * iterated through. inpe (optional) is called when the inp completes  * its way through all the stcbs.  */
end_comment

begin_function
name|int
name|sctp_initiate_iterator
parameter_list|(
name|inp_func
name|inpf
parameter_list|,
name|asoc_func
name|af
parameter_list|,
name|inp_func
name|inpe
parameter_list|,
name|uint32_t
name|pcb_state
parameter_list|,
name|uint32_t
name|pcb_features
parameter_list|,
name|uint32_t
name|asoc_state
parameter_list|,
name|void
modifier|*
name|argp
parameter_list|,
name|uint32_t
name|argi
parameter_list|,
name|end_func
name|ef
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|s_inp
parameter_list|,
name|uint8_t
name|chunk_output_off
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_MALLOC
argument_list|(
name|it
argument_list|,
expr|struct
name|sctp_iterator
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_iterator
argument_list|)
argument_list|,
name|SCTP_M_ITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_PCB
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|it
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|it
argument_list|)
argument_list|)
expr_stmt|;
name|it
operator|->
name|function_assoc
operator|=
name|af
expr_stmt|;
name|it
operator|->
name|function_inp
operator|=
name|inpf
expr_stmt|;
if|if
condition|(
name|inpf
condition|)
name|it
operator|->
name|done_current_ep
operator|=
literal|0
expr_stmt|;
else|else
name|it
operator|->
name|done_current_ep
operator|=
literal|1
expr_stmt|;
name|it
operator|->
name|function_atend
operator|=
name|ef
expr_stmt|;
name|it
operator|->
name|pointer
operator|=
name|argp
expr_stmt|;
name|it
operator|->
name|val
operator|=
name|argi
expr_stmt|;
name|it
operator|->
name|pcb_flags
operator|=
name|pcb_state
expr_stmt|;
name|it
operator|->
name|pcb_features
operator|=
name|pcb_features
expr_stmt|;
name|it
operator|->
name|asoc_state
operator|=
name|asoc_state
expr_stmt|;
name|it
operator|->
name|function_inp_end
operator|=
name|inpe
expr_stmt|;
name|it
operator|->
name|no_chunk_output
operator|=
name|chunk_output_off
expr_stmt|;
name|it
operator|->
name|vn
operator|=
name|curvnet
expr_stmt|;
if|if
condition|(
name|s_inp
condition|)
block|{
comment|/* Assume lock is held here */
name|it
operator|->
name|inp
operator|=
name|s_inp
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|it
operator|->
name|iterator_flags
operator|=
name|SCTP_ITERATOR_DO_SINGLE_INP
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|it
operator|->
name|inp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|listhead
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
name|it
operator|->
name|iterator_flags
operator|=
name|SCTP_ITERATOR_DO_ALL_INP
expr_stmt|;
block|}
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|sctp_it_ctl
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_running
operator|==
literal|0
condition|)
block|{
name|sctp_wakeup_iterator
argument_list|()
expr_stmt|;
block|}
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
comment|/* sa_ignore MEMLEAK {memory is put on the tailq for the iterator} */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

