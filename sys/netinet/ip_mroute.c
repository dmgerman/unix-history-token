begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Stephen Deering  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Stephen Deering of Stanford University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_mroute.c	8.2 (Berkeley) 11/15/93  */
end_comment

begin_comment
comment|/*  * Procedures for the kernel part of DVMRP,  * a Distance-Vector Multicast Routing Protocol.  * (See RFC-1075.)  *  * Written by David Waitzman, BBN Labs, August 1988.  * Modified by Steve Deering, Stanford, February 1989.  *  * MROUTING 1.1  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTING
end_ifndef

begin_decl_stmt
name|int
name|ip_mrtproto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for netstat only */
end_comment

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_mroute.h>
end_include

begin_comment
comment|/* Static forwards */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ip_mrouter_init
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_vif
name|__P
argument_list|(
operator|(
expr|struct
name|vifctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|del_vif
name|__P
argument_list|(
operator|(
name|vifi_t
operator|*
name|vifip
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_lgrp
name|__P
argument_list|(
operator|(
expr|struct
name|lgrplctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|del_lgrp
name|__P
argument_list|(
operator|(
expr|struct
name|lgrplctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|grplst_member
name|__P
argument_list|(
operator|(
expr|struct
name|vif
operator|*
operator|,
expr|struct
name|in_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|nethash
name|__P
argument_list|(
operator|(
expr|struct
name|in_addr
name|in
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|add_mrt
name|__P
argument_list|(
operator|(
expr|struct
name|mrtctl
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|del_mrt
name|__P
argument_list|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mrt
modifier|*
name|mrtfind
name|__P
argument_list|(
operator|(
expr|struct
name|in_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|phyint_send
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|vif
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|tunnel_send
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|vif
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|INSIZ
value|sizeof(struct in_addr)
end_define

begin_define
define|#
directive|define
name|same
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
value|(bcmp((caddr_t)(a1), (caddr_t)(a2), INSIZ) == 0)
end_define

begin_define
define|#
directive|define
name|satosin
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
end_define

begin_comment
comment|/*  * Globals.  All but ip_mrouter and ip_mrtproto could be static,  * except for netstat or debugging purposes.  */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|ip_mrouter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip_mrtproto
init|=
name|IGMP_DVMRP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for netstat only */
end_comment

begin_decl_stmt
name|struct
name|mrt
modifier|*
name|mrttable
index|[
name|MRTHASHSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vif
name|viftable
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mrtstat
name|mrtstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
specifier|static
name|vifi_t
name|numvifs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mrt
modifier|*
name|cached_mrt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|cached_origin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|cached_originmask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Handle DVMRP setsockopt commands to modify the multicast routing tables.  */
end_comment

begin_function
name|int
name|ip_mrouter_cmd
parameter_list|(
name|cmd
parameter_list|,
name|so
parameter_list|,
name|m
parameter_list|)
specifier|register
name|int
name|cmd
decl_stmt|;
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|DVMRP_INIT
operator|&&
name|so
operator|!=
name|ip_mrouter
condition|)
name|error
operator|=
name|EACCES
expr_stmt|;
else|else
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DVMRP_INIT
case|:
name|error
operator|=
name|ip_mrouter_init
argument_list|(
name|so
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_DONE
case|:
name|error
operator|=
name|ip_mrouter_done
argument_list|()
expr_stmt|;
break|break;
case|case
name|DVMRP_ADD_VIF
case|:
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|vifctl
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|add_vif
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vifctl
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_DEL_VIF
case|:
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
name|short
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|del_vif
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vifi_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_ADD_LGRP
case|:
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|lgrplctl
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|add_lgrp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|lgrplctl
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_DEL_LGRP
case|:
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|lgrplctl
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|del_lgrp
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|lgrplctl
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_ADD_MRT
case|:
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|mrtctl
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|add_mrt
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mrtctl
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DVMRP_DEL_MRT
case|:
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|error
operator|=
name|del_mrt
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|in_addr
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable multicast routing  */
end_comment

begin_function
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|so
parameter_list|)
specifier|register
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_IGMP
condition|)
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
if|if
condition|(
name|ip_mrouter
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
name|ip_mrouter
operator|=
name|so
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Disable multicast routing  */
end_comment

begin_function
name|int
name|ip_mrouter_done
parameter_list|()
block|{
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* 	 * For each phyint in use, free its local group list and 	 * disable promiscuous reception of all IP multicasts. 	 */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_grps
condition|)
name|free
argument_list|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_grps
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|satosin
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|satosin
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCDELMULTI
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|viftable
argument_list|,
sizeof|sizeof
argument_list|(
name|viftable
argument_list|)
argument_list|)
expr_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Free any multicast route entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MRTHASHSIZ
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|mrttable
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|mrttable
index|[
name|i
index|]
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mrttable
argument_list|,
sizeof|sizeof
argument_list|(
name|mrttable
argument_list|)
argument_list|)
expr_stmt|;
name|cached_mrt
operator|=
name|NULL
expr_stmt|;
name|ip_mrouter
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a vif to the vif table  */
end_comment

begin_function
specifier|static
name|int
name|add_vif
parameter_list|(
name|vifcp
parameter_list|)
specifier|register
name|struct
name|vifctl
modifier|*
name|vifcp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|viftable
operator|+
name|vifcp
operator|->
name|vifc_vifi
decl_stmt|;
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|sin
init|=
block|{
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_vifi
operator|>=
name|MAXVIFS
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
comment|/* Find the interface with an address in AF_INET family */
name|sin
operator|.
name|sin_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|ifa
operator|=
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_TUNNEL
condition|)
name|vifp
operator|->
name|v_rmt_addr
operator|=
name|vifcp
operator|->
name|vifc_rmt_addr
expr_stmt|;
else|else
block|{
comment|/* Make sure the interface supports multicast */
name|ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* 		 * Enable promiscuous reception of all IP multicasts 		 * from the interface. 		 */
name|satosin
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|satosin
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCADDMULTI
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|vifp
operator|->
name|v_flags
operator|=
name|vifcp
operator|->
name|vifc_flags
expr_stmt|;
name|vifp
operator|->
name|v_threshold
operator|=
name|vifcp
operator|->
name|vifc_threshold
expr_stmt|;
name|vifp
operator|->
name|v_lcl_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|vifp
operator|->
name|v_ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
comment|/* Adjust numvifs up if the vifi is higher than numvifs */
if|if
condition|(
name|numvifs
operator|<=
name|vifcp
operator|->
name|vifc_vifi
condition|)
name|numvifs
operator|=
name|vifcp
operator|->
name|vifc_vifi
operator|+
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a vif from the vif table  */
end_comment

begin_function
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifip
parameter_list|)
specifier|register
name|vifi_t
modifier|*
name|vifip
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|viftable
operator|+
operator|*
name|vifip
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
if|if
condition|(
operator|*
name|vifip
operator|>=
name|numvifs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
if|if
condition|(
name|vifp
operator|->
name|v_lcl_grps
condition|)
name|free
argument_list|(
name|vifp
operator|->
name|v_lcl_grps
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|satosin
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|satosin
argument_list|(
operator|&
name|ifr
operator|.
name|ifr_addr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCDELMULTI
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs down */
for|for
control|(
name|i
operator|=
name|numvifs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|viftable
index|[
name|i
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
break|break;
name|numvifs
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the multicast group in the lgrpctl to the list of local multicast  * group memberships associated with the vif indexed by gcp->lgc_vifi.  */
end_comment

begin_function
specifier|static
name|int
name|add_lgrp
parameter_list|(
name|gcp
parameter_list|)
specifier|register
name|struct
name|lgrplctl
modifier|*
name|gcp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
if|if
condition|(
name|gcp
operator|->
name|lgc_vifi
operator|>=
name|numvifs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vifp
operator|=
name|viftable
operator|+
name|gcp
operator|->
name|lgc_vifi
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|==
literal|0
operator|||
operator|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
comment|/* If not enough space in existing list, allocate a larger one */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_grps_n
operator|+
literal|1
operator|>=
name|vifp
operator|->
name|v_lcl_grps_max
condition|)
block|{
specifier|register
name|int
name|num
decl_stmt|;
specifier|register
name|struct
name|in_addr
modifier|*
name|ip
decl_stmt|;
name|num
operator|=
name|vifp
operator|->
name|v_lcl_grps_max
expr_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
name|num
operator|=
literal|32
expr_stmt|;
comment|/* initial number */
else|else
name|num
operator|+=
name|num
expr_stmt|;
comment|/* double last number */
name|ip
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|malloc
argument_list|(
name|num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
name|num
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX paranoid */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
operator|->
name|v_lcl_grps
argument_list|,
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
name|vifp
operator|->
name|v_lcl_grps_n
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|vifp
operator|->
name|v_lcl_grps_max
operator|=
name|num
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_grps
condition|)
name|free
argument_list|(
name|vifp
operator|->
name|v_lcl_grps
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|vifp
operator|->
name|v_lcl_grps
operator|=
name|ip
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|vifp
operator|->
name|v_lcl_grps
index|[
name|vifp
operator|->
name|v_lcl_grps_n
operator|++
index|]
operator|=
name|gcp
operator|->
name|lgc_gaddr
expr_stmt|;
if|if
condition|(
name|gcp
operator|->
name|lgc_gaddr
operator|.
name|s_addr
operator|==
name|vifp
operator|->
name|v_cached_group
condition|)
name|vifp
operator|->
name|v_cached_result
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete the the local multicast group associated with the vif  * indexed by gcp->lgc_vifi.  */
end_comment

begin_function
specifier|static
name|int
name|del_lgrp
parameter_list|(
name|gcp
parameter_list|)
specifier|register
name|struct
name|lgrplctl
modifier|*
name|gcp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|gcp
operator|->
name|lgc_vifi
operator|>=
name|numvifs
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vifp
operator|=
name|viftable
operator|+
name|gcp
operator|->
name|lgc_vifi
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|==
literal|0
operator|||
operator|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|gcp
operator|->
name|lgc_gaddr
operator|.
name|s_addr
operator|==
name|vifp
operator|->
name|v_cached_group
condition|)
name|vifp
operator|->
name|v_cached_result
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vifp
operator|->
name|v_lcl_grps_n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|same
argument_list|(
operator|&
name|gcp
operator|->
name|lgc_gaddr
argument_list|,
operator|&
name|vifp
operator|->
name|v_lcl_grps
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_lcl_grps_n
operator|--
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vifp
operator|->
name|v_lcl_grps
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|vifp
operator|->
name|v_lcl_grps
index|[
name|i
index|]
argument_list|,
operator|(
name|vifp
operator|->
name|v_lcl_grps_n
operator|-
name|i
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if gaddr is a member of the local group list for vifp.  */
end_comment

begin_function
specifier|static
name|int
name|grplst_member
parameter_list|(
name|vifp
parameter_list|,
name|gaddr
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
name|struct
name|in_addr
name|gaddr
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
specifier|register
name|u_long
name|addr
decl_stmt|;
name|mrtstat
operator|.
name|mrts_grp_lookups
operator|++
expr_stmt|;
name|addr
operator|=
name|gaddr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|vifp
operator|->
name|v_cached_group
condition|)
return|return
operator|(
name|vifp
operator|->
name|v_cached_result
operator|)
return|;
name|mrtstat
operator|.
name|mrts_grp_misses
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vifp
operator|->
name|v_lcl_grps_n
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|addr
operator|==
name|vifp
operator|->
name|v_lcl_grps
index|[
name|i
index|]
operator|.
name|s_addr
condition|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|vifp
operator|->
name|v_cached_group
operator|=
name|addr
expr_stmt|;
name|vifp
operator|->
name|v_cached_result
operator|=
literal|1
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|vifp
operator|->
name|v_cached_group
operator|=
name|addr
expr_stmt|;
name|vifp
operator|->
name|v_cached_result
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A simple hash function: returns MRTHASHMOD of the low-order octet of  * the argument's network or subnet number.  */
end_comment

begin_function
specifier|static
name|u_long
name|nethash
parameter_list|(
name|in
parameter_list|)
name|struct
name|in_addr
name|in
decl_stmt|;
block|{
specifier|register
name|u_long
name|n
decl_stmt|;
name|n
operator|=
name|in_netof
argument_list|(
name|in
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
name|n
operator|>>=
literal|8
expr_stmt|;
return|return
operator|(
name|MRTHASHMOD
argument_list|(
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an mrt entry  */
end_comment

begin_function
specifier|static
name|int
name|add_mrt
parameter_list|(
name|mrtcp
parameter_list|)
specifier|register
name|struct
name|mrtctl
modifier|*
name|mrtcp
decl_stmt|;
block|{
name|struct
name|mrt
modifier|*
name|rt
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|rt
operator|=
name|mrtfind
argument_list|(
name|mrtcp
operator|->
name|mrtc_origin
argument_list|)
condition|)
block|{
comment|/* Just update the route */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rt
operator|->
name|mrt_parent
operator|=
name|mrtcp
operator|->
name|mrtc_parent
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|mrtcp
operator|->
name|mrtc_children
argument_list|,
name|rt
operator|->
name|mrt_children
argument_list|)
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|mrtcp
operator|->
name|mrtc_leaves
argument_list|,
name|rt
operator|->
name|mrt_leaves
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rt
operator|=
operator|(
expr|struct
name|mrt
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
comment|/* 	 * insert new entry at head of hash chain 	 */
name|rt
operator|->
name|mrt_origin
operator|=
name|mrtcp
operator|->
name|mrtc_origin
expr_stmt|;
name|rt
operator|->
name|mrt_originmask
operator|=
name|mrtcp
operator|->
name|mrtc_originmask
expr_stmt|;
name|rt
operator|->
name|mrt_parent
operator|=
name|mrtcp
operator|->
name|mrtc_parent
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|mrtcp
operator|->
name|mrtc_children
argument_list|,
name|rt
operator|->
name|mrt_children
argument_list|)
expr_stmt|;
name|VIFM_COPY
argument_list|(
name|mrtcp
operator|->
name|mrtc_leaves
argument_list|,
name|rt
operator|->
name|mrt_leaves
argument_list|)
expr_stmt|;
comment|/* link into table */
name|hash
operator|=
name|nethash
argument_list|(
name|mrtcp
operator|->
name|mrtc_origin
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mrt_next
operator|=
name|mrttable
index|[
name|hash
index|]
expr_stmt|;
name|mrttable
index|[
name|hash
index|]
operator|=
name|rt
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete an mrt entry  */
end_comment

begin_function
specifier|static
name|int
name|del_mrt
parameter_list|(
name|origin
parameter_list|)
specifier|register
name|struct
name|in_addr
modifier|*
name|origin
decl_stmt|;
block|{
specifier|register
name|struct
name|mrt
modifier|*
name|rt
decl_stmt|,
modifier|*
name|prev_rt
decl_stmt|;
specifier|register
name|u_long
name|hash
init|=
name|nethash
argument_list|(
operator|*
name|origin
argument_list|)
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
for|for
control|(
name|prev_rt
operator|=
name|rt
operator|=
name|mrttable
index|[
name|hash
index|]
init|;
name|rt
condition|;
name|prev_rt
operator|=
name|rt
operator|,
name|rt
operator|=
name|rt
operator|->
name|mrt_next
control|)
if|if
condition|(
name|origin
operator|->
name|s_addr
operator|==
name|rt
operator|->
name|mrt_origin
operator|.
name|s_addr
condition|)
break|break;
if|if
condition|(
operator|!
name|rt
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|cached_mrt
condition|)
name|cached_mrt
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev_rt
operator|==
name|rt
condition|)
name|mrttable
index|[
name|hash
index|]
operator|=
name|rt
operator|->
name|mrt_next
expr_stmt|;
else|else
name|prev_rt
operator|->
name|mrt_next
operator|=
name|rt
operator|->
name|mrt_next
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a route for a given origin IP address.  */
end_comment

begin_function
specifier|static
name|struct
name|mrt
modifier|*
name|mrtfind
parameter_list|(
name|origin
parameter_list|)
name|struct
name|in_addr
name|origin
decl_stmt|;
block|{
specifier|register
name|struct
name|mrt
modifier|*
name|rt
decl_stmt|;
specifier|register
name|u_int
name|hash
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|mrtstat
operator|.
name|mrts_mrt_lookups
operator|++
expr_stmt|;
if|if
condition|(
name|cached_mrt
operator|!=
name|NULL
operator|&&
operator|(
name|origin
operator|.
name|s_addr
operator|&
name|cached_originmask
operator|)
operator|==
name|cached_origin
condition|)
return|return
operator|(
name|cached_mrt
operator|)
return|;
name|mrtstat
operator|.
name|mrts_mrt_misses
operator|++
expr_stmt|;
name|hash
operator|=
name|nethash
argument_list|(
name|origin
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|mrttable
index|[
name|hash
index|]
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|mrt_next
control|)
if|if
condition|(
operator|(
name|origin
operator|.
name|s_addr
operator|&
name|rt
operator|->
name|mrt_originmask
operator|.
name|s_addr
operator|)
operator|==
name|rt
operator|->
name|mrt_origin
operator|.
name|s_addr
condition|)
block|{
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|cached_mrt
operator|=
name|rt
expr_stmt|;
name|cached_origin
operator|=
name|rt
operator|->
name|mrt_origin
operator|.
name|s_addr
expr_stmt|;
name|cached_originmask
operator|=
name|rt
operator|->
name|mrt_originmask
operator|.
name|s_addr
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|rt
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * IP multicast forwarding function. This function assumes that the packet  * pointed to by "ip" has arrived on (or is about to be sent to) the interface  * pointed to by "ifp", and the packet is to be relayed to other networks  * that have members of the packet's destination IP multicast group.  *  * The packet is returned unscathed to the caller, unless it is tunneled  * or erroneous, in which case a non-zero return value tells the caller to  * discard it.  */
end_comment

begin_define
define|#
directive|define
name|IP_HDR_LEN
value|20
end_define

begin_comment
comment|/* # bytes of fixed IP header (excluding options) */
end_comment

begin_define
define|#
directive|define
name|TUNNEL_LEN
value|12
end_define

begin_comment
comment|/* # bytes of IP option for tunnel encapsulation  */
end_comment

begin_function
name|int
name|ip_mforward
parameter_list|(
name|m
parameter_list|,
name|ifp
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mrt
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|int
name|vifi
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ipoptions
decl_stmt|;
name|u_long
name|tunnel_src
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|<
operator|(
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
operator|)
operator|>>
literal|2
operator|||
operator|(
name|ipoptions
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
operator|)
index|[
literal|1
index|]
operator|!=
name|IPOPT_LSRR
condition|)
block|{
comment|/* 		 * Packet arrived via a physical interface. 		 */
name|tunnel_src
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Packet arrived through a tunnel. 		 * 		 * A tunneled packet has a single NOP option and a 		 * two-element loose-source-and-record-route (LSRR) 		 * option immediately following the fixed-size part of 		 * the IP header.  At this point in processing, the IP 		 * header should contain the following IP addresses: 		 * 		 * original source          - in the source address field 		 * destination group        - in the destination address field 		 * remote tunnel end-point  - in the first  element of LSRR 		 * one of this host's addrs - in the second element of LSRR 		 * 		 * NOTE: RFC-1075 would have the original source and 		 * remote tunnel end-point addresses swapped.  However, 		 * that could cause delivery of ICMP error messages to 		 * innocent applications on intermediate routing 		 * hosts!  Therefore, we hereby change the spec. 		 */
comment|/* 		 * Verify that the tunnel options are well-formed. 		 */
if|if
condition|(
name|ipoptions
index|[
literal|0
index|]
operator|!=
name|IPOPT_NOP
operator|||
name|ipoptions
index|[
literal|2
index|]
operator|!=
literal|11
operator|||
comment|/* LSRR option length   */
name|ipoptions
index|[
literal|3
index|]
operator|!=
literal|12
operator|||
comment|/* LSRR address pointer */
operator|(
name|tunnel_src
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|&
name|ipoptions
index|[
literal|4
index|]
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mrtstat
operator|.
name|mrts_bad_tunnel
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * Delete the tunnel options from the packet. 		 */
name|ovbcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|ipoptions
operator|+
name|TUNNEL_LEN
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|ipoptions
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
operator|(
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|TUNNEL_LEN
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|TUNNEL_LEN
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|-=
name|TUNNEL_LEN
operator|>>
literal|2
expr_stmt|;
block|}
comment|/* 	 * Don't forward a packet with time-to-live of zero or one, 	 * or a packet destined to a local-only group. 	 */
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
operator|||
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|<=
name|INADDR_MAX_LOCAL_GROUP
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|tunnel_src
operator|)
return|;
comment|/* 	 * Don't forward if we don't have a route for the packet's origin. 	 */
if|if
condition|(
operator|!
operator|(
name|rt
operator|=
name|mrtfind
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
operator|)
condition|)
block|{
name|mrtstat
operator|.
name|mrts_no_route
operator|++
expr_stmt|;
return|return
operator|(
operator|(
name|int
operator|)
name|tunnel_src
operator|)
return|;
block|}
comment|/* 	 * Don't forward if it didn't arrive from the parent vif for its origin. 	 */
name|vifi
operator|=
name|rt
operator|->
name|mrt_parent
expr_stmt|;
if|if
condition|(
name|tunnel_src
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|||
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|tunnel_src
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|||
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rmt_addr
operator|.
name|s_addr
operator|!=
name|tunnel_src
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|tunnel_src
operator|)
return|;
block|}
comment|/* 	 * For each vif, decide if a copy of the packet should be forwarded. 	 * Forward if: 	 *		- the ttl exceeds the vif's threshold AND 	 *		- the vif is a child in the origin's route AND 	 *		- ( the vif is not a leaf in the origin's route OR 	 *		    the destination group has members on the vif ) 	 * 	 * (This might be speeded up with some sort of cache -- someday.) 	 */
for|for
control|(
name|vifp
operator|=
name|viftable
operator|,
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifp
operator|++
operator|,
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|>
name|vifp
operator|->
name|v_threshold
operator|&&
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|mrt_children
argument_list|)
operator|&&
operator|(
operator|!
name|VIFM_ISSET
argument_list|(
name|vifi
argument_list|,
name|rt
operator|->
name|mrt_leaves
argument_list|)
operator|||
name|grplst_member
argument_list|(
name|vifp
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
condition|)
name|tunnel_send
argument_list|(
name|m
argument_list|,
name|vifp
argument_list|)
expr_stmt|;
else|else
name|phyint_send
argument_list|(
name|m
argument_list|,
name|vifp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
operator|(
name|int
operator|)
name|tunnel_src
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|phyint_send
parameter_list|(
name|m
parameter_list|,
name|vifp
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
specifier|register
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
name|struct
name|ip_moptions
name|simo
decl_stmt|;
name|mb_copy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
name|imo
operator|=
operator|&
name|simo
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|ip
operator|->
name|ip_ttl
operator|-
literal|1
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|ip_output
argument_list|(
name|mb_copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IP_FORWARDING
argument_list|,
name|imo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tunnel_send
parameter_list|(
name|m
parameter_list|,
name|vifp
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|,
modifier|*
name|mb_opts
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip_copy
decl_stmt|;
specifier|register
name|int
name|error
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Make sure that adding the tunnel options won't exceed the 	 * maximum allowed number of option bytes. 	 */
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|>
operator|(
literal|60
operator|-
name|TUNNEL_LEN
operator|)
operator|>>
literal|2
condition|)
block|{
name|mrtstat
operator|.
name|mrts_cant_tunnel
operator|++
expr_stmt|;
return|return;
block|}
comment|/*  	 * Get a private copy of the IP header so that changes to some  	 * of the IP fields don't damage the original header, which is 	 * examined later in ip_input.c. 	 */
name|mb_copy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
name|IP_HDR_LEN
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
name|MGETHDR
argument_list|(
name|mb_opts
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_opts
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Make mb_opts be the new head of the packet chain. 	 * Any options of the packet were left in the old packet chain head 	 */
name|mb_opts
operator|->
name|m_next
operator|=
name|mb_copy
expr_stmt|;
name|mb_opts
operator|->
name|m_len
operator|=
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
expr_stmt|;
name|mb_opts
operator|->
name|m_data
operator|+=
name|MSIZE
operator|-
name|mb_opts
operator|->
name|m_len
expr_stmt|;
name|ip_copy
operator|=
name|mtod
argument_list|(
name|mb_opts
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the base ip header to the new head mbuf. 	 */
operator|*
name|ip_copy
operator|=
operator|*
name|ip
expr_stmt|;
name|ip_copy
operator|->
name|ip_ttl
operator|--
expr_stmt|;
name|ip_copy
operator|->
name|ip_dst
operator|=
name|vifp
operator|->
name|v_rmt_addr
expr_stmt|;
comment|/* remote tunnel end-point */
comment|/* 	 * Adjust the ip header length to account for the tunnel options. 	 */
name|ip_copy
operator|->
name|ip_hl
operator|+=
name|TUNNEL_LEN
operator|>>
literal|2
expr_stmt|;
name|ip_copy
operator|->
name|ip_len
operator|+=
name|TUNNEL_LEN
expr_stmt|;
comment|/* 	 * Add the NOP and LSRR after the base ip header 	 */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip_copy
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IPOPT_NOP
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IPOPT_LSRR
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|11
expr_stmt|;
comment|/* LSRR option length */
operator|*
name|cp
operator|++
operator|=
literal|8
expr_stmt|;
comment|/* LSSR pointer to second element */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|cp
operator|=
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* local tunnel end-point */
name|cp
operator|+=
literal|4
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
name|cp
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/* destination group */
name|error
operator|=
name|ip_output
argument_list|(
name|mb_opts
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IP_FORWARDING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

