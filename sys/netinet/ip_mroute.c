begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * IP multicast forwarding procedures  *  * Written by David Waitzman, BBN Labs, August 1988.  * Modified by Steve Deering, Stanford, February 1989.  * Modified by Mark J. Steiglitz, Stanford, May, 1991  * Modified by Van Jacobson, LBL, January 1993  * Modified by Ajit Thyagarajan, PARC, August 1993  *  * MROUTING 1.8  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/raw_cb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_mroute.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NTOHL
end_ifndef

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|!=
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|NTOHL
parameter_list|(
name|d
parameter_list|)
value|((d) = ntohl((d)))
end_define

begin_define
define|#
directive|define
name|NTOHS
parameter_list|(
name|d
parameter_list|)
value|((d) = ntohs((u_short)(d)))
end_define

begin_define
define|#
directive|define
name|HTONL
parameter_list|(
name|d
parameter_list|)
value|((d) = htonl((d)))
end_define

begin_define
define|#
directive|define
name|HTONS
parameter_list|(
name|d
parameter_list|)
value|((d) = htons((u_short)(d)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NTOHL
parameter_list|(
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|NTOHS
parameter_list|(
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|HTONL
parameter_list|(
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|HTONS
parameter_list|(
name|d
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|mrtstat
name|mrtstat
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTING
end_ifndef

begin_comment
comment|/*  * Dummy routines and globals used when multicast routing is not compiled in.  */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|ip_mrouter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|ip_mrtproto
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_ip_mrouter_cmd
parameter_list|(
name|cmd
parameter_list|,
name|so
parameter_list|,
name|m
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_cmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
init|=
name|_ip_mrouter_cmd
function_decl|;
end_function_decl

begin_function
name|int
name|_ip_mrouter_done
parameter_list|()
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_done
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|_ip_mrouter_done
function_decl|;
end_function_decl

begin_function
name|int
name|_ip_mforward
parameter_list|(
name|ip
parameter_list|,
name|ifp
parameter_list|,
name|m
parameter_list|,
name|imo
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mforward
function_decl|)
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
init|=
name|_ip_mforward
function_decl|;
end_function_decl

begin_function
name|int
name|_mrt_ioctl
parameter_list|(
name|int
name|req
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|mrt_ioctl
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
init|=
name|_mrt_ioctl
function_decl|;
end_function_decl

begin_function
name|void
name|multiencap_decap
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
comment|/* XXX must fixup manually */
name|rip_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|legal_vif_num
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|INSIZ
value|sizeof(struct in_addr)
end_define

begin_define
define|#
directive|define
name|same
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|(bcmp((caddr_t)(a1), (caddr_t)(a2), INSIZ) == 0)
end_define

begin_define
define|#
directive|define
name|MT_MRTABLE
value|MT_RTABLE
end_define

begin_comment
comment|/* since nothing else uses it */
end_comment

begin_comment
comment|/*  * Globals.  All but ip_mrouter and ip_mrtproto could be static,  * except for netstat or debugging purposes.  */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|ip_mrouter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ip_mrtproto
init|=
name|IGMP_DVMRP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for netstat only */
end_comment

begin_define
define|#
directive|define
name|NO_RTE_FOUND
value|0x1
end_define

begin_define
define|#
directive|define
name|RTE_FOUND
value|0x2
end_define

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|mfctable
index|[
name|MFCTBLSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|vif
name|viftable
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|mrtdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug level 	*/
end_comment

begin_decl_stmt
name|u_int
name|tbfdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbf debug level 	*/
end_comment

begin_decl_stmt
name|u_long
name|timeout_val
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of outstanding upcalls */
end_comment

begin_comment
comment|/*  * Define the token bucket filter structures  * tbftable -> each vif has one of these for storing info   * qtable   -> each interface has an associated queue of pkts   */
end_comment

begin_decl_stmt
name|struct
name|tbf
name|tbftable
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pkt_queue
name|qtable
index|[
name|MAXVIFS
index|]
index|[
name|MAXQSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'Interfaces' associated with decapsulator (so we can tell  * packets that went through it from ones that get reflected  * by a broken gateway).  These interfaces are never linked into  * the system ifnet list& no routes point to them.  I.e., packets  * can't be sent this way.  They only exist as a placeholder for  * multicast source verification.  */
end_comment

begin_decl_stmt
name|struct
name|ifnet
name|multicast_decap_if
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENCAP_TTL
value|64
end_define

begin_define
define|#
directive|define
name|ENCAP_PROTO
value|4
end_define

begin_comment
comment|/* prototype IP hdr for encapsulated packets */
end_comment

begin_decl_stmt
name|struct
name|ip
name|multicast_encap_iphdr
init|=
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
block|,
name|IPVERSION
block|,
else|#
directive|else
name|IPVERSION
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
block|,
endif|#
directive|endif
literal|0
block|,
comment|/* tos */
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
block|,
comment|/* total length */
literal|0
block|,
comment|/* id */
literal|0
block|,
comment|/* frag offset */
name|ENCAP_TTL
block|,
name|ENCAP_PROTO
block|,
literal|0
block|,
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
specifier|static
name|vifi_t
name|numvifs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * one-back cache used by multiencap_decap to locate a tunnel's vif  * given a datagram's src ip address.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|last_encap_src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vif
modifier|*
name|last_encap_vif
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|u_long
name|nethash_fc
parameter_list|(
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mfc
modifier|*
name|mfcfind
parameter_list|(
name|u_long
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_sg_cnt
parameter_list|(
name|struct
name|sioc_sg_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_vif_cnt
parameter_list|(
name|struct
name|sioc_vif_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|get_vifs
parameter_list|(
name|caddr_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_vif
parameter_list|(
name|struct
name|vifctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifi_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_mfc
parameter_list|(
name|struct
name|mfcctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_mfc
parameter_list|(
name|struct
name|delmfcctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleanup_cache
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip_mdq
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|struct
name|mfc
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
function_decl|(
modifier|*
name|legal_vif_num
function_decl|)
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|phyint_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|srcrt_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encap_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_control
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|u_long
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_queue
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_process_q
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_dequeue
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_reprocess_q
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|tbf_dq_sel
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_send_packet
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|tbf_update_tokens
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|priority
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * A simple hash function: returns MFCHASHMOD of the low-order octet of  * the argument's network or subnet number and the multicast group assoc.  */
end_comment

begin_function
specifier|static
name|u_long
name|nethash_fc
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
specifier|register
name|u_long
name|m
decl_stmt|;
specifier|register
name|u_long
name|n
decl_stmt|;
block|{
name|struct
name|in_addr
name|in1
decl_stmt|;
name|struct
name|in_addr
name|in2
decl_stmt|;
name|in1
operator|.
name|s_addr
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|in_netof
argument_list|(
name|in1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
name|m
operator|>>=
literal|8
expr_stmt|;
name|in2
operator|.
name|s_addr
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|in_netof
argument_list|(
name|in2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|&
literal|0xff
operator|)
operator|==
literal|0
condition|)
name|n
operator|>>=
literal|8
expr_stmt|;
return|return
operator|(
name|MFCHASHMOD
argument_list|(
name|m
argument_list|)
operator|^
name|MFCHASHMOD
argument_list|(
name|n
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this is a direct-mapped cache used to speed the mapping from a  * datagram source address to the associated multicast route.  Note  * that unlike mrttable, the hash is on IP address, not IP net number.  */
end_comment

begin_define
define|#
directive|define
name|MFCHASHSIZ
value|1024
end_define

begin_define
define|#
directive|define
name|MFCHASH
parameter_list|(
name|a
parameter_list|,
name|g
parameter_list|)
value|((((a)>> 20) ^ ((a)>> 10) ^ (a) ^ \ 			((g)>> 20) ^ ((g)>> 10) ^ (g))& (MFCHASHSIZ-1))
end_define

begin_decl_stmt
name|struct
name|mfc
modifier|*
name|mfchash
index|[
name|MFCHASHSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Find a route for a given origin IP address and Multicast group address  * Type of service parameter to be added in the future!!!  */
end_comment

begin_define
define|#
directive|define
name|MFCFIND
parameter_list|(
name|o
parameter_list|,
name|g
parameter_list|,
name|rt
parameter_list|)
value|{ \ 	register u_int _mrhasho = o; \ 	register u_int _mrhashg = g; \ 	_mrhasho = MFCHASH(_mrhasho, _mrhashg); \ 	++mrtstat.mrts_mfc_lookups; \ 	rt = mfchash[_mrhasho]; \ 	if ((rt == NULL) || \ 	    ((o& rt->mfc_originmask.s_addr) != rt->mfc_origin.s_addr) || \ 	     (g != rt->mfc_mcastgrp.s_addr)) \ 	     if ((rt = mfcfind(o, g)) != NULL) \ 		mfchash[_mrhasho] = rt; \ }
end_define

begin_comment
comment|/*  * Find route by examining hash table entries  */
end_comment

begin_function
specifier|static
name|struct
name|mfc
modifier|*
name|mfcfind
parameter_list|(
name|origin
parameter_list|,
name|mcastgrp
parameter_list|)
name|u_long
name|origin
decl_stmt|;
name|u_long
name|mcastgrp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_rt
decl_stmt|;
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
specifier|register
name|u_long
name|hash
decl_stmt|;
name|hash
operator|=
name|nethash_fc
argument_list|(
name|origin
argument_list|,
name|mcastgrp
argument_list|)
expr_stmt|;
for|for
control|(
name|mb_rt
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|mb_rt
condition|;
name|mb_rt
operator|=
name|mb_rt
operator|->
name|m_next
control|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|origin
operator|&
name|rt
operator|->
name|mfc_originmask
operator|.
name|s_addr
operator|)
operator|==
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|mcastgrp
operator|==
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|mb_rt
operator|->
name|m_act
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|rt
operator|)
return|;
block|}
name|mrtstat
operator|.
name|mrts_mfc_misses
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Macros to compute elapsed time efficiently  * Borrowed from Van Jacobson's scheduling code  */
end_comment

begin_define
define|#
directive|define
name|TV_DELTA
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|delta
parameter_list|)
value|{ \ 	    register int xxs; \ 		\ 	    delta = (a).tv_usec - (b).tv_usec; \ 	    if ((xxs = (a).tv_sec - (b).tv_sec)) { \ 	       switch (xxs) { \ 		      case 2: \ 			  delta += 1000000; \
comment|/* fall through */
value|\ 		      case 1: \ 			  delta += 1000000; \ 			  break; \ 		      default: \ 			  delta += (1000000 * xxs); \ 	       } \ 	    } \ }
end_define

begin_define
define|#
directive|define
name|TV_LT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a).tv_usec< (b).tv_usec&& \ 	      (a).tv_sec<= (b).tv_sec) || (a).tv_sec< (b).tv_sec)
end_define

begin_comment
comment|/*  * Handle DVMRP setsockopt commands to modify the multicast routing tables.  */
end_comment

begin_function
name|int
name|_ip_mrouter_cmd
parameter_list|(
name|cmd
parameter_list|,
name|so
parameter_list|,
name|m
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
name|cmd
operator|!=
name|DVMRP_INIT
operator|&&
name|so
operator|!=
name|ip_mrouter
condition|)
return|return
name|EACCES
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DVMRP_INIT
case|:
return|return
name|ip_mrouter_init
argument_list|(
name|so
argument_list|)
return|;
case|case
name|DVMRP_DONE
case|:
return|return
name|ip_mrouter_done
argument_list|()
return|;
case|case
name|DVMRP_ADD_VIF
case|:
return|return
name|add_vif
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|vifctl
operator|*
argument_list|)
argument_list|)
return|;
case|case
name|DVMRP_DEL_VIF
case|:
return|return
name|del_vif
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|vifi_t
operator|*
argument_list|)
argument_list|)
return|;
case|case
name|DVMRP_ADD_MFC
case|:
return|return
name|add_mfc
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|mfcctl
operator|*
argument_list|)
argument_list|)
return|;
case|case
name|DVMRP_DEL_MFC
case|:
return|return
name|del_mfc
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|delmfcctl
operator|*
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|EOPNOTSUPP
return|;
block|}
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_cmd
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
init|=
name|_ip_mrouter_cmd
function_decl|;
end_function_decl

begin_comment
comment|/*  * Handle ioctl commands to obtain information from the cache  */
end_comment

begin_function
name|int
name|_mrt_ioctl
parameter_list|(
name|cmd
parameter_list|,
name|data
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
operator|(
name|SIOCGETVIFINF
operator|)
case|:
comment|/* Read Virtual Interface (m/cast) */
return|return
operator|(
name|get_vifs
argument_list|(
name|data
argument_list|)
operator|)
return|;
break|break;
case|case
operator|(
name|SIOCGETVIFCNT
operator|)
case|:
return|return
operator|(
name|get_vif_cnt
argument_list|(
operator|(
expr|struct
name|sioc_vif_req
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
break|break;
case|case
operator|(
name|SIOCGETSGCNT
operator|)
case|:
return|return
operator|(
name|get_sg_cnt
argument_list|(
operator|(
expr|struct
name|sioc_sg_req
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|mrt_ioctl
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
init|=
name|_mrt_ioctl
function_decl|;
end_function_decl

begin_comment
comment|/*  * returns the packet count for the source group provided  */
end_comment

begin_function
name|int
name|get_sg_cnt
parameter_list|(
name|req
parameter_list|)
specifier|register
name|struct
name|sioc_sg_req
modifier|*
name|req
decl_stmt|;
block|{
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|MFCFIND
argument_list|(
name|req
operator|->
name|src
operator|.
name|s_addr
argument_list|,
name|req
operator|->
name|grp
operator|.
name|s_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
name|req
operator|->
name|count
operator|=
name|rt
operator|->
name|mfc_pkt_cnt
expr_stmt|;
else|else
name|req
operator|->
name|count
operator|=
literal|0xffffffff
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * returns the input and output packet counts on the interface provided  */
end_comment

begin_function
name|int
name|get_vif_cnt
parameter_list|(
name|req
parameter_list|)
specifier|register
name|struct
name|sioc_vif_req
modifier|*
name|req
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
init|=
name|req
operator|->
name|vifi
decl_stmt|;
name|req
operator|->
name|icount
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_in
expr_stmt|;
name|req
operator|->
name|ocount
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|get_vifs
parameter_list|(
name|data
parameter_list|)
name|char
modifier|*
name|data
decl_stmt|;
block|{
name|struct
name|vif_conf
modifier|*
name|vifc
init|=
operator|(
expr|struct
name|vif_conf
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|vif_req
modifier|*
name|vifrp
decl_stmt|,
name|vifr
decl_stmt|;
name|int
name|space
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|s
decl_stmt|;
name|space
operator|=
name|vifc
operator|->
name|vifc_len
expr_stmt|;
name|vifrp
operator|=
name|vifc
operator|->
name|vifc_req
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|vifc
operator|->
name|vifc_num
operator|=
name|numvifs
expr_stmt|;
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
operator|,
name|vifrp
operator|++
control|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|vifr
operator|.
name|v_flags
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
expr_stmt|;
name|vifr
operator|.
name|v_threshold
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_threshold
expr_stmt|;
name|vifr
operator|.
name|v_lcl_addr
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
expr_stmt|;
name|vifr
operator|.
name|v_rmt_addr
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rmt_addr
expr_stmt|;
name|strncpy
argument_list|(
name|vifr
operator|.
name|v_if_name
argument_list|,
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|->
name|if_name
argument_list|,
name|IFNAMSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|vifr
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|vifr
argument_list|,
operator|(
name|caddr_t
operator|)
name|vifrp
argument_list|,
call|(
name|u_int
call|)
argument_list|(
sizeof|sizeof
name|vifr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Enable multicast routing  */
end_comment

begin_function
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_IGMP
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
name|ip_mrouter
operator|!=
name|NULL
condition|)
return|return
name|EADDRINUSE
return|;
name|ip_mrouter
operator|=
name|so
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mrouter_init"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Disable multicast routing  */
end_comment

begin_function
name|int
name|_ip_mrouter_done
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb_rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*      * For each phyint in use, disable promiscuous reception of all IP      * multicasts.      */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCDELMULTI
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|qtable
argument_list|,
sizeof|sizeof
argument_list|(
name|qtable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tbftable
argument_list|,
sizeof|sizeof
argument_list|(
name|tbftable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|viftable
argument_list|,
sizeof|sizeof
argument_list|(
name|viftable
argument_list|)
argument_list|)
expr_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
comment|/*      * Check if any outstanding timeouts remain      */
if|if
condition|(
name|timeout_val
operator|!=
literal|0
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MFCTBLSIZ
condition|;
name|i
operator|++
control|)
block|{
name|mb_rt
operator|=
name|mfctable
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|mb_rt
condition|)
block|{
if|if
condition|(
name|mb_rt
operator|->
name|m_act
operator|!=
name|NULL
condition|)
block|{
name|untimeout
argument_list|(
name|cleanup_cache
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb_rt
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|=
name|mb_rt
operator|->
name|m_act
condition|)
block|{
name|mb_rt
operator|->
name|m_act
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|rte
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rtdetq
operator|*
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|timeout_val
operator|--
expr_stmt|;
block|}
name|mb_rt
operator|=
name|mb_rt
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|timeout_val
operator|==
literal|0
condition|)
break|break;
block|}
comment|/*      * Free all multicast forwarding cache entries.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MFCTBLSIZ
condition|;
name|i
operator|++
control|)
name|m_freem
argument_list|(
name|mfctable
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mfctable
argument_list|,
sizeof|sizeof
argument_list|(
name|mfctable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mfchash
argument_list|,
sizeof|sizeof
argument_list|(
name|mfchash
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reset de-encapsulation cache      */
name|last_encap_src
operator|=
name|NULL
expr_stmt|;
name|last_encap_vif
operator|=
name|NULL
expr_stmt|;
name|ip_mrouter
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mrouter_done"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_done
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|_ip_mrouter_done
function_decl|;
end_function_decl

begin_comment
comment|/*  * Add a vif to the vif table  */
end_comment

begin_function
specifier|static
name|int
name|add_vif
parameter_list|(
name|vifcp
parameter_list|)
specifier|register
name|struct
name|vifctl
modifier|*
name|vifcp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|viftable
operator|+
name|vifcp
operator|->
name|vifc_vifi
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|sin
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|tbf
modifier|*
name|v_tbf
init|=
name|tbftable
operator|+
name|vifcp
operator|->
name|vifc_vifi
decl_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_vifi
operator|>=
name|MAXVIFS
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
return|return
name|EADDRINUSE
return|;
comment|/* Find the interface with an address in AF_INET family */
name|sin
operator|.
name|sin_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|ifa
operator|=
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
if|if
condition|(
operator|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_SRCRT
operator|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|inited
condition|)
block|{
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|MAXVIFS
condition|;
operator|++
name|s
control|)
block|{
name|multicast_decap_if
index|[
name|s
index|]
operator|.
name|if_name
operator|=
literal|"mdecap"
expr_stmt|;
name|multicast_decap_if
index|[
name|s
index|]
operator|.
name|if_unit
operator|=
name|s
expr_stmt|;
block|}
name|inited
operator|=
literal|1
expr_stmt|;
block|}
name|ifp
operator|=
operator|&
name|multicast_decap_if
index|[
name|vifcp
operator|->
name|vifc_vifi
index|]
expr_stmt|;
block|}
else|else
block|{
name|ifp
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the interface supports multicast */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* Enable promiscuous reception of all IP multicasts from the if */
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCADDMULTI
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* define parameters for the tbf structure */
name|vifp
operator|->
name|v_tbf
operator|=
name|v_tbf
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|last_pkt_t
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_flags
operator|=
name|vifcp
operator|->
name|vifc_flags
expr_stmt|;
name|vifp
operator|->
name|v_threshold
operator|=
name|vifcp
operator|->
name|vifc_threshold
expr_stmt|;
name|vifp
operator|->
name|v_lcl_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|vifp
operator|->
name|v_rmt_addr
operator|=
name|vifcp
operator|->
name|vifc_rmt_addr
expr_stmt|;
name|vifp
operator|->
name|v_ifp
operator|=
name|ifp
expr_stmt|;
name|vifp
operator|->
name|v_rate_limit
operator|=
name|vifcp
operator|->
name|vifc_rate_limit
expr_stmt|;
comment|/* initialize per vif pkt counters */
name|vifp
operator|->
name|v_pkt_in
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_pkt_out
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs up if the vifi is higher than numvifs */
if|if
condition|(
name|numvifs
operator|<=
name|vifcp
operator|->
name|vifc_vifi
condition|)
name|numvifs
operator|=
name|vifcp
operator|->
name|vifc_vifi
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_vif #%d, lcladdr %x, %s %x, thresh %x, rate %d"
argument_list|,
name|vifcp
operator|->
name|vifc_vifi
argument_list|,
name|ntohl
argument_list|(
name|vifcp
operator|->
name|vifc_lcl_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
literal|"rmtaddr"
else|:
literal|"mask"
argument_list|,
name|ntohl
argument_list|(
name|vifcp
operator|->
name|vifc_rmt_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|vifcp
operator|->
name|vifc_threshold
argument_list|,
name|vifcp
operator|->
name|vifc_rate_limit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a vif from the vif table  */
end_comment

begin_function
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifip
parameter_list|)
name|vifi_t
modifier|*
name|vifip
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|viftable
operator|+
operator|*
name|vifip
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|*
name|vifip
operator|>=
name|numvifs
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_ioctl
call|)
argument_list|(
name|ifp
argument_list|,
name|SIOCDELMULTI
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ifr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vifp
operator|==
name|last_encap_vif
condition|)
block|{
name|last_encap_vif
operator|=
literal|0
expr_stmt|;
name|last_encap_src
operator|=
literal|0
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|qtable
index|[
operator|*
name|vifip
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|qtable
index|[
operator|*
name|vifip
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
operator|->
name|v_tbf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|vifp
operator|->
name|v_tbf
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs down */
for|for
control|(
name|vifi
operator|=
name|numvifs
init|;
name|vifi
operator|>
literal|0
condition|;
name|vifi
operator|--
control|)
if|if
condition|(
name|viftable
index|[
name|vifi
operator|-
literal|1
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
break|break;
name|numvifs
operator|=
name|vifi
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"del_vif %d, numvifs %d"
argument_list|,
operator|*
name|vifip
argument_list|,
name|numvifs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|add_mfc
parameter_list|(
name|mfccp
parameter_list|)
name|struct
name|mfcctl
modifier|*
name|mfccp
decl_stmt|;
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|struct
name|mfc
modifier|*
name|rt1
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|prev_mb_rt
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb_ntry
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
specifier|register
name|u_short
name|nstl
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rt
operator|=
name|mfcfind
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
comment|/* If an entry already exists, just update the fields */
if|if
condition|(
name|rt
condition|)
block|{
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc update o %x g %x m %x p %x"
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_originmask
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|VIFM_COPY
argument_list|(
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
argument_list|,
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*       * Find the entry for which the upcall was made and update      */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|hash
operator|=
name|nethash_fc
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_mb_rt
operator|=
name|mb_rt
operator|=
name|mfctable
index|[
name|hash
index|]
operator|,
name|nstl
operator|=
literal|0
init|;
name|mb_rt
condition|;
name|prev_mb_rt
operator|=
name|mb_rt
operator|,
name|mb_rt
operator|=
name|mb_rt
operator|->
name|m_next
control|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|&
name|mfccp
operator|->
name|mfcc_originmask
operator|.
name|s_addr
operator|)
operator|==
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|==
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|mb_rt
operator|->
name|m_act
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|nstl
operator|++
condition|)
block|{
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc o %x g %x m %x p %x dbg %x"
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_originmask
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|,
name|mb_rt
operator|->
name|m_act
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_originmask
operator|=
name|mfccp
operator|->
name|mfcc_originmask
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|VIFM_COPY
argument_list|(
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
argument_list|,
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt1
operator|=
name|rt
expr_stmt|;
block|}
comment|/* prevent cleanup of cache entry */
name|untimeout
argument_list|(
name|cleanup_cache
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb_rt
argument_list|)
expr_stmt|;
name|timeout_val
operator|--
expr_stmt|;
comment|/* free packets Qed at the end of this entry */
while|while
condition|(
name|mb_rt
operator|->
name|m_act
condition|)
block|{
name|mb_ntry
operator|=
name|mb_rt
operator|->
name|m_act
expr_stmt|;
name|rte
operator|=
name|mtod
argument_list|(
name|mb_ntry
argument_list|,
expr|struct
name|rtdetq
operator|*
argument_list|)
expr_stmt|;
name|ip_mdq
argument_list|(
name|rte
operator|->
name|m
argument_list|,
name|rte
operator|->
name|ifp
argument_list|,
name|rte
operator|->
name|tunnel_src
argument_list|,
name|rt1
argument_list|,
name|rte
operator|->
name|imo
argument_list|)
expr_stmt|;
name|mb_rt
operator|->
name|m_act
operator|=
name|mb_ntry
operator|->
name|m_act
expr_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|mb_ntry
argument_list|)
expr_stmt|;
block|}
comment|/*  	     * If more than one entry was created for a single upcall 	     * delete that entry 	     */
if|if
condition|(
name|nstl
operator|>
literal|1
condition|)
block|{
name|MFREE
argument_list|(
name|mb_rt
argument_list|,
name|prev_mb_rt
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|mb_rt
operator|=
name|prev_mb_rt
expr_stmt|;
block|}
block|}
block|}
comment|/*      * It is possible that an entry is being inserted without an upcall      */
if|if
condition|(
name|nstl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc no upcall h %d o %x g %x m %x p %x"
argument_list|,
name|hash
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_originmask
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_mb_rt
operator|=
name|mb_rt
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|mb_rt
condition|;
name|prev_mb_rt
operator|=
name|mb_rt
operator|,
name|mb_rt
operator|=
name|mb_rt
operator|->
name|m_next
control|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|&
name|mfccp
operator|->
name|mfcc_originmask
operator|.
name|s_addr
operator|)
operator|==
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|==
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
operator|)
condition|)
block|{
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_originmask
operator|=
name|mfccp
operator|->
name|mfcc_originmask
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|VIFM_COPY
argument_list|(
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
argument_list|,
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mb_rt
operator|==
name|NULL
condition|)
block|{
comment|/* no upcall, so make a new entry */
name|MGET
argument_list|(
name|mb_rt
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_MRTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
comment|/* insert new entry at head of hash chain */
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_originmask
operator|=
name|mfccp
operator|->
name|mfcc_originmask
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|VIFM_COPY
argument_list|(
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
argument_list|,
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
comment|/* link into table */
name|mb_rt
operator|->
name|m_next
operator|=
name|mfctable
index|[
name|hash
index|]
expr_stmt|;
name|mfctable
index|[
name|hash
index|]
operator|=
name|mb_rt
expr_stmt|;
name|mb_rt
operator|->
name|m_act
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|del_mfc
parameter_list|(
name|mfccp
parameter_list|)
name|struct
name|delmfcctl
modifier|*
name|mfccp
decl_stmt|;
block|{
name|struct
name|in_addr
name|origin
decl_stmt|;
name|struct
name|in_addr
name|mcastgrp
decl_stmt|;
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb_rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|prev_mb_rt
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|struct
name|mfc
modifier|*
modifier|*
name|cmfc
decl_stmt|;
name|struct
name|mfc
modifier|*
modifier|*
name|cmfcend
decl_stmt|;
name|int
name|s
decl_stmt|,
name|i
decl_stmt|;
name|origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|hash
operator|=
name|nethash_fc
argument_list|(
name|origin
operator|.
name|s_addr
argument_list|,
name|mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"del_mfc orig %x mcastgrp %x"
argument_list|,
name|ntohl
argument_list|(
name|origin
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|prev_mb_rt
operator|=
name|mb_rt
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|mb_rt
condition|;
name|prev_mb_rt
operator|=
name|mb_rt
operator|,
name|mb_rt
operator|=
name|mb_rt
operator|->
name|m_next
control|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|&&
name|mcastgrp
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|&&
name|mb_rt
operator|->
name|m_act
operator|==
name|NULL
condition|)
break|break;
block|}
if|if
condition|(
name|mb_rt
operator|==
name|NULL
condition|)
block|{
return|return
name|ESRCH
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|cmfc
operator|=
name|mfchash
expr_stmt|;
name|cmfcend
operator|=
name|cmfc
operator|+
name|MFCHASHSIZ
expr_stmt|;
for|for
control|(
init|;
name|cmfc
operator|<
name|cmfcend
condition|;
operator|++
name|cmfc
control|)
if|if
condition|(
operator|*
name|cmfc
operator|==
name|rt
condition|)
operator|*
name|cmfc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prev_mb_rt
operator|!=
name|mb_rt
condition|)
block|{
comment|/* if moved past head of list */
name|MFREE
argument_list|(
name|mb_rt
argument_list|,
name|prev_mb_rt
operator|->
name|m_next
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* delete head of list, it is in the table */
name|mfctable
index|[
name|hash
index|]
operator|=
name|m_free
argument_list|(
name|mb_rt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * IP multicast forwarding function. This function assumes that the packet  * pointed to by "ip" has arrived on (or is about to be sent to) the interface  * pointed to by "ifp", and the packet is to be relayed to other networks  * that have members of the packet's destination IP multicast group.  *  * The packet is returned unscathed to the caller, unless it is tunneled  * or erroneous, in which case a non-zero return value tells the caller to  * discard it.  */
end_comment

begin_define
define|#
directive|define
name|IP_HDR_LEN
value|20
end_define

begin_comment
comment|/* # bytes of fixed IP header (excluding options) */
end_comment

begin_define
define|#
directive|define
name|TUNNEL_LEN
value|12
end_define

begin_comment
comment|/* # bytes of IP option for tunnel encapsulation  */
end_comment

begin_function
name|int
name|_ip_mforward
parameter_list|(
name|ip
parameter_list|,
name|ifp
parameter_list|,
name|m
parameter_list|,
name|imo
parameter_list|)
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ipoptions
decl_stmt|;
name|u_long
name|tunnel_src
decl_stmt|;
specifier|static
name|struct
name|sockproto
name|k_igmpproto
init|=
block|{
name|AF_INET
block|,
name|IPPROTO_IGMP
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|k_igmpsrc
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|k_igmpdst
init|=
block|{
name|AF_INET
block|}
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mn
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|k_data
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|mrtdebug
operator|>
literal|1
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: src %x, dst %x, ifp %x"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|<
operator|(
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
operator|)
operator|>>
literal|2
operator|||
operator|(
name|ipoptions
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
operator|)
index|[
literal|1
index|]
operator|!=
name|IPOPT_LSRR
condition|)
block|{
comment|/* 	 * Packet arrived via a physical interface. 	 */
name|tunnel_src
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Packet arrived through a source-route tunnel. 	 * 	 * A source-route tunneled packet has a single NOP option and a 	 * two-element 	 * loose-source-and-record-route (LSRR) option immediately following 	 * the fixed-size part of the IP header.  At this point in processing, 	 * the IP header should contain the following IP addresses: 	 * 	 *	original source          - in the source address field 	 *	destination group        - in the destination address field 	 *	remote tunnel end-point  - in the first  element of LSRR 	 *	one of this host's addrs - in the second element of LSRR 	 * 	 * NOTE: RFC-1075 would have the original source and remote tunnel 	 *	 end-point addresses swapped.  However, that could cause 	 *	 delivery of ICMP error messages to innocent applications 	 *	 on intermediate routing hosts!  Therefore, we hereby 	 *	 change the spec. 	 */
comment|/* 	 * Verify that the tunnel options are well-formed. 	 */
if|if
condition|(
name|ipoptions
index|[
literal|0
index|]
operator|!=
name|IPOPT_NOP
operator|||
name|ipoptions
index|[
literal|2
index|]
operator|!=
literal|11
operator|||
comment|/* LSRR option length   */
name|ipoptions
index|[
literal|3
index|]
operator|!=
literal|12
operator|||
comment|/* LSRR address pointer */
operator|(
name|tunnel_src
operator|=
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|&
name|ipoptions
index|[
literal|4
index|]
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mrtstat
operator|.
name|mrts_bad_tunnel
operator|++
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: bad tunnel from %u (%x %x %x %x %x %x)"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ipoptions
index|[
literal|0
index|]
argument_list|,
name|ipoptions
index|[
literal|1
index|]
argument_list|,
name|ipoptions
index|[
literal|2
index|]
argument_list|,
name|ipoptions
index|[
literal|3
index|]
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|&
name|ipoptions
index|[
literal|4
index|]
operator|)
argument_list|,
operator|*
operator|(
name|u_long
operator|*
operator|)
operator|(
operator|&
name|ipoptions
index|[
literal|8
index|]
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Delete the tunnel options from the packet. 	 */
name|ovbcopy
argument_list|(
call|(
name|caddr_t
call|)
argument_list|(
name|ipoptions
operator|+
name|TUNNEL_LEN
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|ipoptions
argument_list|,
call|(
name|unsigned
call|)
argument_list|(
name|m
operator|->
name|m_len
operator|-
operator|(
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|TUNNEL_LEN
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|TUNNEL_LEN
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|-=
name|TUNNEL_LEN
operator|>>
literal|2
expr_stmt|;
name|ifp
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Don't forward a packet with time-to-live of zero or one,      * or a packet destined to a local-only group.      */
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
operator|||
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|<=
name|INADDR_MAX_LOCAL_GROUP
condition|)
return|return
operator|(
name|int
operator|)
name|tunnel_src
return|;
comment|/*      * Determine forwarding vifs from the forwarding cache table      */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|MFCFIND
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
comment|/* Entry exists, so forward if necessary */
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip_mdq
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|tunnel_src
argument_list|,
name|rt
argument_list|,
name|imo
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * If we don't have a route for packet's origin, 	 * Make a copy of the packet& 	 * send message to routing daemon 	 */
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_rt
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_ntry
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mb0
decl_stmt|;
specifier|register
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|rte_m
decl_stmt|;
specifier|register
name|u_long
name|hash
decl_stmt|;
specifier|register
name|struct
name|timeval
name|tp
decl_stmt|;
name|mrtstat
operator|.
name|mrts_no_route
operator|++
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: no rte s %x g %x"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is there an upcall waiting for this packet? */
name|hash
operator|=
name|nethash_fc
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|mb_rt
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|mb_rt
condition|;
name|mb_rt
operator|=
name|mb_rt
operator|->
name|m_next
control|)
block|{
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|&
name|rt
operator|->
name|mfc_originmask
operator|.
name|s_addr
operator|)
operator|==
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|mb_rt
operator|->
name|m_act
operator|!=
name|NULL
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|mb_rt
operator|==
name|NULL
condition|)
block|{
comment|/* no upcall, so make a new entry */
name|MGET
argument_list|(
name|mb_rt
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_MRTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
comment|/* insert new entry at head of hash chain */
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|rt
operator|->
name|mfc_originmask
operator|.
name|s_addr
operator|=
operator|(
name|u_long
operator|)
literal|0xffffffff
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/* link into table */
name|hash
operator|=
name|nethash_fc
argument_list|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
argument_list|,
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|mb_rt
operator|->
name|m_next
operator|=
name|mfctable
index|[
name|hash
index|]
expr_stmt|;
name|mfctable
index|[
name|hash
index|]
operator|=
name|mb_rt
expr_stmt|;
name|mb_rt
operator|->
name|m_act
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* determine if q has overflowed */
for|for
control|(
name|rte_m
operator|=
name|mb_rt
operator|,
name|hash
operator|=
literal|0
init|;
name|rte_m
operator|->
name|m_act
condition|;
name|rte_m
operator|=
name|rte_m
operator|->
name|m_act
control|)
name|hash
operator|++
expr_stmt|;
if|if
condition|(
name|hash
operator|>
name|MAX_UPQ
condition|)
block|{
name|mrtstat
operator|.
name|mrts_upq_ovflw
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* add this packet and timing, ifp info to m_act */
name|MGET
argument_list|(
name|mb_ntry
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_ntry
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|mb_ntry
operator|->
name|m_act
operator|=
name|NULL
expr_stmt|;
name|rte
operator|=
name|mtod
argument_list|(
name|mb_ntry
argument_list|,
expr|struct
name|rtdetq
operator|*
argument_list|)
expr_stmt|;
name|mb0
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb0
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|rte
operator|->
name|m
operator|=
name|mb0
expr_stmt|;
name|rte
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|rte
operator|->
name|tunnel_src
operator|=
name|tunnel_src
expr_stmt|;
name|rte
operator|->
name|imo
operator|=
name|imo
expr_stmt|;
name|rte_m
operator|->
name|m_act
operator|=
name|mb_ntry
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hash
operator|==
literal|0
condition|)
block|{
comment|/*  	     * Send message to routing daemon to install  	     * a route into the kernel table 	     */
name|k_igmpsrc
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|k_igmpdst
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|mm
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|k_data
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|k_data
operator|->
name|ip_p
operator|=
literal|0
expr_stmt|;
name|mrtstat
operator|.
name|mrts_upcalls
operator|++
expr_stmt|;
name|raw_input
argument_list|(
name|mm
argument_list|,
operator|&
name|k_igmpproto
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|k_igmpsrc
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|k_igmpdst
argument_list|)
expr_stmt|;
comment|/* set timer to cleanup entry if upcall is lost */
name|timeout
argument_list|(
name|cleanup_cache
argument_list|,
operator|(
name|caddr_t
operator|)
name|mb_rt
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|timeout_val
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mforward
function_decl|)
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
init|=
name|_ip_mforward
function_decl|;
end_function_decl

begin_comment
comment|/*  * Clean up the cache entry if upcall is not serviced  */
end_comment

begin_function
specifier|static
name|void
name|cleanup_cache
parameter_list|(
name|xmb_rt
parameter_list|)
name|void
modifier|*
name|xmb_rt
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mb_rt
init|=
name|xmb_rt
decl_stmt|;
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|prev_m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|int
name|s
decl_stmt|;
name|rt
operator|=
name|mtod
argument_list|(
name|mb_rt
argument_list|,
expr|struct
name|mfc
operator|*
argument_list|)
expr_stmt|;
name|hash
operator|=
name|nethash_fc
argument_list|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
argument_list|,
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: cleanup ipm %d h %d s %x g %x"
argument_list|,
name|ip_mrouter
argument_list|,
name|hash
argument_list|,
name|ntohl
argument_list|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|mrtstat
operator|.
name|mrts_cache_cleanups
operator|++
expr_stmt|;
comment|/*      * determine entry to be cleaned up in cache table      */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|prev_m0
operator|=
name|m0
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|m0
condition|;
name|prev_m0
operator|=
name|m0
operator|,
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
if|if
condition|(
name|m0
operator|==
name|mb_rt
condition|)
break|break;
comment|/*       * drop all the packets      * free the mbuf with the pkt, if, timing info      */
while|while
condition|(
name|mb_rt
operator|->
name|m_act
condition|)
block|{
name|m
operator|=
name|mb_rt
operator|->
name|m_act
expr_stmt|;
name|mb_rt
operator|->
name|m_act
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|rte
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|rtdetq
operator|*
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/*       * Delete the entry from the cache      */
if|if
condition|(
name|prev_m0
operator|!=
name|m0
condition|)
block|{
comment|/* if moved past head of list */
name|MFREE
argument_list|(
name|m0
argument_list|,
name|prev_m0
operator|->
name|m_next
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* delete head of list, it is in the table */
name|mfctable
index|[
name|hash
index|]
operator|=
name|m_free
argument_list|(
name|m0
argument_list|)
expr_stmt|;
name|timeout_val
operator|--
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Packet forwarding routine once entry in the cache is made  */
end_comment

begin_function
specifier|static
name|int
name|ip_mdq
parameter_list|(
name|m
parameter_list|,
name|ifp
parameter_list|,
name|tunnel_src
parameter_list|,
name|rt
parameter_list|,
name|imo
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|u_long
name|tunnel_src
decl_stmt|;
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
specifier|register
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
comment|/*      * Don't forward if it didn't arrive from the parent vif for its origin.      * Notes: v_ifp is zero for src route tunnels, multicast_decap_if      * for encapsulated tunnels and a real ifnet for non-tunnels so      * the first part of the if catches wrong physical interface or      * tunnel type; v_rmt_addr is zero for non-tunneled packets so      * the 2nd part catches both packets that arrive via a tunnel      * that shouldn't and packets that arrive via the wrong tunnel.      */
name|vifi
operator|=
name|rt
operator|->
name|mfc_parent
expr_stmt|;
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
operator|||
operator|(
name|ifp
operator|==
literal|0
operator|&&
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rmt_addr
operator|.
name|s_addr
operator|!=
name|tunnel_src
operator|)
condition|)
block|{
comment|/* came in the wrong interface */
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"wrong if: ifp %x vifi %d"
argument_list|,
name|ifp
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
operator|++
name|mrtstat
operator|.
name|mrts_wrong_if
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|tunnel_src
return|;
block|}
comment|/* increment the interface and s-g counters */
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_in
operator|++
expr_stmt|;
name|rt
operator|->
name|mfc_pkt_cnt
operator|++
expr_stmt|;
comment|/*      * For each vif, decide if a copy of the packet should be forwarded.      * Forward if:      *		- the ttl exceeds the vif's threshold      *		- there are group members downstream on interface      */
define|#
directive|define
name|MC_SEND
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
value|{                             \ 		(vifp)->v_pkt_out++;                     \                 if ((vifp)->v_flags& VIFF_SRCRT)        \                     srcrt_send((ip), (vifp), (m));       \                 else if ((vifp)->v_flags& VIFF_TUNNEL)  \                     encap_send((ip), (vifp), (m));       \                 else                                     \                     phyint_send((ip), (vifp), (m));      \                 }
comment|/* If no options or the imo_multicast_vif option is 0, don't do this part   */
if|if
condition|(
operator|(
name|imo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|vifi
operator|=
name|imo
operator|->
name|imo_multicast_vif
operator|-
literal|1
operator|)
operator|<
name|numvifs
operator|)
comment|/*&& (vifi>=0)*/
condition|)
block|{
name|MC_SEND
argument_list|(
name|ip
argument_list|,
name|viftable
operator|+
name|vifi
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* make sure we are done: No more physical sends */
block|}
for|for
control|(
name|vifp
operator|=
name|viftable
operator|,
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifp
operator|++
operator|,
name|vifi
operator|++
control|)
if|if
condition|(
operator|(
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_ttl
operator|>
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|)
condition|)
name|MC_SEND
argument_list|(
name|ip
argument_list|,
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* check if a vif number is legal/ok. This is used by ip_output, to export  * numvifs there,   */
end_comment

begin_function
name|int
name|_legal_vif_num
parameter_list|(
name|vif
parameter_list|)
name|int
name|vif
decl_stmt|;
block|{
if|if
condition|(
name|vif
operator|>=
literal|0
operator|&&
name|vif
operator|<=
name|numvifs
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|legal_vif_num
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|_legal_vif_num
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|phyint_send
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mopts
decl_stmt|;
specifier|register
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
if|if
condition|(
operator|(
name|mb_copy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|MALLOC
argument_list|(
name|imo
argument_list|,
expr|struct
name|ip_moptions
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|imo
argument_list|,
name|M_IPMOPTS
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|imo
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return;
block|}
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|ip
operator|->
name|ip_ttl
operator|-
literal|1
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_rate_limit
operator|<=
literal|0
condition|)
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|,
name|imo
argument_list|)
expr_stmt|;
else|else
name|tbf_control
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|,
name|mtod
argument_list|(
name|mb_copy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_len
argument_list|,
name|imo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|srcrt_send
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|,
modifier|*
name|mb_opts
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip_copy
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/*      * Make sure that adding the tunnel options won't exceed the      * maximum allowed number of option bytes.      */
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|>
operator|(
literal|60
operator|-
name|TUNNEL_LEN
operator|)
operator|>>
literal|2
condition|)
block|{
name|mrtstat
operator|.
name|mrts_cant_tunnel
operator|++
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"srcrt_send: no room for tunnel options, from %u"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|mb_copy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|ip_copy
operator|=
name|mtod
argument_list|(
name|mb_copy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip_copy
operator|->
name|ip_ttl
operator|--
expr_stmt|;
name|ip_copy
operator|->
name|ip_dst
operator|=
name|vifp
operator|->
name|v_rmt_addr
expr_stmt|;
comment|/* remote tunnel end-point */
comment|/*      * Adjust the ip header length to account for the tunnel options.      */
name|ip_copy
operator|->
name|ip_hl
operator|+=
name|TUNNEL_LEN
operator|>>
literal|2
expr_stmt|;
name|ip_copy
operator|->
name|ip_len
operator|+=
name|TUNNEL_LEN
expr_stmt|;
name|MGET
argument_list|(
name|mb_opts
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_opts
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * 'Delete' the base ip header from the mb_copy chain      */
name|mb_copy
operator|->
name|m_len
operator|-=
name|IP_HDR_LEN
expr_stmt|;
name|mb_copy
operator|->
name|m_data
operator|+=
name|IP_HDR_LEN
expr_stmt|;
comment|/*      * Make mb_opts be the new head of the packet chain.      * Any options of the packet were left in the old packet chain head      */
name|mb_opts
operator|->
name|m_next
operator|=
name|mb_copy
expr_stmt|;
name|mb_opts
operator|->
name|m_data
operator|+=
literal|16
expr_stmt|;
name|mb_opts
operator|->
name|m_len
operator|=
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
expr_stmt|;
comment|/*      * Copy the base ip header from the mb_copy chain to the new head mbuf      */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip_copy
argument_list|,
name|mtod
argument_list|(
name|mb_opts
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|IP_HDR_LEN
argument_list|)
expr_stmt|;
comment|/*      * Add the NOP and LSRR after the base ip header      */
name|cp
operator|=
name|mtod
argument_list|(
name|mb_opts
argument_list|,
name|u_char
operator|*
argument_list|)
operator|+
name|IP_HDR_LEN
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IPOPT_NOP
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|IPOPT_LSRR
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|11
expr_stmt|;
comment|/* LSRR option length */
operator|*
name|cp
operator|++
operator|=
literal|8
expr_stmt|;
comment|/* LSSR pointer to second element */
operator|*
operator|(
name|u_long
operator|*
operator|)
name|cp
operator|=
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* local tunnel end-point */
name|cp
operator|+=
literal|4
expr_stmt|;
operator|*
operator|(
name|u_long
operator|*
operator|)
name|cp
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/* destination group */
if|if
condition|(
name|vifp
operator|->
name|v_rate_limit
operator|<=
literal|0
condition|)
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_opts
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|tbf_control
argument_list|(
name|vifp
argument_list|,
name|mb_opts
argument_list|,
name|mtod
argument_list|(
name|mb_opts
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
argument_list|,
name|ip_copy
operator|->
name|ip_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encap_send
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip_copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|ip
operator|->
name|ip_len
decl_stmt|;
comment|/*      * copy the old packet& pullup it's IP header into the      * new mbuf so we can modify it.  Try to fill the new      * mbuf since if we don't the ethernet driver will.      */
name|MGET
argument_list|(
name|mb_copy
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
name|mb_copy
operator|->
name|m_data
operator|+=
literal|16
expr_stmt|;
name|mb_copy
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb_copy
operator|->
name|m_next
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|MHLEN
operator|-
name|M_LEADINGSPACE
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
name|i
operator|=
name|len
expr_stmt|;
name|mb_copy
operator|=
name|m_pullup
argument_list|(
name|mb_copy
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
comment|/*      * fill in the encapsulating IP header.      */
name|ip_copy
operator|=
name|mtod
argument_list|(
name|mb_copy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ip_copy
operator|=
name|multicast_encap_iphdr
expr_stmt|;
name|ip_copy
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|ip_id
operator|++
argument_list|)
expr_stmt|;
name|ip_copy
operator|->
name|ip_len
operator|+=
name|len
expr_stmt|;
name|ip_copy
operator|->
name|ip_src
operator|=
name|vifp
operator|->
name|v_lcl_addr
expr_stmt|;
name|ip_copy
operator|->
name|ip_dst
operator|=
name|vifp
operator|->
name|v_rmt_addr
expr_stmt|;
comment|/*      * turn the encapsulated IP header back into a valid one.      */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip_copy
operator|+
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
operator|)
expr_stmt|;
operator|--
name|ip
operator|->
name|ip_ttl
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|LBL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|ultrix
argument_list|)
name|ip
operator|->
name|ip_sum
operator|=
operator|~
name|oc_cksum
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|mb_copy
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|mb_copy
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|mb_copy
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vifp
operator|->
name|v_rate_limit
operator|<=
literal|0
condition|)
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|tbf_control
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|,
name|ip
argument_list|,
name|ip_copy
operator|->
name|ip_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * De-encapsulate a packet and feed it back through ip input (this  * routine is called whenever IP gets a packet with proto type  * ENCAP_PROTO and a local destination address).  */
end_comment

begin_function
name|void
name|multiencap_decap
parameter_list|(
name|m
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|!=
name|ENCAP_PROTO
condition|)
block|{
name|rip_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * dump the packet if it's not to a multicast destination or if      * we don't have an encapsulating tunnel with the source.      * Note:  This code assumes that the remote site IP address      * uniquely identifies the tunnel (i.e., that this site has      * at most one tunnel with the remote site).      */
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|)
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|mrtstat
operator|.
name|mrts_bad_tunnel
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|last_encap_src
condition|)
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vife
decl_stmt|;
name|vifp
operator|=
name|viftable
expr_stmt|;
name|vife
operator|=
name|vifp
operator|+
name|numvifs
expr_stmt|;
name|last_encap_src
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|last_encap_vif
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|vifp
operator|<
name|vife
condition|;
operator|++
name|vifp
control|)
if|if
condition|(
name|vifp
operator|->
name|v_rmt_addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
operator|(
name|vifp
operator|->
name|v_flags
operator|&
operator|(
name|VIFF_TUNNEL
operator||
name|VIFF_SRCRT
operator|)
operator|)
operator|==
name|VIFF_TUNNEL
condition|)
name|last_encap_vif
operator|=
name|vifp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|vifp
operator|=
name|last_encap_vif
operator|)
operator|==
literal|0
condition|)
block|{
name|last_encap_src
operator|=
literal|0
expr_stmt|;
name|mrtstat
operator|.
name|mrts_cant_tunnel
operator|++
expr_stmt|;
comment|/*XXX*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: no tunnel with %u"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
name|hlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ifnet
operator|*
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ifnet
operator|*
operator|*
argument_list|)
operator|)
operator|=
name|ifp
expr_stmt|;
name|ifq
operator|=
operator|&
name|ipintrq
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * normally we would need a "schednetisr(NETISR_IP)" 	 * here but we were called by ip_input and it is going 	 * to loop back& try to dequeue the packet we just 	 * queued as soon as we return so we avoid the 	 * unnecessary software interrrupt. 	 */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Token bucket filter module  */
end_comment

begin_function
name|void
name|tbf_control
parameter_list|(
name|vifp
parameter_list|,
name|m
parameter_list|,
name|ip
parameter_list|,
name|p_len
parameter_list|,
name|imo
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|u_long
name|p_len
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
name|tbf_update_tokens
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
comment|/* if there are enough tokens,       * and the queue is empty,      * send this packet out      */
if|if
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_len
operator|<=
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
condition|)
block|{
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
operator|-=
name|p_len
expr_stmt|;
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|,
name|imo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_len
operator|>
name|MAX_BKT_SIZE
condition|)
block|{
comment|/* drop if packet is too large */
name|mrtstat
operator|.
name|mrts_pkt2large
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* queue packet and timeout till later */
name|tbf_queue
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|,
name|ip
argument_list|,
name|imo
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|tbf_reprocess_q
argument_list|,
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|<
name|MAXQSIZE
condition|)
block|{
comment|/* finite queue length, so queue pkts and process queue */
name|tbf_queue
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|,
name|ip
argument_list|,
name|imo
argument_list|)
expr_stmt|;
name|tbf_process_q
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* queue length too much, try to dq and queue and process */
if|if
condition|(
operator|!
name|tbf_dq_sel
argument_list|(
name|vifp
argument_list|,
name|ip
argument_list|)
condition|)
block|{
name|mrtstat
operator|.
name|mrts_q_overflow
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|tbf_queue
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|,
name|ip
argument_list|,
name|imo
argument_list|)
expr_stmt|;
name|tbf_process_q
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*   * adds a packet to the queue at the interface  */
end_comment

begin_function
name|void
name|tbf_queue
parameter_list|(
name|vifp
parameter_list|,
name|m
parameter_list|,
name|ip
parameter_list|,
name|imo
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
specifier|register
name|u_long
name|ql
decl_stmt|;
specifier|register
name|int
name|index
init|=
operator|(
name|vifp
operator|-
name|viftable
operator|)
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|ql
operator|=
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|ql
index|]
operator|.
name|pkt_m
operator|=
name|m
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|ql
index|]
operator|.
name|pkt_len
operator|=
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|)
operator|->
name|ip_len
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|ql
index|]
operator|.
name|pkt_ip
operator|=
name|ip
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|ql
index|]
operator|.
name|pkt_imo
operator|=
name|imo
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * processes the queue at the interface  */
end_comment

begin_function
name|void
name|tbf_process_q
parameter_list|(
name|vifp
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|pkt_queue
name|pkt_1
decl_stmt|;
specifier|register
name|int
name|index
init|=
operator|(
name|vifp
operator|-
name|viftable
operator|)
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* loop through the queue at the interface and send as many packets      * as possible      */
while|while
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|>
literal|0
condition|)
block|{
comment|/* locate the first packet */
name|pkt_1
operator|.
name|pkt_len
operator|=
operator|(
operator|(
name|qtable
index|[
name|index
index|]
index|[
literal|0
index|]
operator|)
operator|.
name|pkt_len
operator|)
expr_stmt|;
name|pkt_1
operator|.
name|pkt_m
operator|=
operator|(
name|qtable
index|[
name|index
index|]
index|[
literal|0
index|]
operator|)
operator|.
name|pkt_m
expr_stmt|;
name|pkt_1
operator|.
name|pkt_ip
operator|=
operator|(
name|qtable
index|[
name|index
index|]
index|[
literal|0
index|]
operator|)
operator|.
name|pkt_ip
expr_stmt|;
name|pkt_1
operator|.
name|pkt_imo
operator|=
operator|(
name|qtable
index|[
name|index
index|]
index|[
literal|0
index|]
operator|)
operator|.
name|pkt_imo
expr_stmt|;
comment|/* determine if the packet can be sent */
if|if
condition|(
name|pkt_1
operator|.
name|pkt_len
operator|<=
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
condition|)
block|{
comment|/* if so, 	     * reduce no of tokens, dequeue the queue, 	     * send the packet. 	     */
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
operator|-=
name|pkt_1
operator|.
name|pkt_len
expr_stmt|;
name|tbf_dequeue
argument_list|(
name|vifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|pkt_1
operator|.
name|pkt_m
argument_list|,
name|pkt_1
operator|.
name|pkt_imo
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * removes the jth packet from the queue at the interface  */
end_comment

begin_function
name|void
name|tbf_dequeue
parameter_list|(
name|vifp
parameter_list|,
name|j
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
block|{
specifier|register
name|u_long
name|index
init|=
name|vifp
operator|-
name|viftable
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|+
literal|1
init|;
name|i
operator|<=
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_m
operator|=
name|qtable
index|[
name|index
index|]
index|[
name|i
index|]
operator|.
name|pkt_m
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_len
operator|=
name|qtable
index|[
name|index
index|]
index|[
name|i
index|]
operator|.
name|pkt_len
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_ip
operator|=
name|qtable
index|[
name|index
index|]
index|[
name|i
index|]
operator|.
name|pkt_ip
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_imo
operator|=
name|qtable
index|[
name|index
index|]
index|[
name|i
index|]
operator|.
name|pkt_imo
expr_stmt|;
block|}
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_m
operator|=
name|NULL
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_len
operator|=
name|NULL
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_ip
operator|=
name|NULL
expr_stmt|;
name|qtable
index|[
name|index
index|]
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|pkt_imo
operator|=
name|NULL
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|--
expr_stmt|;
if|if
condition|(
name|tbfdebug
operator|>
literal|1
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"tbf_dequeue: vif# %d qlen %d"
argument_list|,
name|vifp
operator|-
name|viftable
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tbf_reprocess_q
parameter_list|(
name|xvifp
parameter_list|)
name|void
modifier|*
name|xvifp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|xvifp
decl_stmt|;
if|if
condition|(
name|ip_mrouter
operator|==
name|NULL
condition|)
return|return;
name|tbf_update_tokens
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
name|tbf_process_q
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
condition|)
name|timeout
argument_list|(
name|tbf_reprocess_q
argument_list|,
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function that will selectively discard a member of the queue  * based on the precedence value and the priority obtained through  * a lookup table - not yet implemented accurately!  */
end_comment

begin_function
name|int
name|tbf_dq_sel
parameter_list|(
name|vifp
parameter_list|,
name|ip
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|u_int
name|p
decl_stmt|;
name|p
operator|=
name|priority
argument_list|(
name|vifp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vifp
operator|->
name|v_tbf
operator|->
name|q_len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|p
operator|>
name|priority
argument_list|(
name|vifp
argument_list|,
name|qtable
index|[
name|vifp
operator|-
name|viftable
index|]
index|[
name|i
index|]
operator|.
name|pkt_ip
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|qtable
index|[
name|vifp
operator|-
name|viftable
index|]
index|[
name|i
index|]
operator|.
name|pkt_m
argument_list|)
expr_stmt|;
name|tbf_dequeue
argument_list|(
name|vifp
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mrtstat
operator|.
name|mrts_drop_sel
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tbf_send_packet
parameter_list|(
name|vifp
parameter_list|,
name|m
parameter_list|,
name|imo
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mcp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
comment|/* if source route tunnels */
if|if
condition|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_SRCRT
condition|)
block|{
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
literal|0
argument_list|,
name|IP_FORWARDING
argument_list|,
name|imo
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
operator|>
literal|1
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"srcrt_send on vif %d err %d"
argument_list|,
name|vifp
operator|-
name|viftable
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
comment|/* If tunnel options */
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
literal|0
argument_list|,
name|IP_FORWARDING
argument_list|,
name|imo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if physical interface option, extract the options and then send */
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
literal|0
argument_list|,
name|IP_FORWARDING
argument_list|,
name|imo
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|imo
argument_list|,
name|M_IPMOPTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
operator|>
literal|1
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"phyint_send on vif %d err %d"
argument_list|,
name|vifp
operator|-
name|viftable
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* determine the current time and then  * the elapsed time (between the last time and time now)  * in milliseconds& update the no. of tokens in the bucket  */
end_comment

begin_function
name|void
name|tbf_update_tokens
parameter_list|(
name|vifp
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
specifier|register
name|u_long
name|t
decl_stmt|;
specifier|register
name|u_long
name|elapsed
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|GET_TIME
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|t
operator|=
name|tp
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
name|tp
operator|.
name|tv_usec
operator|/
literal|1000
expr_stmt|;
name|elapsed
operator|=
operator|(
name|t
operator|-
name|vifp
operator|->
name|v_tbf
operator|->
name|last_pkt_t
operator|)
operator|*
name|vifp
operator|->
name|v_rate_limit
operator|/
literal|8
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
operator|+=
name|elapsed
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|last_pkt_t
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
operator|>
name|MAX_BKT_SIZE
condition|)
name|vifp
operator|->
name|v_tbf
operator|->
name|n_tok
operator|=
name|MAX_BKT_SIZE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|vifp
parameter_list|,
name|ip
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|u_long
name|graddr
decl_stmt|;
specifier|register
name|int
name|prio
decl_stmt|;
comment|/* temporary hack; will add general packet classifier some day */
name|prio
operator|=
literal|50
expr_stmt|;
comment|/* default priority */
comment|/* check for source route options and add option length to get dst */
if|if
condition|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_SRCRT
condition|)
name|graddr
operator|=
name|ntohl
argument_list|(
operator|(
name|ip
operator|+
literal|8
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
else|else
name|graddr
operator|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|graddr
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0x0
case|:
break|break;
case|case
literal|0x1
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe0020001
condition|)
name|prio
operator|=
literal|65
expr_stmt|;
comment|/* MBone Audio */
break|break;
case|case
literal|0x2
case|:
break|break;
case|case
literal|0x3
case|:
break|break;
case|case
literal|0x4
case|:
break|break;
case|case
literal|0x5
case|:
break|break;
case|case
literal|0x6
case|:
break|break;
case|case
literal|0x7
case|:
break|break;
case|case
literal|0x8
case|:
break|break;
case|case
literal|0x9
case|:
break|break;
case|case
literal|0xa
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe000010a
condition|)
name|prio
operator|=
literal|85
expr_stmt|;
comment|/* IETF Low Audio 1 */
break|break;
case|case
literal|0xb
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe000010b
condition|)
name|prio
operator|=
literal|75
expr_stmt|;
comment|/* IETF Audio 1 */
break|break;
case|case
literal|0xc
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe000010c
condition|)
name|prio
operator|=
literal|60
expr_stmt|;
comment|/* IETF Video 1 */
break|break;
case|case
literal|0xd
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe000010d
condition|)
name|prio
operator|=
literal|80
expr_stmt|;
comment|/* IETF Low Audio 2 */
break|break;
case|case
literal|0xe
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe000010e
condition|)
name|prio
operator|=
literal|70
expr_stmt|;
comment|/* IETF Audio 2 */
break|break;
case|case
literal|0xf
case|:
if|if
condition|(
name|graddr
operator|==
literal|0xe000010f
condition|)
name|prio
operator|=
literal|55
expr_stmt|;
comment|/* IETF Video 2 */
break|break;
block|}
if|if
condition|(
name|tbfdebug
operator|>
literal|1
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"graddr%x prio%d"
argument_list|,
name|graddr
argument_list|,
name|prio
argument_list|)
expr_stmt|;
return|return
name|prio
return|;
block|}
end_function

begin_comment
comment|/*  * End of token bucket filter modifications   */
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

