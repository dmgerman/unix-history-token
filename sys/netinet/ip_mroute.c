begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1989 Stephen Deering  * Copyright (c) 1992, 1993  *      The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Stephen Deering of Stanford University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      @(#)ip_mroute.c 8.2 (Berkeley) 11/15/93  */
end_comment

begin_comment
comment|/*  * IP multicast forwarding procedures  *  * Written by David Waitzman, BBN Labs, August 1988.  * Modified by Steve Deering, Stanford, February 1989.  * Modified by Mark J. Steiglitz, Stanford, May, 1991  * Modified by Van Jacobson, LBL, January 1993  * Modified by Ajit Thyagarajan, PARC, August 1993  * Modified by Bill Fenner, PARC, April 1995  * Modified by Ahmed Helmy, SGI, June 1996  * Modified by George Edmond Eddy (Rusty), ISI, February 1998  * Modified by Pavlin Radoslavov, USC/ISI, May 1998, August 1999, October 2000  * Modified by Hitoshi Asaeda, WIDE, August 2000  * Modified by Pavlin Radoslavov, ICSI, October 2002  *  * MROUTING Revision: 3.5  * and PIM-SMv2 and PIM-DM support, advanced API support,  * bandwidth metering and signaling  */
end_comment

begin_comment
comment|/*  * TODO: Prefix functions with ipmf_.  * TODO: Maintain a refcount on if_allmulti() in ifnet or in the protocol  * domain attachment (if_afdata) so we can track consumers of that service.  * TODO: Deprecate routing socket path for SIOCGETSGCNT and SIOCGETVIFCNT,  * move it to socket options.  * TODO: Cleanup LSRR removal further.  * TODO: Push RSVP stubs into raw_ip.c.  * TODO: Use bitstring.h for vif set.  * TODO: Fix mrt6_ioctl dangling ref when dynamically loaded.  * TODO: Sync ip6_mroute.c with this file.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_mrouting.h"
end_include

begin_define
define|#
directive|define
name|_PIM_VT
value|1
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_encap.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_mroute.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_options.h>
end_include

begin_include
include|#
directive|include
file|<netinet/pim.h>
end_include

begin_include
include|#
directive|include
file|<netinet/pim_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_IPMF
end_ifndef

begin_define
define|#
directive|define
name|KTR_IPMF
value|KTR_INET
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VIFI_INVALID
value|((vifi_t) -1)
end_define

begin_define
define|#
directive|define
name|M_HASCL
parameter_list|(
name|m
parameter_list|)
value|((m)->m_flags& M_EXT)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MRTABLE
argument_list|,
literal|"mroutetbl"
argument_list|,
literal|"multicast forwarding cache"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Locking.  We use two locks: one for the virtual interface table and  * one for the forwarding table.  These locks may be nested in which case  * the VIF lock must always be taken first.  Note that each lock is used  * to cover not only the specific data structure but also related data  * structures.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mrouter_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MROUTER_LOCK
parameter_list|()
value|mtx_lock(&mrouter_mtx)
end_define

begin_define
define|#
directive|define
name|MROUTER_UNLOCK
parameter_list|()
value|mtx_unlock(&mrouter_mtx)
end_define

begin_define
define|#
directive|define
name|MROUTER_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&mrouter_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|MROUTER_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&mrouter_mtx, "IPv4 multicast forwarding", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|MROUTER_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&mrouter_mtx)
end_define

begin_decl_stmt
specifier|static
name|struct
name|mrtstat
name|mrtstat
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|mrtstat
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|mrtstat
argument_list|,
name|mrtstat
argument_list|,
literal|"IPv4 Multicast Forwarding Statistics (struct mrtstat, "
literal|"netinet/ip_mroute.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|mfchash
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MFCHASH
parameter_list|(
name|a
parameter_list|,
name|g
parameter_list|)
define|\
value|((((a).s_addr>> 20) ^ ((a).s_addr>> 10) ^ (a).s_addr ^ \ 	  ((g).s_addr>> 20) ^ ((g).s_addr>> 10) ^ (g).s_addr)& mfchash)
end_define

begin_define
define|#
directive|define
name|MFCHASHSIZE
value|256
end_define

begin_decl_stmt
specifier|static
name|u_char
modifier|*
name|nexpire
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0..mfchashsize-1 */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|mfchashsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash size */
end_comment

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|mfchashhdr
argument_list|,
name|mfc
argument_list|)
operator|*
name|mfchashtbl
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|mfc_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MFC_LOCK
parameter_list|()
value|mtx_lock(&mfc_mtx)
end_define

begin_define
define|#
directive|define
name|MFC_UNLOCK
parameter_list|()
value|mtx_unlock(&mfc_mtx)
end_define

begin_define
define|#
directive|define
name|MFC_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&mfc_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|MFC_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&mfc_mtx, "IPv4 multicast forwarding cache", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|MFC_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&mfc_mtx)
end_define

begin_decl_stmt
specifier|static
name|vifi_t
name|numvifs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vif
name|viftable
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_OPAQUE
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|viftable
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|viftable
argument_list|,
sizeof|sizeof
argument_list|(
name|viftable
argument_list|)
argument_list|,
literal|"S,vif[MAXVIFS]"
argument_list|,
literal|"IPv4 Multicast Interfaces (struct vif[MAXVIFS], netinet/ip_mroute.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|vif_mtx
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VIF_LOCK
parameter_list|()
value|mtx_lock(&vif_mtx)
end_define

begin_define
define|#
directive|define
name|VIF_UNLOCK
parameter_list|()
value|mtx_unlock(&vif_mtx)
end_define

begin_define
define|#
directive|define
name|VIF_LOCK_ASSERT
parameter_list|()
value|mtx_assert(&vif_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|VIF_LOCK_INIT
parameter_list|()
define|\
value|mtx_init(&vif_mtx, "IPv4 multicast interfaces", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|VIF_LOCK_DESTROY
parameter_list|()
value|mtx_destroy(&vif_mtx)
end_define

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|if_detach_event_tag
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|expire_upcalls_ch
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EXPIRE_TIMEOUT
value|(hz / 4)
end_define

begin_comment
comment|/* 4x / second		*/
end_comment

begin_define
define|#
directive|define
name|UPCALL_EXPIRE
value|6
end_define

begin_comment
comment|/* number of timeouts	*/
end_comment

begin_comment
comment|/*  * Bandwidth meter variables and constants  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_BWMETER
argument_list|,
literal|"bwmeter"
argument_list|,
literal|"multicast upcall bw meters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Pending timeouts are stored in a hash table, the key being the  * expiration time. Periodically, the entries are analysed and processed.  */
end_comment

begin_define
define|#
directive|define
name|BW_METER_BUCKETS
value|1024
end_define

begin_decl_stmt
specifier|static
name|struct
name|bw_meter
modifier|*
name|bw_meter_timers
index|[
name|BW_METER_BUCKETS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|callout
name|bw_meter_ch
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BW_METER_PERIOD
value|(hz)
end_define

begin_comment
comment|/* periodical handling of bw meters */
end_comment

begin_comment
comment|/*  * Pending upcalls are stored in a vector which is flushed when  * full, or periodically  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bw_upcall
name|bw_upcalls
index|[
name|BW_UPCALLS_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|bw_upcalls_n
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of pending upcalls */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout
name|bw_upcalls_ch
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|BW_UPCALLS_PERIOD
value|(hz)
end_define

begin_comment
comment|/* periodical flush of bw upcalls */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pimstat
name|pimstat
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet
argument_list|,
name|IPPROTO_PIM
argument_list|,
name|pim
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"PIM"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_net_inet_pim
argument_list|,
name|PIMCTL_STATS
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pimstat
argument_list|,
name|pimstat
argument_list|,
literal|"PIM Statistics (struct pimstat, netinet/pim_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_long
name|pim_squelch_wholepkt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_pim
argument_list|,
name|OID_AUTO
argument_list|,
name|squelch_wholepkt
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pim_squelch_wholepkt
argument_list|,
literal|0
argument_list|,
literal|"Disable IGMP_WHOLEPKT notifications if rendezvous point is unspecified"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inetdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|protosw
name|in_pim_protosw
init|=
block|{
operator|.
name|pr_type
operator|=
name|SOCK_RAW
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|inetdomain
block|,
operator|.
name|pr_protocol
operator|=
name|IPPROTO_PIM
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
operator||
name|PR_LASTHDR
block|,
operator|.
name|pr_input
operator|=
name|pim_input
block|,
operator|.
name|pr_output
operator|=
operator|(
name|pr_output_t
operator|*
operator|)
name|rip_output
block|,
operator|.
name|pr_ctloutput
operator|=
name|rip_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|rip_usrreqs
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|encaptab
modifier|*
name|pim_encap_cookie
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|pim_encapcheck
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Note: the PIM Register encapsulation adds the following in front of a  * data packet:  *  * struct pim_encap_hdr {  *    struct ip ip;  *    struct pim_encap_pimhdr  pim;  * }  *  */
end_comment

begin_struct
struct|struct
name|pim_encap_pimhdr
block|{
name|struct
name|pim
name|pim
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|PIM_ENCAP_TTL
value|64
end_define

begin_decl_stmt
specifier|static
name|struct
name|ip
name|pim_encap_iphdr
init|=
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
block|,
name|IPVERSION
block|,
else|#
directive|else
name|IPVERSION
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
block|,
endif|#
directive|endif
literal|0
block|,
comment|/* tos */
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
block|,
comment|/* total length */
literal|0
block|,
comment|/* id */
literal|0
block|,
comment|/* frag offset */
name|PIM_ENCAP_TTL
block|,
name|IPPROTO_PIM
block|,
literal|0
block|,
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|pim_encap_pimhdr
name|pim_encap_pimhdr
init|=
block|{
block|{
name|PIM_MAKE_VT
argument_list|(
name|PIM_VERSION
argument_list|,
name|PIM_REGISTER
argument_list|)
block|,
comment|/* PIM vers and message type */
literal|0
block|,
comment|/* reserved */
literal|0
block|,
comment|/* checksum */
block|}
block|,
literal|0
comment|/* flags */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ifnet
name|multicast_register_if
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vifi_t
name|reg_vif_num
init|=
name|VIFI_INVALID
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_function_decl
specifier|static
name|u_long
name|X_ip_mcast_src
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|X_ip_mforward
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|X_ip_mrouter_done
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|X_ip_mrouter_get
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|X_ip_mrouter_set
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|X_legal_vif_num
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|X_mrt_ioctl
parameter_list|(
name|u_long
parameter_list|,
name|caddr_t
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_bw_upcall
parameter_list|(
name|struct
name|bw_upcall
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_mfc
parameter_list|(
name|struct
name|mfcctl2
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_vif
parameter_list|(
name|struct
name|vifctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bw_meter_prepare_upcall
parameter_list|(
name|struct
name|bw_meter
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bw_meter_process
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bw_meter_receive_packet
parameter_list|(
name|struct
name|bw_meter
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bw_upcalls_send
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_bw_upcall
parameter_list|(
name|struct
name|bw_upcall
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_mfc
parameter_list|(
name|struct
name|mfcctl2
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifi_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_vif_locked
parameter_list|(
name|vifi_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expire_bw_meter_process
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expire_bw_upcalls_send
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expire_mfc
parameter_list|(
name|struct
name|mfc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expire_upcalls
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_bw_list
parameter_list|(
name|struct
name|bw_meter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_sg_cnt
parameter_list|(
name|struct
name|sioc_sg_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_vif_cnt
parameter_list|(
name|struct
name|sioc_vif_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|if_detached_event
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip_mdq
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mfc
modifier|*
parameter_list|,
name|vifi_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mfc
operator|*
name|mfc_find
argument_list|(
expr|struct
name|in_addr
operator|*
argument_list|,
expr|struct
name|in_addr
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|phyint_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|pim_register_prepare
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pim_register_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mfc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pim_register_send_rp
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mfc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pim_register_send_upcall
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|mfc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|schedule_bw_meter
parameter_list|(
name|struct
name|bw_meter
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_packet
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_api_config
parameter_list|(
name|uint32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_assert
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|socket_send
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unschedule_bw_meter
parameter_list|(
name|struct
name|bw_meter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Kernel multicast forwarding API capabilities and setup.  * If more API capabilities are added to the kernel, they should be  * recorded in `mrt_api_support'.  */
end_comment

begin_define
define|#
directive|define
name|MRT_API_VERSION
value|0x0305
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|mrt_api_version
init|=
name|MRT_API_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|mrt_api_support
init|=
operator|(
name|MRT_MFC_FLAGS_DISABLE_WRONGVIF
operator||
name|MRT_MFC_FLAGS_BORDER_VIF
operator||
name|MRT_MFC_RP
operator||
name|MRT_MFC_BW_UPCALL
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|mrt_api_config
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pim_assert_enabled
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|timeval
name|pim_assert_interval
init|=
block|{
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Rate limit */
end_comment

begin_comment
comment|/*  * Find a route for a given origin IP address and multicast group address.  * Statistics must be updated by the caller.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|mfc
operator|*
name|mfc_find
argument_list|(
argument|struct in_addr *o
argument_list|,
argument|struct in_addr *g
argument_list|)
block|{ 	struct
name|mfc
operator|*
name|rt
block|;
name|MFC_LOCK_ASSERT
argument_list|()
block|;
name|LIST_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&mfchashtbl[MFCHASH(*o, *g)]
argument_list|,
argument|mfc_hash
argument_list|)
block|{
if|if
condition|(
name|in_hosteq
argument_list|(
name|rt
operator|->
name|mfc_origin
argument_list|,
operator|*
name|o
argument_list|)
operator|&&
name|in_hosteq
argument_list|(
name|rt
operator|->
name|mfc_mcastgrp
argument_list|,
operator|*
name|g
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
condition|)
break|break;
block|}
end_expr_stmt

begin_return
return|return
operator|(
name|rt
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Handle MRT setsockopt commands to modify the multicast forwarding tables.  */
end_comment

begin_function
unit|static
name|int
name|X_ip_mrouter_set
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|vifctl
name|vifc
decl_stmt|;
name|struct
name|mfcctl2
name|mfc
decl_stmt|;
name|struct
name|bw_upcall
name|bw_upcall
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|V_ip_mrouter
operator|&&
name|sopt
operator|->
name|sopt_name
operator|!=
name|MRT_INIT
condition|)
return|return
name|EPERM
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MRT_INIT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|ip_mrouter_init
argument_list|(
name|so
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_DONE
case|:
name|error
operator|=
name|ip_mrouter_done
argument_list|()
expr_stmt|;
break|break;
case|case
name|MRT_ADD_VIF
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|vifc
argument_list|,
sizeof|sizeof
name|vifc
argument_list|,
sizeof|sizeof
name|vifc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|add_vif
argument_list|(
operator|&
name|vifc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_DEL_VIF
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|vifi
argument_list|,
sizeof|sizeof
name|vifi
argument_list|,
sizeof|sizeof
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|del_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ADD_MFC
case|:
case|case
name|MRT_DEL_MFC
case|:
comment|/* 	 * select data size depending on API version. 	 */
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MRT_ADD_MFC
operator|&&
name|mrt_api_config
operator|&
name|MRT_API_FLAGS_ALL
condition|)
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mfc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfcctl2
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfcctl2
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mfc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfcctl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfcctl
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|mfc
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|mfcctl
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|mfc
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|mfcctl
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MRT_ADD_MFC
condition|)
name|error
operator|=
name|add_mfc
argument_list|(
operator|&
name|mfc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|del_mfc
argument_list|(
operator|&
name|mfc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ASSERT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|set_assert
argument_list|(
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_API_CONFIG
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|set_api_config
argument_list|(
operator|&
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ADD_BW_UPCALL
case|:
case|case
name|MRT_DEL_BW_UPCALL
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|bw_upcall
argument_list|,
sizeof|sizeof
name|bw_upcall
argument_list|,
sizeof|sizeof
name|bw_upcall
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MRT_ADD_BW_UPCALL
condition|)
name|error
operator|=
name|add_bw_upcall
argument_list|(
operator|&
name|bw_upcall
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|del_bw_upcall
argument_list|(
operator|&
name|bw_upcall
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Handle MRT getsockopt commands  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mrouter_get
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MRT_VERSION
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mrt_api_version
argument_list|,
sizeof|sizeof
name|mrt_api_version
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ASSERT
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|pim_assert_enabled
argument_list|,
sizeof|sizeof
name|pim_assert_enabled
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_API_SUPPORT
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mrt_api_support
argument_list|,
sizeof|sizeof
name|mrt_api_support
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_API_CONFIG
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|mrt_api_config
argument_list|,
sizeof|sizeof
name|mrt_api_config
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Handle ioctl commands to obtain information from the cache  */
end_comment

begin_function
specifier|static
name|int
name|X_mrt_ioctl
parameter_list|(
name|u_long
name|cmd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|int
name|fibnum
name|__unused
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/*      * Currently the only function calling this ioctl routine is rtioctl().      * Typically, only root can create the raw socket in order to execute      * this ioctl method, however the request might be coming from a prison      */
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_NETINET_MROUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
operator|(
name|SIOCGETVIFCNT
operator|)
case|:
name|error
operator|=
name|get_vif_cnt
argument_list|(
operator|(
expr|struct
name|sioc_vif_req
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
case|case
operator|(
name|SIOCGETSGCNT
operator|)
case|:
name|error
operator|=
name|get_sg_cnt
argument_list|(
operator|(
expr|struct
name|sioc_sg_req
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * returns the packet, byte, rpf-failure count for the source group provided  */
end_comment

begin_function
specifier|static
name|int
name|get_sg_cnt
parameter_list|(
name|struct
name|sioc_sg_req
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
name|rt
operator|=
name|mfc_find
argument_list|(
operator|&
name|req
operator|->
name|src
argument_list|,
operator|&
name|req
operator|->
name|grp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|req
operator|->
name|pktcnt
operator|=
name|req
operator|->
name|bytecnt
operator|=
name|req
operator|->
name|wrong_if
operator|=
literal|0xffffffff
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
name|req
operator|->
name|pktcnt
operator|=
name|rt
operator|->
name|mfc_pkt_cnt
expr_stmt|;
name|req
operator|->
name|bytecnt
operator|=
name|rt
operator|->
name|mfc_byte_cnt
expr_stmt|;
name|req
operator|->
name|wrong_if
operator|=
name|rt
operator|->
name|mfc_wrong_if
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * returns the input and output packet and byte counts on the vif provided  */
end_comment

begin_function
specifier|static
name|int
name|get_vif_cnt
parameter_list|(
name|struct
name|sioc_vif_req
modifier|*
name|req
parameter_list|)
block|{
name|vifi_t
name|vifi
init|=
name|req
operator|->
name|vifi
decl_stmt|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|vifi
operator|>=
name|numvifs
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|req
operator|->
name|icount
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_in
expr_stmt|;
name|req
operator|->
name|ocount
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_out
expr_stmt|;
name|req
operator|->
name|ibytes
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_in
expr_stmt|;
name|req
operator|->
name|obytes
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_out
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ip_mrouter_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|pim_assert_enabled
operator|=
literal|0
expr_stmt|;
name|mrt_api_config
operator|=
literal|0
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|bw_upcalls_n
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|bw_meter_timers
argument_list|,
sizeof|sizeof
argument_list|(
name|bw_meter_timers
argument_list|)
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|bw_upcalls_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|bw_meter_ch
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|if_detached_event
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MROUTER_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_ip_mrouter
operator|==
name|NULL
condition|)
block|{
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
name|VIF_LOCK
argument_list|()
expr_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
comment|/*      * Tear down multicast forwarder state associated with this ifnet.      * 1. Walk the vif list, matching vifs against this ifnet.      * 2. Walk the multicast forwarding cache (mfc) looking for      *    inner matches with this vif's index.      * 3. Expire any matching multicast forwarding cache entries.      * 4. Free vif state. This should disable ALLMULTI on the interface.      */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mfchashsize
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|,
modifier|*
name|nrt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mfchashtbl
index|[
name|i
index|]
argument_list|)
init|;
name|rt
condition|;
name|rt
operator|=
name|nrt
control|)
block|{
name|nrt
operator|=
name|LIST_NEXT
argument_list|(
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|mfc_parent
operator|==
name|vifi
condition|)
block|{
name|expire_mfc
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|del_vif_locked
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
block|}
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enable multicast forwarding.  */
end_comment

begin_function
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|version
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: so_type %d, pr_protocol %d"
argument_list|,
name|__func__
argument_list|,
name|so
operator|->
name|so_type
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_IGMP
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
return|return
name|ENOPROTOOPT
return|;
name|MROUTER_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_ip_mrouter
operator|!=
name|NULL
condition|)
block|{
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRINUSE
return|;
block|}
name|if_detach_event_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|if_detached_event
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_detach_event_tag
operator|==
name|NULL
condition|)
block|{
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|mfchashtbl
operator|=
name|hashinit_flags
argument_list|(
name|mfchashsize
argument_list|,
name|M_MRTABLE
argument_list|,
operator|&
name|mfchash
argument_list|,
name|HASH_NOWAIT
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|,
name|EXPIRE_TIMEOUT
argument_list|,
name|expire_upcalls
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|bw_upcalls_ch
argument_list|,
name|BW_UPCALLS_PERIOD
argument_list|,
name|expire_bw_upcalls_send
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|bw_meter_ch
argument_list|,
name|BW_METER_PERIOD
argument_list|,
name|expire_bw_meter_process
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|V_ip_mrouter
operator|=
name|so
expr_stmt|;
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: done"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Disable multicast forwarding.  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mrouter_done
parameter_list|(
name|void
parameter_list|)
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|MROUTER_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_ip_mrouter
operator|==
name|NULL
condition|)
block|{
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/*      * Detach/disable hooks to the reset of the system.      */
name|V_ip_mrouter
operator|=
name|NULL
expr_stmt|;
name|mrt_api_config
operator|=
literal|0
expr_stmt|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
comment|/*      * For each phyint in use, disable promiscuous reception of all IP      * multicasts.      */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
argument_list|)
operator|&&
operator|!
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
operator|(
name|VIFF_TUNNEL
operator||
name|VIFF_REGISTER
operator|)
operator|)
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|so
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
decl_stmt|;
name|so
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|so
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|so
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
expr_stmt|;
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|viftable
argument_list|,
sizeof|sizeof
argument_list|(
name|viftable
argument_list|)
argument_list|)
expr_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|pim_assert_enabled
operator|=
literal|0
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|ifnet_departure_event
argument_list|,
name|if_detach_event_tag
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|bw_upcalls_ch
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|bw_meter_ch
argument_list|)
expr_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
comment|/*      * Free all multicast forwarding cache entries.      * Do not use hashdestroy(), as we must perform other cleanup.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mfchashsize
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|,
modifier|*
name|nrt
decl_stmt|;
for|for
control|(
name|rt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mfchashtbl
index|[
name|i
index|]
argument_list|)
init|;
name|rt
condition|;
name|rt
operator|=
name|nrt
control|)
block|{
name|nrt
operator|=
name|LIST_NEXT
argument_list|(
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
name|expire_mfc
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|mfchashtbl
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|mfchashtbl
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
name|nexpire
argument_list|,
sizeof|sizeof
argument_list|(
name|nexpire
index|[
literal|0
index|]
argument_list|)
operator|*
name|mfchashsize
argument_list|)
expr_stmt|;
name|bw_upcalls_n
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
name|bw_meter_timers
argument_list|,
sizeof|sizeof
argument_list|(
name|bw_meter_timers
argument_list|)
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|reg_vif_num
operator|=
name|VIFI_INVALID
expr_stmt|;
name|MROUTER_UNLOCK
argument_list|()
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: done"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Set PIM assert processing global  */
end_comment

begin_function
specifier|static
name|int
name|set_assert
parameter_list|(
name|int
name|i
parameter_list|)
block|{
if|if
condition|(
operator|(
name|i
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
return|return
name|EINVAL
return|;
name|pim_assert_enabled
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Configure API capabilities  */
end_comment

begin_function
name|int
name|set_api_config
parameter_list|(
name|uint32_t
modifier|*
name|apival
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/*      * We can set the API capabilities only if it is the first operation      * after MRT_INIT. I.e.:      *  - there are no vifs installed      *  - pim_assert is not enabled      *  - the MFC table is empty      */
if|if
condition|(
name|numvifs
operator|>
literal|0
condition|)
block|{
operator|*
name|apival
operator|=
literal|0
expr_stmt|;
return|return
name|EPERM
return|;
block|}
if|if
condition|(
name|pim_assert_enabled
condition|)
block|{
operator|*
name|apival
operator|=
literal|0
expr_stmt|;
return|return
name|EPERM
return|;
block|}
name|MFC_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mfchashsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|mfchashtbl
index|[
name|i
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|apival
operator|=
literal|0
expr_stmt|;
return|return
name|EPERM
return|;
block|}
block|}
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|mrt_api_config
operator|=
operator|*
name|apival
operator|&
name|mrt_api_support
expr_stmt|;
operator|*
name|apival
operator|=
name|mrt_api_config
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a vif to the vif table  */
end_comment

begin_function
specifier|static
name|int
name|add_vif
parameter_list|(
name|struct
name|vifctl
modifier|*
name|vifcp
parameter_list|)
block|{
name|struct
name|vif
modifier|*
name|vifp
init|=
name|viftable
operator|+
name|vifcp
operator|->
name|vifc_vifi
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
init|=
block|{
sizeof|sizeof
name|sin
block|,
name|AF_INET
block|}
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_vifi
operator|>=
name|MAXVIFS
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* rate limiting is no longer supported by this code */
if|if
condition|(
name|vifcp
operator|->
name|vifc_rate_limit
operator|!=
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rate limiting is no longer supported\n"
argument_list|)
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|vifp
operator|->
name|v_lcl_addr
argument_list|)
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRINUSE
return|;
block|}
if|if
condition|(
name|in_nullhost
argument_list|(
name|vifcp
operator|->
name|vifc_lcl_addr
argument_list|)
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
comment|/* Find the interface with an address in AF_INET family */
if|if
condition|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_REGISTER
condition|)
block|{
comment|/* 	 * XXX: Because VIFF_REGISTER does not really need a valid 	 * local interface (e.g. it could be 127.0.0.2), we don't 	 * check its address. 	 */
name|ifp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sin
operator|.
name|sin_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|ifa
operator|=
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
name|ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
name|ifa_free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_TUNNEL
operator|)
operator|!=
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: tunnels are no longer supported"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
elseif|else
if|if
condition|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_REGISTER
condition|)
block|{
name|ifp
operator|=
operator|&
name|multicast_register_if
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: add register vif for ifp %p"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_vif_num
operator|==
name|VIFI_INVALID
condition|)
block|{
name|if_initname
argument_list|(
operator|&
name|multicast_register_if
argument_list|,
literal|"register_vif"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|multicast_register_if
operator|.
name|if_flags
operator|=
name|IFF_LOOPBACK
expr_stmt|;
name|reg_vif_num
operator|=
name|vifcp
operator|->
name|vifc_vifi
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Make sure the interface supports multicast */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
comment|/* Enable promiscuous reception of all IP multicasts from the if */
name|error
operator|=
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
name|vifp
operator|->
name|v_flags
operator|=
name|vifcp
operator|->
name|vifc_flags
expr_stmt|;
name|vifp
operator|->
name|v_threshold
operator|=
name|vifcp
operator|->
name|vifc_threshold
expr_stmt|;
name|vifp
operator|->
name|v_lcl_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|vifp
operator|->
name|v_rmt_addr
operator|=
name|vifcp
operator|->
name|vifc_rmt_addr
expr_stmt|;
name|vifp
operator|->
name|v_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* initialize per vif pkt counters */
name|vifp
operator|->
name|v_pkt_in
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_pkt_out
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_bytes_in
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_bytes_out
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|vifp
operator|->
name|v_route
argument_list|,
sizeof|sizeof
argument_list|(
name|vifp
operator|->
name|v_route
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs up if the vifi is higher than numvifs */
if|if
condition|(
name|numvifs
operator|<=
name|vifcp
operator|->
name|vifc_vifi
condition|)
name|numvifs
operator|=
name|vifcp
operator|->
name|vifc_vifi
operator|+
literal|1
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: add vif %d laddr %s thresh %x"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|vifcp
operator|->
name|vifc_vifi
argument_list|,
name|inet_ntoa
argument_list|(
name|vifcp
operator|->
name|vifc_lcl_addr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|vifcp
operator|->
name|vifc_threshold
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a vif from the vif table  */
end_comment

begin_function
specifier|static
name|int
name|del_vif_locked
parameter_list|(
name|vifi_t
name|vifi
parameter_list|)
block|{
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
name|VIF_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|vifi
operator|>=
name|numvifs
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|vifp
operator|=
operator|&
name|viftable
index|[
name|vifi
index|]
expr_stmt|;
if|if
condition|(
name|in_nullhost
argument_list|(
name|vifp
operator|->
name|v_lcl_addr
argument_list|)
condition|)
block|{
return|return
name|EADDRNOTAVAIL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|vifp
operator|->
name|v_flags
operator|&
operator|(
name|VIFF_TUNNEL
operator||
name|VIFF_REGISTER
operator|)
operator|)
condition|)
name|if_allmulti
argument_list|(
name|vifp
operator|->
name|v_ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_REGISTER
condition|)
name|reg_vif_num
operator|=
name|VIFI_INVALID
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vifp
argument_list|)
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: delete vif %d"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|vifi
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs down */
for|for
control|(
name|vifi
operator|=
name|numvifs
init|;
name|vifi
operator|>
literal|0
condition|;
name|vifi
operator|--
control|)
if|if
condition|(
operator|!
name|in_nullhost
argument_list|(
name|viftable
index|[
name|vifi
operator|-
literal|1
index|]
operator|.
name|v_lcl_addr
argument_list|)
condition|)
break|break;
name|numvifs
operator|=
name|vifi
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifi_t
name|vifi
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
name|cc
operator|=
name|del_vif_locked
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|cc
return|;
block|}
end_function

begin_comment
comment|/*  * update an mfc entry without resetting counters and S,G addresses.  */
end_comment

begin_function
specifier|static
name|void
name|update_mfc_params
parameter_list|(
name|struct
name|mfc
modifier|*
name|rt
parameter_list|,
name|struct
name|mfcctl2
modifier|*
name|mfccp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
expr_stmt|;
name|rt
operator|->
name|mfc_flags
index|[
name|i
index|]
operator|=
name|mfccp
operator|->
name|mfcc_flags
index|[
name|i
index|]
operator|&
name|mrt_api_config
operator|&
name|MRT_MFC_FLAGS_ALL
expr_stmt|;
block|}
comment|/* set the RP address */
if|if
condition|(
name|mrt_api_config
operator|&
name|MRT_MFC_RP
condition|)
name|rt
operator|->
name|mfc_rp
operator|=
name|mfccp
operator|->
name|mfcc_rp
expr_stmt|;
else|else
name|rt
operator|->
name|mfc_rp
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * fully initialize an mfc entry from the parameter.  */
end_comment

begin_function
specifier|static
name|void
name|init_mfc_params
parameter_list|(
name|struct
name|mfc
modifier|*
name|rt
parameter_list|,
name|struct
name|mfcctl2
modifier|*
name|mfccp
parameter_list|)
block|{
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|update_mfc_params
argument_list|(
name|rt
argument_list|,
name|mfccp
argument_list|)
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_wrong_if
operator|=
literal|0
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|rt
operator|->
name|mfc_last_assert
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|expire_mfc
parameter_list|(
name|struct
name|mfc
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|,
modifier|*
name|nrte
decl_stmt|;
name|free_bw_list
argument_list|(
name|rt
operator|->
name|mfc_bw_meter
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rte
argument_list|,
argument|&rt->mfc_stall
argument_list|,
argument|rte_link
argument_list|,
argument|nrte
argument_list|)
block|{
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|,
name|rte
argument_list|,
name|rte_link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|add_mfc
parameter_list|(
name|struct
name|mfcctl2
modifier|*
name|mfccp
parameter_list|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|,
modifier|*
name|nrte
decl_stmt|;
name|u_long
name|hash
init|=
literal|0
decl_stmt|;
name|u_short
name|nstl
decl_stmt|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
name|rt
operator|=
name|mfc_find
argument_list|(
operator|&
name|mfccp
operator|->
name|mfcc_origin
argument_list|,
operator|&
name|mfccp
operator|->
name|mfcc_mcastgrp
argument_list|)
expr_stmt|;
comment|/* If an entry already exists, just update the fields */
if|if
condition|(
name|rt
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: update mfc orig %s group %lx parent %x"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|)
expr_stmt|;
name|update_mfc_params
argument_list|(
name|rt
argument_list|,
name|mfccp
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*      * Find the entry for which the upcall was made and update      */
name|nstl
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
name|MFCHASH
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&mfchashtbl[hash]
argument_list|,
argument|mfc_hash
argument_list|)
block|{
if|if
condition|(
name|in_hosteq
argument_list|(
name|rt
operator|->
name|mfc_origin
argument_list|,
name|mfccp
operator|->
name|mfcc_origin
argument_list|)
operator|&&
name|in_hosteq
argument_list|(
name|rt
operator|->
name|mfc_mcastgrp
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
argument_list|)
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: add mfc orig %s group %lx parent %x qh %p"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstl
operator|++
condition|)
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: multiple matches"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|init_mfc_params
argument_list|(
name|rt
argument_list|,
name|mfccp
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
literal|0
expr_stmt|;
comment|/* Don't clean this guy up */
name|nexpire
index|[
name|hash
index|]
operator|--
expr_stmt|;
comment|/* Free queued packets, but attempt to forward them first. */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rte
argument_list|,
argument|&rt->mfc_stall
argument_list|,
argument|rte_link
argument_list|,
argument|nrte
argument_list|)
block|{
if|if
condition|(
name|rte
operator|->
name|ifp
operator|!=
name|NULL
condition|)
name|ip_mdq
argument_list|(
name|rte
operator|->
name|m
argument_list|,
name|rte
operator|->
name|ifp
argument_list|,
name|rt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|,
name|rte
argument_list|,
name|rte_link
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_nstall
operator|--
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/*      * It is possible that an entry is being inserted without an upcall      */
if|if
condition|(
name|nstl
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: adding mfc w/o upcall"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&mfchashtbl[hash]
argument_list|,
argument|mfc_hash
argument_list|)
block|{
if|if
condition|(
name|in_hosteq
argument_list|(
name|rt
operator|->
name|mfc_origin
argument_list|,
name|mfccp
operator|->
name|mfcc_origin
argument_list|)
operator|&&
name|in_hosteq
argument_list|(
name|rt
operator|->
name|mfc_mcastgrp
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
argument_list|)
condition|)
block|{
name|init_mfc_params
argument_list|(
name|rt
argument_list|,
name|mfccp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|mfc_expire
condition|)
name|nexpire
index|[
name|hash
index|]
operator|--
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
literal|0
expr_stmt|;
break|break;
comment|/* XXX */
block|}
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
comment|/* no upcall, so make a new entry */
name|rt
operator|=
operator|(
expr|struct
name|mfc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|init_mfc_params
argument_list|(
name|rt
argument_list|,
name|mfccp
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_nstall
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_bw_meter
operator|=
name|NULL
expr_stmt|;
comment|/* insert new entry at head of hash chain */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mfchashtbl
index|[
name|hash
index|]
argument_list|,
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
block|}
block|}
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|del_mfc
parameter_list|(
name|struct
name|mfcctl2
modifier|*
name|mfccp
parameter_list|)
block|{
name|struct
name|in_addr
name|origin
decl_stmt|;
name|struct
name|in_addr
name|mcastgrp
decl_stmt|;
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: delete mfc orig %s group %lx"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|origin
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
name|rt
operator|=
name|mfc_find
argument_list|(
operator|&
name|origin
argument_list|,
operator|&
name|mcastgrp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
comment|/*      * free the bw_meter entries      */
name|free_bw_list
argument_list|(
name|rt
operator|->
name|mfc_bw_meter
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_bw_meter
operator|=
name|NULL
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a message to the routing daemon on the multicast routing socket.  */
end_comment

begin_function
specifier|static
name|int
name|socket_send
parameter_list|(
name|struct
name|socket
modifier|*
name|s
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mm
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|src
parameter_list|)
block|{
if|if
condition|(
name|s
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|s
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbappendaddr_locked
argument_list|(
operator|&
name|s
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src
argument_list|,
name|mm
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sorwakeup_locked
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|s
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * IP multicast forwarding function. This function assumes that the packet  * pointed to by "ip" has arrived on (or is about to be sent to) the interface  * pointed to by "ifp", and the packet is to be relayed to other networks  * that have members of the packet's destination IP multicast group.  *  * The packet is returned unscathed to the caller, unless it is  * erroneous, in which case a non-zero return value tells the caller to  * discard it.  */
end_comment

begin_define
define|#
directive|define
name|TUNNEL_LEN
value|12
end_define

begin_comment
comment|/* # bytes of IP option for tunnel encapsulation  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mforward
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ip_moptions
modifier|*
name|imo
parameter_list|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"ip_mforward: delete mfc orig %s group %lx ifp %p"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|TUNNEL_LEN
operator|)
operator|>>
literal|2
operator|||
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
operator|)
index|[
literal|1
index|]
operator|!=
name|IPOPT_LSRR
condition|)
block|{
comment|/* 	 * Packet arrived via a physical interface or 	 * an encapsulated tunnel or a register_vif. 	 */
block|}
else|else
block|{
comment|/* 	 * Packet arrived through a source-route tunnel. 	 * Source-route tunnels are no longer supported. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|VIF_LOCK
argument_list|()
expr_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|imo
operator|&&
operator|(
operator|(
name|vifi
operator|=
name|imo
operator|->
name|imo_multicast_vif
operator|)
operator|<
name|numvifs
operator|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<
name|MAXTTL
condition|)
name|ip
operator|->
name|ip_ttl
operator|++
expr_stmt|;
comment|/* compensate for -1 in *_send routines */
name|error
operator|=
name|ip_mdq
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/*      * Don't forward a packet with time-to-live of zero or one,      * or a packet destined to a local-only group.      */
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
operator|||
name|IN_LOCAL_GROUP
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Determine forwarding vifs from the forwarding cache table      */
name|MRTSTAT_INC
argument_list|(
name|mrts_mfc_lookups
argument_list|)
expr_stmt|;
name|rt
operator|=
name|mfc_find
argument_list|(
operator|&
name|ip
operator|->
name|ip_src
argument_list|,
operator|&
name|ip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
comment|/* Entry exists, so forward if necessary */
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|ip_mdq
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|rt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|error
return|;
block|}
else|else
block|{
comment|/* 	 * If we don't have a route for packet's origin, 	 * Make a copy of the packet& send message to routing daemon 	 */
name|struct
name|mbuf
modifier|*
name|mb0
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_mfc_misses
argument_list|)
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_no_route
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"ip_mforward: no mfc for (%s,%lx)"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate mbufs early so that we don't do extra work if we are 	 * just going to fail anyway.  Make sure to pullup the header so 	 * that other people can't step on it. 	 */
name|rte
operator|=
operator|(
expr|struct
name|rtdetq
operator|*
operator|)
name|malloc
argument_list|(
operator|(
sizeof|sizeof
expr|*
name|rte
operator|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rte
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|mb0
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb0
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mb0
argument_list|)
operator|||
name|mb0
operator|->
name|m_len
operator|<
name|hlen
operator|)
condition|)
name|mb0
operator|=
name|m_pullup
argument_list|(
name|mb0
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb0
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* is there an upcall waiting for this flow ? */
name|hash
operator|=
name|MFCHASH
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&mfchashtbl[hash]
argument_list|,
argument|mfc_hash
argument_list|)
block|{
if|if
condition|(
name|in_hosteq
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|rt
operator|->
name|mfc_origin
argument_list|)
operator|&&
name|in_hosteq
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|rt
operator|->
name|mfc_mcastgrp
argument_list|)
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|igmpmsg
modifier|*
name|im
decl_stmt|;
name|struct
name|sockaddr_in
name|k_igmpsrc
init|=
block|{
sizeof|sizeof
name|k_igmpsrc
block|,
name|AF_INET
block|}
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
comment|/* 	     * Locate the vifi for the incoming interface for this packet. 	     * If none found, drop packet. 	     */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
operator|&&
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
condition|;
name|vifi
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|vifi
operator|>=
name|numvifs
condition|)
comment|/* vif not found, drop packet */
goto|goto
name|non_fatal
goto|;
comment|/* no upcall, so make a new entry */
name|rt
operator|=
operator|(
expr|struct
name|mfc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
goto|goto
name|fail
goto|;
comment|/* Make a copy of the header to send to the user level process */
name|mm
operator|=
name|m_copy
argument_list|(
name|mb0
argument_list|,
literal|0
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
goto|goto
name|fail1
goto|;
comment|/* 	     * Send message to routing daemon to install 	     * a route into the kernel table 	     */
name|im
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|igmpmsg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_msgtype
operator|=
name|IGMPMSG_NOCACHE
expr_stmt|;
name|im
operator|->
name|im_mbz
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|im_vif
operator|=
name|vifi
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upcalls
argument_list|)
expr_stmt|;
name|k_igmpsrc
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|V_ip_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|k_igmpsrc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"ip_mforward: socket queue full"
argument_list|)
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upq_sockfull
argument_list|)
expr_stmt|;
name|fail1
label|:
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|fail
label|:
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* insert new entry at head of hash chain */
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
name|UPCALL_EXPIRE
expr_stmt|;
name|nexpire
index|[
name|hash
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
block|{
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_flags
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|rt
operator|->
name|mfc_parent
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* clear the RP address */
name|rt
operator|->
name|mfc_rp
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|rt
operator|->
name|mfc_bw_meter
operator|=
name|NULL
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_wrong_if
operator|=
literal|0
expr_stmt|;
name|timevalclear
argument_list|(
operator|&
name|rt
operator|->
name|mfc_last_assert
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_nstall
operator|=
literal|0
expr_stmt|;
comment|/* link into table */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|mfchashtbl
index|[
name|hash
index|]
argument_list|,
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|,
name|rte
argument_list|,
name|rte_link
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_nstall
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* determine if queue has overflowed */
if|if
condition|(
name|rt
operator|->
name|mfc_nstall
operator|>
name|MAX_UPQ
condition|)
block|{
name|MRTSTAT_INC
argument_list|(
name|mrts_upq_ovflw
argument_list|)
expr_stmt|;
name|non_fatal
label|:
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|,
name|rte
argument_list|,
name|rte_link
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_nstall
operator|++
expr_stmt|;
block|}
name|rte
operator|->
name|m
operator|=
name|mb0
expr_stmt|;
name|rte
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Clean up the cache entry if upcall is not serviced  */
end_comment

begin_function
specifier|static
name|void
name|expire_upcalls
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mfchashsize
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|,
modifier|*
name|nrt
decl_stmt|;
if|if
condition|(
name|nexpire
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|rt
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|mfchashtbl
index|[
name|i
index|]
argument_list|)
init|;
name|rt
condition|;
name|rt
operator|=
name|nrt
control|)
block|{
name|nrt
operator|=
name|LIST_NEXT
argument_list|(
name|rt
argument_list|,
name|mfc_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|rt
operator|->
name|mfc_stall
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rt
operator|->
name|mfc_expire
operator|==
literal|0
operator|||
operator|--
name|rt
operator|->
name|mfc_expire
operator|>
literal|0
condition|)
continue|continue;
comment|/* 		 * free the bw_meter entries 		 */
while|while
condition|(
name|rt
operator|->
name|mfc_bw_meter
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bw_meter
modifier|*
name|x
init|=
name|rt
operator|->
name|mfc_bw_meter
decl_stmt|;
name|rt
operator|->
name|mfc_bw_meter
operator|=
name|x
operator|->
name|bm_mfc_next
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|,
name|M_BWMETER
argument_list|)
expr_stmt|;
block|}
name|MRTSTAT_INC
argument_list|(
name|mrts_cache_cleanups
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: expire (%lx, %lx)"
argument_list|,
name|__func__
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|expire_mfc
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|expire_upcalls_ch
argument_list|,
name|EXPIRE_TIMEOUT
argument_list|,
name|expire_upcalls
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Packet forwarding routine once entry in the cache is made  */
end_comment

begin_function
specifier|static
name|int
name|ip_mdq
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mfc
modifier|*
name|rt
parameter_list|,
name|vifi_t
name|xmt_vif
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|plen
init|=
name|ip
operator|->
name|ip_len
decl_stmt|;
name|VIF_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/*      * If xmt_vif is not -1, send on only the requested vif.      *      * (since vifi_t is u_short, -1 becomes MAXUSHORT, which> numvifs.)      */
if|if
condition|(
name|xmt_vif
operator|<
name|numvifs
condition|)
block|{
if|if
condition|(
name|viftable
index|[
name|xmt_vif
index|]
operator|.
name|v_flags
operator|&
name|VIFF_REGISTER
condition|)
name|pim_register_send
argument_list|(
name|ip
argument_list|,
name|viftable
operator|+
name|xmt_vif
argument_list|,
name|m
argument_list|,
name|rt
argument_list|)
expr_stmt|;
else|else
name|phyint_send
argument_list|(
name|ip
argument_list|,
name|viftable
operator|+
name|xmt_vif
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * Don't forward if it didn't arrive from the parent vif for its origin.      */
name|vifi
operator|=
name|rt
operator|->
name|mfc_parent
expr_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|>=
name|numvifs
operator|)
operator|||
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
operator|)
condition|)
block|{
name|CTR4
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: rx on wrong ifp %p (vifi %d, v_ifp %p)"
argument_list|,
name|__func__
argument_list|,
name|ifp
argument_list|,
operator|(
name|int
operator|)
name|vifi
argument_list|,
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
argument_list|)
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_wrong_if
argument_list|)
expr_stmt|;
operator|++
name|rt
operator|->
name|mfc_wrong_if
expr_stmt|;
comment|/* 	 * If we are doing PIM assert processing, send a message 	 * to the routing daemon. 	 * 	 * XXX: A PIM-SM router needs the WRONGVIF detection so it 	 * can complete the SPT switch, regardless of the type 	 * of the iif (broadcast media, GRE tunnel, etc). 	 */
if|if
condition|(
name|pim_assert_enabled
operator|&&
operator|(
name|vifi
operator|<
name|numvifs
operator|)
operator|&&
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
condition|)
block|{
if|if
condition|(
name|ifp
operator|==
operator|&
name|multicast_register_if
condition|)
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_registers_wrongiif
argument_list|)
expr_stmt|;
comment|/* Get vifi for the incoming packet */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
operator|&&
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
condition|;
name|vifi
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|vifi
operator|>=
name|numvifs
condition|)
return|return
literal|0
return|;
comment|/* The iif is not found: ignore the packet. */
if|if
condition|(
name|rt
operator|->
name|mfc_flags
index|[
name|vifi
index|]
operator|&
name|MRT_MFC_FLAGS_DISABLE_WRONGVIF
condition|)
return|return
literal|0
return|;
comment|/* WRONGVIF disabled: ignore the packet */
if|if
condition|(
name|ratecheck
argument_list|(
operator|&
name|rt
operator|->
name|mfc_last_assert
argument_list|,
operator|&
name|pim_assert_interval
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|k_igmpsrc
init|=
block|{
sizeof|sizeof
name|k_igmpsrc
block|,
name|AF_INET
block|}
decl_stmt|;
name|struct
name|igmpmsg
modifier|*
name|im
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
init|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|hlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|mm
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mm
argument_list|)
operator|||
name|mm
operator|->
name|m_len
operator|<
name|hlen
operator|)
condition|)
name|mm
operator|=
name|m_pullup
argument_list|(
name|mm
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
name|im
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|igmpmsg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_msgtype
operator|=
name|IGMPMSG_WRONGVIF
expr_stmt|;
name|im
operator|->
name|im_mbz
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|im_vif
operator|=
name|vifi
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upcalls
argument_list|)
expr_stmt|;
name|k_igmpsrc
operator|.
name|sin_addr
operator|=
name|im
operator|->
name|im_src
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|V_ip_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|k_igmpsrc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: socket queue full"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upq_sockfull
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* If I sourced this packet, it counts as output, else it was input. */
if|if
condition|(
name|in_hosteq
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
argument_list|)
condition|)
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_out
operator|++
expr_stmt|;
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_out
operator|+=
name|plen
expr_stmt|;
block|}
else|else
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_in
operator|++
expr_stmt|;
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_in
operator|+=
name|plen
expr_stmt|;
block|}
name|rt
operator|->
name|mfc_pkt_cnt
operator|++
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|+=
name|plen
expr_stmt|;
comment|/*      * For each vif, decide if a copy of the packet should be forwarded.      * Forward if:      *		- the ttl exceeds the vif's threshold      *		- there are group members downstream on interface      */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
if|if
condition|(
operator|(
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_ttl
operator|>
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|)
condition|)
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_out
operator|++
expr_stmt|;
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_out
operator|+=
name|plen
expr_stmt|;
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_REGISTER
condition|)
name|pim_register_send
argument_list|(
name|ip
argument_list|,
name|viftable
operator|+
name|vifi
argument_list|,
name|m
argument_list|,
name|rt
argument_list|)
expr_stmt|;
else|else
name|phyint_send
argument_list|(
name|ip
argument_list|,
name|viftable
operator|+
name|vifi
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/*      * Perform upcall-related bw measuring.      */
if|if
condition|(
name|rt
operator|->
name|mfc_bw_meter
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bw_meter
modifier|*
name|x
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|MFC_LOCK_ASSERT
argument_list|()
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rt
operator|->
name|mfc_bw_meter
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|bm_mfc_next
control|)
name|bw_meter_receive_packet
argument_list|(
name|x
argument_list|,
name|plen
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a vif number is legal/ok. This is used by in_mcast.c.  */
end_comment

begin_function
specifier|static
name|int
name|X_legal_vif_num
parameter_list|(
name|int
name|vif
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vif
operator|<
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|vif
operator|<
name|numvifs
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the local address used by this vif  */
end_comment

begin_function
specifier|static
name|u_long
name|X_ip_mcast_src
parameter_list|(
name|int
name|vifi
parameter_list|)
block|{
name|in_addr_t
name|addr
decl_stmt|;
name|addr
operator|=
name|INADDR_ANY
expr_stmt|;
if|if
condition|(
name|vifi
operator|<
literal|0
condition|)
return|return
operator|(
name|addr
operator|)
return|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|vifi
operator|<
name|numvifs
condition|)
name|addr
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|phyint_send
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|vif
modifier|*
name|vifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|VIF_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/*      * Make a new reference to the packet; make sure that      * the IP header is actually copied, not just referenced,      * so that ip_output() only scribbles on the copy.      */
name|mb_copy
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mb_copy
argument_list|)
operator|||
name|mb_copy
operator|->
name|m_len
operator|<
name|hlen
operator|)
condition|)
name|mb_copy
operator|=
name|m_pullup
argument_list|(
name|mb_copy
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
name|send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_packet
parameter_list|(
name|struct
name|vif
modifier|*
name|vifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip_moptions
name|imo
decl_stmt|;
name|struct
name|in_multi
modifier|*
name|imm
index|[
literal|2
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|VIF_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|imo
operator|.
name|imo_multicast_ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
name|imo
operator|.
name|imo_multicast_ttl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_ttl
operator|-
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_multicast_loop
operator|=
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_multicast_vif
operator|=
operator|-
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_num_memberships
operator|=
literal|0
expr_stmt|;
name|imo
operator|.
name|imo_max_memberships
operator|=
literal|2
expr_stmt|;
name|imo
operator|.
name|imo_membership
operator|=
operator|&
name|imm
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Re-entrancy should not be a problem here, because 	 * the packets that we send out and are looped back at us 	 * should get rejected because they appear to come from 	 * the loopback interface, thus preventing looping. 	 */
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
operator|&
name|vifp
operator|->
name|v_route
argument_list|,
name|IP_FORWARDING
argument_list|,
operator|&
name|imo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: vif %td err %d"
argument_list|,
name|__func__
argument_list|,
call|(
name|ptrdiff_t
call|)
argument_list|(
name|vifp
operator|-
name|viftable
argument_list|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stubs for old RSVP socket shim implementation.  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_rsvp_vif
parameter_list|(
name|struct
name|socket
modifier|*
name|so
name|__unused
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|X_ip_rsvp_force_done
parameter_list|(
name|struct
name|socket
modifier|*
name|so
name|__unused
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|X_rsvp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
name|__unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|V_rsvp_on
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Code for bandwidth monitors  */
end_comment

begin_comment
comment|/*  * Define common interface for timeval-related methods  */
end_comment

begin_define
define|#
directive|define
name|BW_TIMEVALCMP
parameter_list|(
name|tvp
parameter_list|,
name|uvp
parameter_list|,
name|cmp
parameter_list|)
value|timevalcmp((tvp), (uvp), cmp)
end_define

begin_define
define|#
directive|define
name|BW_TIMEVALDECR
parameter_list|(
name|vvp
parameter_list|,
name|uvp
parameter_list|)
value|timevalsub((vvp), (uvp))
end_define

begin_define
define|#
directive|define
name|BW_TIMEVALADD
parameter_list|(
name|vvp
parameter_list|,
name|uvp
parameter_list|)
value|timevaladd((vvp), (uvp))
end_define

begin_function
specifier|static
name|uint32_t
name|compute_bw_meter_flags
parameter_list|(
name|struct
name|bw_upcall
modifier|*
name|req
parameter_list|)
block|{
name|uint32_t
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|bu_flags
operator|&
name|BW_UPCALL_UNIT_PACKETS
condition|)
name|flags
operator||=
name|BW_METER_UNIT_PACKETS
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|bu_flags
operator|&
name|BW_UPCALL_UNIT_BYTES
condition|)
name|flags
operator||=
name|BW_METER_UNIT_BYTES
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|bu_flags
operator|&
name|BW_UPCALL_GEQ
condition|)
name|flags
operator||=
name|BW_METER_GEQ
expr_stmt|;
if|if
condition|(
name|req
operator|->
name|bu_flags
operator|&
name|BW_UPCALL_LEQ
condition|)
name|flags
operator||=
name|BW_METER_LEQ
expr_stmt|;
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/*  * Add a bw_meter entry  */
end_comment

begin_function
specifier|static
name|int
name|add_bw_upcall
parameter_list|(
name|struct
name|bw_upcall
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|mfc
modifier|*
name|mfc
decl_stmt|;
name|struct
name|timeval
name|delta
init|=
block|{
name|BW_UPCALL_THRESHOLD_INTERVAL_MIN_SEC
block|,
name|BW_UPCALL_THRESHOLD_INTERVAL_MIN_USEC
block|}
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|bw_meter
modifier|*
name|x
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mrt_api_config
operator|&
name|MRT_MFC_BW_UPCALL
operator|)
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* Test if the flags are valid */
if|if
condition|(
operator|!
operator|(
name|req
operator|->
name|bu_flags
operator|&
operator|(
name|BW_UPCALL_UNIT_PACKETS
operator||
name|BW_UPCALL_UNIT_BYTES
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|!
operator|(
name|req
operator|->
name|bu_flags
operator|&
operator|(
name|BW_UPCALL_GEQ
operator||
name|BW_UPCALL_LEQ
operator|)
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
operator|(
name|req
operator|->
name|bu_flags
operator|&
operator|(
name|BW_UPCALL_GEQ
operator||
name|BW_UPCALL_LEQ
operator|)
operator|)
operator|==
operator|(
name|BW_UPCALL_GEQ
operator||
name|BW_UPCALL_LEQ
operator|)
condition|)
return|return
name|EINVAL
return|;
comment|/* Test if the threshold time interval is valid */
if|if
condition|(
name|BW_TIMEVALCMP
argument_list|(
operator|&
name|req
operator|->
name|bu_threshold
operator|.
name|b_time
argument_list|,
operator|&
name|delta
argument_list|,
operator|<
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|flags
operator|=
name|compute_bw_meter_flags
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/*      * Find if we have already same bw_meter entry      */
name|MFC_LOCK
argument_list|()
expr_stmt|;
name|mfc
operator|=
name|mfc_find
argument_list|(
operator|&
name|req
operator|->
name|bu_src
argument_list|,
operator|&
name|req
operator|->
name|bu_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfc
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
for|for
control|(
name|x
operator|=
name|mfc
operator|->
name|mfc_bw_meter
init|;
name|x
operator|!=
name|NULL
condition|;
name|x
operator|=
name|x
operator|->
name|bm_mfc_next
control|)
block|{
if|if
condition|(
operator|(
name|BW_TIMEVALCMP
argument_list|(
operator|&
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
argument_list|,
operator|&
name|req
operator|->
name|bu_threshold
operator|.
name|b_time
argument_list|,
operator|==
argument_list|)
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|==
name|req
operator|->
name|bu_threshold
operator|.
name|b_packets
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|==
name|req
operator|->
name|bu_threshold
operator|.
name|b_bytes
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_USER_FLAGS
operator|)
operator|==
name|flags
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXX Already installed */
block|}
block|}
comment|/* Allocate the new bw_meter entry */
name|x
operator|=
operator|(
expr|struct
name|bw_meter
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|x
argument_list|)
argument_list|,
name|M_BWMETER
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Set the new bw_meter entry */
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
operator|=
name|req
operator|->
name|bu_threshold
operator|.
name|b_time
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|x
operator|->
name|bm_start_time
operator|=
name|now
expr_stmt|;
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|=
name|req
operator|->
name|bu_threshold
operator|.
name|b_packets
expr_stmt|;
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|=
name|req
operator|->
name|bu_threshold
operator|.
name|b_bytes
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_flags
operator|=
name|flags
expr_stmt|;
name|x
operator|->
name|bm_time_next
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|bm_time_hash
operator|=
name|BW_METER_BUCKETS
expr_stmt|;
comment|/* Add the new bw_meter entry to the front of entries for this MFC */
name|x
operator|->
name|bm_mfc
operator|=
name|mfc
expr_stmt|;
name|x
operator|->
name|bm_mfc_next
operator|=
name|mfc
operator|->
name|mfc_bw_meter
expr_stmt|;
name|mfc
operator|->
name|mfc_bw_meter
operator|=
name|x
expr_stmt|;
name|schedule_bw_meter
argument_list|(
name|x
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_bw_list
parameter_list|(
name|struct
name|bw_meter
modifier|*
name|list
parameter_list|)
block|{
while|while
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|bw_meter
modifier|*
name|x
init|=
name|list
decl_stmt|;
name|list
operator|=
name|list
operator|->
name|bm_mfc_next
expr_stmt|;
name|unschedule_bw_meter
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|x
argument_list|,
name|M_BWMETER
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delete one or multiple bw_meter entries  */
end_comment

begin_function
specifier|static
name|int
name|del_bw_upcall
parameter_list|(
name|struct
name|bw_upcall
modifier|*
name|req
parameter_list|)
block|{
name|struct
name|mfc
modifier|*
name|mfc
decl_stmt|;
name|struct
name|bw_meter
modifier|*
name|x
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|mrt_api_config
operator|&
name|MRT_MFC_BW_UPCALL
operator|)
condition|)
return|return
name|EOPNOTSUPP
return|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
comment|/* Find the corresponding MFC entry */
name|mfc
operator|=
name|mfc_find
argument_list|(
operator|&
name|req
operator|->
name|bu_src
argument_list|,
operator|&
name|req
operator|->
name|bu_dst
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfc
operator|==
name|NULL
condition|)
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
elseif|else
if|if
condition|(
name|req
operator|->
name|bu_flags
operator|&
name|BW_UPCALL_DELETE_ALL
condition|)
block|{
comment|/* 	 * Delete all bw_meter entries for this mfc 	 */
name|struct
name|bw_meter
modifier|*
name|list
decl_stmt|;
name|list
operator|=
name|mfc
operator|->
name|mfc_bw_meter
expr_stmt|;
name|mfc
operator|->
name|mfc_bw_meter
operator|=
name|NULL
expr_stmt|;
name|free_bw_list
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* Delete a single bw_meter entry */
name|struct
name|bw_meter
modifier|*
name|prev
decl_stmt|;
name|uint32_t
name|flags
init|=
literal|0
decl_stmt|;
name|flags
operator|=
name|compute_bw_meter_flags
argument_list|(
name|req
argument_list|)
expr_stmt|;
comment|/* Find the bw_meter entry to delete */
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|x
operator|=
name|mfc
operator|->
name|mfc_bw_meter
init|;
name|x
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|x
operator|,
name|x
operator|=
name|x
operator|->
name|bm_mfc_next
control|)
block|{
if|if
condition|(
operator|(
name|BW_TIMEVALCMP
argument_list|(
operator|&
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
argument_list|,
operator|&
name|req
operator|->
name|bu_threshold
operator|.
name|b_time
argument_list|,
operator|==
argument_list|)
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|==
name|req
operator|->
name|bu_threshold
operator|.
name|b_packets
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|==
name|req
operator|->
name|bu_threshold
operator|.
name|b_bytes
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_USER_FLAGS
operator|)
operator|==
name|flags
condition|)
break|break;
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
condition|)
block|{
comment|/* Delete entry from the list for this MFC */
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|bm_mfc_next
operator|=
name|x
operator|->
name|bm_mfc_next
expr_stmt|;
comment|/* remove from middle*/
else|else
name|x
operator|->
name|bm_mfc
operator|->
name|mfc_bw_meter
operator|=
name|x
operator|->
name|bm_mfc_next
expr_stmt|;
comment|/* new head of list */
name|unschedule_bw_meter
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
comment|/* Free the bw_meter entry */
name|free
argument_list|(
name|x
argument_list|,
name|M_BWMETER
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Perform bandwidth measurement processing that may result in an upcall  */
end_comment

begin_function
specifier|static
name|void
name|bw_meter_receive_packet
parameter_list|(
name|struct
name|bw_meter
modifier|*
name|x
parameter_list|,
name|int
name|plen
parameter_list|,
name|struct
name|timeval
modifier|*
name|nowp
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|MFC_LOCK_ASSERT
argument_list|()
expr_stmt|;
name|delta
operator|=
operator|*
name|nowp
expr_stmt|;
name|BW_TIMEVALDECR
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|x
operator|->
name|bm_start_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_GEQ
condition|)
block|{
comment|/* 	 * Processing for ">=" type of bw_meter entry 	 */
if|if
condition|(
name|BW_TIMEVALCMP
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Reset the bw_meter entry */
name|x
operator|->
name|bm_start_time
operator|=
operator|*
name|nowp
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_flags
operator|&=
operator|~
name|BW_METER_UPCALL_DELIVERED
expr_stmt|;
block|}
comment|/* Record that a packet is received */
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|++
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|+=
name|plen
expr_stmt|;
comment|/* 	 * Test if we should deliver an upcall 	 */
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UPCALL_DELIVERED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_PACKETS
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|>=
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|)
operator|)
operator|||
operator|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_BYTES
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|>=
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|)
operator|)
condition|)
block|{
comment|/* Prepare an upcall for delivery */
name|bw_meter_prepare_upcall
argument_list|(
name|x
argument_list|,
name|nowp
argument_list|)
expr_stmt|;
name|x
operator|->
name|bm_flags
operator||=
name|BW_METER_UPCALL_DELIVERED
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_LEQ
condition|)
block|{
comment|/* 	 * Processing for "<=" type of bw_meter entry 	 */
if|if
condition|(
name|BW_TIMEVALCMP
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* 	     * We are behind time with the multicast forwarding table 	     * scanning for "<=" type of bw_meter entries, so test now 	     * if we should deliver an upcall. 	     */
if|if
condition|(
operator|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_PACKETS
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|<=
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|)
operator|)
operator|||
operator|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_BYTES
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|<=
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|)
operator|)
condition|)
block|{
comment|/* Prepare an upcall for delivery */
name|bw_meter_prepare_upcall
argument_list|(
name|x
argument_list|,
name|nowp
argument_list|)
expr_stmt|;
block|}
comment|/* Reschedule the bw_meter entry */
name|unschedule_bw_meter
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|schedule_bw_meter
argument_list|(
name|x
argument_list|,
name|nowp
argument_list|)
expr_stmt|;
block|}
comment|/* Record that a packet is received */
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|++
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|+=
name|plen
expr_stmt|;
comment|/* 	 * Test if we should restart the measuring interval 	 */
if|if
condition|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_PACKETS
operator|&&
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|<=
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|)
operator|||
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_BYTES
operator|&&
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|<=
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|)
condition|)
block|{
comment|/* Don't restart the measuring interval */
block|}
else|else
block|{
comment|/* Do restart the measuring interval */
comment|/* 	     * XXX: note that we don't unschedule and schedule, because this 	     * might be too much overhead per packet. Instead, when we process 	     * all entries for a given timer hash bin, we check whether it is 	     * really a timeout. If not, we reschedule at that time. 	     */
name|x
operator|->
name|bm_start_time
operator|=
operator|*
name|nowp
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_flags
operator|&=
operator|~
name|BW_METER_UPCALL_DELIVERED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Prepare a bandwidth-related upcall  */
end_comment

begin_function
specifier|static
name|void
name|bw_meter_prepare_upcall
parameter_list|(
name|struct
name|bw_meter
modifier|*
name|x
parameter_list|,
name|struct
name|timeval
modifier|*
name|nowp
parameter_list|)
block|{
name|struct
name|timeval
name|delta
decl_stmt|;
name|struct
name|bw_upcall
modifier|*
name|u
decl_stmt|;
name|MFC_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/*      * Compute the measured time interval      */
name|delta
operator|=
operator|*
name|nowp
expr_stmt|;
name|BW_TIMEVALDECR
argument_list|(
operator|&
name|delta
argument_list|,
operator|&
name|x
operator|->
name|bm_start_time
argument_list|)
expr_stmt|;
comment|/*      * If there are too many pending upcalls, deliver them now      */
if|if
condition|(
name|bw_upcalls_n
operator|>=
name|BW_UPCALLS_MAX
condition|)
name|bw_upcalls_send
argument_list|()
expr_stmt|;
comment|/*      * Set the bw_upcall entry      */
name|u
operator|=
operator|&
name|bw_upcalls
index|[
name|bw_upcalls_n
operator|++
index|]
expr_stmt|;
name|u
operator|->
name|bu_src
operator|=
name|x
operator|->
name|bm_mfc
operator|->
name|mfc_origin
expr_stmt|;
name|u
operator|->
name|bu_dst
operator|=
name|x
operator|->
name|bm_mfc
operator|->
name|mfc_mcastgrp
expr_stmt|;
name|u
operator|->
name|bu_threshold
operator|.
name|b_time
operator|=
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
expr_stmt|;
name|u
operator|->
name|bu_threshold
operator|.
name|b_packets
operator|=
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
expr_stmt|;
name|u
operator|->
name|bu_threshold
operator|.
name|b_bytes
operator|=
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
expr_stmt|;
name|u
operator|->
name|bu_measured
operator|.
name|b_time
operator|=
name|delta
expr_stmt|;
name|u
operator|->
name|bu_measured
operator|.
name|b_packets
operator|=
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
expr_stmt|;
name|u
operator|->
name|bu_measured
operator|.
name|b_bytes
operator|=
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
expr_stmt|;
name|u
operator|->
name|bu_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_PACKETS
condition|)
name|u
operator|->
name|bu_flags
operator||=
name|BW_UPCALL_UNIT_PACKETS
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_BYTES
condition|)
name|u
operator|->
name|bu_flags
operator||=
name|BW_UPCALL_UNIT_BYTES
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_GEQ
condition|)
name|u
operator|->
name|bu_flags
operator||=
name|BW_UPCALL_GEQ
expr_stmt|;
if|if
condition|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_LEQ
condition|)
name|u
operator|->
name|bu_flags
operator||=
name|BW_UPCALL_LEQ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send the pending bandwidth-related upcalls  */
end_comment

begin_function
specifier|static
name|void
name|bw_upcalls_send
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
init|=
name|bw_upcalls_n
operator|*
sizeof|sizeof
argument_list|(
name|bw_upcalls
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|struct
name|sockaddr_in
name|k_igmpsrc
init|=
block|{
sizeof|sizeof
name|k_igmpsrc
block|,
name|AF_INET
block|}
decl_stmt|;
specifier|static
name|struct
name|igmpmsg
name|igmpmsg
init|=
block|{
literal|0
block|,
comment|/* unused1 */
literal|0
block|,
comment|/* unused2 */
name|IGMPMSG_BW_UPCALL
block|,
comment|/* im_msgtype */
literal|0
block|,
comment|/* im_mbz  */
literal|0
block|,
comment|/* im_vif  */
literal|0
block|,
comment|/* unused3 */
block|{
literal|0
block|}
block|,
comment|/* im_src  */
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* im_dst  */
name|MFC_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
name|bw_upcalls_n
operator|==
literal|0
condition|)
return|return;
comment|/* No pending upcalls */
name|bw_upcalls_n
operator|=
literal|0
expr_stmt|;
comment|/*      * Allocate a new mbuf, initialize it with the header and      * the payload for the pending calls.      */
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bw_upcalls_send: cannot allocate mbuf\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmpmsg
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|igmpmsg
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|igmpmsg
argument_list|)
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|bw_upcalls
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/*      * Send the upcalls      * XXX do we need to set the address in k_igmpsrc ?      */
name|MRTSTAT_INC
argument_list|(
name|mrts_upcalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|V_ip_mrouter
argument_list|,
name|m
argument_list|,
operator|&
name|k_igmpsrc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"bw_upcalls_send: ip_mrouter socket queue full\n"
argument_list|)
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upq_sockfull
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the timeout hash value for the bw_meter entries  */
end_comment

begin_define
define|#
directive|define
name|BW_METER_TIMEHASH
parameter_list|(
name|bw_meter
parameter_list|,
name|hash
parameter_list|)
define|\
value|do {								\ 	struct timeval next_timeval = (bw_meter)->bm_start_time;	\ 									\ 	BW_TIMEVALADD(&next_timeval,&(bw_meter)->bm_threshold.b_time); \ 	(hash) = next_timeval.tv_sec;					\ 	if (next_timeval.tv_usec)					\ 	    (hash)++;
comment|/* XXX: make sure we don't timeout early */
value|\ 	(hash) %= BW_METER_BUCKETS;					\     } while (0)
end_define

begin_comment
comment|/*  * Schedule a timer to process periodically bw_meter entry of type "<="  * by linking the entry in the proper hash bucket.  */
end_comment

begin_function
specifier|static
name|void
name|schedule_bw_meter
parameter_list|(
name|struct
name|bw_meter
modifier|*
name|x
parameter_list|,
name|struct
name|timeval
modifier|*
name|nowp
parameter_list|)
block|{
name|int
name|time_hash
decl_stmt|;
name|MFC_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_LEQ
operator|)
condition|)
return|return;
comment|/* XXX: we schedule timers only for "<=" entries */
comment|/*      * Reset the bw_meter entry      */
name|x
operator|->
name|bm_start_time
operator|=
operator|*
name|nowp
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|=
literal|0
expr_stmt|;
name|x
operator|->
name|bm_flags
operator|&=
operator|~
name|BW_METER_UPCALL_DELIVERED
expr_stmt|;
comment|/*      * Compute the timeout hash value and insert the entry      */
name|BW_METER_TIMEHASH
argument_list|(
name|x
argument_list|,
name|time_hash
argument_list|)
expr_stmt|;
name|x
operator|->
name|bm_time_next
operator|=
name|bw_meter_timers
index|[
name|time_hash
index|]
expr_stmt|;
name|bw_meter_timers
index|[
name|time_hash
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|bm_time_hash
operator|=
name|time_hash
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unschedule the periodic timer that processes bw_meter entry of type "<="  * by removing the entry from the proper hash bucket.  */
end_comment

begin_function
specifier|static
name|void
name|unschedule_bw_meter
parameter_list|(
name|struct
name|bw_meter
modifier|*
name|x
parameter_list|)
block|{
name|int
name|time_hash
decl_stmt|;
name|struct
name|bw_meter
modifier|*
name|prev
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|MFC_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_LEQ
operator|)
condition|)
return|return;
comment|/* XXX: we schedule timers only for "<=" entries */
comment|/*      * Compute the timeout hash value and delete the entry      */
name|time_hash
operator|=
name|x
operator|->
name|bm_time_hash
expr_stmt|;
if|if
condition|(
name|time_hash
operator|>=
name|BW_METER_BUCKETS
condition|)
return|return;
comment|/* Entry was not scheduled */
for|for
control|(
name|prev
operator|=
name|NULL
operator|,
name|tmp
operator|=
name|bw_meter_timers
index|[
name|time_hash
index|]
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|tmp
operator|,
name|tmp
operator|=
name|tmp
operator|->
name|bm_time_next
control|)
if|if
condition|(
name|tmp
operator|==
name|x
condition|)
break|break;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"unschedule_bw_meter: bw_meter entry not found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
name|prev
operator|->
name|bm_time_next
operator|=
name|x
operator|->
name|bm_time_next
expr_stmt|;
else|else
name|bw_meter_timers
index|[
name|time_hash
index|]
operator|=
name|x
operator|->
name|bm_time_next
expr_stmt|;
name|x
operator|->
name|bm_time_next
operator|=
name|NULL
expr_stmt|;
name|x
operator|->
name|bm_time_hash
operator|=
name|BW_METER_BUCKETS
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process all "<=" type of bw_meter that should be processed now,  * and for each entry prepare an upcall if necessary. Each processed  * entry is rescheduled again for the (periodic) processing.  *  * This is run periodically (once per second normally). On each round,  * all the potentially matching entries are in the hash slot that we are  * looking at.  */
end_comment

begin_function
specifier|static
name|void
name|bw_meter_process
parameter_list|()
block|{
specifier|static
name|uint32_t
name|last_tv_sec
decl_stmt|;
comment|/* last time we processed this */
name|uint32_t
name|loops
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|process_endtime
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_tv_sec
operator|==
name|now
operator|.
name|tv_sec
condition|)
return|return;
comment|/* nothing to do */
name|loops
operator|=
name|now
operator|.
name|tv_sec
operator|-
name|last_tv_sec
expr_stmt|;
name|last_tv_sec
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|loops
operator|>
name|BW_METER_BUCKETS
condition|)
name|loops
operator|=
name|BW_METER_BUCKETS
expr_stmt|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
comment|/*      * Process all bins of bw_meter entries from the one after the last      * processed to the current one. On entry, i points to the last bucket      * visited, so we need to increment i at the beginning of the loop.      */
for|for
control|(
name|i
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|loops
operator|)
operator|%
name|BW_METER_BUCKETS
init|;
name|loops
operator|>
literal|0
condition|;
name|loops
operator|--
control|)
block|{
name|struct
name|bw_meter
modifier|*
name|x
decl_stmt|,
modifier|*
name|tmp_list
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|>=
name|BW_METER_BUCKETS
condition|)
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Disconnect the list of bw_meter entries from the bin */
name|tmp_list
operator|=
name|bw_meter_timers
index|[
name|i
index|]
expr_stmt|;
name|bw_meter_timers
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* Process the list of bw_meter entries */
while|while
condition|(
name|tmp_list
operator|!=
name|NULL
condition|)
block|{
name|x
operator|=
name|tmp_list
expr_stmt|;
name|tmp_list
operator|=
name|tmp_list
operator|->
name|bm_time_next
expr_stmt|;
comment|/* Test if the time interval is over */
name|process_endtime
operator|=
name|x
operator|->
name|bm_start_time
expr_stmt|;
name|BW_TIMEVALADD
argument_list|(
operator|&
name|process_endtime
argument_list|,
operator|&
name|x
operator|->
name|bm_threshold
operator|.
name|b_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|BW_TIMEVALCMP
argument_list|(
operator|&
name|process_endtime
argument_list|,
operator|&
name|now
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Not yet: reschedule, but don't reset */
name|int
name|time_hash
decl_stmt|;
name|BW_METER_TIMEHASH
argument_list|(
name|x
argument_list|,
name|time_hash
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_hash
operator|==
name|i
operator|&&
name|process_endtime
operator|.
name|tv_sec
operator|==
name|now
operator|.
name|tv_sec
condition|)
block|{
comment|/* 		     * XXX: somehow the bin processing is a bit ahead of time. 		     * Put the entry in the next bin. 		     */
if|if
condition|(
operator|++
name|time_hash
operator|>=
name|BW_METER_BUCKETS
condition|)
name|time_hash
operator|=
literal|0
expr_stmt|;
block|}
name|x
operator|->
name|bm_time_next
operator|=
name|bw_meter_timers
index|[
name|time_hash
index|]
expr_stmt|;
name|bw_meter_timers
index|[
name|time_hash
index|]
operator|=
name|x
expr_stmt|;
name|x
operator|->
name|bm_time_hash
operator|=
name|time_hash
expr_stmt|;
continue|continue;
block|}
comment|/* 	     * Test if we should deliver an upcall 	     */
if|if
condition|(
operator|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_PACKETS
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_measured
operator|.
name|b_packets
operator|<=
name|x
operator|->
name|bm_threshold
operator|.
name|b_packets
operator|)
operator|)
operator|||
operator|(
operator|(
name|x
operator|->
name|bm_flags
operator|&
name|BW_METER_UNIT_BYTES
operator|)
operator|&&
operator|(
name|x
operator|->
name|bm_measured
operator|.
name|b_bytes
operator|<=
name|x
operator|->
name|bm_threshold
operator|.
name|b_bytes
operator|)
operator|)
condition|)
block|{
comment|/* Prepare an upcall for delivery */
name|bw_meter_prepare_upcall
argument_list|(
name|x
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Reschedule for next processing 	     */
name|schedule_bw_meter
argument_list|(
name|x
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Send all upcalls that are pending delivery */
name|bw_upcalls_send
argument_list|()
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A periodic function for sending all upcalls that are pending delivery  */
end_comment

begin_function
specifier|static
name|void
name|expire_bw_upcalls_send
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|MFC_LOCK
argument_list|()
expr_stmt|;
name|bw_upcalls_send
argument_list|()
expr_stmt|;
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|bw_upcalls_ch
argument_list|,
name|BW_UPCALLS_PERIOD
argument_list|,
name|expire_bw_upcalls_send
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A periodic function for periodic scanning of the multicast forwarding  * table for processing all "<=" bw_meter entries.  */
end_comment

begin_function
specifier|static
name|void
name|expire_bw_meter_process
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
name|mrt_api_config
operator|&
name|MRT_MFC_BW_UPCALL
condition|)
name|bw_meter_process
argument_list|()
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|bw_meter_ch
argument_list|,
name|BW_METER_PERIOD
argument_list|,
name|expire_bw_meter_process
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End of bandwidth monitoring code  */
end_comment

begin_comment
comment|/*  * Send the packet up to the user daemon, or eventually do kernel encapsulation  *  */
end_comment

begin_function
specifier|static
name|int
name|pim_register_send
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|vif
modifier|*
name|vifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mfc
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|,
modifier|*
name|mm
decl_stmt|;
comment|/*      * Do not send IGMP_WHOLEPKT notifications to userland, if the      * rendezvous point was unspecified, and we were told not to.      */
if|if
condition|(
name|pim_squelch_wholepkt
operator|!=
literal|0
operator|&&
operator|(
name|mrt_api_config
operator|&
name|MRT_MFC_RP
operator|)
operator|&&
name|in_nullhost
argument_list|(
name|rt
operator|->
name|mfc_rp
argument_list|)
condition|)
return|return
literal|0
return|;
name|mb_copy
operator|=
name|pim_register_prepare
argument_list|(
name|ip
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return
name|ENOBUFS
return|;
comment|/*      * Send all the fragments. Note that the mbuf for each fragment      * is freed by the sending machinery.      */
for|for
control|(
name|mm
operator|=
name|mb_copy
init|;
name|mm
condition|;
name|mm
operator|=
name|mb_copy
control|)
block|{
name|mb_copy
operator|=
name|mm
operator|->
name|m_nextpkt
expr_stmt|;
name|mm
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
name|mm
operator|=
name|m_pullup
argument_list|(
name|mm
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mrt_api_config
operator|&
name|MRT_MFC_RP
operator|)
operator|&&
operator|!
name|in_nullhost
argument_list|(
name|rt
operator|->
name|mfc_rp
argument_list|)
condition|)
block|{
name|pim_register_send_rp
argument_list|(
name|ip
argument_list|,
name|vifp
argument_list|,
name|mm
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pim_register_send_upcall
argument_list|(
name|ip
argument_list|,
name|vifp
argument_list|,
name|mm
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return a copy of the data packet that is ready for PIM Register  * encapsulation.  * XXX: Note that in the returned copy the IP header is a valid one.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|pim_register_prepare
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb_copy
init|=
name|NULL
decl_stmt|;
name|int
name|mtu
decl_stmt|;
comment|/* Take care of delayed checksums */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DELAY_DATA
condition|)
block|{
name|in_delayed_cksum
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DELAY_DATA
expr_stmt|;
block|}
comment|/*      * Copy the old packet& pullup its IP header into the      * new mbuf so we can modify it.      */
name|mb_copy
operator|=
name|m_copypacket
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|mb_copy
operator|=
name|m_pullup
argument_list|(
name|mb_copy
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* take care of the TTL */
name|ip
operator|=
name|mtod
argument_list|(
name|mb_copy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
operator|--
name|ip
operator|->
name|ip_ttl
expr_stmt|;
comment|/* Compute the MTU after the PIM Register encapsulation */
name|mtu
operator|=
literal|0xffff
operator|-
sizeof|sizeof
argument_list|(
name|pim_encap_iphdr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|pim_encap_pimhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|<=
name|mtu
condition|)
block|{
comment|/* Turn the IP header into a valid one */
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|mb_copy
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fragment the packet */
if|if
condition|(
name|ip_fragment
argument_list|(
name|ip
argument_list|,
operator|&
name|mb_copy
argument_list|,
name|mtu
argument_list|,
literal|0
argument_list|,
name|CSUM_DELAY_IP
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|mb_copy
return|;
block|}
end_function

begin_comment
comment|/*  * Send an upcall with the data packet to the user-level process.  */
end_comment

begin_function
specifier|static
name|int
name|pim_register_send_upcall
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|vif
modifier|*
name|vifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mb_copy
parameter_list|,
name|struct
name|mfc
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb_first
decl_stmt|;
name|int
name|len
init|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
decl_stmt|;
name|struct
name|igmpmsg
modifier|*
name|im
decl_stmt|;
name|struct
name|sockaddr_in
name|k_igmpsrc
init|=
block|{
sizeof|sizeof
name|k_igmpsrc
block|,
name|AF_INET
block|}
decl_stmt|;
name|VIF_LOCK_ASSERT
argument_list|()
expr_stmt|;
comment|/*      * Add a new mbuf with an upcall header      */
name|MGETHDR
argument_list|(
name|mb_first
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_first
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|mb_first
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|mb_first
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|igmpmsg
argument_list|)
expr_stmt|;
name|mb_first
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|igmpmsg
argument_list|)
expr_stmt|;
name|mb_first
operator|->
name|m_next
operator|=
name|mb_copy
expr_stmt|;
comment|/* Send message to routing daemon */
name|im
operator|=
name|mtod
argument_list|(
name|mb_first
argument_list|,
expr|struct
name|igmpmsg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_msgtype
operator|=
name|IGMPMSG_WHOLEPKT
expr_stmt|;
name|im
operator|->
name|im_mbz
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|im_vif
operator|=
name|vifp
operator|-
name|viftable
expr_stmt|;
name|im
operator|->
name|im_src
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|im
operator|->
name|im_dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|k_igmpsrc
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upcalls
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|V_ip_mrouter
argument_list|,
name|mb_first
argument_list|,
operator|&
name|k_igmpsrc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: socket queue full"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|MRTSTAT_INC
argument_list|(
name|mrts_upq_sockfull
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Keep statistics */
name|PIMSTAT_INC
argument_list|(
name|pims_snd_registers_msgs
argument_list|)
expr_stmt|;
name|PIMSTAT_ADD
argument_list|(
name|pims_snd_registers_bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate the data packet in PIM Register message and send it to the RP.  */
end_comment

begin_function
specifier|static
name|int
name|pim_register_send_rp
parameter_list|(
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|vif
modifier|*
name|vifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mb_copy
parameter_list|,
name|struct
name|mfc
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mb_first
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip_outer
decl_stmt|;
name|struct
name|pim_encap_pimhdr
modifier|*
name|pimhdr
decl_stmt|;
name|int
name|len
init|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
decl_stmt|;
name|vifi_t
name|vifi
init|=
name|rt
operator|->
name|mfc_parent
decl_stmt|;
name|VIF_LOCK_ASSERT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|>=
name|numvifs
operator|)
operator|||
name|in_nullhost
argument_list|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
comment|/* The iif vif is invalid */
block|}
comment|/*      * Add a new mbuf with the encapsulating header      */
name|MGETHDR
argument_list|(
name|mb_first
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_first
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|mb_first
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|mb_first
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|pim_encap_iphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|pim_encap_pimhdr
argument_list|)
expr_stmt|;
name|mb_first
operator|->
name|m_next
operator|=
name|mb_copy
expr_stmt|;
name|mb_first
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
operator|+
name|mb_first
operator|->
name|m_len
expr_stmt|;
comment|/*      * Fill in the encapsulating IP and PIM header      */
name|ip_outer
operator|=
name|mtod
argument_list|(
name|mb_first
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ip_outer
operator|=
name|pim_encap_iphdr
expr_stmt|;
name|ip_outer
operator|->
name|ip_id
operator|=
name|ip_newid
argument_list|()
expr_stmt|;
name|ip_outer
operator|->
name|ip_len
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
name|pim_encap_iphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|pim_encap_pimhdr
argument_list|)
expr_stmt|;
name|ip_outer
operator|->
name|ip_src
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
expr_stmt|;
name|ip_outer
operator|->
name|ip_dst
operator|=
name|rt
operator|->
name|mfc_rp
expr_stmt|;
comment|/*      * Copy the inner header TOS to the outer header, and take care of the      * IP_DF bit.      */
name|ip_outer
operator|->
name|ip_tos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|&
name|IP_DF
condition|)
name|ip_outer
operator|->
name|ip_off
operator||=
name|IP_DF
expr_stmt|;
name|pimhdr
operator|=
operator|(
expr|struct
name|pim_encap_pimhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip_outer
operator|+
sizeof|sizeof
argument_list|(
name|pim_encap_iphdr
argument_list|)
operator|)
expr_stmt|;
operator|*
name|pimhdr
operator|=
name|pim_encap_pimhdr
expr_stmt|;
comment|/* If the iif crosses a border, set the Border-bit */
if|if
condition|(
name|rt
operator|->
name|mfc_flags
index|[
name|vifi
index|]
operator|&
name|MRT_MFC_FLAGS_BORDER_VIF
operator|&
name|mrt_api_config
condition|)
name|pimhdr
operator|->
name|flags
operator||=
name|htonl
argument_list|(
name|PIM_BORDER_REGISTER
argument_list|)
expr_stmt|;
name|mb_first
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
name|pim_encap_iphdr
argument_list|)
expr_stmt|;
name|pimhdr
operator|->
name|pim
operator|.
name|pim_cksum
operator|=
name|in_cksum
argument_list|(
name|mb_first
argument_list|,
sizeof|sizeof
argument_list|(
name|pim_encap_pimhdr
argument_list|)
argument_list|)
expr_stmt|;
name|mb_first
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
name|pim_encap_iphdr
argument_list|)
expr_stmt|;
name|send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_first
argument_list|)
expr_stmt|;
comment|/* Keep statistics */
name|PIMSTAT_INC
argument_list|(
name|pims_snd_registers_msgs
argument_list|)
expr_stmt|;
name|PIMSTAT_ADD
argument_list|(
name|pims_snd_registers_bytes
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * pim_encapcheck() is called by the encap4_input() path at runtime to  * determine if a packet is for PIM; allowing PIM to be dynamically loaded  * into the kernel.  */
end_comment

begin_function
specifier|static
name|int
name|pim_encapcheck
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|proto
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|KASSERT
argument_list|(
name|proto
operator|==
name|IPPROTO_PIM
argument_list|,
operator|(
literal|"not for IPPROTO_PIM"
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|proto
operator|!=
name|IPPROTO_PIM
condition|)
return|return
literal|0
return|;
comment|/* not for us; reject the datagram. */
return|return
literal|64
return|;
comment|/* claim the datagram. */
block|}
end_function

begin_comment
comment|/*  * PIM-SMv2 and PIM-DM messages processing.  * Receives and verifies the PIM control messages, and passes them  * up to the listening socket, using rip_input().  * The only message with special processing is the PIM_REGISTER message  * (used by PIM-SM): the PIM header is stripped off, and the inner packet  * is passed to if_simloop().  */
end_comment

begin_function
name|void
name|pim_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|struct
name|pim
modifier|*
name|pim
decl_stmt|;
name|int
name|minlen
decl_stmt|;
name|int
name|datalen
init|=
name|ip
operator|->
name|ip_len
decl_stmt|;
name|int
name|ip_tos
decl_stmt|;
name|int
name|iphlen
init|=
name|off
decl_stmt|;
comment|/* Keep statistics */
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_total_msgs
argument_list|)
expr_stmt|;
name|PIMSTAT_ADD
argument_list|(
name|pims_rcv_total_bytes
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
comment|/*      * Validate lengths      */
if|if
condition|(
name|datalen
operator|<
name|PIM_MINLEN
condition|)
block|{
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_tooshort
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: short packet (%d) from %s"
argument_list|,
name|__func__
argument_list|,
name|datalen
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * If the packet is at least as big as a REGISTER, go agead      * and grab the PIM REGISTER header size, to avoid another      * possible m_pullup() later.      *      * PIM_MINLEN       == pimhdr + u_int32_t == 4 + 4 = 8      * PIM_REG_MINLEN   == pimhdr + reghdr + encap_iphdr == 4 + 4 + 20 = 28      */
name|minlen
operator|=
name|iphlen
operator|+
operator|(
name|datalen
operator|>=
name|PIM_REG_MINLEN
condition|?
name|PIM_REG_MINLEN
else|:
name|PIM_MINLEN
operator|)
expr_stmt|;
comment|/*      * Get the IP and PIM headers in contiguous memory, and      * possibly the PIM REGISTER header.      */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EXT
operator|||
name|m
operator|->
name|m_len
operator|<
name|minlen
operator|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|minlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: m_pullup() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* m_pullup() may have given us a new mbuf so reset ip. */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip_tos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
comment|/* adjust mbuf to point to the PIM header */
name|m
operator|->
name|m_data
operator|+=
name|iphlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|iphlen
expr_stmt|;
name|pim
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|pim
operator|*
argument_list|)
expr_stmt|;
comment|/*      * Validate checksum. If PIM REGISTER, exclude the data packet.      *      * XXX: some older PIMv2 implementations don't make this distinction,      * so for compatibility reason perform the checksum over part of the      * message, and if error, then over the whole message.      */
if|if
condition|(
name|PIM_VT_T
argument_list|(
name|pim
operator|->
name|pim_vt
argument_list|)
operator|==
name|PIM_REGISTER
operator|&&
name|in_cksum
argument_list|(
name|m
argument_list|,
name|PIM_MINLEN
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* do nothing, checksum okay */
block|}
elseif|else
if|if
condition|(
name|in_cksum
argument_list|(
name|m
argument_list|,
name|datalen
argument_list|)
condition|)
block|{
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_badsum
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: invalid checksum"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* PIM version check */
if|if
condition|(
name|PIM_VT_V
argument_list|(
name|pim
operator|->
name|pim_vt
argument_list|)
operator|<
name|PIM_VERSION
condition|)
block|{
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_badversion
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: bad version %d expect %d"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|PIM_VT_V
argument_list|(
name|pim
operator|->
name|pim_vt
argument_list|)
argument_list|,
name|PIM_VERSION
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* restore mbuf back to the outer IP */
name|m
operator|->
name|m_data
operator|-=
name|iphlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
name|iphlen
expr_stmt|;
if|if
condition|(
name|PIM_VT_T
argument_list|(
name|pim
operator|->
name|pim_vt
argument_list|)
operator|==
name|PIM_REGISTER
condition|)
block|{
comment|/* 	 * Since this is a REGISTER, we'll make a copy of the register 	 * headers ip + pim + u_int32 + encap_ip, to be passed up to the 	 * routing daemon. 	 */
name|struct
name|sockaddr_in
name|dst
init|=
block|{
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcp
decl_stmt|;
name|struct
name|ip
modifier|*
name|encap_ip
decl_stmt|;
name|u_int32_t
modifier|*
name|reghdr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|vifp
decl_stmt|;
name|VIF_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|reg_vif_num
operator|>=
name|numvifs
operator|)
operator|||
operator|(
name|reg_vif_num
operator|==
name|VIFI_INVALID
operator|)
condition|)
block|{
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: register vif not set: %d"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|reg_vif_num
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX need refcnt? */
name|vifp
operator|=
name|viftable
index|[
name|reg_vif_num
index|]
operator|.
name|v_ifp
expr_stmt|;
name|VIF_UNLOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Validate length 	 */
if|if
condition|(
name|datalen
operator|<
name|PIM_REG_MINLEN
condition|)
block|{
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_tooshort
argument_list|)
expr_stmt|;
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_badregisters
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: register packet size too small"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|reghdr
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|pim
operator|+
literal|1
operator|)
expr_stmt|;
name|encap_ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|reghdr
operator|+
literal|1
operator|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: register: encap ip src %s len %d"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|encap_ip
operator|->
name|ip_src
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|encap_ip
operator|->
name|ip_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* verify the version number of the inner packet */
if|if
condition|(
name|encap_ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_badregisters
argument_list|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: bad encap ip version"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* verify the inner packet is destined to a mcast group */
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|encap_ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_badregisters
argument_list|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: bad encap ip dest %s"
argument_list|,
name|__func__
argument_list|,
name|inet_ntoa
argument_list|(
name|encap_ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If a NULL_REGISTER, pass it to the daemon */
if|if
condition|(
operator|(
name|ntohl
argument_list|(
operator|*
name|reghdr
argument_list|)
operator|&
name|PIM_NULL_REGISTER
operator|)
condition|)
goto|goto
name|pim_input_to_daemon
goto|;
comment|/* 	 * Copy the TOS from the outer IP header to the inner IP header. 	 */
if|if
condition|(
name|encap_ip
operator|->
name|ip_tos
operator|!=
name|ip_tos
condition|)
block|{
comment|/* Outer TOS -> inner TOS */
name|encap_ip
operator|->
name|ip_tos
operator|=
name|ip_tos
expr_stmt|;
comment|/* Recompute the inner header checksum. Sigh... */
comment|/* adjust mbuf to point to the inner IP header */
name|m
operator|->
name|m_data
operator|+=
operator|(
name|iphlen
operator|+
name|PIM_MINLEN
operator|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
operator|(
name|iphlen
operator|+
name|PIM_MINLEN
operator|)
expr_stmt|;
name|encap_ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|encap_ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|encap_ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
comment|/* restore mbuf to point back to the outer IP header */
name|m
operator|->
name|m_data
operator|-=
operator|(
name|iphlen
operator|+
name|PIM_MINLEN
operator|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|iphlen
operator|+
name|PIM_MINLEN
operator|)
expr_stmt|;
block|}
comment|/* 	 * Decapsulate the inner IP packet and loopback to forward it 	 * as a normal multicast packet. Also, make a copy of the 	 *     outer_iphdr + pimhdr + reghdr + encap_iphdr 	 * to pass to the daemon later, so it can take the appropriate 	 * actions (e.g., send back PIM_REGISTER_STOP). 	 * XXX: here m->m_data points to the outer IP header. 	 */
name|mcp
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|iphlen
operator|+
name|PIM_REG_MINLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcp
operator|==
name|NULL
condition|)
block|{
name|CTR1
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: m_copy() failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Keep statistics */
comment|/* XXX: registers_bytes include only the encap. mcast pkt */
name|PIMSTAT_INC
argument_list|(
name|pims_rcv_registers_msgs
argument_list|)
expr_stmt|;
name|PIMSTAT_ADD
argument_list|(
name|pims_rcv_registers_bytes
argument_list|,
name|ntohs
argument_list|(
name|encap_ip
operator|->
name|ip_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * forward the inner ip packet; point m_data at the inner ip. 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
name|PIM_MINLEN
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_IPMF
argument_list|,
literal|"%s: forward decap'd REGISTER: src %lx dst %lx vif %d"
argument_list|,
name|__func__
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|encap_ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|encap_ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|reg_vif_num
argument_list|)
expr_stmt|;
comment|/* NB: vifp was collected above; can it change on us? */
name|if_simloop
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|,
name|dst
operator|.
name|sin_family
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* prepare the register head to send to the mrouting daemon */
name|m
operator|=
name|mcp
expr_stmt|;
block|}
name|pim_input_to_daemon
label|:
comment|/*      * Pass the PIM message up to the daemon; if it is a Register message,      * pass the 'head' only up to the daemon. This includes the      * outer IP header, PIM header, PIM-Register header and the      * inner IP header.      * XXX: the outer IP header pkt size of a Register is not adjust to      * reflect the fact that the inner multicast data is truncated.      */
name|rip_input
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_mfctable
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|mfchashtbl
operator|==
name|NULL
condition|)
comment|/* XXX unlocked */
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|MFC_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mfchashsize
condition|;
name|i
operator|++
control|)
block|{
name|LIST_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&mfchashtbl[i]
argument_list|,
argument|mfc_hash
argument_list|)
block|{
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|rt
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mfc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out_locked
goto|;
block|}
block|}
name|out_locked
label|:
name|MFC_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|mfctable
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|sysctl_mfctable
argument_list|,
literal|"IPv4 Multicast Forwarding Table (struct *mfc[mfchashsize], "
literal|"netinet/ip_mroute.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|ip_mroute_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|MROUTER_LOCK_INIT
argument_list|()
expr_stmt|;
name|MFC_LOCK_INIT
argument_list|()
expr_stmt|;
name|VIF_LOCK_INIT
argument_list|()
expr_stmt|;
name|mfchashsize
operator|=
name|MFCHASHSIZE
expr_stmt|;
if|if
condition|(
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"net.inet.ip.mfchashsize"
argument_list|,
operator|&
name|mfchashsize
argument_list|)
operator|&&
operator|!
name|powerof2
argument_list|(
name|mfchashsize
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"WARNING: %s not a power of 2; using default\n"
argument_list|,
literal|"net.inet.ip.mfchashsize"
argument_list|)
expr_stmt|;
name|mfchashsize
operator|=
name|MFCHASHSIZE
expr_stmt|;
block|}
name|MALLOC
argument_list|(
name|nexpire
argument_list|,
name|u_char
operator|*
argument_list|,
name|mfchashsize
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pim_squelch_wholepkt
operator|=
literal|0
expr_stmt|;
name|TUNABLE_ULONG_FETCH
argument_list|(
literal|"net.inet.pim.squelch_wholepkt"
argument_list|,
operator|&
name|pim_squelch_wholepkt
argument_list|)
expr_stmt|;
name|ip_mrouter_reset
argument_list|()
expr_stmt|;
name|pim_encap_cookie
operator|=
name|encap_attach_func
argument_list|(
name|AF_INET
argument_list|,
name|IPPROTO_PIM
argument_list|,
name|pim_encapcheck
argument_list|,
operator|&
name|in_pim_protosw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pim_encap_cookie
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"ip_mroute: unable to attach pim encap\n"
argument_list|)
expr_stmt|;
name|VIF_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|MFC_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|MROUTER_LOCK_DESTROY
argument_list|()
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|ip_mcast_src
operator|=
name|X_ip_mcast_src
expr_stmt|;
name|ip_mforward
operator|=
name|X_ip_mforward
expr_stmt|;
name|ip_mrouter_done
operator|=
name|X_ip_mrouter_done
expr_stmt|;
name|ip_mrouter_get
operator|=
name|X_ip_mrouter_get
expr_stmt|;
name|ip_mrouter_set
operator|=
name|X_ip_mrouter_set
expr_stmt|;
name|ip_rsvp_force_done
operator|=
name|X_ip_rsvp_force_done
expr_stmt|;
name|ip_rsvp_vif
operator|=
name|X_ip_rsvp_vif
expr_stmt|;
name|legal_vif_num
operator|=
name|X_legal_vif_num
expr_stmt|;
name|mrt_ioctl
operator|=
name|X_mrt_ioctl
expr_stmt|;
name|rsvp_input_p
operator|=
name|X_rsvp_input
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
comment|/* 	 * Typically module unload happens after the user-level 	 * process has shutdown the kernel services (the check 	 * below insures someone can't just yank the module out 	 * from under a running process).  But if the module is 	 * just loaded and then unloaded w/o starting up a user 	 * process we still need to cleanup. 	 */
if|if
condition|(
name|V_ip_mrouter
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|pim_encap_cookie
condition|)
block|{
name|encap_detach
argument_list|(
name|pim_encap_cookie
argument_list|)
expr_stmt|;
name|pim_encap_cookie
operator|=
name|NULL
expr_stmt|;
block|}
name|X_ip_mrouter_done
argument_list|()
expr_stmt|;
name|FREE
argument_list|(
name|nexpire
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|nexpire
operator|=
name|NULL
expr_stmt|;
name|ip_mcast_src
operator|=
name|NULL
expr_stmt|;
name|ip_mforward
operator|=
name|NULL
expr_stmt|;
name|ip_mrouter_done
operator|=
name|NULL
expr_stmt|;
name|ip_mrouter_get
operator|=
name|NULL
expr_stmt|;
name|ip_mrouter_set
operator|=
name|NULL
expr_stmt|;
name|ip_rsvp_force_done
operator|=
name|NULL
expr_stmt|;
name|ip_rsvp_vif
operator|=
name|NULL
expr_stmt|;
name|legal_vif_num
operator|=
name|NULL
expr_stmt|;
name|mrt_ioctl
operator|=
name|NULL
expr_stmt|;
name|rsvp_input_p
operator|=
name|NULL
expr_stmt|;
name|VIF_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|MFC_LOCK_DESTROY
argument_list|()
expr_stmt|;
name|MROUTER_LOCK_DESTROY
argument_list|()
expr_stmt|;
break|break;
default|default:
return|return
name|EOPNOTSUPP
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|ip_mroutemod
init|=
block|{
literal|"ip_mroute"
block|,
name|ip_mroute_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|ip_mroute
argument_list|,
name|ip_mroutemod
argument_list|,
name|SI_SUB_PSEUDO
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

