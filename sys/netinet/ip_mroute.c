begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * IP multicast forwarding procedures  *  * Written by David Waitzman, BBN Labs, August 1988.  * Modified by Steve Deering, Stanford, February 1989.  * Modified by Mark J. Steiglitz, Stanford, May, 1991  * Modified by Van Jacobson, LBL, January 1993  * Modified by Ajit Thyagarajan, PARC, August 1993  * Modified by Bill Fenner, PARC, April 1995  *  * MROUTING Revision: 3.5  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"opt_mrouting.h"
end_include

begin_include
include|#
directive|include
file|"opt_random_ip_id.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_mroute.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NTOHL
end_ifndef

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|!=
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|NTOHL
parameter_list|(
name|d
parameter_list|)
value|((d) = ntohl((d)))
end_define

begin_define
define|#
directive|define
name|NTOHS
parameter_list|(
name|d
parameter_list|)
value|((d) = ntohs((u_short)(d)))
end_define

begin_define
define|#
directive|define
name|HTONL
parameter_list|(
name|d
parameter_list|)
value|((d) = htonl((d)))
end_define

begin_define
define|#
directive|define
name|HTONS
parameter_list|(
name|d
parameter_list|)
value|((d) = htons((u_short)(d)))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NTOHL
parameter_list|(
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|NTOHS
parameter_list|(
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|HTONL
parameter_list|(
name|d
parameter_list|)
end_define

begin_define
define|#
directive|define
name|HTONS
parameter_list|(
name|d
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTING
end_ifndef

begin_decl_stmt
specifier|extern
name|u_long
name|_ip_mcast_src
name|__P
argument_list|(
operator|(
name|int
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_ip_mforward
name|__P
argument_list|(
operator|(
expr|struct
name|ip
operator|*
name|ip
operator|,
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
expr|struct
name|mbuf
operator|*
name|m
operator|,
expr|struct
name|ip_moptions
operator|*
name|imo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_ip_mrouter_done
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_ip_mrouter_get
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
name|so
operator|,
expr|struct
name|sockopt
operator|*
name|sopt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_ip_mrouter_set
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
name|so
operator|,
expr|struct
name|sockopt
operator|*
name|sopt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|_mrt_ioctl
name|__P
argument_list|(
operator|(
name|int
name|req
operator|,
name|caddr_t
name|data
operator|,
expr|struct
name|proc
operator|*
name|p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dummy routines and globals used when multicast routing is not compiled in.  */
end_comment

begin_decl_stmt
name|struct
name|socket
modifier|*
name|ip_mrouter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int
name|rsvpdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_ip_mrouter_set
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_set
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
init|=
name|_ip_mrouter_set
function_decl|;
end_function_decl

begin_function
name|int
name|_ip_mrouter_get
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_get
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
init|=
name|_ip_mrouter_get
function_decl|;
end_function_decl

begin_function
name|int
name|_ip_mrouter_done
parameter_list|()
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_done
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|_ip_mrouter_done
function_decl|;
end_function_decl

begin_function
name|int
name|_ip_mforward
parameter_list|(
name|ip
parameter_list|,
name|ifp
parameter_list|,
name|m
parameter_list|,
name|imo
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mforward
function_decl|)
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
init|=
name|_ip_mforward
function_decl|;
end_function_decl

begin_function
name|int
name|_mrt_ioctl
parameter_list|(
name|int
name|req
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
return|return
name|EOPNOTSUPP
return|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|mrt_ioctl
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|,
name|struct
name|proc
modifier|*
parameter_list|)
init|=
name|_mrt_ioctl
function_decl|;
end_function_decl

begin_function
name|void
name|rsvp_input
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|)
comment|/* XXX must fixup manually */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
block|{
comment|/* Can still get packets with rsvp_on = 0 if there is a local member      * of the group to which the RSVP packet is addressed.  But in this      * case we want to throw the packet away.      */
if|if
condition|(
operator|!
name|rsvp_on
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ip_rsvpd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"rsvp_input: Sending packet up old-style socket\n"
argument_list|)
expr_stmt|;
name|rip_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Drop the packet */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ipip_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
comment|/* XXX must fixup manually */
name|rip_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|int
function_decl|(
modifier|*
name|legal_vif_num
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
literal|0
function_decl|;
end_function_decl

begin_comment
comment|/*  * This should never be called, since IP_MULTICAST_VIF should fail, but  * just in case it does get called, the code a little lower in ip_output  * will assign the packet a local address.  */
end_comment

begin_function
name|u_long
name|_ip_mcast_src
parameter_list|(
name|int
name|vifi
parameter_list|)
block|{
return|return
name|INADDR_ANY
return|;
block|}
end_function

begin_function_decl
name|u_long
function_decl|(
modifier|*
name|ip_mcast_src
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|_ip_mcast_src
function_decl|;
end_function_decl

begin_function
name|int
name|ip_rsvp_vif_init
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip_rsvp_vif_done
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ip_rsvp_force_done
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
return|return;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MROUTING */
end_comment

begin_define
define|#
directive|define
name|M_HASCL
parameter_list|(
name|m
parameter_list|)
value|((m)->m_flags& M_EXT)
end_define

begin_define
define|#
directive|define
name|INSIZ
value|sizeof(struct in_addr)
end_define

begin_define
define|#
directive|define
name|same
parameter_list|(
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|(bcmp((caddr_t)(a1), (caddr_t)(a2), INSIZ) == 0)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_MRTABLE
argument_list|,
literal|"mroutetbl"
argument_list|,
literal|"multicast routing tables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Globals.  All but ip_mrouter and ip_mrtproto could be static,  * except for netstat or debugging purposes.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_decl_stmt
name|struct
name|socket
modifier|*
name|ip_mrouter
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mrtstat
name|mrtstat
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MROUTE_LKM */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|X_ipip_input
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
name|m
operator|,
name|int
name|iphlen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|mrtstat
name|mrtstat
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_mrtproto
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NO_RTE_FOUND
value|0x1
end_define

begin_define
define|#
directive|define
name|RTE_FOUND
value|0x2
end_define

begin_decl_stmt
specifier|static
name|struct
name|mfc
modifier|*
name|mfctable
index|[
name|MFCTBLSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|nexpire
index|[
name|MFCTBLSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vif
name|viftable
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|mrtdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debug level 	*/
end_comment

begin_define
define|#
directive|define
name|DEBUG_MFC
value|0x02
end_define

begin_define
define|#
directive|define
name|DEBUG_FORWARD
value|0x04
end_define

begin_define
define|#
directive|define
name|DEBUG_EXPIRE
value|0x08
end_define

begin_define
define|#
directive|define
name|DEBUG_XMIT
value|0x10
end_define

begin_decl_stmt
specifier|static
name|u_int
name|tbfdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbf debug level 	*/
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|rsvpdebug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rsvp debug level   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|callout_handle
name|expire_upcalls_ch
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|EXPIRE_TIMEOUT
value|(hz / 4)
end_define

begin_comment
comment|/* 4x / second		*/
end_comment

begin_define
define|#
directive|define
name|UPCALL_EXPIRE
value|6
end_define

begin_comment
comment|/* number of timeouts	*/
end_comment

begin_comment
comment|/*  * Define the token bucket filter structures  * tbftable -> each vif has one of these for storing info   */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|tbf
name|tbftable
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TBF_REPROCESS
value|(hz / 100)
end_define

begin_comment
comment|/* 100x / second */
end_comment

begin_comment
comment|/*  * 'Interfaces' associated with decapsulator (so we can tell  * packets that went through it from ones that get reflected  * by a broken gateway).  These interfaces are never linked into  * the system ifnet list& no routes point to them.  I.e., packets  * can't be sent this way.  They only exist as a placeholder for  * multicast source verification.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ifnet
name|multicast_decap_if
index|[
name|MAXVIFS
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ENCAP_TTL
value|64
end_define

begin_define
define|#
directive|define
name|ENCAP_PROTO
value|IPPROTO_IPIP
end_define

begin_comment
comment|/* 4 */
end_comment

begin_comment
comment|/* prototype IP hdr for encapsulated packets */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|ip
name|multicast_encap_iphdr
init|=
block|{
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
block|,
name|IPVERSION
block|,
else|#
directive|else
name|IPVERSION
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
block|,
endif|#
directive|endif
literal|0
block|,
comment|/* tos */
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
block|,
comment|/* total length */
literal|0
block|,
comment|/* id */
literal|0
block|,
comment|/* frag offset */
name|ENCAP_TTL
block|,
name|ENCAP_PROTO
block|,
literal|0
block|,
comment|/* checksum */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Private variables.  */
end_comment

begin_decl_stmt
specifier|static
name|vifi_t
name|numvifs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_encap_tunnel
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * one-back cache used by ipip_input to locate a tunnel's vif  * given a datagram's src ip address.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|last_encap_src
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|vif
modifier|*
name|last_encap_vif
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_long
name|X_ip_mcast_src
name|__P
argument_list|(
operator|(
name|int
name|vifi
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|X_ip_mforward
name|__P
argument_list|(
operator|(
expr|struct
name|ip
operator|*
name|ip
operator|,
expr|struct
name|ifnet
operator|*
name|ifp
operator|,
expr|struct
name|mbuf
operator|*
name|m
operator|,
expr|struct
name|ip_moptions
operator|*
name|imo
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|X_ip_mrouter_done
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|X_ip_mrouter_get
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
name|so
operator|,
expr|struct
name|sockopt
operator|*
name|m
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|X_ip_mrouter_set
name|__P
argument_list|(
operator|(
expr|struct
name|socket
operator|*
name|so
operator|,
expr|struct
name|sockopt
operator|*
name|m
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|X_legal_vif_num
name|__P
argument_list|(
operator|(
name|int
name|vif
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|X_mrt_ioctl
name|__P
argument_list|(
operator|(
name|int
name|cmd
operator|,
name|caddr_t
name|data
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|get_sg_cnt
parameter_list|(
name|struct
name|sioc_sg_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_vif_cnt
parameter_list|(
name|struct
name|sioc_vif_req
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_vif
parameter_list|(
name|struct
name|vifctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifi_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|add_mfc
parameter_list|(
name|struct
name|mfcctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|del_mfc
parameter_list|(
name|struct
name|mfcctl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|socket_send
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_assert
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|expire_upcalls
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ip_mdq
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mfc
modifier|*
parameter_list|,
name|vifi_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|phyint_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|encap_send
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbf_control
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbf_queue
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbf_process_q
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbf_reprocess_q
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tbf_dq_sel
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbf_send_packet
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tbf_update_tokens
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|priority
parameter_list|(
name|struct
name|vif
modifier|*
parameter_list|,
name|struct
name|ip
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|multiencap_decap
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * whether or not special PIM assert processing is enabled.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pim_assert
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Rate limit for assert notification messages, in usec  */
end_comment

begin_define
define|#
directive|define
name|ASSERT_MSG_TIME
value|3000000
end_define

begin_comment
comment|/*  * Hash function for a source, group entry  */
end_comment

begin_define
define|#
directive|define
name|MFCHASH
parameter_list|(
name|a
parameter_list|,
name|g
parameter_list|)
value|MFCHASHMOD(((a)>> 20) ^ ((a)>> 10) ^ (a) ^ \ 			((g)>> 20) ^ ((g)>> 10) ^ (g))
end_define

begin_comment
comment|/*  * Find a route for a given origin IP address and Multicast group address  * Type of service parameter to be added in the future!!!  */
end_comment

begin_define
define|#
directive|define
name|MFCFIND
parameter_list|(
name|o
parameter_list|,
name|g
parameter_list|,
name|rt
parameter_list|)
value|{ \ 	register struct mfc *_rt = mfctable[MFCHASH(o,g)]; \ 	rt = NULL; \ 	++mrtstat.mrts_mfc_lookups; \ 	while (_rt) { \ 		if ((_rt->mfc_origin.s_addr == o)&& \ 		    (_rt->mfc_mcastgrp.s_addr == g)&& \ 		    (_rt->mfc_stall == NULL)) { \ 			rt = _rt; \ 			break; \ 		} \ 		_rt = _rt->mfc_next; \ 	} \ 	if (rt == NULL) { \ 		++mrtstat.mrts_mfc_misses; \ 	} \ }
end_define

begin_comment
comment|/*  * Macros to compute elapsed time efficiently  * Borrowed from Van Jacobson's scheduling code  */
end_comment

begin_define
define|#
directive|define
name|TV_DELTA
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|delta
parameter_list|)
value|{ \ 	    register int xxs; \ 		\ 	    delta = (a).tv_usec - (b).tv_usec; \ 	    if ((xxs = (a).tv_sec - (b).tv_sec)) { \ 	       switch (xxs) { \ 		      case 2: \ 			  delta += 1000000; \
comment|/* fall through */
value|\ 		      case 1: \ 			  delta += 1000000; \ 			  break; \ 		      default: \ 			  delta += (1000000 * xxs); \ 	       } \ 	    } \ }
end_define

begin_define
define|#
directive|define
name|TV_LT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a).tv_usec< (b).tv_usec&& \ 	      (a).tv_sec<= (b).tv_sec) || (a).tv_sec< (b).tv_sec)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|UPCALL_TIMING
end_ifdef

begin_decl_stmt
name|u_long
name|upcall_data
index|[
literal|51
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|collate
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UPCALL_TIMING */
end_comment

begin_comment
comment|/*  * Handle MRT setsockopt commands to modify the multicast routing tables.  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mrouter_set
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|vifctl
name|vifc
decl_stmt|;
name|struct
name|mfcctl
name|mfc
decl_stmt|;
if|if
condition|(
name|so
operator|!=
name|ip_mrouter
operator|&&
name|sopt
operator|->
name|sopt_name
operator|!=
name|MRT_INIT
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MRT_INIT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|ip_mrouter_init
argument_list|(
name|so
argument_list|,
name|optval
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_DONE
case|:
name|error
operator|=
name|ip_mrouter_done
argument_list|()
expr_stmt|;
break|break;
case|case
name|MRT_ADD_VIF
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|vifc
argument_list|,
sizeof|sizeof
name|vifc
argument_list|,
sizeof|sizeof
name|vifc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|add_vif
argument_list|(
operator|&
name|vifc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_DEL_VIF
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|vifi
argument_list|,
sizeof|sizeof
name|vifi
argument_list|,
sizeof|sizeof
name|vifi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|error
operator|=
name|del_vif
argument_list|(
name|vifi
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ADD_MFC
case|:
case|case
name|MRT_DEL_MFC
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|mfc
argument_list|,
sizeof|sizeof
name|mfc
argument_list|,
sizeof|sizeof
name|mfc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|MRT_ADD_MFC
condition|)
name|error
operator|=
name|add_mfc
argument_list|(
operator|&
name|mfc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|del_mfc
argument_list|(
operator|&
name|mfc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ASSERT
case|:
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|,
sizeof|sizeof
name|optval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|set_assert
argument_list|(
name|optval
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_set
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
init|=
name|X_ip_mrouter_set
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle MRT getsockopt commands  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mrouter_get
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
specifier|static
name|int
name|version
init|=
literal|0x0305
decl_stmt|;
comment|/* !!! why is this here? XXX */
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
case|case
name|MRT_VERSION
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|version
argument_list|,
sizeof|sizeof
name|version
argument_list|)
expr_stmt|;
break|break;
case|case
name|MRT_ASSERT
case|:
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|pim_assert
argument_list|,
sizeof|sizeof
name|pim_assert
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_get
function_decl|)
parameter_list|(
name|struct
name|socket
modifier|*
parameter_list|,
name|struct
name|sockopt
modifier|*
parameter_list|)
init|=
name|X_ip_mrouter_get
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Handle ioctl commands to obtain information from the cache  */
end_comment

begin_function
specifier|static
name|int
name|X_mrt_ioctl
parameter_list|(
name|cmd
parameter_list|,
name|data
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
operator|(
name|SIOCGETVIFCNT
operator|)
case|:
return|return
operator|(
name|get_vif_cnt
argument_list|(
operator|(
expr|struct
name|sioc_vif_req
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
break|break;
case|case
operator|(
name|SIOCGETSGCNT
operator|)
case|:
return|return
operator|(
name|get_sg_cnt
argument_list|(
operator|(
expr|struct
name|sioc_sg_req
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|int
function_decl|(
modifier|*
name|mrt_ioctl
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|caddr_t
parameter_list|)
init|=
name|X_mrt_ioctl
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * returns the packet, byte, rpf-failure count for the source group provided  */
end_comment

begin_function
specifier|static
name|int
name|get_sg_cnt
parameter_list|(
name|req
parameter_list|)
specifier|register
name|struct
name|sioc_sg_req
modifier|*
name|req
decl_stmt|;
block|{
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|MFCFIND
argument_list|(
name|req
operator|->
name|src
operator|.
name|s_addr
argument_list|,
name|req
operator|->
name|grp
operator|.
name|s_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|req
operator|->
name|pktcnt
operator|=
name|rt
operator|->
name|mfc_pkt_cnt
expr_stmt|;
name|req
operator|->
name|bytecnt
operator|=
name|rt
operator|->
name|mfc_byte_cnt
expr_stmt|;
name|req
operator|->
name|wrong_if
operator|=
name|rt
operator|->
name|mfc_wrong_if
expr_stmt|;
block|}
else|else
name|req
operator|->
name|pktcnt
operator|=
name|req
operator|->
name|bytecnt
operator|=
name|req
operator|->
name|wrong_if
operator|=
literal|0xffffffff
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * returns the input and output packet and byte counts on the vif provided  */
end_comment

begin_function
specifier|static
name|int
name|get_vif_cnt
parameter_list|(
name|req
parameter_list|)
specifier|register
name|struct
name|sioc_vif_req
modifier|*
name|req
decl_stmt|;
block|{
specifier|register
name|vifi_t
name|vifi
init|=
name|req
operator|->
name|vifi
decl_stmt|;
if|if
condition|(
name|vifi
operator|>=
name|numvifs
condition|)
return|return
name|EINVAL
return|;
name|req
operator|->
name|icount
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_in
expr_stmt|;
name|req
operator|->
name|ocount
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_out
expr_stmt|;
name|req
operator|->
name|ibytes
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_in
expr_stmt|;
name|req
operator|->
name|obytes
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_out
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Enable multicast routing  */
end_comment

begin_function
specifier|static
name|int
name|ip_mrouter_init
parameter_list|(
name|so
parameter_list|,
name|version
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|int
name|version
decl_stmt|;
block|{
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mrouter_init: so_type = %d, pr_protocol = %d\n"
argument_list|,
name|so
operator|->
name|so_type
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_IGMP
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
name|version
operator|!=
literal|1
condition|)
return|return
name|ENOPROTOOPT
return|;
if|if
condition|(
name|ip_mrouter
operator|!=
name|NULL
condition|)
return|return
name|EADDRINUSE
return|;
name|ip_mrouter
operator|=
name|so
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mfctable
argument_list|,
sizeof|sizeof
argument_list|(
name|mfctable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|nexpire
argument_list|,
sizeof|sizeof
argument_list|(
name|nexpire
argument_list|)
argument_list|)
expr_stmt|;
name|pim_assert
operator|=
literal|0
expr_stmt|;
name|expire_upcalls_ch
operator|=
name|timeout
argument_list|(
name|expire_upcalls
argument_list|,
operator|(
name|caddr_t
operator|)
name|NULL
argument_list|,
name|EXPIRE_TIMEOUT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mrouter_init\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Disable multicast routing  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mrouter_done
parameter_list|()
block|{
name|vifi_t
name|vifi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/*      * For each phyint in use, disable promiscuous reception of all IP      * multicasts.      */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
expr_stmt|;
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|tbftable
argument_list|,
sizeof|sizeof
argument_list|(
name|tbftable
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|viftable
argument_list|,
sizeof|sizeof
argument_list|(
name|viftable
argument_list|)
argument_list|)
expr_stmt|;
name|numvifs
operator|=
literal|0
expr_stmt|;
name|pim_assert
operator|=
literal|0
expr_stmt|;
name|untimeout
argument_list|(
name|expire_upcalls
argument_list|,
operator|(
name|caddr_t
operator|)
name|NULL
argument_list|,
name|expire_upcalls_ch
argument_list|)
expr_stmt|;
comment|/*      * Free all multicast forwarding cache entries.      */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MFCTBLSIZ
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|rt
operator|=
name|mfctable
index|[
name|i
index|]
init|;
name|rt
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|mfc
modifier|*
name|nr
init|=
name|rt
operator|->
name|mfc_next
decl_stmt|;
for|for
control|(
name|rte
operator|=
name|rt
operator|->
name|mfc_stall
init|;
name|rte
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|rtdetq
modifier|*
name|n
init|=
name|rte
operator|->
name|next
decl_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|rte
operator|=
name|n
expr_stmt|;
block|}
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|rt
operator|=
name|nr
expr_stmt|;
block|}
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|mfctable
argument_list|,
sizeof|sizeof
argument_list|(
name|mfctable
argument_list|)
argument_list|)
expr_stmt|;
comment|/*      * Reset de-encapsulation cache      */
name|last_encap_src
operator|=
literal|0
expr_stmt|;
name|last_encap_vif
operator|=
name|NULL
expr_stmt|;
name|have_encap_tunnel
operator|=
literal|0
expr_stmt|;
name|ip_mrouter
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mrouter_done\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mrouter_done
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|X_ip_mrouter_done
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set PIM assert processing global  */
end_comment

begin_function
specifier|static
name|int
name|set_assert
parameter_list|(
name|i
parameter_list|)
name|int
name|i
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|i
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|i
operator|!=
literal|0
operator|)
condition|)
return|return
name|EINVAL
return|;
name|pim_assert
operator|=
name|i
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a vif to the vif table  */
end_comment

begin_function
specifier|static
name|int
name|add_vif
parameter_list|(
name|vifcp
parameter_list|)
specifier|register
name|struct
name|vifctl
modifier|*
name|vifcp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|viftable
operator|+
name|vifcp
operator|->
name|vifc_vifi
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|sin
init|=
block|{
sizeof|sizeof
name|sin
block|,
name|AF_INET
block|}
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
name|struct
name|tbf
modifier|*
name|v_tbf
init|=
name|tbftable
operator|+
name|vifcp
operator|->
name|vifc_vifi
decl_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_vifi
operator|>=
name|MAXVIFS
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
return|return
name|EADDRINUSE
return|;
comment|/* Find the interface with an address in AF_INET family */
name|sin
operator|.
name|sin_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|ifa
operator|=
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|ifp
operator|=
name|ifa
operator|->
name|ifa_ifp
expr_stmt|;
if|if
condition|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
if|if
condition|(
operator|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_SRCRT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * An encapsulating tunnel is wanted.  Tell ipip_input() to 		 * start paying attention to encapsulated packets. 		 */
if|if
condition|(
name|have_encap_tunnel
operator|==
literal|0
condition|)
block|{
name|have_encap_tunnel
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
name|MAXVIFS
condition|;
operator|++
name|s
control|)
block|{
name|multicast_decap_if
index|[
name|s
index|]
operator|.
name|if_name
operator|=
literal|"mdecap"
expr_stmt|;
name|multicast_decap_if
index|[
name|s
index|]
operator|.
name|if_unit
operator|=
name|s
expr_stmt|;
block|}
block|}
comment|/* 		 * Set interface to fake encapsulator interface 		 */
name|ifp
operator|=
operator|&
name|multicast_decap_if
index|[
name|vifcp
operator|->
name|vifc_vifi
index|]
expr_stmt|;
comment|/* 		 * Prepare cached route entry 		 */
name|bzero
argument_list|(
operator|&
name|vifp
operator|->
name|v_route
argument_list|,
sizeof|sizeof
argument_list|(
name|vifp
operator|->
name|v_route
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"source routed tunnels not supported\n"
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
block|}
else|else
block|{
comment|/* Make sure the interface supports multicast */
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* Enable promiscuous reception of all IP multicasts from the if */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* define parameters for the tbf structure */
name|vifp
operator|->
name|v_tbf
operator|=
name|v_tbf
expr_stmt|;
name|GET_TIME
argument_list|(
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_last_pkt_t
argument_list|)
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_n_tok
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_q_len
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_max_q_len
operator|=
name|MAXQSIZE
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_q
operator|=
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_t
operator|=
name|NULL
expr_stmt|;
name|vifp
operator|->
name|v_flags
operator|=
name|vifcp
operator|->
name|vifc_flags
expr_stmt|;
name|vifp
operator|->
name|v_threshold
operator|=
name|vifcp
operator|->
name|vifc_threshold
expr_stmt|;
name|vifp
operator|->
name|v_lcl_addr
operator|=
name|vifcp
operator|->
name|vifc_lcl_addr
expr_stmt|;
name|vifp
operator|->
name|v_rmt_addr
operator|=
name|vifcp
operator|->
name|vifc_rmt_addr
expr_stmt|;
name|vifp
operator|->
name|v_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* scaling up here allows division by 1024 in critical code */
name|vifp
operator|->
name|v_rate_limit
operator|=
name|vifcp
operator|->
name|vifc_rate_limit
operator|*
literal|1024
operator|/
literal|1000
expr_stmt|;
name|vifp
operator|->
name|v_rsvp_on
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_rsvpd
operator|=
name|NULL
expr_stmt|;
comment|/* initialize per vif pkt counters */
name|vifp
operator|->
name|v_pkt_in
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_pkt_out
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_bytes_in
operator|=
literal|0
expr_stmt|;
name|vifp
operator|->
name|v_bytes_out
operator|=
literal|0
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs up if the vifi is higher than numvifs */
if|if
condition|(
name|numvifs
operator|<=
name|vifcp
operator|->
name|vifc_vifi
condition|)
name|numvifs
operator|=
name|vifcp
operator|->
name|vifc_vifi
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_vif #%d, lcladdr %lx, %s %lx, thresh %x, rate %d\n"
argument_list|,
name|vifcp
operator|->
name|vifc_vifi
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|vifcp
operator|->
name|vifc_lcl_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|vifcp
operator|->
name|vifc_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
literal|"rmtaddr"
else|:
literal|"mask"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|vifcp
operator|->
name|vifc_rmt_addr
operator|.
name|s_addr
argument_list|)
argument_list|,
name|vifcp
operator|->
name|vifc_threshold
argument_list|,
name|vifcp
operator|->
name|vifc_rate_limit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a vif from the vif table  */
end_comment

begin_function
specifier|static
name|int
name|del_vif
parameter_list|(
name|vifi
parameter_list|)
name|vifi_t
name|vifi
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
operator|&
name|viftable
index|[
name|vifi
index|]
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|ifreq
name|ifr
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|vifi
operator|>=
name|numvifs
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vifp
operator|->
name|v_lcl_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
name|EADDRNOTAVAIL
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
operator|(
name|ifr
operator|.
name|ifr_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
name|if_allmulti
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vifp
operator|==
name|last_encap_vif
condition|)
block|{
name|last_encap_vif
operator|=
literal|0
expr_stmt|;
name|last_encap_src
operator|=
literal|0
expr_stmt|;
block|}
comment|/*      * Free packets queued at the interface      */
while|while
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_q
condition|)
block|{
name|m
operator|=
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_q
expr_stmt|;
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_q
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
operator|->
name|v_tbf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|vifp
operator|->
name|v_tbf
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vifp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"del_vif %d, numvifs %d\n"
argument_list|,
name|vifi
argument_list|,
name|numvifs
argument_list|)
expr_stmt|;
comment|/* Adjust numvifs down */
for|for
control|(
name|vifi
operator|=
name|numvifs
init|;
name|vifi
operator|>
literal|0
condition|;
name|vifi
operator|--
control|)
if|if
condition|(
name|viftable
index|[
name|vifi
operator|-
literal|1
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
break|break;
name|numvifs
operator|=
name|vifi
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|add_mfc
parameter_list|(
name|mfccp
parameter_list|)
name|struct
name|mfcctl
modifier|*
name|mfccp
decl_stmt|;
block|{
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
specifier|register
name|u_short
name|nstl
decl_stmt|;
name|int
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
name|MFCFIND
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
comment|/* If an entry already exists, just update the fields */
if|if
condition|(
name|rt
condition|)
block|{
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_MFC
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc update o %lx g %lx p %x\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*       * Find the entry for which the upcall was made and update      */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|hash
operator|=
name|MFCHASH
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|,
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|mfctable
index|[
name|hash
index|]
operator|,
name|nstl
operator|=
literal|0
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|mfc_next
control|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|==
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|==
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|mfc_stall
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|nstl
operator|++
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"add_mfc %s o %lx g %lx p %x dbx %p\n"
argument_list|,
literal|"multiple kernel entries"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rt
operator|->
name|mfc_stall
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_MFC
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc o %lx g %lx p %x dbg %p\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|,
operator|(
name|void
operator|*
operator|)
name|rt
operator|->
name|mfc_stall
argument_list|)
expr_stmt|;
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_wrong_if
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_last_assert
operator|.
name|tv_sec
operator|=
name|rt
operator|->
name|mfc_last_assert
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
literal|0
expr_stmt|;
comment|/* Don't clean this guy up */
name|nexpire
index|[
name|hash
index|]
operator|--
expr_stmt|;
comment|/* free packets Qed at the end of this entry */
for|for
control|(
name|rte
operator|=
name|rt
operator|->
name|mfc_stall
init|;
name|rte
operator|!=
name|NULL
condition|;
control|)
block|{
name|struct
name|rtdetq
modifier|*
name|n
init|=
name|rte
operator|->
name|next
decl_stmt|;
name|ip_mdq
argument_list|(
name|rte
operator|->
name|m
argument_list|,
name|rte
operator|->
name|ifp
argument_list|,
name|rt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|UPCALL_TIMING
name|collate
argument_list|(
operator|&
operator|(
name|rte
operator|->
name|t
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* UPCALL_TIMING */
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|rte
operator|=
name|n
expr_stmt|;
block|}
name|rt
operator|->
name|mfc_stall
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/*      * It is possible that an entry is being inserted without an upcall      */
if|if
condition|(
name|nstl
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_MFC
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"add_mfc no upcall h %lu o %lx g %lx p %x\n"
argument_list|,
name|hash
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|,
name|mfccp
operator|->
name|mfcc_parent
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|rt
operator|!=
name|NULL
condition|;
name|rt
operator|=
name|rt
operator|->
name|mfc_next
control|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|==
name|mfccp
operator|->
name|mfcc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|==
name|mfccp
operator|->
name|mfcc_mcastgrp
operator|.
name|s_addr
operator|)
condition|)
block|{
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_wrong_if
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_last_assert
operator|.
name|tv_sec
operator|=
name|rt
operator|->
name|mfc_last_assert
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|mfc_expire
condition|)
name|nexpire
index|[
name|hash
index|]
operator|--
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
comment|/* no upcall, so make a new entry */
name|rt
operator|=
operator|(
expr|struct
name|mfc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* insert new entry at head of hash chain */
name|rt
operator|->
name|mfc_origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
name|mfccp
operator|->
name|mfcc_parent
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
name|mfccp
operator|->
name|mfcc_ttls
index|[
name|i
index|]
expr_stmt|;
comment|/* initialize pkt counters per src-grp */
name|rt
operator|->
name|mfc_pkt_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_wrong_if
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_last_assert
operator|.
name|tv_sec
operator|=
name|rt
operator|->
name|mfc_last_assert
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_stall
operator|=
name|NULL
expr_stmt|;
comment|/* link into table */
name|rt
operator|->
name|mfc_next
operator|=
name|mfctable
index|[
name|hash
index|]
expr_stmt|;
name|mfctable
index|[
name|hash
index|]
operator|=
name|rt
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|UPCALL_TIMING
end_ifdef

begin_comment
comment|/*  * collect delay statistics on the upcalls   */
end_comment

begin_function
specifier|static
name|void
name|collate
parameter_list|(
name|t
parameter_list|)
specifier|register
name|struct
name|timeval
modifier|*
name|t
decl_stmt|;
block|{
specifier|register
name|u_long
name|d
decl_stmt|;
specifier|register
name|struct
name|timeval
name|tp
decl_stmt|;
specifier|register
name|u_long
name|delta
decl_stmt|;
name|GET_TIME
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|TV_LT
argument_list|(
operator|*
name|t
argument_list|,
name|tp
argument_list|)
condition|)
block|{
name|TV_DELTA
argument_list|(
name|tp
argument_list|,
operator|*
name|t
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|d
operator|=
name|delta
operator|>>
literal|10
expr_stmt|;
if|if
condition|(
name|d
operator|>
literal|50
condition|)
name|d
operator|=
literal|50
expr_stmt|;
operator|++
name|upcall_data
index|[
name|d
index|]
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UPCALL_TIMING */
end_comment

begin_comment
comment|/*  * Delete an mfc entry  */
end_comment

begin_function
specifier|static
name|int
name|del_mfc
parameter_list|(
name|mfccp
parameter_list|)
name|struct
name|mfcctl
modifier|*
name|mfccp
decl_stmt|;
block|{
name|struct
name|in_addr
name|origin
decl_stmt|;
name|struct
name|in_addr
name|mcastgrp
decl_stmt|;
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
name|struct
name|mfc
modifier|*
modifier|*
name|nptr
decl_stmt|;
name|u_long
name|hash
decl_stmt|;
name|int
name|s
decl_stmt|;
name|origin
operator|=
name|mfccp
operator|->
name|mfcc_origin
expr_stmt|;
name|mcastgrp
operator|=
name|mfccp
operator|->
name|mfcc_mcastgrp
expr_stmt|;
name|hash
operator|=
name|MFCHASH
argument_list|(
name|origin
operator|.
name|s_addr
argument_list|,
name|mcastgrp
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_MFC
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"del_mfc orig %lx mcastgrp %lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|nptr
operator|=
operator|&
name|mfctable
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|rt
operator|=
operator|*
name|nptr
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|origin
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|&&
name|mcastgrp
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|&&
name|rt
operator|->
name|mfc_stall
operator|==
name|NULL
condition|)
break|break;
name|nptr
operator|=
operator|&
name|rt
operator|->
name|mfc_next
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
operator|*
name|nptr
operator|=
name|rt
operator|->
name|mfc_next
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a message to mrouted on the multicast routing socket  */
end_comment

begin_function
specifier|static
name|int
name|socket_send
parameter_list|(
name|s
parameter_list|,
name|mm
parameter_list|,
name|src
parameter_list|)
name|struct
name|socket
modifier|*
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|src
decl_stmt|;
block|{
if|if
condition|(
name|s
condition|)
block|{
if|if
condition|(
name|sbappendaddr
argument_list|(
operator|&
name|s
operator|->
name|so_rcv
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src
argument_list|,
name|mm
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sorwakeup
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * IP multicast forwarding function. This function assumes that the packet  * pointed to by "ip" has arrived on (or is about to be sent to) the interface  * pointed to by "ifp", and the packet is to be relayed to other networks  * that have members of the packet's destination IP multicast group.  *  * The packet is returned unscathed to the caller, unless it is  * erroneous, in which case a non-zero return value tells the caller to  * discard it.  */
end_comment

begin_define
define|#
directive|define
name|IP_HDR_LEN
value|20
end_define

begin_comment
comment|/* # bytes of fixed IP header (excluding options) */
end_comment

begin_define
define|#
directive|define
name|TUNNEL_LEN
value|12
end_define

begin_comment
comment|/* # bytes of IP option for tunnel encapsulation  */
end_comment

begin_function
specifier|static
name|int
name|X_ip_mforward
parameter_list|(
name|ip
parameter_list|,
name|ifp
parameter_list|,
name|m
parameter_list|,
name|imo
parameter_list|)
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
block|{
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|ipoptions
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|k_igmpsrc
init|=
block|{
sizeof|sizeof
name|k_igmpsrc
block|,
name|AF_INET
block|}
decl_stmt|;
specifier|static
name|int
name|srctun
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|int
name|s
decl_stmt|;
name|vifi_t
name|vifi
decl_stmt|;
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_FORWARD
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: src %lx, dst %lx, ifp %p\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_hl
operator|<
operator|(
name|IP_HDR_LEN
operator|+
name|TUNNEL_LEN
operator|)
operator|>>
literal|2
operator|||
operator|(
name|ipoptions
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
operator|)
index|[
literal|1
index|]
operator|!=
name|IPOPT_LSRR
condition|)
block|{
comment|/* 	 * Packet arrived via a physical interface or 	 * an encapsulated tunnel. 	 */
block|}
else|else
block|{
comment|/* 	 * Packet arrived through a source-route tunnel. 	 * Source-route tunnels are no longer supported. 	 */
if|if
condition|(
operator|(
name|srctun
operator|++
operator|%
literal|1000
operator|)
operator|==
literal|0
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ip_mforward: received source-routed packet from %lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|(
name|imo
operator|)
operator|&&
operator|(
operator|(
name|vifi
operator|=
name|imo
operator|->
name|imo_multicast_vif
operator|)
operator|<
name|numvifs
operator|)
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<
literal|255
condition|)
name|ip
operator|->
name|ip_ttl
operator|++
expr_stmt|;
comment|/* compensate for -1 in *_send routines */
if|if
condition|(
name|rsvpdebug
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_RSVP
condition|)
block|{
name|vifp
operator|=
name|viftable
operator|+
name|vifi
expr_stmt|;
name|printf
argument_list|(
literal|"Sending IPPROTO_RSVP from %lx to %lx on vif %d (%s%s%d)\n"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|,
name|vifi
argument_list|,
operator|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|?
literal|"tunnel on "
else|:
literal|""
argument_list|,
name|vifp
operator|->
name|v_ifp
operator|->
name|if_name
argument_list|,
name|vifp
operator|->
name|v_ifp
operator|->
name|if_unit
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ip_mdq
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|,
name|vifi
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|rsvpdebug
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_RSVP
condition|)
block|{
name|printf
argument_list|(
literal|"Warning: IPPROTO_RSVP from %lx to %lx without vif option\n"
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|imo
condition|)
name|printf
argument_list|(
literal|"In fact, no options were specified at all\n"
argument_list|)
expr_stmt|;
block|}
comment|/*      * Don't forward a packet with time-to-live of zero or one,      * or a packet destined to a local-only group.      */
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
literal|1
operator|||
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|<=
name|INADDR_MAX_LOCAL_GROUP
condition|)
return|return
literal|0
return|;
comment|/*      * Determine forwarding vifs from the forwarding cache table      */
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|MFCFIND
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|rt
argument_list|)
expr_stmt|;
comment|/* Entry exists, so forward if necessary */
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ip_mdq
argument_list|(
name|m
argument_list|,
name|ifp
argument_list|,
name|rt
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* 	 * If we don't have a route for packet's origin, 	 * Make a copy of the packet& 	 * send message to routing daemon 	 */
specifier|register
name|struct
name|mbuf
modifier|*
name|mb0
decl_stmt|;
specifier|register
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
specifier|register
name|u_long
name|hash
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
ifdef|#
directive|ifdef
name|UPCALL_TIMING
name|struct
name|timeval
name|tp
decl_stmt|;
name|GET_TIME
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mrtstat
operator|.
name|mrts_no_route
operator|++
expr_stmt|;
if|if
condition|(
name|mrtdebug
operator|&
operator|(
name|DEBUG_FORWARD
operator||
name|DEBUG_MFC
operator|)
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: no rte s %lx g %lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate mbufs early so that we don't do extra work if we are 	 * just going to fail anyway.  Make sure to pullup the header so 	 * that other people can't step on it. 	 */
name|rte
operator|=
operator|(
expr|struct
name|rtdetq
operator|*
operator|)
name|malloc
argument_list|(
operator|(
sizeof|sizeof
expr|*
name|rte
operator|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rte
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
name|mb0
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb0
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mb0
argument_list|)
operator|||
name|mb0
operator|->
name|m_len
operator|<
name|hlen
operator|)
condition|)
name|mb0
operator|=
name|m_pullup
argument_list|(
name|mb0
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb0
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* is there an upcall waiting for this packet? */
name|hash
operator|=
name|MFCHASH
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
expr_stmt|;
for|for
control|(
name|rt
operator|=
name|mfctable
index|[
name|hash
index|]
init|;
name|rt
condition|;
name|rt
operator|=
name|rt
operator|->
name|mfc_next
control|)
block|{
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|)
operator|&&
operator|(
name|rt
operator|->
name|mfc_stall
operator|!=
name|NULL
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|igmpmsg
modifier|*
name|im
decl_stmt|;
comment|/* no upcall, so make a new entry */
name|rt
operator|=
operator|(
expr|struct
name|mfc
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|rt
argument_list|)
argument_list|,
name|M_MRTABLE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* Make a copy of the header to send to the user level process */
name|mm
operator|=
name|m_copy
argument_list|(
name|mb0
argument_list|,
literal|0
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/*  	     * Send message to routing daemon to install  	     * a route into the kernel table 	     */
name|k_igmpsrc
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|im
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|igmpmsg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_msgtype
operator|=
name|IGMPMSG_NOCACHE
expr_stmt|;
name|im
operator|->
name|im_mbz
operator|=
literal|0
expr_stmt|;
name|mrtstat
operator|.
name|mrts_upcalls
operator|++
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|ip_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|k_igmpsrc
argument_list|)
operator|<
literal|0
condition|)
block|{
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"ip_mforward: ip_mrouter socket queue full\n"
argument_list|)
expr_stmt|;
operator|++
name|mrtstat
operator|.
name|mrts_upq_sockfull
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rt
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|ENOBUFS
return|;
block|}
comment|/* insert new entry at head of hash chain */
name|rt
operator|->
name|mfc_origin
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|rt
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|rt
operator|->
name|mfc_expire
operator|=
name|UPCALL_EXPIRE
expr_stmt|;
name|nexpire
index|[
name|hash
index|]
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numvifs
condition|;
name|i
operator|++
control|)
name|rt
operator|->
name|mfc_ttls
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|mfc_parent
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* link into table */
name|rt
operator|->
name|mfc_next
operator|=
name|mfctable
index|[
name|hash
index|]
expr_stmt|;
name|mfctable
index|[
name|hash
index|]
operator|=
name|rt
expr_stmt|;
name|rt
operator|->
name|mfc_stall
operator|=
name|rte
expr_stmt|;
block|}
else|else
block|{
comment|/* determine if q has overflowed */
name|int
name|npkts
init|=
literal|0
decl_stmt|;
name|struct
name|rtdetq
modifier|*
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
operator|&
name|rt
operator|->
name|mfc_stall
init|;
operator|*
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
operator|&
operator|(
operator|*
name|p
operator|)
operator|->
name|next
control|)
name|npkts
operator|++
expr_stmt|;
if|if
condition|(
name|npkts
operator|>
name|MAX_UPQ
condition|)
block|{
name|mrtstat
operator|.
name|mrts_upq_ovflw
operator|++
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mb0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Add this entry to the end of the queue */
operator|*
name|p
operator|=
name|rte
expr_stmt|;
block|}
name|rte
operator|->
name|m
operator|=
name|mb0
expr_stmt|;
name|rte
operator|->
name|ifp
operator|=
name|ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|UPCALL_TIMING
name|rte
operator|->
name|t
operator|=
name|tp
expr_stmt|;
endif|#
directive|endif
name|rte
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|int
function_decl|(
modifier|*
name|ip_mforward
function_decl|)
parameter_list|(
name|struct
name|ip
modifier|*
parameter_list|,
name|struct
name|ifnet
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ip_moptions
modifier|*
parameter_list|)
init|=
name|X_ip_mforward
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Clean up the cache entry if upcall is not serviced  */
end_comment

begin_function
specifier|static
name|void
name|expire_upcalls
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|struct
name|rtdetq
modifier|*
name|rte
decl_stmt|;
name|struct
name|mfc
modifier|*
name|mfc
decl_stmt|,
modifier|*
modifier|*
name|nptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MFCTBLSIZ
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nexpire
index|[
name|i
index|]
operator|==
literal|0
condition|)
continue|continue;
name|nptr
operator|=
operator|&
name|mfctable
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|mfc
operator|=
operator|*
name|nptr
init|;
name|mfc
operator|!=
name|NULL
condition|;
name|mfc
operator|=
operator|*
name|nptr
control|)
block|{
comment|/* 	     * Skip real cache entries 	     * Make sure it wasn't marked to not expire (shouldn't happen) 	     * If it expires now 	     */
if|if
condition|(
name|mfc
operator|->
name|mfc_stall
operator|!=
name|NULL
operator|&&
name|mfc
operator|->
name|mfc_expire
operator|!=
literal|0
operator|&&
operator|--
name|mfc
operator|->
name|mfc_expire
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_EXPIRE
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"expire_upcalls: expiring (%lx %lx)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfc
operator|->
name|mfc_origin
operator|.
name|s_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mfc
operator|->
name|mfc_mcastgrp
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * drop all the packets 		 * free the mbuf with the pkt, if, timing info 		 */
for|for
control|(
name|rte
operator|=
name|mfc
operator|->
name|mfc_stall
init|;
name|rte
condition|;
control|)
block|{
name|struct
name|rtdetq
modifier|*
name|n
init|=
name|rte
operator|->
name|next
decl_stmt|;
name|m_freem
argument_list|(
name|rte
operator|->
name|m
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rte
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
name|rte
operator|=
name|n
expr_stmt|;
block|}
operator|++
name|mrtstat
operator|.
name|mrts_cache_cleanups
expr_stmt|;
name|nexpire
index|[
name|i
index|]
operator|--
expr_stmt|;
operator|*
name|nptr
operator|=
name|mfc
operator|->
name|mfc_next
expr_stmt|;
name|free
argument_list|(
name|mfc
argument_list|,
name|M_MRTABLE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nptr
operator|=
operator|&
name|mfc
operator|->
name|mfc_next
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|expire_upcalls_ch
operator|=
name|timeout
argument_list|(
name|expire_upcalls
argument_list|,
operator|(
name|caddr_t
operator|)
name|NULL
argument_list|,
name|EXPIRE_TIMEOUT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Packet forwarding routine once entry in the cache is made  */
end_comment

begin_function
specifier|static
name|int
name|ip_mdq
parameter_list|(
name|m
parameter_list|,
name|ifp
parameter_list|,
name|rt
parameter_list|,
name|xmt_vif
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|struct
name|mfc
modifier|*
name|rt
decl_stmt|;
specifier|register
name|vifi_t
name|xmt_vif
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|vifi_t
name|vifi
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|int
name|plen
init|=
name|ip
operator|->
name|ip_len
decl_stmt|;
comment|/*  * Macro to send packet on vif.  Since RSVP packets don't get counted on  * input, they shouldn't get counted on output, so statistics keeping is  * seperate.  */
define|#
directive|define
name|MC_SEND
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
value|{                             \                 if ((vifp)->v_flags& VIFF_TUNNEL)  	 \                     encap_send((ip), (vifp), (m));       \                 else                                     \                     phyint_send((ip), (vifp), (m));      \ }
comment|/*      * If xmt_vif is not -1, send on only the requested vif.      *      * (since vifi_t is u_short, -1 becomes MAXUSHORT, which> numvifs.)      */
if|if
condition|(
name|xmt_vif
operator|<
name|numvifs
condition|)
block|{
name|MC_SEND
argument_list|(
name|ip
argument_list|,
name|viftable
operator|+
name|xmt_vif
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*      * Don't forward if it didn't arrive from the parent vif for its origin.      */
name|vifi
operator|=
name|rt
operator|->
name|mfc_parent
expr_stmt|;
if|if
condition|(
operator|(
name|vifi
operator|>=
name|numvifs
operator|)
operator|||
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|!=
name|ifp
operator|)
condition|)
block|{
comment|/* came in the wrong interface */
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_FORWARD
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"wrong if: ifp %p vifi %d vififp %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ifp
argument_list|,
name|vifi
argument_list|,
operator|(
name|void
operator|*
operator|)
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
argument_list|)
expr_stmt|;
operator|++
name|mrtstat
operator|.
name|mrts_wrong_if
expr_stmt|;
operator|++
name|rt
operator|->
name|mfc_wrong_if
expr_stmt|;
comment|/* 	 * If we are doing PIM assert processing, and we are forwarding 	 * packets on this interface, and it is a broadcast medium 	 * interface (and not a tunnel), send a message to the routing daemon. 	 */
if|if
condition|(
name|pim_assert
operator|&&
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|&&
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|&&
operator|!
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_flags
operator|&
name|VIFF_TUNNEL
operator|)
condition|)
block|{
name|struct
name|sockaddr_in
name|k_igmpsrc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|igmpmsg
modifier|*
name|im
decl_stmt|;
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
specifier|register
name|u_long
name|delta
decl_stmt|;
name|GET_TIME
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|TV_DELTA
argument_list|(
name|rt
operator|->
name|mfc_last_assert
argument_list|,
name|now
argument_list|,
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|>
name|ASSERT_MSG_TIME
condition|)
block|{
name|mm
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mm
argument_list|)
operator|||
name|mm
operator|->
name|m_len
operator|<
name|hlen
operator|)
condition|)
name|mm
operator|=
name|m_pullup
argument_list|(
name|mm
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
return|return
name|ENOBUFS
return|;
block|}
name|rt
operator|->
name|mfc_last_assert
operator|=
name|now
expr_stmt|;
name|im
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|igmpmsg
operator|*
argument_list|)
expr_stmt|;
name|im
operator|->
name|im_msgtype
operator|=
name|IGMPMSG_WRONGVIF
expr_stmt|;
name|im
operator|->
name|im_mbz
operator|=
literal|0
expr_stmt|;
name|im
operator|->
name|im_vif
operator|=
name|vifi
expr_stmt|;
name|k_igmpsrc
operator|.
name|sin_addr
operator|=
name|im
operator|->
name|im_src
expr_stmt|;
name|socket_send
argument_list|(
name|ip_mrouter
argument_list|,
name|mm
argument_list|,
operator|&
name|k_igmpsrc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
comment|/* If I sourced this packet, it counts as output, else it was input. */
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
condition|)
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_out
operator|++
expr_stmt|;
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_out
operator|+=
name|plen
expr_stmt|;
block|}
else|else
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_pkt_in
operator|++
expr_stmt|;
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_bytes_in
operator|+=
name|plen
expr_stmt|;
block|}
name|rt
operator|->
name|mfc_pkt_cnt
operator|++
expr_stmt|;
name|rt
operator|->
name|mfc_byte_cnt
operator|+=
name|plen
expr_stmt|;
comment|/*      * For each vif, decide if a copy of the packet should be forwarded.      * Forward if:      *		- the ttl exceeds the vif's threshold      *		- there are group members downstream on interface      */
for|for
control|(
name|vifp
operator|=
name|viftable
operator|,
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifp
operator|++
operator|,
name|vifi
operator|++
control|)
if|if
condition|(
operator|(
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ip
operator|->
name|ip_ttl
operator|>
name|rt
operator|->
name|mfc_ttls
index|[
name|vifi
index|]
operator|)
condition|)
block|{
name|vifp
operator|->
name|v_pkt_out
operator|++
expr_stmt|;
name|vifp
operator|->
name|v_bytes_out
operator|+=
name|plen
expr_stmt|;
name|MC_SEND
argument_list|(
name|ip
argument_list|,
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * check if a vif number is legal/ok. This is used by ip_output, to export  * numvifs there,   */
end_comment

begin_function
specifier|static
name|int
name|X_legal_vif_num
parameter_list|(
name|vif
parameter_list|)
name|int
name|vif
decl_stmt|;
block|{
if|if
condition|(
name|vif
operator|>=
literal|0
operator|&&
name|vif
operator|<
name|numvifs
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|int
function_decl|(
modifier|*
name|legal_vif_num
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|X_legal_vif_num
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return the local address used by this vif  */
end_comment

begin_function
specifier|static
name|u_long
name|X_ip_mcast_src
parameter_list|(
name|vifi
parameter_list|)
name|int
name|vifi
decl_stmt|;
block|{
if|if
condition|(
name|vifi
operator|>=
literal|0
operator|&&
name|vifi
operator|<
name|numvifs
condition|)
return|return
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_lcl_addr
operator|.
name|s_addr
return|;
else|else
return|return
name|INADDR_ANY
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MROUTE_LKM
end_ifndef

begin_function_decl
name|u_long
function_decl|(
modifier|*
name|ip_mcast_src
function_decl|)
parameter_list|(
name|int
parameter_list|)
init|=
name|X_ip_mcast_src
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|phyint_send
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
specifier|register
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
comment|/*      * Make a new reference to the packet; make sure that      * the IP header is actually copied, not just referenced,      * so that ip_output() only scribbles on the copy.      */
name|mb_copy
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|&&
operator|(
name|M_HASCL
argument_list|(
name|mb_copy
argument_list|)
operator|||
name|mb_copy
operator|->
name|m_len
operator|<
name|hlen
operator|)
condition|)
name|mb_copy
operator|=
name|m_pullup
argument_list|(
name|mb_copy
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|vifp
operator|->
name|v_rate_limit
operator|==
literal|0
condition|)
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|)
expr_stmt|;
else|else
name|tbf_control
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|,
name|mtod
argument_list|(
name|mb_copy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
argument_list|,
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|encap_send
parameter_list|(
name|ip
parameter_list|,
name|vifp
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|mb_copy
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip_copy
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|len
init|=
name|ip
operator|->
name|ip_len
decl_stmt|;
comment|/*      * copy the old packet& pullup its IP header into the      * new mbuf so we can modify it.  Try to fill the new      * mbuf since if we don't the ethernet driver will.      */
name|MGETHDR
argument_list|(
name|mb_copy
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
name|mb_copy
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|mb_copy
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mb_copy
operator|->
name|m_next
operator|=
name|m_copy
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
return|return;
block|}
name|i
operator|=
name|MHLEN
operator|-
name|M_LEADINGSPACE
argument_list|(
name|mb_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|len
condition|)
name|i
operator|=
name|len
expr_stmt|;
name|mb_copy
operator|=
name|m_pullup
argument_list|(
name|mb_copy
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb_copy
operator|==
name|NULL
condition|)
return|return;
name|mb_copy
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
operator|+
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
comment|/*      * fill in the encapsulating IP header.      */
name|ip_copy
operator|=
name|mtod
argument_list|(
name|mb_copy
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
operator|*
name|ip_copy
operator|=
name|multicast_encap_iphdr
expr_stmt|;
ifdef|#
directive|ifdef
name|RANDOM_IP_ID
name|ip_copy
operator|->
name|ip_id
operator|=
name|ip_randomid
argument_list|()
expr_stmt|;
else|#
directive|else
name|ip_copy
operator|->
name|ip_id
operator|=
name|htons
argument_list|(
name|ip_id
operator|++
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ip_copy
operator|->
name|ip_len
operator|+=
name|len
expr_stmt|;
name|ip_copy
operator|->
name|ip_src
operator|=
name|vifp
operator|->
name|v_lcl_addr
expr_stmt|;
name|ip_copy
operator|->
name|ip_dst
operator|=
name|vifp
operator|->
name|v_rmt_addr
expr_stmt|;
comment|/*      * turn the encapsulated IP header back into a valid one.      */
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip_copy
operator|+
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
operator|)
expr_stmt|;
operator|--
name|ip
operator|->
name|ip_ttl
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|mb_copy
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|mb_copy
argument_list|,
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
argument_list|)
expr_stmt|;
name|mb_copy
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
name|multicast_encap_iphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_rate_limit
operator|==
literal|0
condition|)
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|)
expr_stmt|;
else|else
name|tbf_control
argument_list|(
name|vifp
argument_list|,
name|mb_copy
argument_list|,
name|ip
argument_list|,
name|ip_copy
operator|->
name|ip_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * De-encapsulate a packet and feed it back through ip input (this  * routine is called whenever IP gets a packet with proto type  * ENCAP_PROTO and a local destination address).  */
end_comment

begin_function
name|void
ifdef|#
directive|ifdef
name|MROUTE_LKM
name|X_ipip_input
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|)
else|#
directive|else
function|ipip_input
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|)
endif|#
directive|endif
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|int
name|hlen
init|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
specifier|register
name|struct
name|ifqueue
modifier|*
name|ifq
decl_stmt|;
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
if|if
condition|(
operator|!
name|have_encap_tunnel
condition|)
block|{
name|rip_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*      * dump the packet if it's not to a multicast destination or if      * we don't have an encapsulating tunnel with the source.      * Note:  This code assumes that the remote site IP address      * uniquely identifies the tunnel (i.e., that this site has      * at most one tunnel with the remote site).      */
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|hlen
operator|)
operator|)
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
operator|++
name|mrtstat
operator|.
name|mrts_bad_tunnel
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|!=
name|last_encap_src
condition|)
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vife
decl_stmt|;
name|vifp
operator|=
name|viftable
expr_stmt|;
name|vife
operator|=
name|vifp
operator|+
name|numvifs
expr_stmt|;
name|last_encap_src
operator|=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|last_encap_vif
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|vifp
operator|<
name|vife
condition|;
operator|++
name|vifp
control|)
if|if
condition|(
name|vifp
operator|->
name|v_rmt_addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
operator|(
name|vifp
operator|->
name|v_flags
operator|&
operator|(
name|VIFF_TUNNEL
operator||
name|VIFF_SRCRT
operator|)
operator|)
operator|==
name|VIFF_TUNNEL
condition|)
name|last_encap_vif
operator|=
name|vifp
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|vifp
operator|=
name|last_encap_vif
operator|)
operator|==
literal|0
condition|)
block|{
name|last_encap_src
operator|=
literal|0
expr_stmt|;
name|mrtstat
operator|.
name|mrts_cant_tunnel
operator|++
expr_stmt|;
comment|/*XXX*/
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"ip_mforward: no tunnel with %lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
if|if
condition|(
name|hlen
operator|>
name|IP_HDR_LEN
condition|)
name|ip_stripoptions
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
name|IP_HDR_LEN
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|IP_HDR_LEN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|IP_HDR_LEN
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|ifp
expr_stmt|;
name|ifq
operator|=
operator|&
name|ipintrq
expr_stmt|;
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
if|if
condition|(
name|IF_QFULL
argument_list|(
name|ifq
argument_list|)
condition|)
block|{
name|IF_DROP
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IF_ENQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * normally we would need a "schednetisr(NETISR_IP)" 	 * here but we were called by ip_input and it is going 	 * to loop back& try to dequeue the packet we just 	 * queued as soon as we return so we avoid the 	 * unnecessary software interrrupt. 	 */
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Token bucket filter module  */
end_comment

begin_function
specifier|static
name|void
name|tbf_control
parameter_list|(
name|vifp
parameter_list|,
name|m
parameter_list|,
name|ip
parameter_list|,
name|p_len
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|u_long
name|p_len
decl_stmt|;
block|{
specifier|register
name|struct
name|tbf
modifier|*
name|t
init|=
name|vifp
operator|->
name|v_tbf
decl_stmt|;
if|if
condition|(
name|p_len
operator|>
name|MAX_BKT_SIZE
condition|)
block|{
comment|/* drop if packet is too large */
name|mrtstat
operator|.
name|mrts_pkt2large
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|tbf_update_tokens
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
comment|/* if there are enough tokens,       * and the queue is empty,      * send this packet out      */
if|if
condition|(
name|t
operator|->
name|tbf_q_len
operator|==
literal|0
condition|)
block|{
comment|/* queue empty, send packet if enough tokens */
if|if
condition|(
name|p_len
operator|<=
name|t
operator|->
name|tbf_n_tok
condition|)
block|{
name|t
operator|->
name|tbf_n_tok
operator|-=
name|p_len
expr_stmt|;
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* queue packet and timeout till later */
name|tbf_queue
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|tbf_reprocess_q
argument_list|,
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
name|TBF_REPROCESS
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|t
operator|->
name|tbf_q_len
operator|<
name|t
operator|->
name|tbf_max_q_len
condition|)
block|{
comment|/* finite queue length, so queue pkts and process queue */
name|tbf_queue
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tbf_process_q
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* queue length too much, try to dq and queue and process */
if|if
condition|(
operator|!
name|tbf_dq_sel
argument_list|(
name|vifp
argument_list|,
name|ip
argument_list|)
condition|)
block|{
name|mrtstat
operator|.
name|mrts_q_overflow
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|tbf_queue
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|tbf_process_q
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*   * adds a packet to the queue at the interface  */
end_comment

begin_function
specifier|static
name|void
name|tbf_queue
parameter_list|(
name|vifp
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|tbf
modifier|*
name|t
init|=
name|vifp
operator|->
name|v_tbf
decl_stmt|;
if|if
condition|(
name|t
operator|->
name|tbf_t
operator|==
name|NULL
condition|)
block|{
comment|/* Queue was empty */
name|t
operator|->
name|tbf_q
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert at tail */
name|t
operator|->
name|tbf_t
operator|->
name|m_act
operator|=
name|m
expr_stmt|;
block|}
comment|/* Set new tail pointer */
name|t
operator|->
name|tbf_t
operator|=
name|m
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* Make sure we didn't get fed a bogus mbuf */
if|if
condition|(
name|m
operator|->
name|m_act
condition|)
name|panic
argument_list|(
literal|"tbf_queue: m_act"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m
operator|->
name|m_act
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|tbf_q_len
operator|++
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*   * processes the queue at the interface  */
end_comment

begin_function
specifier|static
name|void
name|tbf_process_q
parameter_list|(
name|vifp
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|tbf
modifier|*
name|t
init|=
name|vifp
operator|->
name|v_tbf
decl_stmt|;
comment|/* loop through the queue at the interface and send as many packets      * as possible      */
while|while
condition|(
name|t
operator|->
name|tbf_q_len
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|t
operator|->
name|tbf_q
expr_stmt|;
name|len
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_len
expr_stmt|;
comment|/* determine if the packet can be sent */
if|if
condition|(
name|len
operator|<=
name|t
operator|->
name|tbf_n_tok
condition|)
block|{
comment|/* if so, 	     * reduce no of tokens, dequeue the packet, 	     * send the packet. 	     */
name|t
operator|->
name|tbf_n_tok
operator|-=
name|len
expr_stmt|;
name|t
operator|->
name|tbf_q
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
if|if
condition|(
operator|--
name|t
operator|->
name|tbf_q_len
operator|==
literal|0
condition|)
name|t
operator|->
name|tbf_t
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_act
operator|=
name|NULL
expr_stmt|;
name|tbf_send_packet
argument_list|(
name|vifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbf_reprocess_q
parameter_list|(
name|xvifp
parameter_list|)
name|void
modifier|*
name|xvifp
decl_stmt|;
block|{
specifier|register
name|struct
name|vif
modifier|*
name|vifp
init|=
name|xvifp
decl_stmt|;
if|if
condition|(
name|ip_mrouter
operator|==
name|NULL
condition|)
return|return;
name|tbf_update_tokens
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
name|tbf_process_q
argument_list|(
name|vifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_tbf
operator|->
name|tbf_q_len
condition|)
name|timeout
argument_list|(
name|tbf_reprocess_q
argument_list|,
operator|(
name|caddr_t
operator|)
name|vifp
argument_list|,
name|TBF_REPROCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* function that will selectively discard a member of the queue  * based on the precedence value and the priority  */
end_comment

begin_function
specifier|static
name|int
name|tbf_dq_sel
parameter_list|(
name|vifp
parameter_list|,
name|ip
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|u_int
name|p
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|last
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|tbf
modifier|*
name|t
init|=
name|vifp
operator|->
name|v_tbf
decl_stmt|;
name|p
operator|=
name|priority
argument_list|(
name|vifp
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|np
operator|=
operator|&
name|t
operator|->
name|tbf_q
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|*
name|np
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|>
name|priority
argument_list|(
name|vifp
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|np
operator|=
name|m
operator|->
name|m_act
expr_stmt|;
comment|/* If we're removing the last packet, fix the tail pointer */
if|if
condition|(
name|m
operator|==
name|t
operator|->
name|tbf_t
condition|)
name|t
operator|->
name|tbf_t
operator|=
name|last
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* it's impossible for the queue to be empty, but 	     * we check anyway. */
if|if
condition|(
operator|--
name|t
operator|->
name|tbf_q_len
operator|==
literal|0
condition|)
name|t
operator|->
name|tbf_t
operator|=
name|NULL
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|mrtstat
operator|.
name|mrts_drop_sel
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|np
operator|=
operator|&
name|m
operator|->
name|m_act
expr_stmt|;
name|last
operator|=
name|m
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tbf_send_packet
parameter_list|(
name|vifp
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|struct
name|ip_moptions
name|imo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
if|if
condition|(
name|vifp
operator|->
name|v_flags
operator|&
name|VIFF_TUNNEL
condition|)
block|{
comment|/* If tunnel options */
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|vifp
operator|->
name|v_route
argument_list|,
name|IP_FORWARDING
argument_list|,
operator|(
expr|struct
name|ip_moptions
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|imo
operator|.
name|imo_multicast_ifp
operator|=
name|vifp
operator|->
name|v_ifp
expr_stmt|;
name|imo
operator|.
name|imo_multicast_ttl
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
operator|->
name|ip_ttl
operator|-
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_multicast_loop
operator|=
literal|1
expr_stmt|;
name|imo
operator|.
name|imo_multicast_vif
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Re-entrancy should not be a problem here, because 	 * the packets that we send out and are looped back at us 	 * should get rejected because they appear to come from 	 * the loopback interface, thus preventing looping. 	 */
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
name|NULL
argument_list|,
name|IP_FORWARDING
argument_list|,
operator|&
name|imo
argument_list|)
expr_stmt|;
if|if
condition|(
name|mrtdebug
operator|&
name|DEBUG_XMIT
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"phyint_send on vif %d err %d\n"
argument_list|,
name|vifp
operator|-
name|viftable
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* determine the current time and then  * the elapsed time (between the last time and time now)  * in milliseconds& update the no. of tokens in the bucket  */
end_comment

begin_function
specifier|static
name|void
name|tbf_update_tokens
parameter_list|(
name|vifp
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
block|{
name|struct
name|timeval
name|tp
decl_stmt|;
specifier|register
name|u_long
name|tm
decl_stmt|;
specifier|register
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|struct
name|tbf
modifier|*
name|t
init|=
name|vifp
operator|->
name|v_tbf
decl_stmt|;
name|GET_TIME
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|TV_DELTA
argument_list|(
name|tp
argument_list|,
name|t
operator|->
name|tbf_last_pkt_t
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|/*      * This formula is actually      * "time in seconds" * "bytes/second".      *      * (tm / 1000000) * (v_rate_limit * 1000 * (1000/1024) / 8)      *      * The (1000/1024) was introduced in add_vif to optimize      * this divide into a shift.      */
name|t
operator|->
name|tbf_n_tok
operator|+=
name|tm
operator|*
name|vifp
operator|->
name|v_rate_limit
operator|/
literal|1024
operator|/
literal|8
expr_stmt|;
name|t
operator|->
name|tbf_last_pkt_t
operator|=
name|tp
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|tbf_n_tok
operator|>
name|MAX_BKT_SIZE
condition|)
name|t
operator|->
name|tbf_n_tok
operator|=
name|MAX_BKT_SIZE
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|priority
parameter_list|(
name|vifp
parameter_list|,
name|ip
parameter_list|)
specifier|register
name|struct
name|vif
modifier|*
name|vifp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
block|{
specifier|register
name|int
name|prio
decl_stmt|;
comment|/* temporary hack; may add general packet classifier some day */
comment|/*      * The UDP port space is divided up into four priority ranges:      * [0, 16384)     : unclassified - lowest priority      * [16384, 32768) : audio - highest priority      * [32768, 49152) : whiteboard - medium priority      * [49152, 65536) : video - low priority      */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|struct
name|udphdr
modifier|*
name|udp
init|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|)
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
decl_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
operator|&
literal|0xc000
condition|)
block|{
case|case
literal|0x4000
case|:
name|prio
operator|=
literal|70
expr_stmt|;
break|break;
case|case
literal|0x8000
case|:
name|prio
operator|=
literal|60
expr_stmt|;
break|break;
case|case
literal|0xc000
case|:
name|prio
operator|=
literal|55
expr_stmt|;
break|break;
default|default:
name|prio
operator|=
literal|50
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tbfdebug
operator|>
literal|1
condition|)
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"port %x prio%d\n"
argument_list|,
name|ntohs
argument_list|(
name|udp
operator|->
name|uh_dport
argument_list|)
argument_list|,
name|prio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prio
operator|=
literal|50
expr_stmt|;
block|}
return|return
name|prio
return|;
block|}
end_function

begin_comment
comment|/*  * End of token bucket filter modifications   */
end_comment

begin_function
name|int
name|ip_rsvp_vif_init
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"ip_rsvp_vif_init: so_type = %d, pr_protocol = %d\n"
argument_list|,
name|so
operator|->
name|so_type
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RSVP
condition|)
return|return
name|EOPNOTSUPP
return|;
comment|/* Check mbuf. */
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"ip_rsvp_vif_init: vif = %d rsvp_on = %d\n"
argument_list|,
name|i
argument_list|,
name|rsvp_on
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* Check vif. */
if|if
condition|(
operator|!
name|legal_vif_num
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
comment|/* Check if socket is available. */
if|if
condition|(
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvpd
operator|!=
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EADDRINUSE
return|;
block|}
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvpd
operator|=
name|so
expr_stmt|;
comment|/* This may seem silly, but we need to be sure we don't over-increment      * the RSVP counter, in case something slips up.      */
if|if
condition|(
operator|!
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvp_on
condition|)
block|{
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvp_on
operator|=
literal|1
expr_stmt|;
name|rsvp_on
operator|++
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ip_rsvp_vif_done
parameter_list|(
name|so
parameter_list|,
name|sopt
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockopt
modifier|*
name|sopt
decl_stmt|;
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"ip_rsvp_vif_done: so_type = %d, pr_protocol = %d\n"
argument_list|,
name|so
operator|->
name|so_type
argument_list|,
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RSVP
condition|)
return|return
name|EOPNOTSUPP
return|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|,
sizeof|sizeof
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* Check vif. */
if|if
condition|(
operator|!
name|legal_vif_num
argument_list|(
name|i
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EADDRNOTAVAIL
return|;
block|}
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"ip_rsvp_vif_done: v_rsvpd = %p so = %p\n"
argument_list|,
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvpd
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvpd
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This may seem silly, but we need to be sure we don't over-decrement 	 * the RSVP counter, in case something slips up. 	 */
if|if
condition|(
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvp_on
condition|)
block|{
name|viftable
index|[
name|i
index|]
operator|.
name|v_rsvp_on
operator|=
literal|0
expr_stmt|;
name|rsvp_on
operator|--
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ip_rsvp_force_done
parameter_list|(
name|so
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
block|{
name|int
name|vifi
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
comment|/* Don't bother if it is not the right type of socket. */
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RSVP
condition|)
return|return;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* The socket may be attached to more than one vif...this      * is perfectly legal.      */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
block|{
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvpd
operator|==
name|so
condition|)
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvpd
operator|=
name|NULL
expr_stmt|;
comment|/* This may seem silly, but we need to be sure we don't 	     * over-decrement the RSVP counter, in case something slips up. 	     */
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvp_on
condition|)
block|{
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvp_on
operator|=
literal|0
expr_stmt|;
name|rsvp_on
operator|--
expr_stmt|;
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|rsvp_input
parameter_list|(
name|m
parameter_list|,
name|off
parameter_list|,
name|proto
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|proto
decl_stmt|;
block|{
name|int
name|vifi
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|static
name|struct
name|sockaddr_in
name|rsvp_src
init|=
block|{
sizeof|sizeof
name|rsvp_src
block|,
name|AF_INET
block|}
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"rsvp_input: rsvp_on %d\n"
argument_list|,
name|rsvp_on
argument_list|)
expr_stmt|;
comment|/* Can still get packets with rsvp_on = 0 if there is a local member      * of the group to which the RSVP packet is addressed.  But in this      * case we want to throw the packet away.      */
if|if
condition|(
operator|!
name|rsvp_on
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"rsvp_input: check vifs\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|!
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
condition|)
name|panic
argument_list|(
literal|"rsvp_input no hdr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
comment|/* Find which vif the packet arrived on. */
for|for
control|(
name|vifi
operator|=
literal|0
init|;
name|vifi
operator|<
name|numvifs
condition|;
name|vifi
operator|++
control|)
if|if
condition|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_ifp
operator|==
name|ifp
condition|)
break|break;
if|if
condition|(
name|vifi
operator|==
name|numvifs
operator|||
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvpd
operator|==
name|NULL
condition|)
block|{
comment|/* 	 * If the old-style non-vif-associated socket is set, 	 * then use it.  Otherwise, drop packet since there 	 * is no specific socket for this vif. 	 */
if|if
condition|(
name|ip_rsvpd
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"rsvp_input: Sending packet up old-style socket\n"
argument_list|)
expr_stmt|;
name|rip_input
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|proto
argument_list|)
expr_stmt|;
comment|/* xxx */
block|}
else|else
block|{
if|if
condition|(
name|rsvpdebug
operator|&&
name|vifi
operator|==
name|numvifs
condition|)
name|printf
argument_list|(
literal|"rsvp_input: Can't find vif for packet.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rsvpdebug
operator|&&
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvpd
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"rsvp_input: No socket defined for vif %d\n"
argument_list|,
name|vifi
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
name|rsvp_src
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
if|if
condition|(
name|rsvpdebug
operator|&&
name|m
condition|)
name|printf
argument_list|(
literal|"rsvp_input: m->m_len = %d, sbspace() = %ld\n"
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
name|sbspace
argument_list|(
operator|&
operator|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvpd
operator|->
name|so_rcv
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|socket_send
argument_list|(
name|viftable
index|[
name|vifi
index|]
operator|.
name|v_rsvpd
argument_list|,
name|m
argument_list|,
operator|&
name|rsvp_src
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"rsvp_input: Failed to append to socket\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rsvpdebug
condition|)
name|printf
argument_list|(
literal|"rsvp_input: send packet up\n"
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MROUTE_LKM
end_ifdef

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/exec.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/lkm.h>
end_include

begin_macro
name|MOD_MISC
argument_list|(
literal|"ip_mroute_mod"
argument_list|)
end_macro

begin_function
specifier|static
name|int
name|ip_mroute_mod_handle
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|lkm_misc
modifier|*
name|args
init|=
name|lkmtp
operator|->
name|private
operator|.
name|lkm_misc
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
specifier|static
name|int
function_decl|(
modifier|*
name|old_ip_mrouter_cmd
function_decl|)
parameter_list|()
function_decl|;
specifier|static
name|int
function_decl|(
modifier|*
name|old_ip_mrouter_done
function_decl|)
parameter_list|()
function_decl|;
specifier|static
name|int
function_decl|(
modifier|*
name|old_ip_mforward
function_decl|)
parameter_list|()
function_decl|;
specifier|static
name|int
function_decl|(
modifier|*
name|old_mrt_ioctl
function_decl|)
parameter_list|()
function_decl|;
specifier|static
name|void
function_decl|(
modifier|*
name|old_proto4_input
function_decl|)
parameter_list|()
function_decl|;
specifier|static
name|int
function_decl|(
modifier|*
name|old_legal_vif_num
function_decl|)
parameter_list|()
function_decl|;
specifier|extern
name|struct
name|protosw
name|inetsw
index|[]
decl_stmt|;
case|case
name|LKM_E_LOAD
case|:
if|if
condition|(
name|lkmexists
argument_list|(
name|lkmtp
argument_list|)
operator|||
name|ip_mrtproto
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
name|old_ip_mrouter_cmd
operator|=
name|ip_mrouter_cmd
expr_stmt|;
name|ip_mrouter_cmd
operator|=
name|X_ip_mrouter_cmd
expr_stmt|;
name|old_ip_mrouter_done
operator|=
name|ip_mrouter_done
expr_stmt|;
name|ip_mrouter_done
operator|=
name|X_ip_mrouter_done
expr_stmt|;
name|old_ip_mforward
operator|=
name|ip_mforward
expr_stmt|;
name|ip_mforward
operator|=
name|X_ip_mforward
expr_stmt|;
name|old_mrt_ioctl
operator|=
name|mrt_ioctl
expr_stmt|;
name|mrt_ioctl
operator|=
name|X_mrt_ioctl
expr_stmt|;
name|old_proto4_input
operator|=
name|inetsw
index|[
name|ip_protox
index|[
name|ENCAP_PROTO
index|]
index|]
operator|.
name|pr_input
expr_stmt|;
name|inetsw
index|[
name|ip_protox
index|[
name|ENCAP_PROTO
index|]
index|]
operator|.
name|pr_input
operator|=
name|X_ipip_input
expr_stmt|;
name|old_legal_vif_num
operator|=
name|legal_vif_num
expr_stmt|;
name|legal_vif_num
operator|=
name|X_legal_vif_num
expr_stmt|;
name|ip_mrtproto
operator|=
name|IGMP_DVMRP
expr_stmt|;
name|printf
argument_list|(
literal|"\nIP multicast routing loaded\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LKM_E_UNLOAD
case|:
if|if
condition|(
name|ip_mrouter
condition|)
return|return
name|EINVAL
return|;
name|ip_mrouter_cmd
operator|=
name|old_ip_mrouter_cmd
expr_stmt|;
name|ip_mrouter_done
operator|=
name|old_ip_mrouter_done
expr_stmt|;
name|ip_mforward
operator|=
name|old_ip_mforward
expr_stmt|;
name|mrt_ioctl
operator|=
name|old_mrt_ioctl
expr_stmt|;
name|inetsw
index|[
name|ip_protox
index|[
name|ENCAP_PROTO
index|]
index|]
operator|.
name|pr_input
operator|=
name|old_proto4_input
expr_stmt|;
name|legal_vif_num
operator|=
name|old_legal_vif_num
expr_stmt|;
name|ip_mrtproto
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip_mroute_mod
parameter_list|(
name|struct
name|lkm_table
modifier|*
name|lkmtp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|int
name|ver
parameter_list|)
block|{
name|DISPATCH
argument_list|(
name|lkmtp
argument_list|,
name|cmd
argument_list|,
name|ver
argument_list|,
name|ip_mroute_mod_handle
argument_list|,
name|ip_mroute_mod_handle
argument_list|,
name|nosys
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MROUTE_LKM */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MROUTING */
end_comment

end_unit

