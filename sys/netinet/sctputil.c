begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/sctp6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_comment
comment|/* for sctp_deliver_data() */
end_comment

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_SCTP
end_ifndef

begin_define
define|#
directive|define
name|KTR_SCTP
value|KTR_SUBSYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|sctp_cc_functions
name|sctp_cc_functions
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|struct
name|sctp_ss_functions
name|sctp_ss_functions
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_sblog
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|incr
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|stcb
operator|=
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|so_sbcc
operator|=
name|sb
operator|->
name|sb_cc
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|stcb_sbcc
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|stcb_sbcc
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|incr
operator|=
name|incr
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_SB
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_closing
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int16_t
name|loc
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|inp
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|sctp_flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|state
operator|=
operator|(
name|uint16_t
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|state
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|stcb
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|state
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_CLOSE
argument_list|,
literal|0
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rto_logging
parameter_list|(
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rto
operator|.
name|net
operator|=
operator|(
name|void
operator|*
operator|)
name|net
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rto
operator|.
name|rtt
operator|=
name|net
operator|->
name|rtt
operator|/
literal|1000
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_RTT
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_strm_del_alt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint16_t
name|sseq
parameter_list|,
name|uint16_t
name|stream
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|stcb
operator|=
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_tsn
operator|=
name|tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_sseq
operator|=
name|sseq
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_tsn
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_sseq
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|strm
operator|=
name|stream
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_STRM
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_nagle_event
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|total_flight
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|total_in_queue
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|count_in_queue
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|count_in_flight
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_NAGLE
argument_list|,
name|action
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_sack
parameter_list|(
name|uint32_t
name|old_cumack
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint16_t
name|gaps
parameter_list|,
name|uint16_t
name|dups
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|cumack
operator|=
name|cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|oldcumack
operator|=
name|old_cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|numGaps
operator|=
name|gaps
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|numDups
operator|=
name|dups
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_SACK
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_map
parameter_list|(
name|uint32_t
name|map
parameter_list|,
name|uint32_t
name|cum
parameter_list|,
name|uint32_t
name|high
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|map
operator|.
name|base
operator|=
name|map
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|map
operator|.
name|cum
operator|=
name|cum
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|map
operator|.
name|high
operator|=
name|high
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MAP
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_fr
parameter_list|(
name|uint32_t
name|biggest_tsn
parameter_list|,
name|uint32_t
name|biggest_new_tsn
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|fr
operator|.
name|largest_tsn
operator|=
name|biggest_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|fr
operator|.
name|largest_new_tsn
operator|=
name|biggest_new_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|fr
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_FR
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
end_ifdef

begin_function
name|void
name|sctp_log_mb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|mp
operator|=
name|m
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|mbuf_flags
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|SCTP_BUF_GET_FLAGS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|data
operator|=
name|SCTP_BUF_AT
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|ext
operator|=
name|SCTP_BUF_EXTEND_BASE
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|refcnt
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|SCTP_BUF_EXTEND_REFCNT
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|ext
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MBUF
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_mbc
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|m
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|from
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_log_strm_del
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|poschk
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Gak log of NULL?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_tsn
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_sseq
operator|=
operator|(
name|uint16_t
operator|)
name|control
operator|->
name|mid
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|strm
operator|=
name|control
operator|->
name|sinfo_stream
expr_stmt|;
if|if
condition|(
name|poschk
operator|!=
name|NULL
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_tsn
operator|=
name|poschk
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_sseq
operator|=
operator|(
name|uint16_t
operator|)
name|poschk
operator|->
name|mid
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_tsn
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_sseq
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_STRM
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_cwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|augment
parameter_list|,
name|uint8_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|net
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_new_value
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|inflight
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|pseudo_cumack
operator|=
name|net
operator|->
name|pseudo_cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|meets_pseudo_cumack
operator|=
name|net
operator|->
name|new_pseudo_cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|need_new_pseudo_cumack
operator|=
name|net
operator|->
name|find_pseudo_cumack
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_CWNDLOG_PRESEND
operator|==
name|from
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|meets_pseudo_cumack
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_augment
operator|=
name|augment
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_CWND
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_lock
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint8_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
operator|->
name|sctp_socket
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock
operator|=
operator|(
name|void
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|inp
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|tcb_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|stcb
operator|->
name|tcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|tcb_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|inp
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|inp_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|inp
operator|->
name|inp_mtx
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|create_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|inp
operator|->
name|inp_create_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|inp_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|create_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|info_lock
operator|=
name|rw_wowned
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_ep_mtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|)
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_mtx
operator|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sockrcvbuf_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_mtx
operator|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|socksndbuf_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_mtx
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sockrcvbuf_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|socksndbuf_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_LOCK_EVENT
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_maxburst
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|burst
parameter_list|,
name|uint8_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|net
operator|=
name|net
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_new_value
operator|=
name|error
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|inflight
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_augment
operator|=
name|burst
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MAXBURST
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_rwnd
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|peers_rwnd
parameter_list|,
name|uint32_t
name|snd_size
parameter_list|,
name|uint32_t
name|overhead
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|rwnd
operator|=
name|peers_rwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|send_size
operator|=
name|snd_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|overhead
operator|=
name|overhead
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|new_rwnd
operator|=
literal|0
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_RWND
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_rwnd_set
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|peers_rwnd
parameter_list|,
name|uint32_t
name|flight_size
parameter_list|,
name|uint32_t
name|overhead
parameter_list|,
name|uint32_t
name|a_rwndval
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|rwnd
operator|=
name|peers_rwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|send_size
operator|=
name|flight_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|overhead
operator|=
name|overhead
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|new_rwnd
operator|=
name|a_rwndval
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_RWND
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_MBCNT_LOGGING
end_ifdef

begin_function
specifier|static
name|void
name|sctp_log_mbcnt
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|total_oq
parameter_list|,
name|uint32_t
name|book
parameter_list|,
name|uint32_t
name|total_mbcnt_q
parameter_list|,
name|uint32_t
name|mbcnt
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|total_queue_size
operator|=
name|total_oq
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|size_change
operator|=
name|book
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|total_queue_mb_size
operator|=
name|total_mbcnt_q
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|mbcnt_change
operator|=
name|mbcnt
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MBCNT
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_misc_ints
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|a
parameter_list|,
name|uint32_t
name|b
parameter_list|,
name|uint32_t
name|c
parameter_list|,
name|uint32_t
name|d
parameter_list|)
block|{
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_MISC_EVENT
argument_list|,
name|from
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_wakeup_log
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|wake_cnt
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|wake_cnt
operator|=
name|wake_cnt
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|flight
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|send_q
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sent_q
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|<
literal|0xff
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|stream_qcnt
operator|=
operator|(
name|uint8_t
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|stream_qcnt
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|<
literal|0xff
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|chunks_on_oque
operator|=
operator|(
name|uint8_t
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|chunks_on_oque
operator|=
literal|0xff
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator|=
literal|0
expr_stmt|;
comment|/* set in the defered mode stuff */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_DONT_WAKE
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEOUTPUT
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEINPUT
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator||=
literal|4
expr_stmt|;
comment|/* what about the sb */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|stcb
operator|->
name|sctp_socket
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sbflags
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&
literal|0x00ff
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sbflags
operator|=
literal|0xff
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_WAKE
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_block
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|size_t
name|sendlen
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|onsb
operator|=
name|asoc
operator|->
name|total_output_queue_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|send_sent_qcnt
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|asoc
operator|->
name|send_queue_cnt
operator|+
name|asoc
operator|->
name|sent_queue_cnt
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|peer_rwnd
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|stream_qcnt
operator|=
operator|(
name|uint16_t
operator|)
name|asoc
operator|->
name|stream_queue_cnt
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|chunks_on_oque
operator|=
operator|(
name|uint16_t
operator|)
name|asoc
operator|->
name|chunks_on_out_queue
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|flight_size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|sndlen
operator|=
operator|(
name|uint32_t
operator|)
name|sendlen
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_BLOCK
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_fill_stat_log
parameter_list|(
name|void
modifier|*
name|optval
name|SCTP_UNUSED
parameter_list|,
name|size_t
modifier|*
name|optsize
name|SCTP_UNUSED
parameter_list|)
block|{
comment|/* May need to fix this if ktrdump does not work */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
end_ifdef

begin_decl_stmt
name|uint8_t
name|sctp_audit_data
index|[
name|SCTP_AUDIT_SIZE
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sctp_audit_indx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_print_audit_report
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sctp_audit_indx
init|;
name|i
operator|<
name|SCTP_AUDIT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xe0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xf0
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xc0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"%2.2x%2.2x "
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
literal|14
operator|)
operator|==
literal|0
condition|)
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctp_audit_indx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xe0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xf0
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xc0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"%2.2x%2.2x "
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
literal|14
operator|)
operator|==
literal|0
condition|)
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_auditing
parameter_list|(
name|int
name|from
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|resend_cnt
decl_stmt|,
name|tot_out
decl_stmt|,
name|rep
decl_stmt|,
name|tot_book_cnt
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAA
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0x000000ff
operator|&
name|from
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0x01
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0x02
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xA1
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
operator|(
literal|0x000000ff
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|)
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|0
expr_stmt|;
name|tot_book_cnt
operator|=
literal|0
expr_stmt|;
name|resend_cnt
operator|=
name|tot_out
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|resend_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tot_out
operator|+=
name|chk
operator|->
name|book_size
expr_stmt|;
name|tot_book_cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resend_cnt
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA1
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"resend_cnt:%d asoc-tot:%d\n"
argument_list|,
name|resend_cnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|rep
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
name|resend_cnt
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xA2
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
operator|(
literal|0x000000ff
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|)
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tot_out
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA2
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|1
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"tot_flt:%d asoc_tot:%d\n"
argument_list|,
name|tot_out
argument_list|,
operator|(
name|int
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|=
name|tot_out
expr_stmt|;
block|}
if|if
condition|(
name|tot_book_cnt
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA5
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|1
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"tot_flt_book:%d\n"
argument_list|,
name|tot_book_cnt
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|=
name|tot_book_cnt
expr_stmt|;
block|}
name|tot_out
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|tot_out
operator|+=
name|lnet
operator|->
name|flight_size
expr_stmt|;
block|}
if|if
condition|(
name|tot_out
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA3
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|1
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"real flight:%d net total was %d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|tot_out
argument_list|)
expr_stmt|;
comment|/* now corrective action */
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|tot_out
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|lnet
operator|)
operator|&&
operator|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
condition|)
block|{
name|tot_out
operator|+=
name|chk
operator|->
name|book_size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lnet
operator|->
name|flight_size
operator|!=
name|tot_out
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"net:%p flight was %d corrected to %d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lnet
argument_list|,
name|lnet
operator|->
name|flight_size
argument_list|,
name|tot_out
argument_list|)
expr_stmt|;
name|lnet
operator|->
name|flight_size
operator|=
name|tot_out
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rep
condition|)
block|{
name|sctp_print_audit_report
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_audit_log
parameter_list|(
name|uint8_t
name|ev
parameter_list|,
name|uint8_t
name|fd
parameter_list|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
name|ev
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
name|fd
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * sctp_stop_timers_for_shutdown() should be called  * when entering the SHUTDOWN_SENT or SHUTDOWN_ACK_SENT  * state to make sure that all timers are stopped.  */
end_comment

begin_function
name|void
name|sctp_stop_timers_for_shutdown
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * a list of sizes based on typical mtu's, used only if next hop size not  * returned.  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|sctp_mtu_sizes
index|[]
init|=
block|{
literal|68
block|,
literal|296
block|,
literal|508
block|,
literal|512
block|,
literal|544
block|,
literal|576
block|,
literal|1006
block|,
literal|1492
block|,
literal|1500
block|,
literal|1536
block|,
literal|2002
block|,
literal|2048
block|,
literal|4352
block|,
literal|4464
block|,
literal|8166
block|,
literal|17914
block|,
literal|32000
block|,
literal|65535
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the largest MTU smaller than val. If there is no  * entry, just return val.  */
end_comment

begin_function
name|uint32_t
name|sctp_get_prev_mtu
parameter_list|(
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|<=
name|sctp_mtu_sizes
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|(
name|val
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|sctp_mtu_sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|<=
name|sctp_mtu_sizes
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|sctp_mtu_sizes
index|[
name|i
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the smallest MTU larger than val. If there is no  * entry, just return val.  */
end_comment

begin_function
name|uint32_t
name|sctp_get_next_mtu
parameter_list|(
name|uint32_t
name|val
parameter_list|)
block|{
comment|/* select another MTU that is just bigger than this one */
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|sctp_mtu_sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|<
name|sctp_mtu_sizes
index|[
name|i
index|]
condition|)
block|{
return|return
operator|(
name|sctp_mtu_sizes
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_fill_random_store
parameter_list|(
name|struct
name|sctp_pcb
modifier|*
name|m
parameter_list|)
block|{
comment|/* 	 * Here we use the MD5/SHA-1 to hash with our good randomNumbers and 	 * our counter. The result becomes our good random numbers and we 	 * then setup to give these out. Note that we do no locking to 	 * protect this. This is ok, since if competing folks call this we 	 * will get more gobbled gook in the random store which is what we 	 * want. There is a danger that two guys will use the same random 	 * numbers, but thats ok too since that is random as well :-> 	 */
name|m
operator|->
name|store_at
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_hmac
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|random_numbers
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|random_numbers
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|m
operator|->
name|random_counter
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|random_counter
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|random_store
argument_list|)
expr_stmt|;
name|m
operator|->
name|random_counter
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_select_initial_TSN
parameter_list|(
name|struct
name|sctp_pcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* 	 * A true implementation should use random selection process to get 	 * the initial stream sequence number, using RFC1750 as a good 	 * guideline 	 */
name|uint32_t
name|x
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|store_at
decl_stmt|,
name|new_store
decl_stmt|;
if|if
condition|(
name|inp
operator|->
name|initial_sequence_debug
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|ret
operator|=
name|inp
operator|->
name|initial_sequence_debug
expr_stmt|;
name|inp
operator|->
name|initial_sequence_debug
operator|++
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|retry
label|:
name|store_at
operator|=
name|inp
operator|->
name|store_at
expr_stmt|;
name|new_store
operator|=
name|store_at
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_store
operator|>=
operator|(
name|SCTP_SIGNATURE_SIZE
operator|-
literal|3
operator|)
condition|)
block|{
name|new_store
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|store_at
argument_list|,
name|store_at
argument_list|,
name|new_store
argument_list|)
condition|)
block|{
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|new_store
operator|==
literal|0
condition|)
block|{
comment|/* Refill the random store */
name|sctp_fill_random_store
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|inp
operator|->
name|random_store
index|[
name|store_at
index|]
expr_stmt|;
name|xp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|p
expr_stmt|;
name|x
operator|=
operator|*
name|xp
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_select_a_tag
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint16_t
name|rport
parameter_list|,
name|int
name|check
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
name|check
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|x
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
comment|/* we never use 0 */
continue|continue;
block|}
if|if
condition|(
operator|!
name|check
operator|||
name|sctp_is_vtag_good
argument_list|(
name|x
argument_list|,
name|lport
argument_list|,
name|rport
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|sctp_map_assoc_state
parameter_list|(
name|int
name|kernel_state
parameter_list|)
block|{
name|int32_t
name|user_state
decl_stmt|;
if|if
condition|(
name|kernel_state
operator|&
name|SCTP_STATE_WAS_ABORTED
condition|)
block|{
name|user_state
operator|=
name|SCTP_CLOSED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kernel_state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|user_state
operator|=
name|SCTP_SHUTDOWN_PENDING
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|kernel_state
operator|&
name|SCTP_STATE_MASK
condition|)
block|{
case|case
name|SCTP_STATE_EMPTY
case|:
name|user_state
operator|=
name|SCTP_CLOSED
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_INUSE
case|:
name|user_state
operator|=
name|SCTP_CLOSED
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
name|user_state
operator|=
name|SCTP_COOKIE_WAIT
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
name|user_state
operator|=
name|SCTP_COOKIE_ECHOED
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_OPEN
case|:
name|user_state
operator|=
name|SCTP_ESTABLISHED
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_SHUTDOWN_SENT
case|:
name|user_state
operator|=
name|SCTP_SHUTDOWN_SENT
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_SHUTDOWN_RECEIVED
case|:
name|user_state
operator|=
name|SCTP_SHUTDOWN_RECEIVED
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_SHUTDOWN_ACK_SENT
case|:
name|user_state
operator|=
name|SCTP_SHUTDOWN_ACK_SENT
expr_stmt|;
break|break;
default|default:
name|user_state
operator|=
name|SCTP_CLOSED
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|user_state
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_init_asoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|override_tag
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|o_strms
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
comment|/* 	 * Anything set to zero is taken care of by the allocation routine's 	 * bzero 	 */
comment|/* 	 * Up front select what scoping to apply on addresses I tell my peer 	 * Not sure what to do with these right now, we will need to come up 	 * with a way to set them. We may need to pass them through from the 	 * caller in the sctp_aloc_assoc() function. 	 */
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_DETAILED_STR_STATS
argument_list|)
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* init all variables to a known value. */
name|SCTP_SET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_INUSE
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|max_burst
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_burst
expr_stmt|;
name|asoc
operator|->
name|fr_max_burst
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|fr_max_burst
expr_stmt|;
name|asoc
operator|->
name|heart_beat_delay
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|cookie_life
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
expr_stmt|;
name|asoc
operator|->
name|sctp_cmt_on_off
operator|=
name|inp
operator|->
name|sctp_cmt_on_off
expr_stmt|;
name|asoc
operator|->
name|ecn_supported
operator|=
name|inp
operator|->
name|ecn_supported
expr_stmt|;
name|asoc
operator|->
name|prsctp_supported
operator|=
name|inp
operator|->
name|prsctp_supported
expr_stmt|;
name|asoc
operator|->
name|idata_supported
operator|=
name|inp
operator|->
name|idata_supported
expr_stmt|;
name|asoc
operator|->
name|auth_supported
operator|=
name|inp
operator|->
name|auth_supported
expr_stmt|;
name|asoc
operator|->
name|asconf_supported
operator|=
name|inp
operator|->
name|asconf_supported
expr_stmt|;
name|asoc
operator|->
name|reconfig_supported
operator|=
name|inp
operator|->
name|reconfig_supported
expr_stmt|;
name|asoc
operator|->
name|nrsack_supported
operator|=
name|inp
operator|->
name|nrsack_supported
expr_stmt|;
name|asoc
operator|->
name|pktdrop_supported
operator|=
name|inp
operator|->
name|pktdrop_supported
expr_stmt|;
name|asoc
operator|->
name|idata_supported
operator|=
name|inp
operator|->
name|idata_supported
expr_stmt|;
name|asoc
operator|->
name|sctp_cmt_pf
operator|=
operator|(
name|uint8_t
operator|)
literal|0
expr_stmt|;
name|asoc
operator|->
name|sctp_frag_point
operator|=
name|inp
operator|->
name|sctp_frag_point
expr_stmt|;
name|asoc
operator|->
name|sctp_features
operator|=
name|inp
operator|->
name|sctp_features
expr_stmt|;
name|asoc
operator|->
name|default_dscp
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_dscp
expr_stmt|;
name|asoc
operator|->
name|max_cwnd
operator|=
name|inp
operator|->
name|max_cwnd
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
condition|)
block|{
name|asoc
operator|->
name|default_flowlabel
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_flags
operator|&
name|IN6P_AUTOFLOWLABEL
condition|)
block|{
name|asoc
operator|->
name|default_flowlabel
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|default_flowlabel
operator|&=
literal|0x000fffff
expr_stmt|;
name|asoc
operator|->
name|default_flowlabel
operator||=
literal|0x80000000
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|default_flowlabel
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|asoc
operator|->
name|sb_send_resv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|override_tag
condition|)
block|{
name|asoc
operator|->
name|my_vtag
operator|=
name|override_tag
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|my_vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the nonce tags */
name|asoc
operator|->
name|my_vtag_nonce
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|peer_vtag_nonce
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|vrf_id
operator|=
name|vrf_id
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|asoc
operator|->
name|tsn_in_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_out_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_in_wrapped
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_out_wrapped
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cumack_log_atsnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_FS_SPEC_LOG
name|asoc
operator|->
name|fs_index
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|assoc_up_sent
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_out
operator|=
name|asoc
operator|->
name|str_reset_seq_out
operator|=
name|asoc
operator|->
name|init_seq_number
operator|=
name|asoc
operator|->
name|sending_seq
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_out_acked
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|-
literal|1
expr_stmt|;
comment|/* we are optimisitic here */
name|asoc
operator|->
name|peer_supports_nat
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
comment|/* for CMT */
name|asoc
operator|->
name|last_net_cmt_send_started
operator|=
name|NULL
expr_stmt|;
comment|/* This will need to be adjusted */
name|asoc
operator|->
name|last_acked_seq
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* here we are different, we hold the next one we expect */
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|initial_init_rto_max
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_init_rto_max
expr_stmt|;
name|asoc
operator|->
name|initial_rto
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_rto
expr_stmt|;
name|asoc
operator|->
name|max_init_times
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_init_times
expr_stmt|;
name|asoc
operator|->
name|max_send_times
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_send_times
expr_stmt|;
name|asoc
operator|->
name|def_net_failure
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
expr_stmt|;
name|asoc
operator|->
name|def_net_pf_threshold
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_pf_threshold
expr_stmt|;
name|asoc
operator|->
name|free_chunk_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|iam_blocking
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|context
operator|=
name|inp
operator|->
name|sctp_context
expr_stmt|;
name|asoc
operator|->
name|local_strreset_support
operator|=
name|inp
operator|->
name|local_strreset_support
expr_stmt|;
name|asoc
operator|->
name|def_send
operator|=
name|inp
operator|->
name|def_send
expr_stmt|;
name|asoc
operator|->
name|delayed_ack
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sack_freq
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_sack_freq
expr_stmt|;
name|asoc
operator|->
name|pr_sctp_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|asoc
operator|->
name|scope
operator|.
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asoc
operator|->
name|scope
operator|.
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|scope
operator|.
name|ipv4_addr_legal
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|asoc
operator|->
name|scope
operator|.
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|scope
operator|.
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|my_rwnd
operator|=
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|peers_rwnd
operator|=
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|smallest_mtu
operator|=
name|inp
operator|->
name|sctp_frag_point
expr_stmt|;
name|asoc
operator|->
name|minrto
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
expr_stmt|;
name|asoc
operator|->
name|maxrto
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
expr_stmt|;
name|asoc
operator|->
name|stream_locked_on
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_echo_cnt_onq
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|sctp_restricted_addrs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_ack_sent
argument_list|)
expr_stmt|;
comment|/* Setup to fill the hb random cache at first HB */
name|asoc
operator|->
name|hb_random_idx
operator|=
literal|4
expr_stmt|;
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|auto_close_time
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|congestion_control_module
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_cc_module
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|=
name|sctp_cc_functions
index|[
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_cc_module
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|stream_scheduling_module
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_ss_module
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|=
name|sctp_ss_functions
index|[
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_ss_module
index|]
expr_stmt|;
comment|/* 	 * Now the stream parameters, here we allocate space for all streams 	 * that we request by default. 	 */
name|asoc
operator|->
name|strm_realoutsize
operator|=
name|asoc
operator|->
name|streamoutcnt
operator|=
name|asoc
operator|->
name|pre_open_streams
operator|=
name|o_strms
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
expr|struct
name|sctp_stream_out
operator|*
argument_list|,
name|asoc
operator|->
name|streamoutcnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_out
argument_list|)
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmout
operator|==
name|NULL
condition|)
block|{
comment|/* big trouble no memory */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * inbound side must be set to 0xffff, also NOTE when we get 		 * the INIT-ACK back (for INIT sender) we MUST reduce the 		 * count (streamoutcnt) but first check if we sent to any of 		 * the upper streams that were dropped (if some were). Those 		 * that were dropped must be notified to the upper layer as 		 * failed to send. 		 */
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|next_mid_ordered
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|next_mid_unordered
operator|=
literal|0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|chunks_on_queues
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_DETAILED_STR_STATS
argument_list|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SCTP_PR_SCTP_MAX
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_sent
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_unsent
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_sent
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_unsent
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|sid
operator|=
name|i
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_OPENING
expr_stmt|;
name|asoc
operator|->
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
name|stcb
argument_list|,
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now the mapping array */
name|asoc
operator|->
name|mapping_array_size
operator|=
name|SCTP_INITIAL_MAPPING_ARRAY
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|mapping_array
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
comment|/* Now the init of the other outqueues */
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|free_chunks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|max_inbound_streams
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|)
expr_stmt|;
comment|/* authentication fields */
name|asoc
operator|->
name|authinfo
operator|.
name|random
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|active_keyid
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|assoc_key
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|assoc_keyid
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|recv_key
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|recv_keyid
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|shared_keys
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|marked_retrans
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|port
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|port
expr_stmt|;
name|asoc
operator|->
name|timoinit
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timodata
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timosack
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoshutdown
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoheartbeat
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timocookie
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoshutdownack
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|discontinuity_time
operator|=
name|asoc
operator|->
name|start_time
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_PR_SCTP_MAX
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|asoc
operator|->
name|abandoned_unsent
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|abandoned_sent
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * sa_ignore MEMLEAK {memory is put in the assoc mapping array and 	 * freed later when the association is freed. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_print_mapping_array
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"Mapping array size: %d, baseTSN: %8.8x, cumAck: %8.8x, highestTSN: (%8.8x, %8.8x).\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
expr_stmt|;
for|for
control|(
name|limit
operator|=
name|asoc
operator|->
name|mapping_array_size
init|;
name|limit
operator|>
literal|1
condition|;
name|limit
operator|--
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|mapping_array
index|[
name|limit
operator|-
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
break|break;
block|}
block|}
name|SCTP_PRINTF
argument_list|(
literal|"Renegable mapping array (last %d entries are zero):\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
operator|-
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"%2.2x%c"
argument_list|,
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|16
operator|)
condition|?
literal|' '
else|:
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|%
literal|16
condition|)
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|limit
operator|=
name|asoc
operator|->
name|mapping_array_size
init|;
name|limit
operator|>
literal|1
condition|;
name|limit
operator|--
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
index|[
name|limit
operator|-
literal|1
index|]
condition|)
block|{
break|break;
block|}
block|}
name|SCTP_PRINTF
argument_list|(
literal|"Non renegable mapping array (last %d entries are zero):\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
operator|-
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"%2.2x%c"
argument_list|,
name|asoc
operator|->
name|nr_mapping_array
index|[
name|i
index|]
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|16
operator|)
condition|?
literal|' '
else|:
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|%
literal|16
condition|)
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_expand_mapping_array
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|needed
parameter_list|)
block|{
comment|/* mapping array needs to grow */
name|uint8_t
modifier|*
name|new_array1
decl_stmt|,
modifier|*
name|new_array2
decl_stmt|;
name|uint32_t
name|new_size
decl_stmt|;
name|new_size
operator|=
name|asoc
operator|->
name|mapping_array_size
operator|+
operator|(
operator|(
name|needed
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
name|SCTP_MAPPING_ARRAY_INCR
operator|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_array1
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|new_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_array2
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|new_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_array1
operator|==
name|NULL
operator|)
operator|||
operator|(
name|new_array2
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't get more, forget it */
name|SCTP_PRINTF
argument_list|(
literal|"No memory for expansion of SCTP mapping array %d\n"
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_array1
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|new_array1
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_array2
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|new_array2
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|new_array1
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_array2
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_array1
argument_list|,
name|asoc
operator|->
name|mapping_array
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_array2
argument_list|,
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array
operator|=
name|new_array1
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array
operator|=
name|new_array2
expr_stmt|;
name|asoc
operator|->
name|mapping_array_size
operator|=
name|new_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_iterator_work
parameter_list|(
name|struct
name|sctp_iterator
modifier|*
name|it
parameter_list|)
block|{
name|int
name|iteration_count
init|=
literal|0
decl_stmt|;
name|int
name|inp_skip
init|=
literal|0
decl_stmt|;
name|int
name|first_in
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|tinp
decl_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
name|sctp_it_ctl
operator|.
name|cur_it
operator|=
name|it
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* iterator is complete */
name|done_with_iterator
label|:
name|sctp_it_ctl
operator|.
name|cur_it
operator|=
name|NULL
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|function_atend
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|it
operator|->
name|function_atend
call|)
argument_list|(
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|it
argument_list|,
name|SCTP_M_ITER
argument_list|)
expr_stmt|;
return|return;
block|}
name|select_a_new_ep
label|:
if|if
condition|(
name|first_in
condition|)
block|{
name|first_in
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|it
operator|->
name|pcb_flags
operator|)
operator|&&
operator|(
operator|(
name|it
operator|->
name|inp
operator|->
name|sctp_flags
operator|&
name|it
operator|->
name|pcb_flags
operator|)
operator|!=
name|it
operator|->
name|pcb_flags
operator|)
operator|)
operator|||
operator|(
operator|(
name|it
operator|->
name|pcb_features
operator|)
operator|&&
operator|(
operator|(
name|it
operator|->
name|inp
operator|->
name|sctp_features
operator|&
name|it
operator|->
name|pcb_features
operator|)
operator|!=
name|it
operator|->
name|pcb_features
operator|)
operator|)
condition|)
block|{
comment|/* endpoint flags or features don't match, so keep looking */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done_with_iterator
goto|;
block|}
name|tinp
operator|=
name|it
operator|->
name|inp
expr_stmt|;
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* now go through each assoc which is in the desired state */
if|if
condition|(
name|it
operator|->
name|done_current_ep
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp
operator|!=
name|NULL
condition|)
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
name|it
operator|->
name|done_current_ep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* run the per instance function */
name|it
operator|->
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|it
operator|->
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp_skip
operator|)
operator|||
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp_end
operator|!=
name|NULL
condition|)
block|{
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp_end
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|no_stcb
goto|;
block|}
while|while
condition|(
name|it
operator|->
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|asoc_state
operator|&&
operator|(
operator|(
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|it
operator|->
name|asoc_state
operator|)
operator|!=
name|it
operator|->
name|asoc_state
operator|)
condition|)
block|{
comment|/* not in the right state... keep looking */
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|next_assoc
goto|;
block|}
comment|/* see if we have limited out the iterator loop */
name|iteration_count
operator|++
expr_stmt|;
if|if
condition|(
name|iteration_count
operator|>
name|SCTP_ITERATOR_MAX_AT_ONCE
condition|)
block|{
comment|/* Pause to let others grab the lock */
name|atomic_add_int
argument_list|(
operator|&
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
condition|)
block|{
comment|/* We won't be staying here */
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&
name|SCTP_ITERATOR_STOP_CUR_IT
condition|)
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&=
operator|~
name|SCTP_ITERATOR_STOP_CUR_IT
expr_stmt|;
goto|goto
name|done_with_iterator
goto|;
block|}
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&
name|SCTP_ITERATOR_STOP_CUR_INP
condition|)
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&=
operator|~
name|SCTP_ITERATOR_STOP_CUR_INP
expr_stmt|;
goto|goto
name|no_stcb
goto|;
block|}
comment|/* If we reach here huh? */
name|SCTP_PRINTF
argument_list|(
literal|"Unknown it ctl flag %x\n"
argument_list|,
name|sctp_it_ctl
operator|.
name|iterator_flags
argument_list|)
expr_stmt|;
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iteration_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* run function on this one */
call|(
modifier|*
name|it
operator|->
name|function_assoc
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|stcb
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * we lie here, it really needs to have its own type but 		 * first I must verify that this won't effect things :-0 		 */
if|if
condition|(
name|it
operator|->
name|no_chunk_output
operator|==
literal|0
condition|)
name|sctp_chunk_output
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|next_assoc
label|:
name|it
operator|->
name|stcb
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Run last function */
if|if
condition|(
name|it
operator|->
name|function_inp_end
operator|!=
name|NULL
condition|)
block|{
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp_end
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|no_stcb
label|:
comment|/* done with all assocs on this endpoint, move on to next endpoint */
name|it
operator|->
name|done_current_ep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
goto|goto
name|select_a_new_ep
goto|;
block|}
end_function

begin_function
name|void
name|sctp_iterator_worker
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
decl_stmt|,
modifier|*
name|nit
decl_stmt|;
comment|/* This function is called with the WQ lock in place */
name|sctp_it_ctl
operator|.
name|iterator_running
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|it
argument_list|,
argument|&sctp_it_ctl.iteratorhead
argument_list|,
argument|sctp_nxt_itr
argument_list|,
argument|nit
argument_list|)
block|{
comment|/* now lets work on this one */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sctp_it_ctl
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|it
operator|->
name|vn
argument_list|)
expr_stmt|;
name|sctp_iterator_work
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
name|sctp_it_ctl
operator|.
name|iterator_running
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_addr_wq
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* deal with the ADDR wq from the rtsock calls */
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|,
modifier|*
name|nwi
decl_stmt|;
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asc
argument_list|,
expr|struct
name|sctp_asconf_iterator
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_iterator
argument_list|)
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
if|if
condition|(
name|asc
operator|==
name|NULL
condition|)
block|{
comment|/* Try later, no memory */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|asc
operator|->
name|list_of_work
argument_list|)
expr_stmt|;
name|asc
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|wi
argument_list|,
argument|&SCTP_BASE_INFO(addr_wq)
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nwi
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|asc
operator|->
name|list_of_work
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|asc
operator|->
name|cnt
operator|++
expr_stmt|;
block|}
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asc
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_initiate_iterator
argument_list|(
name|sctp_asconf_iterator_ep
argument_list|,
name|sctp_asconf_iterator_stcb
argument_list|,
name|NULL
argument_list|,
comment|/* No ep end for boundall */
name|SCTP_PCB_FLAGS_BOUNDALL
argument_list|,
name|SCTP_PCB_ANY_FEATURES
argument_list|,
name|SCTP_ASOC_ANY_STATE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|asc
argument_list|,
literal|0
argument_list|,
name|sctp_asconf_iterator_end
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Failed to initiate iterator for handle_addr_wq\n"
argument_list|)
expr_stmt|;
comment|/* 			 * Freeing if we are stopping or put back on the 			 * addr_wq. 			 */
if|if
condition|(
name|SCTP_BASE_VAR
argument_list|(
name|sctp_pcb_initialized
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_asconf_iterator_end
argument_list|(
name|asc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|wi
argument_list|,
argument|&asc->list_of_work
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq
argument_list|)
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
block|}
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asc
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_timeout_handler
parameter_list|(
name|void
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_timer
modifier|*
name|tmr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|int
name|did_output
decl_stmt|;
name|int
name|type
decl_stmt|;
name|tmr
operator|=
operator|(
expr|struct
name|sctp_timer
operator|*
operator|)
name|t
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|tmr
operator|->
name|ep
expr_stmt|;
name|stcb
operator|=
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|tmr
operator|->
name|tcb
expr_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|tmr
operator|->
name|net
expr_stmt|;
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|tmr
operator|->
name|vnet
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xF0
argument_list|,
operator|(
name|uint8_t
operator|)
name|tmr
operator|->
name|type
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|3
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sanity checks... */
if|if
condition|(
name|tmr
operator|->
name|self
operator|!=
operator|(
name|void
operator|*
operator|)
name|tmr
condition|)
block|{
comment|/* 		 * SCTP_PRINTF("Stale SCTP timer fired (%p), ignoring...\n", 		 * (void *)tmr); 		 */
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa001
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_IS_TIMER_TYPE_VALID
argument_list|(
name|tmr
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * SCTP_PRINTF("SCTP timer fired with invalid type: 0x%x\n", 		 * tmr->type); 		 */
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa002
expr_stmt|;
if|if
condition|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_ADDR_WQ
operator|)
operator|&&
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if this is an iterator timeout, get the struct and clear inp */
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa003
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_INPKILL
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_INIT
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SEND
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_RECV
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_HEARTBEAT
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SHUTDOWN
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SHUTDOWNACK
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_ASOCKILL
operator|)
operator|)
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa004
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|type
operator|=
name|tmr
operator|->
name|type
expr_stmt|;
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa005
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Timer type %d goes off\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_ACTIVE
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa006
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|!=
name|SCTP_TIMER_TYPE_ASOCKILL
operator|)
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* record in stopped what t-o occurred */
name|tmr
operator|->
name|stopped_from
operator|=
name|type
expr_stmt|;
comment|/* mark as being serviced now */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
comment|/* 		 * Callout has been rescheduled. 		 */
goto|goto
name|get_out
goto|;
block|}
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_ACTIVE
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
comment|/* 		 * Not active, so no action. 		 */
goto|goto
name|get_out
goto|;
block|}
name|SCTP_OS_TIMER_DEACTIVATE
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* call the handler for the appropriate timer type */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SCTP_TIMER_TYPE_ZERO_COPY
case|:
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_ZCOPY_SENDQ
case|:
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_SENDQ_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_ADDR_WQ
case|:
name|sctp_handle_addr_wq
argument_list|()
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SEND
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timodata
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timodata
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|--
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|<
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_t3rxt_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
comment|/* 			 * safeguard. If there on some on the sent queue 			 * somewhere but no timers running something is 			 * wrong... so we start a timer on the first chunk 			 * on the send queue on whatever net it is sent to. 			 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_INIT
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoinit
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoinit
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_t1init_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
comment|/* We do output but not here */
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_RECV
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timosack
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timosack
operator|++
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SACK_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWN
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_shutdown_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoshutdown
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoshutdown
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SHUT_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_HEARTBEAT
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoheartbeat
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoheartbeat
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_heartbeat_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
operator|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_HB_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_COOKIE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_cookie_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timocookie
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timocookie
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * We consider T3 and Cookie timer pretty much the same with 		 * respect to where from in chunk_output. 		 */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_NEWCOOKIE
case|:
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|secret
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timosecret
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|time_of_secret_change
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|last_secret_number
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|++
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|>=
name|SCTP_HOW_MANY_SECRETS
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|=
literal|0
expr_stmt|;
block|}
name|secret
operator|=
operator|(
name|int
operator|)
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_OF_SECRETS
condition|;
name|i
operator|++
control|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|secret_key
index|[
name|secret
index|]
index|[
name|i
index|]
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_NEWCOOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PATHMTURAISE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timopathmtu
argument_list|)
expr_stmt|;
name|sctp_pathmtu_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNACK
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_shutdownack_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoshutdownack
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoshutdownack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SHUT_ACK_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoshutdownguard
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Shutdown guard timer expired"
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
case|case
name|SCTP_TIMER_TYPE_STRRESET
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_strreset_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timostrmrst
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_STRRST_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASCONF
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_asconf_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoasconf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_ASCONF_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PRIM_DELETED
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|sctp_delete_prim_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timodelprim
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_AUTOCLOSE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoautoclose
argument_list|)
expr_stmt|;
name|sctp_autoclose_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_AUTOCLOSE_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASOCKILL
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoassockill
argument_list|)
expr_stmt|;
comment|/* Can we free it yet? */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * free asoc, always unlocks (or destroy's) so prevent 		 * duplicate unlock or unlock of a free mtx :-0 		 */
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_no_decr
goto|;
case|case
name|SCTP_TIMER_TYPE_INPKILL
case|:
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoinpkill
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 		 * special case, take away our increment since WE are the 		 * killer 		 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INPKILL
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_FROM_INPKILL_TIMER
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_no_decr
goto|;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"sctp_timeout_handler:unknown timer %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xF1
argument_list|,
operator|(
name|uint8_t
operator|)
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|sctp_auditing
argument_list|(
literal|5
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|did_output
operator|)
operator|&&
name|stcb
condition|)
block|{
comment|/* 		 * Now we need to clean up the control chunk chain if an 		 * ECNE is on it. It must be marked as UNSENT again so next 		 * call will continue to send it until such time that we get 		 * a CWR, to remove it. It is, however, less likely that we 		 * will find a ecn echo on the chain though. 		 */
name|sctp_fix_ecn_echo
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
block|}
name|get_out
label|:
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|out_decr
label|:
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|out_no_decr
label|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Timer now complete (type = %d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_timer_start
parameter_list|(
name|int
name|t_type
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|to_ticks
decl_stmt|;
name|struct
name|sctp_timer
modifier|*
name|tmr
decl_stmt|;
if|if
condition|(
operator|(
name|t_type
operator|!=
name|SCTP_TIMER_TYPE_ADDR_WQ
operator|)
operator|&&
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
return|return;
name|tmr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t_type
condition|)
block|{
case|case
name|SCTP_TIMER_TYPE_ZERO_COPY
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_timer
expr_stmt|;
name|to_ticks
operator|=
name|SCTP_ZERO_COPY_TICK_DELAY
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ZCOPY_SENDQ
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_sendq_timer
expr_stmt|;
name|to_ticks
operator|=
name|SCTP_ZERO_COPY_SENDQ_TICK_DELAY
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ADDR_WQ
case|:
comment|/* Only 1 tick away :-) */
name|tmr
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq_timer
argument_list|)
expr_stmt|;
name|to_ticks
operator|=
name|SCTP_ADDRESS_TICK_DELAY
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SEND
case|:
comment|/* Here we use the RTO timer */
block|{
name|int
name|rto_val
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|rto_val
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
block|}
else|else
block|{
name|rto_val
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
block|}
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|rto_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_INIT
case|:
comment|/* 		 * Here we use the INIT timer default usually about 1 		 * minute. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_RECV
case|:
comment|/* 		 * Here we use the Delayed-Ack timer value from the inp 		 * ususually about 200ms. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
expr_stmt|;
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWN
case|:
comment|/* Here we use the RTO of the destination. */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_HEARTBEAT
case|:
comment|/* 		 * the net is used here so that we can add in the RTO. Even 		 * though we use a different timer. We also add the HB timer 		 * PLUS a random jitter. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|uint32_t
name|rndval
decl_stmt|;
name|uint32_t
name|jitter
decl_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
operator|)
operator|&&
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
block|}
name|rndval
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|jitter
operator|=
name|rndval
operator|%
name|to_ticks
expr_stmt|;
if|if
condition|(
name|jitter
operator|>=
operator|(
name|to_ticks
operator|>>
literal|1
operator|)
condition|)
block|{
name|to_ticks
operator|=
name|to_ticks
operator|+
operator|(
name|jitter
operator|-
operator|(
name|to_ticks
operator|>>
literal|1
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|to_ticks
operator|-
name|jitter
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
name|to_ticks
operator|+=
name|net
operator|->
name|heart_beat_delay
expr_stmt|;
block|}
comment|/* 			 * Now we must convert the to_ticks that are now in 			 * ms to ticks. 			 */
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|to_ticks
argument_list|)
expr_stmt|;
name|tmr
operator|=
operator|&
name|net
operator|->
name|hb_timer
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_COOKIE
case|:
comment|/* 		 * Here we can use the RTO timer from the network since one 		 * RTT was compelete. If a retran happened then we will be 		 * using the RTO initial value. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_NEWCOOKIE
case|:
comment|/* 		 * nothing needed but the endpoint here ususually about 60 		 * minutes. 		 */
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
name|to_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_SIGNATURE
index|]
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASOCKILL
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_ASOC_KILL_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_INPKILL
case|:
comment|/* 		 * The inp is setup to die. We re-use the signature_chage 		 * timer since that has stopped and we are in the GONE 		 * state. 		 */
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_INP_KILL_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PATHMTURAISE
case|:
comment|/* 		 * Here we use the value found in the EP for PMTU ususually 		 * about 10 minutes. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NO_PMTUD
condition|)
block|{
return|return;
block|}
name|to_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_PMTU
index|]
expr_stmt|;
name|tmr
operator|=
operator|&
name|net
operator|->
name|pmtu_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNACK
case|:
comment|/* Here we use the RTO of the destination */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
case|:
comment|/* 		 * Here we use the endpoints shutdown guard timer usually 		 * about 3 minutes. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_MAXSHUTDOWN
index|]
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
literal|5
operator|*
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_MAXSHUTDOWN
index|]
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shut_guard_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_STRRESET
case|:
comment|/* 		 * Here the timer comes from the stcb but its value is from 		 * the net's RTO. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASCONF
case|:
comment|/* 		 * Here the timer comes from the stcb but its value is from 		 * the net's RTO. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PRIM_DELETED
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|!=
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|delete_prim_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_AUTOCLOSE
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Really an error since stcb is NOT set to 			 * autoclose 			 */
return|return;
block|}
name|to_ticks
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
expr_stmt|;
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|autoclose_timer
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"%s: Unknown timer type %d\n"
argument_list|,
name|__func__
argument_list|,
name|t_type
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
if|if
condition|(
operator|(
name|to_ticks
operator|<=
literal|0
operator|)
operator|||
operator|(
name|tmr
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"%s: %d:software error to_ticks:%d tmr:%p not set ??\n"
argument_list|,
name|__func__
argument_list|,
name|t_type
argument_list|,
name|to_ticks
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tmr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
comment|/* 		 * we do NOT allow you to have it already running. if it is 		 * we leave the current one up unchanged 		 */
return|return;
block|}
comment|/* At this point we can proceed */
if|if
condition|(
name|t_type
operator|==
name|SCTP_TIMER_TYPE_SEND
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|++
expr_stmt|;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0
expr_stmt|;
name|tmr
operator|->
name|type
operator|=
name|t_type
expr_stmt|;
name|tmr
operator|->
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
expr_stmt|;
name|tmr
operator|->
name|tcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|tmr
operator|->
name|net
operator|=
operator|(
name|void
operator|*
operator|)
name|net
expr_stmt|;
name|tmr
operator|->
name|self
operator|=
operator|(
name|void
operator|*
operator|)
name|tmr
expr_stmt|;
name|tmr
operator|->
name|vnet
operator|=
operator|(
name|void
operator|*
operator|)
name|curvnet
expr_stmt|;
name|tmr
operator|->
name|ticks
operator|=
name|sctp_get_tick_count
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
name|tmr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_timer_stop
parameter_list|(
name|int
name|t_type
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_timer
modifier|*
name|tmr
decl_stmt|;
if|if
condition|(
operator|(
name|t_type
operator|!=
name|SCTP_TIMER_TYPE_ADDR_WQ
operator|)
operator|&&
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
return|return;
name|tmr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t_type
condition|)
block|{
case|case
name|SCTP_TIMER_TYPE_ZERO_COPY
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ZCOPY_SENDQ
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_sendq_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ADDR_WQ
case|:
name|tmr
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq_timer
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SEND
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_INIT
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_RECV
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWN
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_HEARTBEAT
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|hb_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_COOKIE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_NEWCOOKIE
case|:
comment|/* nothing needed but the endpoint here */
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
comment|/* 		 * We re-use the newcookie timer for the INP kill timer. We 		 * must assure that we do not kill it by accident. 		 */
break|break;
case|case
name|SCTP_TIMER_TYPE_ASOCKILL
case|:
comment|/* 		 * Stop the asoc kill timer. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_INPKILL
case|:
comment|/* 		 * The inp is setup to die. We re-use the signature_chage 		 * timer since that has stopped and we are in the GONE 		 * state. 		 */
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PATHMTURAISE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|pmtu_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNACK
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shut_guard_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_STRRESET
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASCONF
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PRIM_DELETED
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|delete_prim_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_AUTOCLOSE
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|autoclose_timer
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"%s: Unknown timer type %d\n"
argument_list|,
name|__func__
argument_list|,
name|t_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tmr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|t_type
operator|)
operator|&&
name|tmr
operator|->
name|type
condition|)
block|{
comment|/* 		 * Ok we have a timer that is under joint use. Cookie timer 		 * per chance with the SEND timer. We therefore are NOT 		 * running the timer that the caller wants stopped.  So just 		 * return. 		 */
return|return;
block|}
if|if
condition|(
operator|(
name|t_type
operator|==
name|SCTP_TIMER_TYPE_SEND
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|--
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|<
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|tmr
operator|->
name|self
operator|=
name|NULL
expr_stmt|;
name|tmr
operator|->
name|stopped_from
operator|=
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint32_t
name|sctp_calculate_len
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|tlen
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|at
decl_stmt|;
name|at
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|at
condition|)
block|{
name|tlen
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_mtu_size_reset
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
block|{
comment|/* 	 * Reset the P-MTU size on this association, this involves changing 	 * the asoc MTU, going through ANY chunk+overhead larger than mtu to 	 * allow the DF flag to be cleared. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|unsigned
name|int
name|eff_mtu
decl_stmt|,
name|ovh
decl_stmt|;
name|asoc
operator|->
name|smallest_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MIN_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
block|}
name|eff_mtu
operator|=
name|mtu
operator|-
name|ovh
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|send_size
operator|>
name|eff_mtu
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|send_size
operator|>
name|eff_mtu
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * given an association and starting time of the current RTT period return  * RTO in number of msecs net should point to the current network  */
end_comment

begin_function
name|uint32_t
name|sctp_calculate_rto
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|timeval
modifier|*
name|told
parameter_list|,
name|int
name|safe
parameter_list|,
name|int
name|rtt_from_sack
parameter_list|)
block|{
comment|/*- 	 * given an association and the starting time of the current RTT 	 * period (in value1/value2) return RTO in number of msecs. 	 */
name|int32_t
name|rtt
decl_stmt|;
comment|/* RTT in ms */
name|uint32_t
name|new_rto
decl_stmt|;
name|int
name|first_measure
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|then
decl_stmt|,
modifier|*
name|old
decl_stmt|;
comment|/* Copy it out for sparc64 */
if|if
condition|(
name|safe
operator|==
name|sctp_align_unsafe_makecopy
condition|)
block|{
name|old
operator|=
operator|&
name|then
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|then
argument_list|,
name|told
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|safe
operator|==
name|sctp_align_safe_nocopy
condition|)
block|{
name|old
operator|=
name|told
expr_stmt|;
block|}
else|else
block|{
comment|/* error */
name|SCTP_PRINTF
argument_list|(
literal|"Huh, bad rto calc call\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/************************/
comment|/* 1. calculate new RTT */
comment|/************************/
comment|/* get the current time */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|use_precise_time
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETPTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|timevalsub
argument_list|(
operator|&
name|now
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* store the current RTT in us */
name|net
operator|->
name|rtt
operator|=
operator|(
name|uint64_t
operator|)
literal|1000000
operator|*
operator|(
name|uint64_t
operator|)
name|now
operator|.
name|tv_sec
operator|+
operator|(
name|uint64_t
operator|)
name|now
operator|.
name|tv_usec
expr_stmt|;
comment|/* compute rtt in ms */
name|rtt
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|net
operator|->
name|rtt
operator|/
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_rtt_calculated
operator|)
operator|&&
operator|(
name|rtt_from_sack
operator|==
name|SCTP_RTT_FROM_DATA
operator|)
condition|)
block|{
comment|/* 		 * Tell the CC module that a new update has just occurred 		 * from a sack 		 */
call|(
modifier|*
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_rtt_calculated
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Do we need to determine the lan? We do this only on sacks i.e. 	 * RTT being determined from data not non-data (HB/INIT->INITACK). 	 */
if|if
condition|(
operator|(
name|rtt_from_sack
operator|==
name|SCTP_RTT_FROM_DATA
operator|)
operator|&&
operator|(
name|net
operator|->
name|lan_type
operator|==
name|SCTP_LAN_UNKNOWN
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|rtt
operator|>
name|SCTP_LOCAL_LAN_RTT
condition|)
block|{
name|net
operator|->
name|lan_type
operator|=
name|SCTP_LAN_INTERNET
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|lan_type
operator|=
name|SCTP_LAN_LOCAL
expr_stmt|;
block|}
block|}
comment|/***************************/
comment|/* 2. update RTTVAR& SRTT */
comment|/***************************/
comment|/*- 	 * Compute the scaled average lastsa and the 	 * scaled variance lastsv as described in van Jacobson 	 * Paper "Congestion Avoidance and Control", Annex A. 	 * 	 * (net->lastsa>> SCTP_RTT_SHIFT) is the srtt 	 * (net->lastsa>> SCTP_RTT_VAR_SHIFT) is the rttvar 	 */
if|if
condition|(
name|net
operator|->
name|RTO_measured
condition|)
block|{
name|rtt
operator|-=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
expr_stmt|;
name|net
operator|->
name|lastsa
operator|+=
name|rtt
expr_stmt|;
if|if
condition|(
name|rtt
operator|<
literal|0
condition|)
block|{
name|rtt
operator|=
operator|-
name|rtt
expr_stmt|;
block|}
name|rtt
operator|-=
operator|(
name|net
operator|->
name|lastsv
operator|>>
name|SCTP_RTT_VAR_SHIFT
operator|)
expr_stmt|;
name|net
operator|->
name|lastsv
operator|+=
name|rtt
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RTTVAR_LOGGING_ENABLE
condition|)
block|{
name|rto_logging
argument_list|(
name|net
argument_list|,
name|SCTP_LOG_RTTVAR
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* First RTO measurment */
name|net
operator|->
name|RTO_measured
operator|=
literal|1
expr_stmt|;
name|first_measure
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|lastsa
operator|=
name|rtt
operator|<<
name|SCTP_RTT_SHIFT
expr_stmt|;
name|net
operator|->
name|lastsv
operator|=
operator|(
name|rtt
operator|/
literal|2
operator|)
operator|<<
name|SCTP_RTT_VAR_SHIFT
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RTTVAR_LOGGING_ENABLE
condition|)
block|{
name|rto_logging
argument_list|(
name|net
argument_list|,
name|SCTP_LOG_INITIAL_RTT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|lastsv
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|lastsv
operator|=
name|SCTP_CLOCK_GRANULARITY
expr_stmt|;
block|}
name|new_rto
operator|=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
operator|+
name|net
operator|->
name|lastsv
expr_stmt|;
if|if
condition|(
operator|(
name|new_rto
operator|>
name|SCTP_SAT_NETWORK_MIN
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sat_network_lockout
operator|==
literal|0
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|first_measure
operator|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sat_network_lockout
operator|=
literal|1
expr_stmt|;
block|}
comment|/* bound it, per C6/C7 in Section 5.3.1 */
if|if
condition|(
name|new_rto
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|new_rto
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|new_rto
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|new_rto
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
comment|/* we are now returning the RTO */
return|return
operator|(
name|new_rto
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return a pointer to a contiguous piece of data from the given mbuf chain  * starting at 'off' for 'len' bytes.  If the desired piece spans more than  * one mbuf, a copy is made at 'ptr'. caller must ensure that the buffer size  * is>= 'len' returns NULL if there there isn't 'len' bytes in the chain.  */
end_comment

begin_function
name|caddr_t
name|sctp_m_getptr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|uint8_t
modifier|*
name|in_ptr
parameter_list|)
block|{
name|uint32_t
name|count
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|in_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|len
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* find the desired start location */
while|while
condition|(
operator|(
name|m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|off
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|off
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
condition|)
break|break;
name|off
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* is the current mbuf large enough (eg. contiguous)? */
if|if
condition|(
operator|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|-
name|off
operator|)
operator|>=
name|len
condition|)
block|{
return|return
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
return|;
block|}
else|else
block|{
comment|/* else, it spans more than one mbuf, so save a temp copy... */
while|while
condition|(
operator|(
name|m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
block|{
name|count
operator|=
name|min
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|,
name|ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|ptr
operator|+=
name|count
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|in_ptr
operator|)
return|;
block|}
block|}
end_function

begin_function
name|struct
name|sctp_paramhdr
modifier|*
name|sctp_get_next_param
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_paramhdr
modifier|*
name|pull
parameter_list|,
name|int
name|pull_limit
parameter_list|)
block|{
comment|/* This just provides a typed signature to Peter's Pull routine */
return|return
operator|(
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|pull_limit
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|pull
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_add_pad_tombuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|padlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_last
decl_stmt|;
name|caddr_t
name|dp
decl_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|3
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|padlen
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
comment|/* 		 * The easy way. We hope the majority of the time we hit 		 * here :) 		 */
name|m_last
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* Hard way we must grow the mbuf chain */
name|m_last
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|padlen
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_last
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_last
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_last
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|m_last
expr_stmt|;
block|}
name|dp
operator|=
name|mtod
argument_list|(
name|m_last
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m_last
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_last
argument_list|)
operator|+=
name|padlen
expr_stmt|;
name|memset
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_last
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_pad_lastmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|padval
parameter_list|,
name|struct
name|mbuf
modifier|*
name|last_mbuf
parameter_list|)
block|{
comment|/* find the last mbuf in chain and pad it */
name|struct
name|mbuf
modifier|*
name|m_at
decl_stmt|;
if|if
condition|(
name|last_mbuf
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|sctp_add_pad_tombuf
argument_list|(
name|last_mbuf
argument_list|,
name|padval
argument_list|)
operator|)
return|;
block|}
else|else
block|{
for|for
control|(
name|m_at
operator|=
name|m
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|sctp_add_pad_tombuf
argument_list|(
name|m_at
argument_list|,
name|padval
argument_list|)
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_assoc_change
parameter_list|(
name|uint16_t
name|state
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|error
parameter_list|,
name|struct
name|sctp_abort_chunk
modifier|*
name|abort
parameter_list|,
name|uint8_t
name|from_peer
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_assoc_change
modifier|*
name|sac
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|unsigned
name|int
name|notif_len
decl_stmt|;
name|uint16_t
name|abort_len
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
condition|)
block|{
name|notif_len
operator|=
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort
operator|!=
name|NULL
condition|)
block|{
name|abort_len
operator|=
name|ntohs
argument_list|(
name|abort
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abort_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|state
operator|==
name|SCTP_COMM_UP
operator|)
operator|||
operator|(
name|state
operator|==
name|SCTP_RESTART
operator|)
condition|)
block|{
name|notif_len
operator|+=
name|SCTP_ASSOC_SUPPORTS_MAX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|SCTP_COMM_LOST
operator|)
operator|||
operator|(
name|state
operator|==
name|SCTP_CANT_STR_ASSOC
operator|)
condition|)
block|{
name|notif_len
operator|+=
name|abort_len
expr_stmt|;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|notif_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
comment|/* Retry with smaller value. */
name|notif_len
operator|=
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
expr_stmt|;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|notif_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
goto|goto
name|set_error
goto|;
block|}
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sac
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_assoc_change
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sac
argument_list|,
literal|0
argument_list|,
name|notif_len
argument_list|)
expr_stmt|;
name|sac
operator|->
name|sac_type
operator|=
name|SCTP_ASSOC_CHANGE
expr_stmt|;
name|sac
operator|->
name|sac_flags
operator|=
literal|0
expr_stmt|;
name|sac
operator|->
name|sac_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
expr_stmt|;
name|sac
operator|->
name|sac_state
operator|=
name|state
expr_stmt|;
name|sac
operator|->
name|sac_error
operator|=
name|error
expr_stmt|;
comment|/* XXX verify these stream counts */
name|sac
operator|->
name|sac_outbound_streams
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
name|sac
operator|->
name|sac_inbound_streams
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
expr_stmt|;
name|sac
operator|->
name|sac_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|notif_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|state
operator|==
name|SCTP_COMM_UP
operator|)
operator|||
operator|(
name|state
operator|==
name|SCTP_RESTART
operator|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|==
literal|1
condition|)
block|{
name|sac
operator|->
name|sac_info
index|[
name|i
operator|++
index|]
operator|=
name|SCTP_ASSOC_SUPPORTS_PR
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|1
condition|)
block|{
name|sac
operator|->
name|sac_info
index|[
name|i
operator|++
index|]
operator|=
name|SCTP_ASSOC_SUPPORTS_AUTH
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|1
condition|)
block|{
name|sac
operator|->
name|sac_info
index|[
name|i
operator|++
index|]
operator|=
name|SCTP_ASSOC_SUPPORTS_ASCONF
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|idata_supported
operator|==
literal|1
condition|)
block|{
name|sac
operator|->
name|sac_info
index|[
name|i
operator|++
index|]
operator|=
name|SCTP_ASSOC_SUPPORTS_INTERLEAVING
expr_stmt|;
block|}
name|sac
operator|->
name|sac_info
index|[
name|i
operator|++
index|]
operator|=
name|SCTP_ASSOC_SUPPORTS_MULTIBUF
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|reconfig_supported
operator|==
literal|1
condition|)
block|{
name|sac
operator|->
name|sac_info
index|[
name|i
operator|++
index|]
operator|=
name|SCTP_ASSOC_SUPPORTS_RE_CONFIG
expr_stmt|;
block|}
name|sac
operator|->
name|sac_length
operator|+=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|state
operator|==
name|SCTP_COMM_LOST
operator|)
operator|||
operator|(
name|state
operator|==
name|SCTP_CANT_STR_ASSOC
operator|)
condition|)
block|{
name|memcpy
argument_list|(
name|sac
operator|->
name|sac_info
argument_list|,
name|abort
argument_list|,
name|abort_len
argument_list|)
expr_stmt|;
name|sac
operator|->
name|sac_length
operator|+=
name|abort_len
expr_stmt|;
block|}
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|sac
operator|->
name|sac_length
expr_stmt|;
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * For 1-to-1 style sockets, we send up and error when an ABORT 	 * comes in. 	 */
name|set_error
label|:
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|state
operator|==
name|SCTP_COMM_LOST
operator|)
operator|||
operator|(
name|state
operator|==
name|SCTP_CANT_STR_ASSOC
operator|)
operator|)
condition|)
block|{
name|SOCK_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_peer
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|ECONNREFUSED
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ETIMEDOUT
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|ECONNABORTED
expr_stmt|;
block|}
block|}
name|SOCK_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
comment|/* Wake ANY sleepers */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|state
operator|==
name|SCTP_COMM_LOST
operator|)
operator|||
operator|(
name|state
operator|==
name|SCTP_CANT_STR_ASSOC
operator|)
operator|)
condition|)
block|{
name|socantrcvmore
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
name|sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_peer_addr_change
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|state
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_paddr_change
modifier|*
name|spc
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|spc
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_paddr_change
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|spc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_type
operator|=
name|SCTP_PEER_ADDR_CHANGE
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator|=
literal|0
expr_stmt|;
name|spc
operator|->
name|spc_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
block|{
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|spc
operator|->
name|spc_aaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
operator|&
name|spc
operator|->
name|spc_aaddr
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|memcpy
argument_list|(
operator|&
name|spc
operator|->
name|spc_aaddr
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|spc
operator|->
name|spc_aaddr
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|spc
operator|->
name|spc_aaddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
comment|/* recover scope_id for user */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* clear embedded scope_id for user */
name|in6_clearscope
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
name|spc
operator|->
name|spc_state
operator|=
name|state
expr_stmt|;
name|spc
operator|->
name|spc_error
operator|=
name|error
expr_stmt|;
name|spc
operator|->
name|spc_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_send_failed
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint8_t
name|sent
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_send_failed
modifier|*
name|ssf
decl_stmt|;
name|struct
name|sctp_send_failed_event
modifier|*
name|ssfe
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|chkhdr
decl_stmt|;
name|int
name|notifhdr_len
decl_stmt|,
name|chk_len
decl_stmt|,
name|chkhdr_len
decl_stmt|,
name|padding_len
decl_stmt|,
name|payload_len
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
operator|&&
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVNSENDFAILEVNT
argument_list|)
operator|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVNSENDFAILEVNT
argument_list|)
condition|)
block|{
name|notifhdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed_event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notifhdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
expr_stmt|;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|notifhdr_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|notifhdr_len
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|idata_supported
condition|)
block|{
name|chkhdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chkhdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
block|}
comment|/* Use some defaults in case we can't access the chunk header */
if|if
condition|(
name|chk
operator|->
name|send_size
operator|>=
name|chkhdr_len
condition|)
block|{
name|payload_len
operator|=
name|chk
operator|->
name|send_size
operator|-
name|chkhdr_len
expr_stmt|;
block|}
else|else
block|{
name|payload_len
operator|=
literal|0
expr_stmt|;
block|}
name|padding_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|chkhdr
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|chkhdr
operator|!=
name|NULL
condition|)
block|{
name|chk_len
operator|=
name|ntohs
argument_list|(
name|chkhdr
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chk_len
operator|>=
name|chkhdr_len
operator|)
operator|&&
operator|(
name|chk
operator|->
name|send_size
operator|>=
name|chk_len
operator|)
operator|&&
operator|(
name|chk
operator|->
name|send_size
operator|-
name|chk_len
operator|<
literal|4
operator|)
condition|)
block|{
name|padding_len
operator|=
name|chk
operator|->
name|send_size
operator|-
name|chk_len
expr_stmt|;
name|payload_len
operator|=
name|chk
operator|->
name|send_size
operator|-
name|chkhdr_len
operator|-
name|padding_len
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVNSENDFAILEVNT
argument_list|)
condition|)
block|{
name|ssfe
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_send_failed_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ssfe
argument_list|,
literal|0
argument_list|,
name|notifhdr_len
argument_list|)
expr_stmt|;
name|ssfe
operator|->
name|ssfe_type
operator|=
name|SCTP_SEND_FAILED_EVENT
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
name|ssfe
operator|->
name|ssfe_flags
operator|=
name|SCTP_DATA_SENT
expr_stmt|;
block|}
else|else
block|{
name|ssfe
operator|->
name|ssfe_flags
operator|=
name|SCTP_DATA_UNSENT
expr_stmt|;
block|}
name|ssfe
operator|->
name|ssfe_length
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|notifhdr_len
operator|+
name|payload_len
argument_list|)
expr_stmt|;
name|ssfe
operator|->
name|ssfe_error
operator|=
name|error
expr_stmt|;
comment|/* not exactly what the user sent in, but should be close :) */
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_sid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
expr_stmt|;
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_context
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
expr_stmt|;
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|ssfe
operator|->
name|ssfe_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ssf
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_send_failed
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ssf
argument_list|,
literal|0
argument_list|,
name|notifhdr_len
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_type
operator|=
name|SCTP_SEND_FAILED
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_SENT
expr_stmt|;
block|}
else|else
block|{
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_UNSENT
expr_stmt|;
block|}
name|ssf
operator|->
name|ssf_length
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|notifhdr_len
operator|+
name|payload_len
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_error
operator|=
name|error
expr_stmt|;
comment|/* not exactly what the user sent in, but should be close :) */
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_stream
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ssn
operator|=
operator|(
name|uint16_t
operator|)
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_context
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
comment|/* Trim off the sctp chunk header (it should be there) */
if|if
condition|(
name|chk
operator|->
name|send_size
operator|==
name|chkhdr_len
operator|+
name|payload_len
operator|+
name|padding_len
condition|)
block|{
name|m_adj
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|chkhdr_len
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|chk
operator|->
name|data
argument_list|,
operator|-
name|padding_len
argument_list|)
expr_stmt|;
name|sctp_mbuf_crush
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|-=
operator|(
name|chkhdr_len
operator|+
name|padding_len
operator|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|chk
operator|->
name|data
expr_stmt|;
comment|/* Steal off the mbuf */
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For this case, we check the actual socket buffer, since the assoc 	 * is going away we don't want to overfill the socket buffer for a 	 * non-reader 	 */
if|if
condition|(
name|sctp_sbspace_failedmsgs
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_send_failed2
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_send_failed
modifier|*
name|ssf
decl_stmt|;
name|struct
name|sctp_send_failed_event
modifier|*
name|ssfe
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|int
name|notifhdr_len
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
operator|&&
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVNSENDFAILEVNT
argument_list|)
operator|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVNSENDFAILEVNT
argument_list|)
condition|)
block|{
name|notifhdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed_event
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notifhdr_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
expr_stmt|;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|notifhdr_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
comment|/* no space left */
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|notifhdr_len
expr_stmt|;
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVNSENDFAILEVNT
argument_list|)
condition|)
block|{
name|ssfe
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_send_failed_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ssfe
argument_list|,
literal|0
argument_list|,
name|notifhdr_len
argument_list|)
expr_stmt|;
name|ssfe
operator|->
name|ssfe_type
operator|=
name|SCTP_SEND_FAILED_EVENT
expr_stmt|;
name|ssfe
operator|->
name|ssfe_flags
operator|=
name|SCTP_DATA_UNSENT
expr_stmt|;
name|ssfe
operator|->
name|ssfe_length
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|notifhdr_len
operator|+
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
name|ssfe
operator|->
name|ssfe_error
operator|=
name|error
expr_stmt|;
comment|/* not exactly what the user sent in, but should be close :) */
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_sid
operator|=
name|sp
operator|->
name|sid
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_flags
operator|=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
block|}
else|else
block|{
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_flags
operator|=
name|SCTP_DATA_NOT_FRAG
expr_stmt|;
block|}
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_ppid
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|ssfe
operator|->
name|ssfe_info
operator|.
name|snd_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|ssfe
operator|->
name|ssfe_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ssf
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_send_failed
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ssf
argument_list|,
literal|0
argument_list|,
name|notifhdr_len
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_type
operator|=
name|SCTP_SEND_FAILED
expr_stmt|;
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_UNSENT
expr_stmt|;
name|ssf
operator|->
name|ssf_length
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|notifhdr_len
operator|+
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_error
operator|=
name|error
expr_stmt|;
comment|/* not exactly what the user sent in, but should be close :) */
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_stream
operator|=
name|sp
operator|->
name|sid
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ssn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_flags
operator|=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
block|}
else|else
block|{
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_flags
operator|=
name|SCTP_DATA_NOT_FRAG
expr_stmt|;
block|}
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ppid
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|sp
operator|->
name|data
expr_stmt|;
comment|/* Steal off the mbuf */
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For this case, we check the actual socket buffer, since the assoc 	 * is going away we don't want to overfill the socket buffer for a 	 * non-reader 	 */
if|if
condition|(
name|sctp_sbspace_failedmsgs
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_adaptation_layer
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_adaptation_event
modifier|*
name|sai
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaption_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sai
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_adaptation_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sai
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_event
argument_list|)
argument_list|)
expr_stmt|;
name|sai
operator|->
name|sai_type
operator|=
name|SCTP_ADAPTATION_INDICATION
expr_stmt|;
name|sai
operator|->
name|sai_flags
operator|=
literal|0
expr_stmt|;
name|sai
operator|->
name|sai_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_event
argument_list|)
expr_stmt|;
name|sai
operator|->
name|sai_adaptation_ind
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_adaptation
expr_stmt|;
name|sai
operator|->
name|sai_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This always must be called with the read-queue LOCKED in the INP */
end_comment

begin_function
specifier|static
name|void
name|sctp_notify_partial_delivery_indication
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_pdapi_event
modifier|*
name|pdapi
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_CANT_READ
condition|)
block|{
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pdapi
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_pdapi_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pdapi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
argument_list|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_type
operator|=
name|SCTP_PARTIAL_DELIVERY_EVENT
expr_stmt|;
name|pdapi
operator|->
name|pdapi_flags
operator|=
literal|0
expr_stmt|;
name|pdapi
operator|->
name|pdapi_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_indication
operator|=
name|error
expr_stmt|;
name|pdapi
operator|->
name|pdapi_stream
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_seq
operator|=
operator|(
name|val
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|sb
operator|=
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
name|sb
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
condition|)
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|read_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* we really should not see this case */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|&&
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
comment|/* This should always be the case */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_shutdown_event
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_shutdown_event
modifier|*
name|sse
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
comment|/* 	 * For TCP model AND UDP connected sockets we will send an error up 	 * when an SHUTDOWN completes 	 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* mark socket closed for read/write and wakeup! */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|socantsendmore
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|sse
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_shutdown_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sse
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
argument_list|)
expr_stmt|;
name|sse
operator|->
name|sse_type
operator|=
name|SCTP_SHUTDOWN_EVENT
expr_stmt|;
name|sse
operator|->
name|sse_flags
operator|=
literal|0
expr_stmt|;
name|sse
operator|->
name|sse_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
expr_stmt|;
name|sse
operator|->
name|sse_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_sender_dry_event
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_sender_dry_event
modifier|*
name|event
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
comment|/* no space left */
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|event
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_sender_dry_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|event
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|->
name|sender_dry_type
operator|=
name|SCTP_SENDER_DRY_EVENT
expr_stmt|;
name|event
operator|->
name|sender_dry_flags
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|sender_dry_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
expr_stmt|;
name|event
operator|->
name|sender_dry_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_notify_stream_reset_add
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|numberin
parameter_list|,
name|uint16_t
name|numberout
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_stream_change_event
modifier|*
name|stradd
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_CHANGEEVNT
argument_list|)
operator|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_req_out
operator|)
operator|&&
name|flag
condition|)
block|{
comment|/* Peer made the request, don't tell the local user */
name|stcb
operator|->
name|asoc
operator|.
name|peer_req_out
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|peer_req_out
operator|=
literal|0
expr_stmt|;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_change_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|stradd
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_stream_change_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stradd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_change_event
argument_list|)
argument_list|)
expr_stmt|;
name|stradd
operator|->
name|strchange_type
operator|=
name|SCTP_STREAM_CHANGE_EVENT
expr_stmt|;
name|stradd
operator|->
name|strchange_flags
operator|=
name|flag
expr_stmt|;
name|stradd
operator|->
name|strchange_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_change_event
argument_list|)
expr_stmt|;
name|stradd
operator|->
name|strchange_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stradd
operator|->
name|strchange_instrms
operator|=
name|numberin
expr_stmt|;
name|stradd
operator|->
name|strchange_outstrms
operator|=
name|numberout
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_change_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* no space */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_notify_stream_reset_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|sending_tsn
parameter_list|,
name|uint32_t
name|recv_tsn
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_assoc_reset_event
modifier|*
name|strasoc
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_ASSOC_RESETEVNT
argument_list|)
operator|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_reset_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|strasoc
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_assoc_reset_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strasoc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_reset_event
argument_list|)
argument_list|)
expr_stmt|;
name|strasoc
operator|->
name|assocreset_type
operator|=
name|SCTP_ASSOC_RESET_EVENT
expr_stmt|;
name|strasoc
operator|->
name|assocreset_flags
operator|=
name|flag
expr_stmt|;
name|strasoc
operator|->
name|assocreset_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_reset_event
argument_list|)
expr_stmt|;
name|strasoc
operator|->
name|assocreset_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|strasoc
operator|->
name|assocreset_local_tsn
operator|=
name|sending_tsn
expr_stmt|;
name|strasoc
operator|->
name|assocreset_remote_tsn
operator|=
name|recv_tsn
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_reset_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* no space */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_stream_reset_event
modifier|*
name|strreset
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
operator|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_event
argument_list|)
operator|+
operator|(
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* never enough room */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|strreset
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_stream_reset_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|strreset
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|strreset
operator|->
name|strreset_type
operator|=
name|SCTP_STREAM_RESET_EVENT
expr_stmt|;
name|strreset
operator|->
name|strreset_flags
operator|=
name|flag
expr_stmt|;
name|strreset
operator|->
name|strreset_length
operator|=
name|len
expr_stmt|;
name|strreset
operator|->
name|strreset_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|strreset
operator|->
name|strreset_stream_list
index|[
name|i
index|]
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* no space */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_remote_error
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|error
parameter_list|,
name|struct
name|sctp_error_chunk
modifier|*
name|chunk
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_remote_error
modifier|*
name|sre
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|unsigned
name|int
name|notif_len
decl_stmt|;
name|uint16_t
name|chunk_len
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|chunk
operator|!=
name|NULL
condition|)
block|{
name|chunk_len
operator|=
name|ntohs
argument_list|(
name|chunk
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunk_len
operator|=
literal|0
expr_stmt|;
block|}
name|notif_len
operator|=
call|(
name|unsigned
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_remote_error
argument_list|)
operator|+
name|chunk_len
argument_list|)
expr_stmt|;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|notif_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
comment|/* Retry with smaller value. */
name|notif_len
operator|=
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_remote_error
argument_list|)
expr_stmt|;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|notif_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|sre
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_remote_error
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sre
argument_list|,
literal|0
argument_list|,
name|notif_len
argument_list|)
expr_stmt|;
name|sre
operator|->
name|sre_type
operator|=
name|SCTP_REMOTE_ERROR
expr_stmt|;
name|sre
operator|->
name|sre_flags
operator|=
literal|0
expr_stmt|;
name|sre
operator|->
name|sre_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_remote_error
argument_list|)
expr_stmt|;
name|sre
operator|->
name|sre_error
operator|=
name|error
expr_stmt|;
name|sre
operator|->
name|sre_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|notif_len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_remote_error
argument_list|)
condition|)
block|{
name|memcpy
argument_list|(
name|sre
operator|->
name|sre_data
argument_list|,
name|chunk
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
name|sre
operator|->
name|sre_length
operator|+=
name|chunk_len
expr_stmt|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|sre
operator|->
name|sre_length
expr_stmt|;
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_ulp_notify
parameter_list|(
name|uint32_t
name|notification
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
comment|/* If the socket is gone we are out of here */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|notification
operator|==
name|SCTP_NOTIFY_INTERFACE_DOWN
operator|)
operator|||
operator|(
name|notification
operator|==
name|SCTP_NOTIFY_INTERFACE_UP
operator|)
operator|||
operator|(
name|notification
operator|==
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
operator|)
condition|)
block|{
comment|/* Don't report these in front states */
return|return;
block|}
block|}
switch|switch
condition|(
name|notification
condition|)
block|{
case|case
name|SCTP_NOTIFY_ASSOC_UP
case|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_up_sent
operator|==
literal|0
condition|)
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_COMM_UP
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|assoc_up_sent
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|adaptation_needed
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|adaptation_sent
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_notify_adaptation_layer
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|0
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_NO_PEER_AUTH
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_ASSOC_DOWN
case|:
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_SHUTDOWN_COMP
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_INTERFACE_DOWN
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|data
expr_stmt|;
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_UNREACHABLE
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_INTERFACE_UP
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|data
expr_stmt|;
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_AVAILABLE
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|data
expr_stmt|;
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_CONFIRMED
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
case|:
name|sctp_notify_send_failed2
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
expr|struct
name|sctp_stream_queue_pending
operator|*
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_SENT_DG_FAIL
case|:
name|sctp_notify_send_failed
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|error
argument_list|,
operator|(
expr|struct
name|sctp_tmit_chunk
operator|*
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_UNSENT_DG_FAIL
case|:
name|sctp_notify_send_failed
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
name|error
argument_list|,
operator|(
expr|struct
name|sctp_tmit_chunk
operator|*
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
case|:
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|sctp_notify_partial_delivery_indication
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
name|val
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_ASSOC_LOC_ABORTED
case|:
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
operator|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
operator|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_CANT_STR_ASSOC
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_COMM_LOST
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|data
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_ASSOC_REM_ABORTED
case|:
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
operator|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
operator|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_CANT_STR_ASSOC
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_COMM_LOST
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|data
argument_list|,
literal|1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_ASSOC_RESTART
case|:
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_RESTART
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|0
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_NO_PEER_AUTH
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_SEND
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
name|SCTP_STREAM_RESET_OUTGOING_SSN
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_RECV
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
name|SCTP_STREAM_RESET_INCOMING
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_FAILED_OUT
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|(
name|SCTP_STREAM_RESET_OUTGOING_SSN
operator||
name|SCTP_STREAM_RESET_FAILED
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_DENIED_OUT
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|(
name|SCTP_STREAM_RESET_OUTGOING_SSN
operator||
name|SCTP_STREAM_RESET_DENIED
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_FAILED_IN
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|(
name|SCTP_STREAM_RESET_INCOMING
operator||
name|SCTP_STREAM_RESET_FAILED
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_DENIED_IN
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|(
name|SCTP_STREAM_RESET_INCOMING
operator||
name|SCTP_STREAM_RESET_DENIED
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_ADD_IP
case|:
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_ADDED
argument_list|,
name|data
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_DELETE_IP
case|:
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_REMOVED
argument_list|,
name|data
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_SET_PRIMARY
case|:
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_MADE_PRIM
argument_list|,
name|data
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_PEER_SHUTDOWN
case|:
name|sctp_notify_shutdown_event
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_AUTH_NEW_KEY
case|:
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_NEW_KEY
argument_list|,
name|error
argument_list|,
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_AUTH_FREE_KEY
case|:
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_FREE_KEY
argument_list|,
name|error
argument_list|,
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_NO_PEER_AUTH
case|:
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_NO_AUTH
argument_list|,
name|error
argument_list|,
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_SENDER_DRY
case|:
name|sctp_notify_sender_dry_event
argument_list|(
name|stcb
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_REMOTE_ERROR
case|:
name|sctp_notify_remote_error
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
name|data
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_UTIL1
argument_list|,
literal|"%s: unknown notification %xh (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|notification
argument_list|,
name|notification
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end switch */
block|}
end_function

begin_function
name|void
name|sctp_report_all_outbound
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|error
parameter_list|,
name|int
name|holds_lock
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* already being freed */
return|return;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
return|return;
block|}
comment|/* now through all the gunk freeing chunks */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* sent queue SHOULD be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"No chunks on the queues for sid %u."
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* pending send queue SHOULD be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"No chunks on the queues for sid %u."
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_UNSENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* For each stream */
name|outs
operator|=
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
expr_stmt|;
comment|/* clean up any sends there */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&outs->outqueue
argument_list|,
argument|next
argument_list|,
argument|nsp
argument_list|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_remove_from_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|outs
argument_list|,
name|sp
argument_list|,
name|holds_lock
argument_list|)
expr_stmt|;
name|sctp_free_spbufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sp
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free the chunk */
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
block|}
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_abort_notification
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint8_t
name|from_peer
parameter_list|,
name|uint16_t
name|error
parameter_list|,
name|struct
name|sctp_abort_chunk
modifier|*
name|abort
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|)
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_WAS_ABORTED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
return|return;
block|}
comment|/* Tell them we lost the asoc */
name|sctp_report_all_outbound
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
literal|1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_peer
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_REM_ABORTED
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|abort
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_LOC_ABORTED
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|abort
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_abort_association
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|uint32_t
name|vtag
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|vtag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
name|vrf_id
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
block|}
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|vtag
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* We have a TCB to abort, send notification too */
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_WAS_ABORTED
expr_stmt|;
comment|/* Ok, now lets free it */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
end_ifdef

begin_function
name|void
name|sctp_print_out_track_log
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NOSIY_PRINTS
name|int
name|i
decl_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"Last ep reason:%x\n"
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"IN bound TSN log-aaa\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_wrapped
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"None rcvd\n"
argument_list|)
expr_stmt|;
goto|goto
name|none_in
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_wrapped
condition|)
block|{
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
init|;
name|i
operator|<
name|SCTP_TSN_LOG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
name|none_in
label|:
name|SCTP_PRINTF
argument_list|(
literal|"OUT bound TSN log-aaa\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_wrapped
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"None sent\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_wrapped
condition|)
block|{
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
init|;
name|i
operator|<
name|SCTP_TSN_LOG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_abort_an_association
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Got to have a TCB */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
condition|)
block|{
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_DIRECTLY_NOCMPSET
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_WAS_ABORTED
expr_stmt|;
block|}
comment|/* notify the peer */
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
comment|/* notify the ulp */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
comment|/* now free the asoc */
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|sctp_print_out_track_log
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sctp_handle_ootb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|cause
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint16_t
name|fibnum
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|unsigned
name|int
name|chk_length
decl_stmt|;
name|int
name|contains_init_chunk
decl_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_outoftheblue
argument_list|)
expr_stmt|;
comment|/* Generate a TO address for future reference */
if|if
condition|(
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
condition|)
block|{
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_DIRECTLY_NOCMPSET
argument_list|)
expr_stmt|;
block|}
block|}
name|contains_init_chunk
operator|=
literal|0
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|NULL
condition|)
block|{
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
comment|/* break to abort land */
break|break;
block|}
switch|switch
condition|(
name|ch
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INIT
case|:
name|contains_init_chunk
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_PACKET_DROPPED
case|:
comment|/* we don't respond to pkt-dropped */
return|return;
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
comment|/* we don't respond with an ABORT to an ABORT */
return|return;
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
comment|/* 			 * we ignore it since we are not waiting for it and 			 * peer is gone 			 */
return|return;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
name|sctp_send_shutdown_complete2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|contains_init_chunk
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|cause
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * check the inbound datagram to make sure there is not an abort inside it,  * if there is return 1, else return 0.  */
end_comment

begin_function
name|int
name|sctp_is_there_an_abort_here
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|uint32_t
modifier|*
name|vtagfill
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init_chk
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|chk_length
decl_stmt|;
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|NULL
condition|)
block|{
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
comment|/* packet is probably corrupt */
break|break;
block|}
comment|/* we seem to be ok, is it an abort? */
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ABORT_ASSOCIATION
condition|)
block|{
comment|/* yep, tell them */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
condition|)
block|{
comment|/* need to update the Vtag */
name|init_chk
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|init_chk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_chk
operator|!=
name|NULL
condition|)
block|{
operator|*
name|vtagfill
operator|=
name|ntohl
argument_list|(
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Nope, move to the next chunk */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * currently (2/02), ifa_addr embeds scope_id's and don't have sin6_scope_id  * set (i.e. it's 0) so, create this function to compare link local scopes  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|uint32_t
name|sctp_is_same_scope
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|addr1
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|addr2
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|a
decl_stmt|,
name|b
decl_stmt|;
comment|/* save copies */
name|a
operator|=
operator|*
name|addr1
expr_stmt|;
name|b
operator|=
operator|*
name|addr2
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|sin6_scope_id
operator|==
literal|0
condition|)
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|a
argument_list|)
condition|)
block|{
comment|/* can't get scope, so can't match */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|.
name|sin6_scope_id
operator|==
literal|0
condition|)
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|b
argument_list|)
condition|)
block|{
comment|/* can't get scope, so can't match */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|.
name|sin6_scope_id
operator|!=
name|b
operator|.
name|sin6_scope_id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns a sockaddr_in6 with embedded scope recovered and removed  */
end_comment

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|sctp_recover_scope
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|addr
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|store
parameter_list|)
block|{
comment|/* check and strip embedded scope junk */
if|if
condition|(
name|addr
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
operator|*
name|store
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|sa6_recoverscope
argument_list|(
name|store
argument_list|)
condition|)
block|{
comment|/* use the recovered scope */
name|addr
operator|=
name|store
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* else, return the original "to" addr */
name|in6_clearscope
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * are the two addresses the same?  currently a "scopeless" check returns: 1  * if same, 0 if not  */
end_comment

begin_function
name|int
name|sctp_cmpaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa1
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa2
parameter_list|)
block|{
comment|/* must be valid */
if|if
condition|(
name|sa1
operator|==
name|NULL
operator|||
name|sa2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* must be the same family */
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* IPv6 addresses */
name|struct
name|sockaddr_in6
modifier|*
name|sin6_1
decl_stmt|,
modifier|*
name|sin6_2
decl_stmt|;
name|sin6_1
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa1
expr_stmt|;
name|sin6_2
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa2
expr_stmt|;
return|return
operator|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6_1
argument_list|,
name|sin6_2
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
comment|/* IPv4 addresses */
name|struct
name|sockaddr_in
modifier|*
name|sin_1
decl_stmt|,
modifier|*
name|sin_2
decl_stmt|;
name|sin_1
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa1
expr_stmt|;
name|sin_2
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa2
expr_stmt|;
return|return
operator|(
name|sin_1
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sin_2
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
return|;
block|}
endif|#
directive|endif
default|default:
comment|/* we don't do these... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_print_address
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"IPv6 address: %s:port:%d scope:%u\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
argument_list|,
name|sin6
operator|->
name|sin6_scope_id
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"IPv4 address: %u.%u.%u.%u:%d\n"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|SCTP_PRINTF
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|sctp_pull_off_control_to_new_inp
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|old_inp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|new_inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|waitflags
parameter_list|)
block|{
comment|/* 	 * go through our old INP and pull off any control structures that 	 * belong to stcb and move then to the new inp. 	 */
name|struct
name|socket
modifier|*
name|old_so
decl_stmt|,
modifier|*
name|new_so
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
name|struct
name|sctp_readhead
name|tmp_queue
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|old_so
operator|=
name|old_inp
operator|->
name|sctp_socket
expr_stmt|;
name|new_so
operator|=
name|new_inp
operator|->
name|sctp_socket
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|tmp_queue
argument_list|)
expr_stmt|;
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|waitflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Gak, can't get sblock, we have a problem. data will be 		 * left stranded.. and we don't dare look at it since the 		 * other thread may be reading something. Oh well, its a 		 * screwed up app that does a peeloff OR a accept while 		 * reading from the main socket... actually its only the 		 * peeloff() case, since I think read will fail on a 		 * listening socket.. 		 */
return|return;
block|}
comment|/* lock the socket buffers */
name|SCTP_INP_READ_LOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&old_inp->read_queue
argument_list|,
argument|next
argument_list|,
argument|nctl
argument_list|)
block|{
comment|/* Pull off all for out target stcb */
if|if
condition|(
name|control
operator|->
name|stcb
operator|==
name|stcb
condition|)
block|{
comment|/* remove it we want it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|old_inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tmp_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sbfree
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
comment|/* Remove the sb-lock on the old socket */
name|sbunlock
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now we move them over to the new socket buffer */
name|SCTP_INP_READ_LOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&tmp_queue
argument_list|,
argument|next
argument_list|,
argument|nctl
argument_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|new_inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|new_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
operator|&
name|new_so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|new_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_wakeup_the_read_socket
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_add_to_readq
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|inp_read_lock_held
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/* 	 * Here we must place the control on the end of the socket read 	 * queue AND increment sb_cc so that select will work properly on 	 * read. 	 */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* Gak, TSNH!! */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Gak, inp NULL on add_to_readq"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_CANT_READ
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|inp
operator|->
name|total_recvs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|control
operator|->
name|do_not_ref_stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|total_recvs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip mbufs with NO length */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First one */
name|control
operator|->
name|data
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
continue|continue;
block|}
name|prev
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
comment|/* Everything got collapsed out?? */
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end
condition|)
block|{
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_read_q
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|&&
name|inp
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_wakeup_the_read_socket
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*************HOLD THIS COMMENT FOR PATCH FILE OF  *************ALTERNATE ROUTING CODE  */
end_comment

begin_comment
comment|/*************HOLD THIS COMMENT FOR END OF PATCH FILE OF  *************ALTERNATE ROUTING CODE  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_generate_cause
parameter_list|(
name|uint16_t
name|code
parameter_list|,
name|char
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sctp_gen_error_cause
modifier|*
name|cause
decl_stmt|;
name|size_t
name|info_len
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|code
operator|==
literal|0
operator|)
operator|||
operator|(
name|info
operator|==
name|NULL
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|info_len
operator|=
name|strlen
argument_list|(
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|info_len
operator|>
operator|(
name|SCTP_MAX_CAUSE_LENGTH
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
call|(
name|uint16_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
name|info_len
argument_list|)
expr_stmt|;
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|len
expr_stmt|;
name|cause
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_gen_error_cause
operator|*
argument_list|)
expr_stmt|;
name|cause
operator|->
name|code
operator|=
name|htons
argument_list|(
name|code
argument_list|)
expr_stmt|;
name|cause
operator|->
name|length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cause
operator|->
name|info
argument_list|,
name|info
argument_list|,
name|info_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_generate_no_user_data_cause
parameter_list|(
name|uint32_t
name|tsn
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sctp_error_no_user_data
modifier|*
name|no_user_data_cause
decl_stmt|;
name|uint16_t
name|len
decl_stmt|;
name|len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_no_user_data
argument_list|)
expr_stmt|;
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|len
expr_stmt|;
name|no_user_data_cause
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_error_no_user_data
operator|*
argument_list|)
expr_stmt|;
name|no_user_data_cause
operator|->
name|cause
operator|.
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_NO_USER_DATA
argument_list|)
expr_stmt|;
name|no_user_data_cause
operator|->
name|cause
operator|.
name|length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|no_user_data_cause
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|tsn
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_MBCNT_LOGGING
end_ifdef

begin_function
name|void
name|sctp_free_bufspace
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
parameter_list|,
name|int
name|chk_cnt
parameter_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|->
name|chunks_on_out_queue
operator|-=
name|chk_cnt
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBCNT_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mbcnt
argument_list|(
name|SCTP_LOG_MBCNT_DECREASE
argument_list|,
name|asoc
operator|->
name|total_output_queue_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
literal|0
argument_list|,
name|tp1
operator|->
name|mbcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|total_output_queue_size
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|total_output_queue_size
argument_list|,
operator|-
name|tp1
operator|->
name|book_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|&&
operator|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_release_pr_sctp_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
parameter_list|,
name|uint8_t
name|sent
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|strq
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
init|=
name|NULL
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|uint32_t
name|mid
decl_stmt|;
name|uint16_t
name|sid
decl_stmt|;
name|uint8_t
name|foundeom
init|=
literal|0
decl_stmt|;
name|int
name|ret_sz
init|=
literal|0
decl_stmt|;
name|int
name|notdone
decl_stmt|;
name|int
name|do_wakeup_routine
init|=
literal|0
decl_stmt|;
name|sid
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
expr_stmt|;
name|mid
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
expr_stmt|;
if|if
condition|(
name|sent
operator|||
operator|!
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|abandoned_sent
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|abandoned_sent
index|[
name|PR_SCTP_POLICY
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
index|]
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|sid
index|]
operator|.
name|abandoned_sent
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_DETAILED_STR_STATS
argument_list|)
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|stream
index|]
operator|.
name|abandoned_sent
index|[
name|PR_SCTP_POLICY
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|abandoned_unsent
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|abandoned_unsent
index|[
name|PR_SCTP_POLICY
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
index|]
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|sid
index|]
operator|.
name|abandoned_unsent
index|[
literal|0
index|]
operator|++
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_DETAILED_STR_STATS
argument_list|)
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|stream
index|]
operator|.
name|abandoned_unsent
index|[
name|PR_SCTP_POLICY
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
index|]
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
do|do
block|{
name|ret_sz
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|tp1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_UNSENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|tp1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|do_wakeup_routine
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_FORWARD_TSN_SKIP
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
comment|/* not frag'ed we ae done   */
name|notdone
operator|=
literal|0
expr_stmt|;
name|foundeom
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* end of frag, we are done */
name|notdone
operator|=
literal|0
expr_stmt|;
name|foundeom
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Its a begin or middle piece, we must mark all of 			 * it 			 */
name|notdone
operator|=
literal|1
expr_stmt|;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|tp1
operator|&&
name|notdone
condition|)
do|;
if|if
condition|(
name|foundeom
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The multi-part message was scattered across the send and 		 * sent queue. 		 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|tp2
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
operator|!=
name|sid
operator|)
operator|||
operator|(
operator|!
name|SCTP_MID_EQ
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|idata_supported
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
argument_list|,
name|mid
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
comment|/* 			 * save to chk in case we have some on stream out 			 * queue. If so and we have an un-transmitted one we 			 * don't have to fudge the TSN. 			 */
name|chk
operator|=
name|tp1
expr_stmt|;
name|ret_sz
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sent
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|tp1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_UNSENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|tp1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* No flight involved here book the size to 0 */
name|tp1
operator|->
name|book_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|foundeom
operator|=
literal|1
expr_stmt|;
block|}
name|do_wakeup_routine
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|sent
operator|=
name|SCTP_FORWARD_TSN_SKIP
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 			 * on to the sent queue so we can wait for it to be 			 * passed by. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
operator|--
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|foundeom
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Still no eom found. That means there is stuff left on the 		 * stream out queue.. yuck. 		 */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|strq
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|sid
index|]
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|discard_rest
operator|=
literal|1
expr_stmt|;
comment|/* 			 * We may need to put a chunk on the queue that 			 * holds the TSN that would have been sent with the 			 * LAST bit. 			 */
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* Yep, we have to */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * we are hosed. All we can do is 					 * nothing.. which will cause an 					 * abort if the peer is paying 					 * attention. 					 */
goto|goto
name|oh_well
goto|;
block|}
name|memset
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chk
argument_list|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_FORWARD_TSN_SKIP
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|idata_supported
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
operator|=
name|strq
operator|->
name|next_mid_ordered
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
operator|=
name|strq
operator|->
name|next_mid_unordered
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
operator|=
name|strq
operator|->
name|next_mid_ordered
expr_stmt|;
block|}
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
operator|=
name|sp
operator|->
name|sid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
name|sp
operator|->
name|act_flags
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strq
operator|->
name|chunks_on_queues
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|pr_sctp_cnt
operator|++
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator||=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator||=
name|SCTP_DATA_UNORDERED
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|idata_supported
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|strq
operator|->
name|next_mid_ordered
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|strq
operator|->
name|next_mid_unordered
operator|++
expr_stmt|;
block|}
else|else
block|{
name|strq
operator|->
name|next_mid_ordered
operator|++
expr_stmt|;
block|}
block|}
name|oh_well
label|:
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
comment|/* 				 * Pull any data to free up the SB and allow 				 * sender to "add more" while we will throw 				 * away :-) 				 */
name|sctp_free_spbufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|ret_sz
operator|+=
name|sp
operator|->
name|length
expr_stmt|;
name|do_wakeup_routine
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_wakeup_routine
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_sz
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|sctp_sowwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|ret_sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * checks to see if the given address, sa, is one that is currently known by  * the kernel note: can't distinguish the same address on multiple interfaces  * and doesn't handle multiple addresses with different zone/scope id's note:  * ifa_ifwithaddr() compares the entire sockaddr struct  */
end_comment

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_find_ifa_in_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|holds_lock
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|!=
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|laddr
operator|->
name|ifa
operator|)
return|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
argument_list|)
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|laddr
operator|->
name|ifa
operator|)
return|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_get_ifa_hash_val
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|^
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|16
operator|)
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|uint32_t
name|hash_of_addr
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
name|hash_of_addr
operator|=
operator|(
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|0
index|]
operator|+
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|1
index|]
operator|+
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|+
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|hash_of_addr
operator|=
operator|(
name|hash_of_addr
operator|^
operator|(
name|hash_of_addr
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|hash_of_addr
operator|)
return|;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_find_ifa_by_addr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
name|holds_lock
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifalist
modifier|*
name|hash_head
decl_stmt|;
name|uint32_t
name|hash_of_addr
decl_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hash_of_addr
operator|=
name|sctp_get_ifa_hash_val
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|hash_head
operator|=
operator|&
name|vrf
operator|->
name|vrf_addr_hash
index|[
operator|(
name|hash_of_addr
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|hash_head
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"hash_of_addr:%x mask:%x table:%x - "
argument_list|,
name|hash_of_addr
argument_list|,
operator|(
name|uint32_t
operator|)
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|hash_of_addr
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"No such bucket for address\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|hash_head
argument_list|,
argument|next_bucket
argument_list|)
block|{
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|!=
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sctp_ifap
operator|)
return|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
argument_list|)
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sctp_ifap
operator|)
return|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_user_rcvd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
modifier|*
name|freed_so_far
parameter_list|,
name|int
name|hold_rlock
parameter_list|,
name|uint32_t
name|rwnd_req
parameter_list|)
block|{
comment|/* User pulled some data, do we need a rwnd update? */
name|int
name|r_unlocked
init|=
literal|0
decl_stmt|;
name|uint32_t
name|dif
decl_stmt|,
name|rwnd
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
operator|(
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator||
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator||
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* Pre-check If we are freeing no update */
goto|goto
name|no_lock
goto|;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|so
operator|=
name|stcb
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|freed_by_sorcv_sincelast
argument_list|,
operator|*
name|freed_so_far
argument_list|)
expr_stmt|;
comment|/* Have you have freed enough to look */
operator|*
name|freed_so_far
operator|=
literal|0
expr_stmt|;
comment|/* Yep, its worth a look and the lock overhead */
comment|/* Figure out what the rwnd would be */
name|rwnd
operator|=
name|sctp_calc_rwnd
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwnd
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|my_last_reported_rwnd
condition|)
block|{
name|dif
operator|=
name|rwnd
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|my_last_reported_rwnd
expr_stmt|;
block|}
else|else
block|{
name|dif
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dif
operator|>=
name|rwnd_req
condition|)
block|{
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|r_unlocked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* 			 * One last check before we allow the guy possibly 			 * to get in. There is a race, where the guy has not 			 * reached the gate. In that case 			 */
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* No reports here */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_wu_sacks_sent
argument_list|)
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_RCVD
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
comment|/* make sure no timer is running */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update how much we have pending */
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
name|dif
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|so
operator|&&
name|r_unlocked
operator|&&
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|no_lock
label|:
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|sctp_sorecvmsg
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|int
name|fromlen
parameter_list|,
name|int
modifier|*
name|msg_flags
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sinfo
parameter_list|,
name|int
name|filling_sinfo
parameter_list|)
block|{
comment|/* 	 * MSG flags we will look at MSG_DONTWAIT - non-blocking IO. 	 * MSG_PEEK - Look don't touch :-D (only valid with OUT mbuf copy 	 * mp=NULL thus uio is the copy method to userland) MSG_WAITALL - ?? 	 * On the way out we may send out any combination of: 	 * MSG_NOTIFICATION MSG_EOR 	 * 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|int
name|my_len
init|=
literal|0
decl_stmt|;
name|int
name|cp_len
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
init|=
name|NULL
decl_stmt|,
modifier|*
name|ctl
init|=
name|NULL
decl_stmt|,
modifier|*
name|nxt
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|int
name|wakeup_read_socket
init|=
literal|0
decl_stmt|;
name|int
name|freecnt_applied
init|=
literal|0
decl_stmt|;
name|int
name|out_flags
init|=
literal|0
decl_stmt|,
name|in_flags
init|=
literal|0
decl_stmt|;
name|int
name|block_allowed
init|=
literal|1
decl_stmt|;
name|uint32_t
name|freed_so_far
init|=
literal|0
decl_stmt|;
name|uint32_t
name|copied_so_far
init|=
literal|0
decl_stmt|;
name|int
name|in_eeor_mode
init|=
literal|0
decl_stmt|;
name|int
name|no_rcv_needed
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rwnd_req
init|=
literal|0
decl_stmt|;
name|int
name|hold_sblock
init|=
literal|0
decl_stmt|;
name|int
name|hold_rlock
init|=
literal|0
decl_stmt|;
name|ssize_t
name|slen
init|=
literal|0
decl_stmt|;
name|uint32_t
name|held_length
init|=
literal|0
decl_stmt|;
name|int
name|sockbuf_lock
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msg_flags
condition|)
block|{
name|in_flags
operator|=
operator|*
name|msg_flags
expr_stmt|;
if|if
condition|(
name|in_flags
operator|&
name|MSG_PEEK
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_read_peeks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in_flags
operator|=
literal|0
expr_stmt|;
block|}
name|slen
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* Pull in and set up our int flags */
if|if
condition|(
name|in_flags
operator|&
name|MSG_OOB
condition|)
block|{
comment|/* Out of band's NOT supported */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|&&
operator|(
name|mp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|||
name|SCTP_SO_IS_NBIO
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|block_allowed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* setup the endpoint */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|rwnd_req
operator|=
operator|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
operator|>>
name|SCTP_RWND_HIWAT_SHIFT
operator|)
expr_stmt|;
comment|/* Must be at least a MTU's worth */
if|if
condition|(
name|rwnd_req
operator|<
name|SCTP_MIN_RWND
condition|)
name|rwnd_req
operator|=
name|SCTP_MIN_RWND
expr_stmt|;
name|in_eeor_mode
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RECV_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_ENTER
argument_list|,
name|rwnd_req
argument_list|,
name|in_eeor_mode
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
operator|(
name|uint32_t
operator|)
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RECV_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_ENTERPL
argument_list|,
name|rwnd_req
argument_list|,
name|block_allowed
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
operator|(
name|uint32_t
operator|)
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
name|block_allowed
condition|?
name|SBL_WAIT
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|release_unlocked
goto|;
block|}
name|sockbuf_lock
operator|=
literal|1
expr_stmt|;
name|restart
label|:
name|restart_nosblocks
label|:
if|if
condition|(
name|hold_sblock
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
comment|/* indicate EOF */
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|<=
name|held_length
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * For active open side clear flags for 				 * re-use passive open is blocked by 				 * connect. 				 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAS_ABORTED
condition|)
block|{
comment|/* 					 * You were aborted, passive side 					 * always hits here 					 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator||
name|SS_ISCONNECTED
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|block_allowed
condition|)
block|{
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|held_length
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart_nosblocks
goto|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|hold_sblock
operator|==
literal|1
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* we possibly have data we can read */
comment|/* sa_ignore FREED_MEMORY */
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This could be happening since the appender did the 		 * increment but as not yet did the tailq insert onto the 		 * read_queue 		 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh, its non zero and nothing on control?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|)
condition|)
block|{
comment|/* 		 * Clean up code for freeing assoc that left behind a 		 * pdapi.. maybe a peer in EEOR that just closed after 		 * sending and never indicated a EOR. 		 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|hold_rlock
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
comment|/* Hmm there is data here .. fix */
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|m_tmp
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m_tmp
condition|)
block|{
name|cnt
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|m_tmp
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
block|}
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|length
operator|=
name|cnt
expr_stmt|;
block|}
else|else
block|{
comment|/* remove it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Add back any hiddend data */
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|hold_rlock
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|end_added
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Do we also need to check for (control->pdapi_aborted == 		 * 1)? 		 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|hold_rlock
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"control->data not null but control->length == 0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Strange, data left in the control buffer. Cleaning up.\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|control
operator|->
name|aux_data
condition|)
block|{
name|sctp_m_free
argument_list|(
name|control
operator|->
name|aux_data
argument_list|)
expr_stmt|;
name|control
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|panic
argument_list|(
literal|"About to free ctl:%p so:%p and its in %d"
argument_list|,
name|control
argument_list|,
name|so
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|hold_rlock
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|control
operator|->
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
operator|)
operator|&&
operator|(
name|filling_sinfo
operator|)
condition|)
block|{
comment|/* find a more suitable one then this */
name|ctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
if|if
condition|(
operator|(
name|ctl
operator|->
name|stcb
operator|!=
name|control
operator|->
name|stcb
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|length
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|some_taken
operator|||
operator|(
name|ctl
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|||
operator|(
operator|(
name|ctl
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|ctl
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*- 					 * If we have a different TCB next, and there is data 					 * present. If we have already taken some (pdapi), OR we can 					 * ref the tcb and no delivery as started on this stream, we 					 * take it. Note we allow a notification on a different 					 * assoc to be delivered.. 					 */
name|control
operator|=
name|ctl
expr_stmt|;
goto|goto
name|found_one
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|length
operator|)
operator|&&
operator|(
operator|(
name|ctl
operator|->
name|some_taken
operator|)
operator|||
operator|(
operator|(
name|ctl
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ctl
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|ctl
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*- 					 * If we have the same tcb, and there is data present, and we 					 * have the strm interleave feature present. Then if we have 					 * taken some (pdapi) or we can refer to tht tcb AND we have 					 * not started a delivery for this stream, we can take it. 					 * Note we do NOT allow a notificaiton on the same assoc to 					 * be delivered. 					 */
name|control
operator|=
name|ctl
expr_stmt|;
goto|goto
name|found_one
goto|;
block|}
name|ctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * if we reach here, not suitable replacement is available 		 *<or> fragment interleave is NOT on. So stuff the sb_cc 		 * into the our held count, and its time to sleep again. 		 */
name|held_length
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Clear the held length since there is something to read */
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|found_one
label|:
comment|/* 	 * If we reach here, control has a some data for us to read off. 	 * Note that stcb COULD be NULL. 	 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|hold_rlock
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|some_taken
operator|++
expr_stmt|;
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
condition|)
block|{
if|if
condition|(
name|freecnt_applied
operator|==
literal|0
condition|)
name|stcb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
condition|)
block|{
comment|/* you can't free it on me please */
comment|/* 			 * The lock on the socket buffer protects us so the 			 * free code will stop. But since we used the 			 * socketbuf lock and the sender uses the tcb_lock 			 * to increment, we need to use the atomic add to 			 * the refcnt 			 */
if|if
condition|(
name|freecnt_applied
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"refcnt already incremented"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"refcnt already incremented?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|freecnt_applied
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Setup to remember how much we have not yet told 			 * the peer our rwnd has opened up. Note we grab the 			 * value from the tcb from last time. Note too that 			 * sack sending clears this when a sack is sent, 			 * which is fine. Once we hit the rwnd_req, we then 			 * will go to the sctp_user_rcvd() that will not 			 * lock until it KNOWs it MUST send a WUP-SACK. 			 */
name|freed_so_far
operator|=
name|stcb
operator|->
name|freed_by_sorcv_sincelast
expr_stmt|;
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
operator|&&
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|1
expr_stmt|;
block|}
comment|/* First lets get off the sinfo and sockaddr info */
if|if
condition|(
operator|(
name|sinfo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|filling_sinfo
operator|!=
literal|0
operator|)
condition|)
block|{
name|sinfo
operator|->
name|sinfo_stream
operator|=
name|control
operator|->
name|sinfo_stream
expr_stmt|;
name|sinfo
operator|->
name|sinfo_ssn
operator|=
operator|(
name|uint16_t
operator|)
name|control
operator|->
name|mid
expr_stmt|;
name|sinfo
operator|->
name|sinfo_flags
operator|=
name|control
operator|->
name|sinfo_flags
expr_stmt|;
name|sinfo
operator|->
name|sinfo_ppid
operator|=
name|control
operator|->
name|sinfo_ppid
expr_stmt|;
name|sinfo
operator|->
name|sinfo_context
operator|=
name|control
operator|->
name|sinfo_context
expr_stmt|;
name|sinfo
operator|->
name|sinfo_timetolive
operator|=
name|control
operator|->
name|sinfo_timetolive
expr_stmt|;
name|sinfo
operator|->
name|sinfo_tsn
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|sinfo
operator|->
name|sinfo_cumtsn
operator|=
name|control
operator|->
name|sinfo_cumtsn
expr_stmt|;
name|sinfo
operator|->
name|sinfo_assoc_id
operator|=
name|control
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|nxt
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
operator|||
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
condition|)
block|{
name|struct
name|sctp_extrcvinfo
modifier|*
name|s_extra
decl_stmt|;
name|s_extra
operator|=
operator|(
expr|struct
name|sctp_extrcvinfo
operator|*
operator|)
name|sinfo
expr_stmt|;
if|if
condition|(
operator|(
name|nxt
operator|)
operator|&&
operator|(
name|nxt
operator|->
name|length
operator|)
condition|)
block|{
name|s_extra
operator|->
name|serinfo_next_flags
operator|=
name|SCTP_NEXT_MSG_AVAIL
expr_stmt|;
if|if
condition|(
name|nxt
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|s_extra
operator|->
name|serinfo_next_flags
operator||=
name|SCTP_NEXT_MSG_IS_UNORDERED
expr_stmt|;
block|}
if|if
condition|(
name|nxt
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|s_extra
operator|->
name|serinfo_next_flags
operator||=
name|SCTP_NEXT_MSG_IS_NOTIFICATION
expr_stmt|;
block|}
name|s_extra
operator|->
name|serinfo_next_aid
operator|=
name|nxt
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_length
operator|=
name|nxt
operator|->
name|length
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_ppid
operator|=
name|nxt
operator|->
name|sinfo_ppid
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_stream
operator|=
name|nxt
operator|->
name|sinfo_stream
expr_stmt|;
if|if
condition|(
name|nxt
operator|->
name|tail_mbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nxt
operator|->
name|end_added
condition|)
block|{
name|s_extra
operator|->
name|serinfo_next_flags
operator||=
name|SCTP_NEXT_MSG_ISCOMPLETE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 				 * we explicitly 0 this, since the memcpy 				 * got some other things beyond the older 				 * sinfo_ that is on the control's structure 				 * :-D 				 */
name|nxt
operator|=
name|NULL
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_flags
operator|=
name|SCTP_NO_NEXT_MSG
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_aid
operator|=
literal|0
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_length
operator|=
literal|0
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_ppid
operator|=
literal|0
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_stream
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * update off the real current cum-ack, if we have an stcb. 		 */
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
name|stcb
condition|)
name|sinfo
operator|->
name|sinfo_cumtsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
comment|/* 		 * mask off the high bits, we keep the actual chunk bits in 		 * there. 		 */
name|sinfo
operator|->
name|sinfo_flags
operator|&=
literal|0x00ff
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
name|sinfo
operator|->
name|sinfo_flags
operator||=
name|SCTP_UNORDERED
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
block|{
name|int
name|index
decl_stmt|,
name|newindex
decl_stmt|;
name|struct
name|sctp_pcbtsn_rlog
modifier|*
name|entry
decl_stmt|;
do|do
block|{
name|index
operator|=
name|inp
operator|->
name|readlog_index
expr_stmt|;
name|newindex
operator|=
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newindex
operator|>=
name|SCTP_READ_LOG_SIZE
condition|)
block|{
name|newindex
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|readlog_index
argument_list|,
name|index
argument_list|,
name|newindex
argument_list|)
operator|==
literal|0
condition|)
do|;
name|entry
operator|=
operator|&
name|inp
operator|->
name|readlog
index|[
name|index
index|]
expr_stmt|;
name|entry
operator|->
name|vtag
operator|=
name|control
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|entry
operator|->
name|strm
operator|=
name|control
operator|->
name|sinfo_stream
expr_stmt|;
name|entry
operator|->
name|seq
operator|=
operator|(
name|uint16_t
operator|)
name|control
operator|->
name|mid
expr_stmt|;
name|entry
operator|->
name|sz
operator|=
name|control
operator|->
name|length
expr_stmt|;
name|entry
operator|->
name|flgs
operator|=
name|control
operator|->
name|sinfo_flags
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|fromlen
operator|>
literal|0
operator|)
operator|&&
operator|(
name|from
operator|!=
name|NULL
operator|)
condition|)
block|{
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin6
operator|=
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|in6_sin_2_v4mapsin6
argument_list|(
operator|&
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
argument_list|,
operator|&
name|store
operator|.
name|sin6
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin
operator|=
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
block|}
else|#
directive|else
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin
operator|=
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
endif|#
directive|endif
break|break;
endif|#
directive|endif
default|default:
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|from
argument_list|,
operator|&
name|store
argument_list|,
name|min
argument_list|(
operator|(
name|size_t
operator|)
name|fromlen
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|{
name|struct
name|sockaddr_in6
name|lsa6
decl_stmt|,
modifier|*
name|from6
decl_stmt|;
name|from6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|from
expr_stmt|;
name|sctp_recover_scope_mac
argument_list|(
name|from6
argument_list|,
operator|(
operator|&
name|lsa6
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now copy out what data we can */
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/* copy out each mbuf in the chain up to length */
name|get_more_data
label|:
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
comment|/* Move out all we can */
name|cp_len
operator|=
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|my_len
operator|=
operator|(
name|int
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_len
operator|>
name|my_len
condition|)
block|{
comment|/* not enough in this buf */
name|cp_len
operator|=
name|my_len
expr_stmt|;
block|}
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp_len
operator|>
literal|0
condition|)
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|cp_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* re-read */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
name|stcb
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|no_rcv_needed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* error we are out of here */
goto|goto
name|release
goto|;
block|}
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cp_len
operator|==
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|control
operator|->
name|end_added
operator|)
condition|)
block|{
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|out_flags
operator||=
name|MSG_NOTIFICATION
expr_stmt|;
block|}
comment|/* we ate up the mbuf */
if|if
condition|(
name|in_flags
operator|&
name|MSG_PEEK
condition|)
block|{
comment|/* just looking */
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
block|}
else|else
block|{
comment|/* dispose of the mbuf */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sbfree
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|MSIZE
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
comment|/* 					 * been through it all, must hold sb 					 * lock ok to null tail 					 */
if|if
condition|(
name|control
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|control
operator|->
name|end_added
operator|==
literal|0
operator|)
operator|||
operator|(
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 							 * If the end is not 							 * added, OR the 							 * next is NOT null 							 * we MUST have the 							 * lock. 							 */
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|inp
operator|->
name|inp_rdata_mtx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Hmm we don't own the lock?"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|control
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|control
operator|->
name|end_added
operator|)
operator|&&
operator|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"end_added, nothing left and no MSG_EOR"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
comment|/* Do we need to trim the mbuf? */
if|if
condition|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|out_flags
operator||=
name|MSG_NOTIFICATION
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_BUF_RESV_UF
argument_list|(
name|m
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|-=
name|cp_len
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
name|stcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
block|}
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|MSIZE
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
condition|)
block|{
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end while(m) */
comment|/* 		 * At this point we have looked at it all and we either have 		 * a MSG_EOR/or read all the user wants...<OR> 		 * control->length == 0. 		 */
if|if
condition|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|&&
operator|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we are done with this control */
if|if
condition|(
name|control
operator|->
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"control->data not null at read eor?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Strange, data left in the control buffer .. invarients would panic?\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|done_with_control
label|:
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Add back any hiddend data */
if|if
condition|(
name|control
operator|->
name|held_length
condition|)
block|{
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|wakeup_read_socket
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|aux_data
condition|)
block|{
name|sctp_m_free
argument_list|(
name|control
operator|->
name|aux_data
argument_list|)
expr_stmt|;
name|control
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
block|}
name|no_rcv_needed
operator|=
name|control
operator|->
name|do_not_ref_stcb
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|panic
argument_list|(
literal|"About to free ctl:%p so:%p and its in %d"
argument_list|,
name|control
argument_list|,
name|so
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
operator|&&
operator|(
name|no_rcv_needed
operator|==
literal|0
operator|)
condition|)
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The user did not read all of this 				 * message, turn off the returned MSG_EOR 				 * since we are leaving more behind on the 				 * control to read. 				 */
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|end_added
operator|&&
operator|(
name|control
operator|->
name|data
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|control
operator|->
name|tail_mbuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Gak, control->length is corrupt?"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|no_rcv_needed
operator|=
name|control
operator|->
name|do_not_ref_stcb
expr_stmt|;
name|out_flags
operator|&=
operator|~
name|MSG_EOR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out_flags
operator|&
name|MSG_EOR
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|in_eeor_mode
operator|)
operator|&&
operator|(
name|copied_so_far
operator|>=
operator|(
name|uint32_t
operator|)
name|max
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
goto|goto
name|release
goto|;
block|}
comment|/* 		 * If I hit here the receiver wants more and this message is 		 * NOT done (pd-api). So two questions. Can we block? if not 		 * we are done. Did the user NOT set MSG_WAITALL? 		 */
if|if
condition|(
name|block_allowed
operator|==
literal|0
condition|)
block|{
goto|goto
name|release
goto|;
block|}
comment|/* 		 * We need to wait for more data a few things: - We don't 		 * sbunlock() so we don't get someone else reading. - We 		 * must be sure to account for the case where what is added 		 * is NOT to our control when we wakeup. 		 */
comment|/* 		 * Do we need to tell the transport a rwnd update might be 		 * needed before we go to sleep? 		 */
if|if
condition|(
operator|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|no_rcv_needed
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
name|wait_some_more
label|:
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
goto|goto
name|release
goto|;
if|if
condition|(
name|hold_rlock
operator|==
literal|1
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|copied_so_far
operator|)
operator|&&
operator|(
name|control
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|<=
name|control
operator|->
name|held_length
condition|)
block|{
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|release
goto|;
block|}
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|length
operator|==
literal|0
condition|)
block|{
comment|/* still nothing here */
if|if
condition|(
name|control
operator|->
name|end_added
operator|==
literal|1
condition|)
block|{
comment|/* he aborted, or is done i.e.did a shutdown */
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|pdapi_aborted
condition|)
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
name|out_flags
operator||=
name|MSG_TRUNC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|done_with_control
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
name|held_length
condition|)
block|{
name|control
operator|->
name|held_length
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|held_length
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|wait_some_more
goto|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * we must re-sync since data is probably being 			 * added 			 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|data
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 				 * big trouble.. we have the lock and its 				 * corrupt? 				 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Impossible data==NULL length !=0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
name|out_flags
operator||=
name|MSG_TRUNC
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done_with_control
goto|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* We will fall around to get more data */
block|}
goto|goto
name|get_more_data
goto|;
block|}
else|else
block|{
comment|/*- 		 * Give caller back the mbuf chain, 		 * store in uio_resid the length 		 */
name|wakeup_read_socket
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|end_added
operator|==
literal|0
operator|)
operator|||
operator|(
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Need to get rlock */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|out_flags
operator||=
name|MSG_NOTIFICATION
expr_stmt|;
block|}
name|uio
operator|->
name|uio_resid
operator|=
name|control
operator|->
name|length
expr_stmt|;
operator|*
name|mp
operator|=
name|control
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sbfree
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|freed_so_far
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|freed_so_far
operator|+=
name|MSIZE
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|data
operator|=
name|control
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|out_flags
operator|&
name|MSG_EOR
condition|)
block|{
comment|/* Done with this control */
goto|goto
name|done_with_control
goto|;
block|}
block|}
name|release
label|:
if|if
condition|(
name|hold_rlock
operator|==
literal|1
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
operator|==
literal|1
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sockbuf_lock
operator|=
literal|0
expr_stmt|;
name|release_unlocked
label|:
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
operator|&&
operator|(
name|control
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|no_rcv_needed
operator|==
literal|0
operator|)
condition|)
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|msg_flags
condition|)
block|{
operator|*
name|msg_flags
operator|=
name|out_flags
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sinfo
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
operator|||
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
operator|)
condition|)
block|{
name|struct
name|sctp_extrcvinfo
modifier|*
name|s_extra
decl_stmt|;
name|s_extra
operator|=
operator|(
expr|struct
name|sctp_extrcvinfo
operator|*
operator|)
name|sinfo
expr_stmt|;
name|s_extra
operator|->
name|serinfo_next_flags
operator|=
name|SCTP_NO_NEXT_MSG
expr_stmt|;
block|}
if|if
condition|(
name|hold_rlock
operator|==
literal|1
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sockbuf_lock
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freecnt_applied
condition|)
block|{
comment|/* 		 * The lock on the socket buffer protects us so the free 		 * code will stop. But since we used the socketbuf lock and 		 * the sender uses the tcb_lock to increment, we need to use 		 * the atomic add to the refcnt. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"stcb for refcnt has gone NULL?"
argument_list|)
expr_stmt|;
goto|goto
name|stage_left
goto|;
else|#
directive|else
goto|goto
name|stage_left
goto|;
endif|#
directive|endif
block|}
comment|/* Save the value back for next time */
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
name|freed_so_far
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RECV_RWND_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_DONE
argument_list|,
name|freed_so_far
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uio
operator|)
condition|?
operator|(
name|slen
operator|-
name|uio
operator|->
name|uio_resid
operator|)
else|:
name|slen
argument_list|)
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_DONE
argument_list|,
name|freed_so_far
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|uio
operator|)
condition|?
operator|(
name|slen
operator|-
name|uio
operator|->
name|uio_resid
operator|)
else|:
name|slen
argument_list|)
argument_list|,
literal|0
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
block|}
name|stage_left
label|:
if|if
condition|(
name|wakeup_read_socket
condition|)
block|{
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
end_ifdef

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_m_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|m
argument_list|,
name|SCTP_MBUF_IFREE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_free
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_m_freem
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
while|while
condition|(
name|mb
operator|!=
name|NULL
condition|)
name|mb
operator|=
name|sctp_m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_dynamic_set_primary
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/* 	 * Given a local address. For all associations that holds the 	 * address, request a peer-set-primary. 	 */
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|,
name|vrf_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EADDRNOTAVAIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
comment|/* 	 * Now that we have the ifa we must awaken the iterator with this 	 * message. 	 */
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Now incr the count and int wi structure */
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|wi
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|SCTP_SET_PRIM_ADDR
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now add it to the work queue */
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Should this really be a tailq? As it is we will process the 	 * newest first :-0 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq
argument_list|)
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fromlen
decl_stmt|;
name|uint8_t
name|sockbuf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
name|struct
name|sctp_extrcvinfo
name|sinfo
decl_stmt|;
name|int
name|filling_sinfo
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
comment|/* pickup the assoc we are reading from */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
operator|&&
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
operator|&&
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
operator|)
operator|||
operator|(
name|controlp
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* user does not want the sndrcv ctl */
name|filling_sinfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|psa
condition|)
block|{
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sockbuf
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|sockbuf
argument_list|)
expr_stmt|;
name|from
operator|->
name|sa_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|NULL
expr_stmt|;
name|fromlen
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|filling_sinfo
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sctp_sorecvmsg
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|from
argument_list|,
name|fromlen
argument_list|,
name|flagsp
argument_list|,
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|sinfo
argument_list|,
name|filling_sinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlp
operator|!=
name|NULL
condition|)
block|{
comment|/* copy back the sinfo in a CMSG format */
if|if
condition|(
name|filling_sinfo
condition|)
operator|*
name|controlp
operator|=
name|sctp_build_ctl_nchunk
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|sinfo
argument_list|)
expr_stmt|;
else|else
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|psa
condition|)
block|{
comment|/* copy back the address info */
if|if
condition|(
name|from
operator|&&
name|from
operator|->
name|sa_len
condition|)
block|{
operator|*
name|psa
operator|=
name|sodupsockaddr
argument_list|(
name|from
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_connectx_helper_add
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|totaddr
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|size_t
name|incr
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
name|sa
operator|=
name|addr
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totaddr
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
comment|/* assoc gone no un-lock */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|added
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
comment|/* assoc gone no un-lock */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|added
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
name|incr
operator|)
expr_stmt|;
block|}
name|out_now
label|:
return|return
operator|(
name|added
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_connectx_helper_find
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|unsigned
name|int
modifier|*
name|totaddr
parameter_list|,
name|unsigned
name|int
modifier|*
name|num_v4
parameter_list|,
name|unsigned
name|int
modifier|*
name|num_v6
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|unsigned
name|int
name|limit
parameter_list|,
name|int
modifier|*
name|bad_addr
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|unsigned
name|int
name|incr
decl_stmt|,
name|at
decl_stmt|,
name|i
decl_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
name|sa
operator|=
name|addr
expr_stmt|;
operator|*
name|error
operator|=
operator|*
name|num_v6
operator|=
operator|*
name|num_v4
operator|=
literal|0
expr_stmt|;
comment|/* account and validate addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|totaddr
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|incr
operator|=
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
name|incr
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|bad_addr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
operator|*
name|num_v4
operator|)
operator|+=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Must be non-mapped for connectx */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|bad_addr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|incr
operator|=
operator|(
name|unsigned
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
name|incr
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|bad_addr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
operator|*
name|num_v6
operator|)
operator|+=
literal|1
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
operator|*
name|totaddr
operator|=
name|i
expr_stmt|;
name|incr
operator|=
literal|0
expr_stmt|;
comment|/* we are done */
break|break;
block|}
if|if
condition|(
name|i
operator|==
operator|*
name|totaddr
condition|)
block|{
break|break;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|at
operator|+
name|incr
operator|)
operator|>
name|limit
condition|)
block|{
operator|*
name|totaddr
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
name|incr
operator|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sctp_bindx(ADD) for one address.  * assumes all arguments are valid/checked by caller.  */
end_comment

begin_function
name|void
name|sctp_bindx_add_address
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|sctp_assoc_t
name|assoc_id
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr_touse
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
comment|/* see if we're bound all already! */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|addr_touse
operator|=
name|sa
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* can only bind v6 on PF_INET6 sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|INET
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_touse
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind v4-mapped on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind v4 on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Can't get proc for Net/Open BSD */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
operator|*
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr_touse
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * No locks required here since bind and mgmt_ep_sa all do their own 	 * locking. If we do something for the FIX: below we may need to 	 * lock in that case. 	 */
if|if
condition|(
name|assoc_id
operator|==
literal|0
condition|)
block|{
comment|/* add the address */
name|struct
name|sctp_inpcb
modifier|*
name|lep
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|lsin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_touse
decl_stmt|;
comment|/* validate the incoming port */
if|if
condition|(
operator|(
name|lsin
operator|->
name|sin_port
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lsin
operator|->
name|sin_port
operator|!=
name|inp
operator|->
name|sctp_lport
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* user specified 0 port, set it to existing port */
name|lsin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
block|}
name|lep
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr_touse
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lep
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We must decrement the refcount since we have the 			 * ep already and are binding. No remove going on 			 * here. 			 */
name|SCTP_INP_DECR_REF
argument_list|(
name|lep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lep
operator|==
name|inp
condition|)
block|{
comment|/* already bound to it.. ok */
return|return;
block|}
elseif|else
if|if
condition|(
name|lep
operator|==
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_touse
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
operator|*
name|error
operator|=
name|sctp_addr_mgmt_ep_sa
argument_list|(
name|inp
argument_list|,
name|addr_touse
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|,
name|vrf_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|error
condition|)
return|return;
block|}
else|else
block|{
comment|/* 		 * FIX: decide whether we allow assoc based bindx 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * sctp_bindx(DELETE) for one address.  * assumes all arguments are valid/checked by caller.  */
end_comment

begin_function
name|void
name|sctp_bindx_delete_address
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|sctp_assoc_t
name|assoc_id
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr_touse
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
comment|/* see if we're bound all already! */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|addr_touse
operator|=
name|sa
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* can only bind v6 on PF_INET6 sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|INET
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_touse
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind mapped-v4 on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind v4 on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * No lock required mgmt_ep_sa does its own locking. If the FIX: 	 * below is ever changed we may need to lock before calling 	 * association level binding. 	 */
if|if
condition|(
name|assoc_id
operator|==
literal|0
condition|)
block|{
comment|/* delete the address */
operator|*
name|error
operator|=
name|sctp_addr_mgmt_ep_sa
argument_list|(
name|inp
argument_list|,
name|addr_touse
argument_list|,
name|SCTP_DEL_IP_ADDRESS
argument_list|,
name|vrf_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * FIX: decide whether we allow assoc based bindx 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * returns the valid local address count for an assoc, taking into account  * all scoping rules  */
end_comment

begin_function
name|int
name|sctp_local_addr_count
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|int
name|loopback_scope
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
name|int
name|ipv4_local_scope
decl_stmt|,
name|ipv4_addr_legal
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
name|int
name|local_scope
decl_stmt|,
name|site_scope
decl_stmt|,
name|ipv6_addr_legal
decl_stmt|;
endif|#
directive|endif
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Turn on all the appropriate scopes */
name|loopback_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|loopback_scope
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
name|ipv4_local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
expr_stmt|;
name|ipv4_addr_legal
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_addr_legal
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
name|local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|local_scope
expr_stmt|;
name|site_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|site_scope
expr_stmt|;
name|ipv6_addr_legal
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv6_addr_legal
expr_stmt|;
endif|#
directive|endif
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
comment|/* no vrf, no addresses */
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* 		 * bound all case: go through all ifns on the vrf 		 */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* 							 * skip unspecified 							 * addrs 							 */
continue|continue;
block|}
if|if
condition|(
name|prison_check_ip4
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* count this one */
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|prison_check_ip6
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_scope
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|!=
literal|0
condition|)
comment|/* 									 * 									 * bad 									 * link 									 * 									 * local 									 * 									 * address 									 */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* count this one */
name|count
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * subset bound case 		 */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* count this one */
name|count
operator|++
expr_stmt|;
block|}
block|}
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SCTP_LOCAL_TRACE_BUF
argument_list|)
end_if

begin_function
name|void
name|sctp_log_trace
parameter_list|(
name|uint32_t
name|subsys
parameter_list|,
specifier|const
name|char
modifier|*
name|str
name|SCTP_UNUSED
parameter_list|,
name|uint32_t
name|a
parameter_list|,
name|uint32_t
name|b
parameter_list|,
name|uint32_t
name|c
parameter_list|,
name|uint32_t
name|d
parameter_list|,
name|uint32_t
name|e
parameter_list|,
name|uint32_t
name|f
parameter_list|)
block|{
name|uint32_t
name|saveindex
decl_stmt|,
name|newindex
decl_stmt|;
do|do
block|{
name|saveindex
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|saveindex
operator|>=
name|SCTP_MAX_LOGGING_SIZE
condition|)
block|{
name|newindex
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|newindex
operator|=
name|saveindex
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|index
argument_list|,
name|saveindex
argument_list|,
name|newindex
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|saveindex
operator|>=
name|SCTP_MAX_LOGGING_SIZE
condition|)
block|{
name|saveindex
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|timestamp
operator|=
name|SCTP_GET_CYCLECOUNT
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|subsys
operator|=
name|subsys
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|d
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|e
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sctp_recv_udp_tunneled_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
name|SCTP_UNUSED
parameter_list|,
name|void
modifier|*
name|ctx
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|sp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uhdr
decl_stmt|;
name|uint16_t
name|port
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't handle one that is not a pkt hdr */
goto|goto
name|out
goto|;
block|}
comment|/* Pull the src port */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|uhdr
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|iph
operator|+
name|off
operator|)
expr_stmt|;
name|port
operator|=
name|uhdr
operator|->
name|uh_sport
expr_stmt|;
comment|/* 	 * Split out the mbuf chain. Leave the IP header in m, place the 	 * rest in the sp. 	 */
name|sp
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* Gak, drop packet, we can't do a split */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sp
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
condition|)
block|{
comment|/* Gak, packet can't have an SCTP header in it - too small */
name|m_freem
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Now pull up the UDP header and SCTP header together */
name|sp
operator|=
name|m_pullup
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* Gak pullup failed */
goto|goto
name|out
goto|;
block|}
comment|/* Trim out the UDP header */
name|m_adj
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now reconstruct the mbuf chain */
for|for
control|(
name|last
operator|=
name|m
init|;
name|last
operator|->
name|m_next
condition|;
name|last
operator|=
name|last
operator|->
name|m_next
control|)
empty_stmt|;
name|last
operator|->
name|m_next
operator|=
name|sp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|sp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* 	 * The CSUM_DATA_VALID flags indicates that the HW checked the UDP 	 * checksum and it was valid. Since CSUM_DATA_VALID == 	 * CSUM_SCTP_VALID this would imply that the HW also verified the 	 * SCTP checksum. Therefore, clear the bit. 	 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_CRCOFFLOAD
argument_list|,
literal|"sctp_recv_udp_tunneled_packet(): Packet of length %d received on %s with csum_flags 0x%b.\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|if_name
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|CSUM_BITS
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
operator|~
name|CSUM_DATA_VALID
expr_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|IPVERSION
case|:
name|iph
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|iph
operator|->
name|ip_len
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_input_with_port
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_plen
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|sctp6_input_with_port
argument_list|(
operator|&
name|m
argument_list|,
operator|&
name|off
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
goto|goto
name|out
goto|;
break|break;
block|}
return|return;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|sctp_recv_icmp_tunneled_packet
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|vip
parameter_list|,
name|void
modifier|*
name|ctx
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|outer_ip
decl_stmt|,
modifier|*
name|inner_ip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|struct
name|icmp
modifier|*
name|icmp
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|ch
decl_stmt|;
name|struct
name|sockaddr_in
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|code
decl_stmt|;
name|inner_ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|vip
expr_stmt|;
name|icmp
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|inner_ip
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|)
expr_stmt|;
name|outer_ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|icmp
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|outer_ip
operator|->
name|ip_len
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
literal|8
operator|+
operator|(
name|inner_ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
literal|8
condition|)
block|{
return|return;
block|}
name|udp
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|inner_ip
operator|+
operator|(
name|inner_ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
name|udp
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|src
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|src
operator|.
name|sin_addr
operator|=
name|inner_ip
operator|->
name|ip_src
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|dst
operator|.
name|sin_addr
operator|=
name|inner_ip
operator|->
name|ip_dst
expr_stmt|;
comment|/* 	 * 'dst' holds the dest of the packet that failed to be sent. 'src' 	 * holds our local endpoint address. Thus we reverse the dst and the 	 * src in the lookup. 	 */
name|inp
operator|=
name|NULL
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|SCTP_DEFAULT_VRFID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Check the UDP port numbers */
if|if
condition|(
operator|(
name|udp
operator|->
name|uh_dport
operator|!=
name|net
operator|->
name|port
operator|)
operator|||
operator|(
name|udp
operator|->
name|uh_sport
operator|!=
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check the verification tag */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This must be the verification tag used for 			 * sending out packets. We don't consider packets 			 * reflecting the verification tag. 			 */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|outer_ip
operator|->
name|ip_len
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
literal|8
operator|+
operator|(
name|inner_ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
literal|8
operator|+
literal|20
condition|)
block|{
comment|/* 				 * In this case we can check if we got an 				 * INIT chunk and if the initiate tag 				 * matches. 				 */
name|ch
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
operator|(
name|sh
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|ch
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|type
operator|=
name|icmp
operator|->
name|icmp_type
expr_stmt|;
name|code
operator|=
name|icmp
operator|->
name|icmp_code
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|ICMP_UNREACH
operator|)
operator|&&
operator|(
name|code
operator|==
name|ICMP_UNREACH_PORT
operator|)
condition|)
block|{
name|code
operator|=
name|ICMP_UNREACH_PROTOCOL
expr_stmt|;
block|}
name|sctp_notify
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|ntohs
argument_list|(
name|inner_ip
operator|->
name|ip_len
argument_list|)
argument_list|,
operator|(
name|uint32_t
operator|)
name|ntohs
argument_list|(
name|icmp
operator|->
name|icmp_nextmtu
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|void
name|sctp_recv_icmp6_tunneled_packet
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|d
parameter_list|,
name|void
modifier|*
name|ctx
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|ip6ctlparam
modifier|*
name|ip6cp
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctphdr
name|sh
decl_stmt|;
name|struct
name|udphdr
name|udp
decl_stmt|;
name|struct
name|sockaddr_in6
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|uint8_t
name|type
decl_stmt|,
name|code
decl_stmt|;
name|ip6cp
operator|=
operator|(
expr|struct
name|ip6ctlparam
operator|*
operator|)
name|d
expr_stmt|;
comment|/* 	 * XXX: We assume that when IPV6 is non NULL, M and OFF are valid. 	 */
if|if
condition|(
name|ip6cp
operator|->
name|ip6c_m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
comment|/* 	 * Check if we can safely examine the ports and the verification tag 	 * of the SCTP common header. 	 */
if|if
condition|(
name|ip6cp
operator|->
name|ip6c_m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ip6cp
operator|->
name|ip6c_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* Copy out the UDP header. */
name|memset
argument_list|(
operator|&
name|udp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|ip6cp
operator|->
name|ip6c_m
argument_list|,
name|ip6cp
operator|->
name|ip6c_off
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|udp
argument_list|)
expr_stmt|;
comment|/* Copy out the port numbers and the verification tag. */
name|memset
argument_list|(
operator|&
name|sh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|ip6cp
operator|->
name|ip6c_m
argument_list|,
name|ip6cp
operator|->
name|ip6c_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sh
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|src
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|src
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin6_port
operator|=
name|sh
operator|.
name|src_port
expr_stmt|;
name|src
operator|.
name|sin6_addr
operator|=
name|ip6cp
operator|->
name|ip6c_ip6
operator|->
name|ip6_src
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|src
operator|.
name|sin6_addr
argument_list|,
name|ip6cp
operator|->
name|ip6c_m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
operator|&
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|dst
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin6_port
operator|=
name|sh
operator|.
name|dest_port
expr_stmt|;
name|dst
operator|.
name|sin6_addr
operator|=
name|ip6cp
operator|->
name|ip6c_ip6
operator|->
name|ip6_dst
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|dst
operator|.
name|sin6_addr
argument_list|,
name|ip6cp
operator|->
name|ip6c_m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
name|inp
operator|=
name|NULL
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|SCTP_DEFAULT_VRFID
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* Check the UDP port numbers */
if|if
condition|(
operator|(
name|udp
operator|.
name|uh_dport
operator|!=
name|net
operator|->
name|port
operator|)
operator|||
operator|(
name|udp
operator|.
name|uh_sport
operator|!=
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check the verification tag */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|.
name|v_tag
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * This must be the verification tag used for 			 * sending out packets. We don't consider packets 			 * reflecting the verification tag. 			 */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|.
name|v_tag
argument_list|)
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ip6cp
operator|->
name|ip6c_m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>=
name|ip6cp
operator|->
name|ip6c_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|sctp_init
argument_list|,
name|a_rwnd
argument_list|)
condition|)
block|{
comment|/* 				 * In this case we can check if we got an 				 * INIT chunk and if the initiate tag 				 * matches. 				 */
name|uint32_t
name|initiate_tag
decl_stmt|;
name|uint8_t
name|chunk_type
decl_stmt|;
name|m_copydata
argument_list|(
name|ip6cp
operator|->
name|ip6c_m
argument_list|,
name|ip6cp
operator|->
name|ip6c_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|chunk_type
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|ip6cp
operator|->
name|ip6c_m
argument_list|,
name|ip6cp
operator|->
name|ip6c_off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|initiate_tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|||
operator|(
name|ntohl
argument_list|(
name|initiate_tag
argument_list|)
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|type
operator|=
name|ip6cp
operator|->
name|ip6c_icmp6
operator|->
name|icmp6_type
expr_stmt|;
name|code
operator|=
name|ip6cp
operator|->
name|ip6c_icmp6
operator|->
name|icmp6_code
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|==
name|ICMP6_DST_UNREACH
operator|)
operator|&&
operator|(
name|code
operator|==
name|ICMP6_DST_UNREACH_NOPORT
operator|)
condition|)
block|{
name|type
operator|=
name|ICMP6_PARAM_PROB
expr_stmt|;
name|code
operator|=
name|ICMP6_PARAMPROB_NEXTHEADER
expr_stmt|;
block|}
name|sctp6_notify
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|ntohl
argument_list|(
name|ip6cp
operator|->
name|ip6c_icmp6
operator|->
name|icmp6_mtu
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* reduce inp's ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_over_udp_stop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * This function assumes sysctl caller holds sctp_sysctl_info_lock() 	 * for writting! 	 */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|soclose
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|soclose
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|sctp_over_udp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|uint16_t
name|port
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * This function assumes sysctl caller holds sctp_sysctl_info_lock() 	 * for writting! 	 */
name|port
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|port
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Must have a port set */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Already running -- must stop first */
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Already running -- must stop first */
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|ret
operator|=
name|socreate
argument_list|(
name|PF_INET
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|curthread
argument_list|)
operator|)
condition|)
block|{
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Call the special UDP hook. */
if|if
condition|(
operator|(
name|ret
operator|=
name|udp_set_kernel_tunneling
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
argument_list|,
name|sctp_recv_udp_tunneled_packet
argument_list|,
name|sctp_recv_icmp_tunneled_packet
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Ok, we have a socket, bind it to the port. */
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sobind
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|udp4_tun_socket
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|curthread
argument_list|)
operator|)
condition|)
block|{
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|ret
operator|=
name|socreate
argument_list|(
name|PF_INET6
argument_list|,
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|,
name|curthread
operator|->
name|td_ucred
argument_list|,
name|curthread
argument_list|)
operator|)
condition|)
block|{
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Call the special UDP hook. */
if|if
condition|(
operator|(
name|ret
operator|=
name|udp_set_kernel_tunneling
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
argument_list|,
name|sctp_recv_udp_tunneled_packet
argument_list|,
name|sctp_recv_icmp6_tunneled_packet
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Ok, we have a socket, bind it to the port. */
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|sobind
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|udp6_tun_socket
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|curthread
argument_list|)
operator|)
condition|)
block|{
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|||
name|defined
argument_list|(
name|INET
argument_list|)
end_if

begin_comment
comment|/*  * sctp_min_mtu ()returns the minimum of all non-zero arguments.  * If all arguments are zero, zero is returned.  */
end_comment

begin_function
name|uint32_t
name|sctp_min_mtu
parameter_list|(
name|uint32_t
name|mtu1
parameter_list|,
name|uint32_t
name|mtu2
parameter_list|,
name|uint32_t
name|mtu3
parameter_list|)
block|{
if|if
condition|(
name|mtu1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mtu2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mtu3
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|min
argument_list|(
name|mtu1
argument_list|,
name|min
argument_list|(
name|mtu2
argument_list|,
name|mtu3
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|min
argument_list|(
name|mtu1
argument_list|,
name|mtu2
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|mtu3
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|min
argument_list|(
name|mtu1
argument_list|,
name|mtu3
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|mtu1
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|mtu2
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mtu3
operator|>
literal|0
condition|)
block|{
return|return
operator|(
name|min
argument_list|(
name|mtu2
argument_list|,
name|mtu3
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|mtu2
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
name|mtu3
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_hc_set_mtu
parameter_list|(
name|union
name|sctp_sockstore
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|fibnum
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
block|{
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|inc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_conninfo
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|.
name|inc_fibnum
operator|=
name|fibnum
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|inc
operator|.
name|inc_faddr
operator|=
name|addr
operator|->
name|sin
operator|.
name|sin_addr
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|inc
operator|.
name|inc_flags
operator||=
name|INC_ISIPV6
expr_stmt|;
name|inc
operator|.
name|inc6_faddr
operator|=
name|addr
operator|->
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return;
block|}
name|tcp_hc_updatemtu
argument_list|(
operator|&
name|inc
argument_list|,
operator|(
name|u_long
operator|)
name|mtu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_hc_get_mtu
parameter_list|(
name|union
name|sctp_sockstore
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|fibnum
parameter_list|)
block|{
name|struct
name|in_conninfo
name|inc
decl_stmt|;
name|memset
argument_list|(
operator|&
name|inc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_conninfo
argument_list|)
argument_list|)
expr_stmt|;
name|inc
operator|.
name|inc_fibnum
operator|=
name|fibnum
expr_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|inc
operator|.
name|inc_faddr
operator|=
name|addr
operator|->
name|sin
operator|.
name|sin_addr
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|inc
operator|.
name|inc_flags
operator||=
name|INC_ISIPV6
expr_stmt|;
name|inc
operator|.
name|inc6_faddr
operator|=
name|addr
operator|->
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|uint32_t
operator|)
name|tcp_hc_getmtu
argument_list|(
operator|&
name|inc
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

