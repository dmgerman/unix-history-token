begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctputil.c,v 1.37 2005/03/07 23:26:09 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_comment
comment|/* for sctp_deliver_data() */
end_comment

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|KTR_SCTP
end_ifndef

begin_define
define|#
directive|define
name|KTR_SCTP
value|KTR_SUBSYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|sctp_cc_functions
name|sctp_cc_functions
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sctp_ss_functions
name|sctp_ss_functions
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_sblog
parameter_list|(
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|incr
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|stcb
operator|=
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|so_sbcc
operator|=
name|sb
operator|->
name|sb_cc
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|stcb_sbcc
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|stcb_sbcc
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sb
operator|.
name|incr
operator|=
name|incr
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_SB
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_closing
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int16_t
name|loc
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|inp
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|sctp_flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|state
operator|=
operator|(
name|uint16_t
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|state
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|stcb
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|state
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|close
operator|.
name|loc
operator|=
name|loc
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_CLOSE
argument_list|,
literal|0
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rto_logging
parameter_list|(
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rto
operator|.
name|net
operator|=
operator|(
name|void
operator|*
operator|)
name|net
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rto
operator|.
name|rtt
operator|=
name|net
operator|->
name|prev_rtt
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_RTT
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_strm_del_alt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint16_t
name|sseq
parameter_list|,
name|uint16_t
name|stream
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|stcb
operator|=
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_tsn
operator|=
name|tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_sseq
operator|=
name|sseq
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_tsn
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_sseq
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|strm
operator|=
name|stream
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_STRM
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_nagle_event
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|action
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|total_flight
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|total_in_queue
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|count_in_queue
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|nagle
operator|.
name|count_in_flight
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_NAGLE
argument_list|,
name|action
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_sack
parameter_list|(
name|uint32_t
name|old_cumack
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint16_t
name|gaps
parameter_list|,
name|uint16_t
name|dups
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|cumack
operator|=
name|cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|oldcumack
operator|=
name|old_cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|numGaps
operator|=
name|gaps
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|sack
operator|.
name|numDups
operator|=
name|dups
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_SACK
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_map
parameter_list|(
name|uint32_t
name|map
parameter_list|,
name|uint32_t
name|cum
parameter_list|,
name|uint32_t
name|high
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|map
operator|.
name|base
operator|=
name|map
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|map
operator|.
name|cum
operator|=
name|cum
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|map
operator|.
name|high
operator|=
name|high
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MAP
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_fr
parameter_list|(
name|uint32_t
name|biggest_tsn
parameter_list|,
name|uint32_t
name|biggest_new_tsn
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|fr
operator|.
name|largest_tsn
operator|=
name|biggest_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|fr
operator|.
name|largest_new_tsn
operator|=
name|biggest_new_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|fr
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_FR
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_mb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|mp
operator|=
name|m
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|mbuf_flags
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|SCTP_BUF_GET_FLAGS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|data
operator|=
name|SCTP_BUF_AT
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|ext
operator|=
name|SCTP_BUF_EXTEND_BASE
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|refcnt
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|SCTP_BUF_EXTEND_REFCNT
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|ext
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mb
operator|.
name|refcnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MBUF
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_strm_del
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|poschk
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Gak log of NULL?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_tsn
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|n_sseq
operator|=
name|control
operator|->
name|sinfo_ssn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|strm
operator|=
name|control
operator|->
name|sinfo_stream
expr_stmt|;
if|if
condition|(
name|poschk
operator|!=
name|NULL
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_tsn
operator|=
name|poschk
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_sseq
operator|=
name|poschk
operator|->
name|sinfo_ssn
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_tsn
operator|=
literal|0
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|strlog
operator|.
name|e_sseq
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_STRM
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_cwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|augment
parameter_list|,
name|uint8_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|net
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_new_value
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|inflight
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|pseudo_cumack
operator|=
name|net
operator|->
name|pseudo_cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|meets_pseudo_cumack
operator|=
name|net
operator|->
name|new_pseudo_cumack
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|need_new_pseudo_cumack
operator|=
name|net
operator|->
name|find_pseudo_cumack
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_CWNDLOG_PRESEND
operator|==
name|from
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|meets_pseudo_cumack
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_augment
operator|=
name|augment
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_CWND
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_lock
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint8_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
operator|->
name|sctp_socket
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock
operator|=
operator|(
name|void
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|inp
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|tcb_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|stcb
operator|->
name|tcb_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|tcb_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
block|}
if|if
condition|(
name|inp
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|inp_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|inp
operator|->
name|inp_mtx
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|create_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
name|inp
operator|->
name|inp_create_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|inp_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|create_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
block|}
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|info_lock
operator|=
name|rw_wowned
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|ipi_ep_mtx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|)
condition|)
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_mtx
operator|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sockrcvbuf_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_mtx
operator|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|socksndbuf_lock
operator|=
name|mtx_owned
argument_list|(
operator|&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_mtx
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sock_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|sockrcvbuf_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|lock
operator|.
name|socksndbuf_lock
operator|=
name|SCTP_LOCK_UNKNOWN
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_LOCK_EVENT
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_maxburst
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|burst
parameter_list|,
name|uint8_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sctp_clog
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sctp_clog
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|net
operator|=
name|net
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_new_value
operator|=
name|error
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|inflight
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cwnd_augment
operator|=
name|burst
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_send
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|>
literal|255
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
literal|255
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|cwnd
operator|.
name|cnt_in_str
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MAXBURST
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_rwnd
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|peers_rwnd
parameter_list|,
name|uint32_t
name|snd_size
parameter_list|,
name|uint32_t
name|overhead
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|rwnd
operator|=
name|peers_rwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|send_size
operator|=
name|snd_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|overhead
operator|=
name|overhead
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|new_rwnd
operator|=
literal|0
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_RWND
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_rwnd_set
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|peers_rwnd
parameter_list|,
name|uint32_t
name|flight_size
parameter_list|,
name|uint32_t
name|overhead
parameter_list|,
name|uint32_t
name|a_rwndval
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|rwnd
operator|=
name|peers_rwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|send_size
operator|=
name|flight_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|overhead
operator|=
name|overhead
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|rwnd
operator|.
name|new_rwnd
operator|=
name|a_rwndval
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_RWND
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_mbcnt
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|total_oq
parameter_list|,
name|uint32_t
name|book
parameter_list|,
name|uint32_t
name|total_mbcnt_q
parameter_list|,
name|uint32_t
name|mbcnt
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|total_queue_size
operator|=
name|total_oq
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|size_change
operator|=
name|book
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|total_queue_mb_size
operator|=
name|total_mbcnt_q
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|mbcnt
operator|.
name|mbcnt_change
operator|=
name|mbcnt
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_MBCNT
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_misc_ints
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|uint32_t
name|a
parameter_list|,
name|uint32_t
name|b
parameter_list|,
name|uint32_t
name|c
parameter_list|,
name|uint32_t
name|d
parameter_list|)
block|{
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_MISC_EVENT
argument_list|,
name|from
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_wakeup_log
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|cumtsn
parameter_list|,
name|uint32_t
name|wake_cnt
parameter_list|,
name|int
name|from
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|wake_cnt
operator|=
name|wake_cnt
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|flight
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|send_q
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sent_q
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|<
literal|0xff
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|stream_qcnt
operator|=
operator|(
name|uint8_t
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|stream_qcnt
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|<
literal|0xff
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|chunks_on_oque
operator|=
operator|(
name|uint8_t
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
expr_stmt|;
else|else
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|chunks_on_oque
operator|=
literal|0xff
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator|=
literal|0
expr_stmt|;
comment|/* set in the defered mode stuff */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_DONT_WAKE
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator||=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEOUTPUT
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator||=
literal|2
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEINPUT
condition|)
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sctpflags
operator||=
literal|4
expr_stmt|;
comment|/* what about the sb */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|struct
name|socket
modifier|*
name|so
init|=
name|stcb
operator|->
name|sctp_socket
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sbflags
operator|=
call|(
name|uint8_t
call|)
argument_list|(
operator|(
name|so
operator|->
name|so_snd
operator|.
name|sb_flags
operator|&
literal|0x00ff
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clog
operator|.
name|x
operator|.
name|wake
operator|.
name|sbflags
operator|=
literal|0xff
expr_stmt|;
block|}
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_WAKE
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_log_block
parameter_list|(
name|uint8_t
name|from
parameter_list|,
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|sendlen
parameter_list|)
block|{
name|struct
name|sctp_cwnd_log
name|sctp_clog
decl_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|onsb
operator|=
name|asoc
operator|->
name|total_output_queue_size
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|send_sent_qcnt
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|asoc
operator|->
name|send_queue_cnt
operator|+
name|asoc
operator|->
name|sent_queue_cnt
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|peer_rwnd
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|stream_qcnt
operator|=
operator|(
name|uint16_t
operator|)
name|asoc
operator|->
name|stream_queue_cnt
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|chunks_on_oque
operator|=
operator|(
name|uint16_t
operator|)
name|asoc
operator|->
name|chunks_on_out_queue
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|flight_size
operator|=
call|(
name|uint16_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|/
literal|1024
argument_list|)
expr_stmt|;
name|sctp_clog
operator|.
name|x
operator|.
name|blk
operator|.
name|sndlen
operator|=
name|sendlen
expr_stmt|;
name|SCTP_CTR6
argument_list|(
name|KTR_SCTP
argument_list|,
literal|"SCTP:%d[%d]:%x-%x-%x-%x"
argument_list|,
name|SCTP_LOG_EVENT_BLOCK
argument_list|,
name|from
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log1
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log2
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log3
argument_list|,
name|sctp_clog
operator|.
name|x
operator|.
name|misc
operator|.
name|log4
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_fill_stat_log
parameter_list|(
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
modifier|*
name|optsize
parameter_list|)
block|{
comment|/* May need to fix this if ktrdump does not work */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
end_ifdef

begin_decl_stmt
name|uint8_t
name|sctp_audit_data
index|[
name|SCTP_AUDIT_SIZE
index|]
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sctp_audit_indx
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_print_audit_report
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|sctp_audit_indx
init|;
name|i
operator|<
name|SCTP_AUDIT_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xe0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xf0
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xc0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"%2.2x%2.2x "
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
literal|14
operator|)
operator|==
literal|0
condition|)
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sctp_audit_indx
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xe0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xf0
condition|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|0xc0
operator|)
operator|&&
operator|(
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|0x01
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"%2.2x%2.2x "
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|,
operator|(
name|uint32_t
operator|)
name|sctp_audit_data
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
literal|14
operator|)
operator|==
literal|0
condition|)
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_auditing
parameter_list|(
name|int
name|from
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|resend_cnt
decl_stmt|,
name|tot_out
decl_stmt|,
name|rep
decl_stmt|,
name|tot_book_cnt
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAA
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0x000000ff
operator|&
name|from
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0x01
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0x02
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xA1
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
operator|(
literal|0x000000ff
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|)
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|0
expr_stmt|;
name|tot_book_cnt
operator|=
literal|0
expr_stmt|;
name|resend_cnt
operator|=
name|tot_out
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|resend_cnt
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tot_out
operator|+=
name|chk
operator|->
name|book_size
expr_stmt|;
name|tot_book_cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|resend_cnt
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA1
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"resend_cnt:%d asoc-tot:%d\n"
argument_list|,
name|resend_cnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|rep
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
name|resend_cnt
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xA2
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
operator|(
literal|0x000000ff
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|)
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tot_out
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA2
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|1
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"tot_flt:%d asoc_tot:%d\n"
argument_list|,
name|tot_out
argument_list|,
operator|(
name|int
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|=
name|tot_out
expr_stmt|;
block|}
if|if
condition|(
name|tot_book_cnt
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA5
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|1
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"tot_flt_book:%d\n"
argument_list|,
name|tot_book_cnt
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|=
name|tot_book_cnt
expr_stmt|;
block|}
name|tot_out
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|tot_out
operator|+=
name|lnet
operator|->
name|flight_size
expr_stmt|;
block|}
if|if
condition|(
name|tot_out
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
condition|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
literal|0xAF
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
literal|0xA3
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
name|rep
operator|=
literal|1
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"real flight:%d net total was %d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|tot_out
argument_list|)
expr_stmt|;
comment|/* now corrective action */
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|tot_out
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|lnet
operator|)
operator|&&
operator|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
condition|)
block|{
name|tot_out
operator|+=
name|chk
operator|->
name|book_size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|lnet
operator|->
name|flight_size
operator|!=
name|tot_out
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"net:%p flight was %d corrected to %d\n"
argument_list|,
name|lnet
argument_list|,
name|lnet
operator|->
name|flight_size
argument_list|,
name|tot_out
argument_list|)
expr_stmt|;
name|lnet
operator|->
name|flight_size
operator|=
name|tot_out
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rep
condition|)
block|{
name|sctp_print_audit_report
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_audit_log
parameter_list|(
name|uint8_t
name|ev
parameter_list|,
name|uint8_t
name|fd
parameter_list|)
block|{
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|0
index|]
operator|=
name|ev
expr_stmt|;
name|sctp_audit_data
index|[
name|sctp_audit_indx
index|]
index|[
literal|1
index|]
operator|=
name|fd
expr_stmt|;
name|sctp_audit_indx
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_audit_indx
operator|>=
name|SCTP_AUDIT_SIZE
condition|)
block|{
name|sctp_audit_indx
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * sctp_stop_timers_for_shutdown() should be called  * when entering the SHUTDOWN_SENT or SHUTDOWN_ACK_SENT  * state to make sure that all timers are stopped.  */
end_comment

begin_function
name|void
name|sctp_stop_timers_for_shutdown
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|hb_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|strreset_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|autoclose_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|asoc
operator|->
name|delayed_event_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * a list of sizes based on typical mtu's, used only if next hop size not  * returned.  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|sctp_mtu_sizes
index|[]
init|=
block|{
literal|68
block|,
literal|296
block|,
literal|508
block|,
literal|512
block|,
literal|544
block|,
literal|576
block|,
literal|1006
block|,
literal|1492
block|,
literal|1500
block|,
literal|1536
block|,
literal|2002
block|,
literal|2048
block|,
literal|4352
block|,
literal|4464
block|,
literal|8166
block|,
literal|17914
block|,
literal|32000
block|,
literal|65535
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the largest MTU smaller than val. If there is no  * entry, just return val.  */
end_comment

begin_function
name|uint32_t
name|sctp_get_prev_mtu
parameter_list|(
name|uint32_t
name|val
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|val
operator|<=
name|sctp_mtu_sizes
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|(
name|val
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|sctp_mtu_sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|<=
name|sctp_mtu_sizes
index|[
name|i
index|]
condition|)
block|{
break|break;
block|}
block|}
return|return
operator|(
name|sctp_mtu_sizes
index|[
name|i
operator|-
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the smallest MTU larger than val. If there is no  * entry, just return val.  */
end_comment

begin_function
name|uint32_t
name|sctp_get_next_mtu
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
comment|/* select another MTU that is just bigger than this one */
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|sctp_mtu_sizes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|val
operator|<
name|sctp_mtu_sizes
index|[
name|i
index|]
condition|)
block|{
return|return
operator|(
name|sctp_mtu_sizes
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_fill_random_store
parameter_list|(
name|struct
name|sctp_pcb
modifier|*
name|m
parameter_list|)
block|{
comment|/* 	 * Here we use the MD5/SHA-1 to hash with our good randomNumbers and 	 * our counter. The result becomes our good random numbers and we 	 * then setup to give these out. Note that we do no locking to 	 * protect this. This is ok, since if competing folks call this we 	 * will get more gobbled gook in the random store which is what we 	 * want. There is a danger that two guys will use the same random 	 * numbers, but thats ok too since that is random as well :-> 	 */
name|m
operator|->
name|store_at
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_hmac
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|random_numbers
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|random_numbers
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|m
operator|->
name|random_counter
argument_list|,
sizeof|sizeof
argument_list|(
name|m
operator|->
name|random_counter
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|random_store
argument_list|)
expr_stmt|;
name|m
operator|->
name|random_counter
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_select_initial_TSN
parameter_list|(
name|struct
name|sctp_pcb
modifier|*
name|inp
parameter_list|)
block|{
comment|/* 	 * A true implementation should use random selection process to get 	 * the initial stream sequence number, using RFC1750 as a good 	 * guideline 	 */
name|uint32_t
name|x
decl_stmt|,
modifier|*
name|xp
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|store_at
decl_stmt|,
name|new_store
decl_stmt|;
if|if
condition|(
name|inp
operator|->
name|initial_sequence_debug
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|ret
decl_stmt|;
name|ret
operator|=
name|inp
operator|->
name|initial_sequence_debug
expr_stmt|;
name|inp
operator|->
name|initial_sequence_debug
operator|++
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|retry
label|:
name|store_at
operator|=
name|inp
operator|->
name|store_at
expr_stmt|;
name|new_store
operator|=
name|store_at
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_store
operator|>=
operator|(
name|SCTP_SIGNATURE_SIZE
operator|-
literal|3
operator|)
condition|)
block|{
name|new_store
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|store_at
argument_list|,
name|store_at
argument_list|,
name|new_store
argument_list|)
condition|)
block|{
goto|goto
name|retry
goto|;
block|}
if|if
condition|(
name|new_store
operator|==
literal|0
condition|)
block|{
comment|/* Refill the random store */
name|sctp_fill_random_store
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
operator|&
name|inp
operator|->
name|random_store
index|[
name|store_at
index|]
expr_stmt|;
name|xp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|p
expr_stmt|;
name|x
operator|=
operator|*
name|xp
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_select_a_tag
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|lport
parameter_list|,
name|uint16_t
name|rport
parameter_list|,
name|int
name|save_in_twait
parameter_list|)
block|{
name|uint32_t
name|x
decl_stmt|,
name|not_done
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|not_done
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|not_done
condition|)
block|{
name|x
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
block|{
comment|/* we never use 0 */
continue|continue;
block|}
if|if
condition|(
name|sctp_is_vtag_good
argument_list|(
name|inp
argument_list|,
name|x
argument_list|,
name|lport
argument_list|,
name|rport
argument_list|,
operator|&
name|now
argument_list|,
name|save_in_twait
argument_list|)
condition|)
block|{
name|not_done
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_init_asoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|override_tag
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
comment|/* 	 * Anything set to zero is taken care of by the allocation routine's 	 * bzero 	 */
comment|/* 	 * Up front select what scoping to apply on addresses I tell my peer 	 * Not sure what to do with these right now, we will need to come up 	 * with a way to set them. We may need to pass them through from the 	 * caller in the sctp_aloc_assoc() function. 	 */
name|int
name|i
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* init all variables to a known value. */
name|SCTP_SET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_INUSE
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|max_burst
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|max_burst
expr_stmt|;
name|asoc
operator|->
name|heart_beat_delay
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|cookie_life
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
expr_stmt|;
name|asoc
operator|->
name|sctp_cmt_on_off
operator|=
name|m
operator|->
name|sctp_cmt_on_off
expr_stmt|;
name|asoc
operator|->
name|sctp_nr_sack_on_off
operator|=
operator|(
name|uint8_t
operator|)
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sctp_cmt_pf
operator|=
operator|(
name|uint8_t
operator|)
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_pf
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sctp_frag_point
operator|=
name|m
operator|->
name|sctp_frag_point
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|asoc
operator|->
name|default_tos
operator|=
name|m
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_tos
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|default_tos
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|asoc
operator|->
name|default_flowlabel
operator|=
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|m
operator|)
operator|->
name|in6p_flowinfo
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|default_flowlabel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|sb_send_resv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|override_tag
condition|)
block|{
name|asoc
operator|->
name|my_vtag
operator|=
name|override_tag
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|my_vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|m
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Get the nonce tags */
name|asoc
operator|->
name|my_vtag_nonce
operator|=
name|sctp_select_a_tag
argument_list|(
name|m
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|peer_vtag_nonce
operator|=
name|sctp_select_a_tag
argument_list|(
name|m
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|vrf_id
operator|=
name|vrf_id
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|m
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
condition|)
name|asoc
operator|->
name|hb_is_disabled
operator|=
literal|1
expr_stmt|;
else|else
name|asoc
operator|->
name|hb_is_disabled
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|asoc
operator|->
name|tsn_in_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_out_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_in_wrapped
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_out_wrapped
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cumack_log_atsnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_FS_SPEC_LOG
name|asoc
operator|->
name|fs_index
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|refcnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|assoc_up_sent
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_out
operator|=
name|asoc
operator|->
name|str_reset_seq_out
operator|=
name|asoc
operator|->
name|init_seq_number
operator|=
name|asoc
operator|->
name|sending_seq
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|m
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_out_acked
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|-
literal|1
expr_stmt|;
comment|/* we are optimisitic here */
name|asoc
operator|->
name|peer_supports_pktdrop
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|peer_supports_nat
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
comment|/* for CMT */
name|asoc
operator|->
name|last_net_cmt_send_started
operator|=
name|NULL
expr_stmt|;
comment|/* This will need to be adjusted */
name|asoc
operator|->
name|last_acked_seq
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* here we are different, we hold the next one we expect */
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|initial_init_rto_max
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|initial_init_rto_max
expr_stmt|;
name|asoc
operator|->
name|initial_rto
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|initial_rto
expr_stmt|;
name|asoc
operator|->
name|max_init_times
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|max_init_times
expr_stmt|;
name|asoc
operator|->
name|max_send_times
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|max_send_times
expr_stmt|;
name|asoc
operator|->
name|def_net_failure
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|def_net_failure
expr_stmt|;
name|asoc
operator|->
name|free_chunk_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|iam_blocking
operator|=
literal|0
expr_stmt|;
comment|/* ECN Nonce initialization */
name|asoc
operator|->
name|context
operator|=
name|m
operator|->
name|sctp_context
expr_stmt|;
name|asoc
operator|->
name|def_send
operator|=
name|m
operator|->
name|def_send
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|receiver_nonce_sum
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|delayed_ack
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sack_freq
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_sack_freq
expr_stmt|;
name|asoc
operator|->
name|pr_sctp_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
comment|/* Its a V6 socket */
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|m
expr_stmt|;
name|asoc
operator|->
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
comment|/* Now look at the binding flag to see if V4 will be legal */
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|asoc
operator|->
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* V4 addresses are NOT legal on the association */
name|asoc
operator|->
name|ipv4_addr_legal
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Its a V4 socket, no - V6 */
name|asoc
operator|->
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|my_rwnd
operator|=
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|m
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|peers_rwnd
operator|=
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|m
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|smallest_mtu
operator|=
name|m
operator|->
name|sctp_frag_point
expr_stmt|;
name|asoc
operator|->
name|minrto
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
expr_stmt|;
name|asoc
operator|->
name|maxrto
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
expr_stmt|;
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|stream_locked_on
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_echo_cnt_onq
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|sctp_restricted_addrs
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_ack_sent
argument_list|)
expr_stmt|;
comment|/* Setup to fill the hb random cache at first HB */
name|asoc
operator|->
name|hb_random_idx
operator|=
literal|4
expr_stmt|;
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|auto_close_time
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|congestion_control_module
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_default_cc_module
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|=
name|sctp_cc_functions
index|[
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_default_cc_module
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|stream_scheduling_module
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_default_ss_module
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|=
name|sctp_ss_functions
index|[
name|m
operator|->
name|sctp_ep
operator|.
name|sctp_default_ss_module
index|]
expr_stmt|;
comment|/* 	 * Now the stream parameters, here we allocate space for all streams 	 * that we request by default. 	 */
name|asoc
operator|->
name|strm_realoutsize
operator|=
name|asoc
operator|->
name|streamoutcnt
operator|=
name|asoc
operator|->
name|pre_open_streams
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
expr|struct
name|sctp_stream_out
operator|*
argument_list|,
name|asoc
operator|->
name|streamoutcnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_out
argument_list|)
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmout
operator|==
name|NULL
condition|)
block|{
comment|/* big trouble no memory */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * inbound side must be set to 0xffff, also NOTE when we get 		 * the INIT-ACK back (for INIT sender) we MUST reduce the 		 * count (streamoutcnt) but first check if we sent to any of 		 * the upper streams that were dropped (if some were). Those 		 * that were dropped must be notified to the upper layer as 		 * failed to send. 		 */
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_sent
operator|=
literal|0x0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now the mapping array */
name|asoc
operator|->
name|mapping_array_size
operator|=
name|SCTP_INITIAL_MAPPING_ARRAY
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|mapping_array
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
comment|/* Now the init of the other outqueues */
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|free_chunks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|max_inbound_streams
operator|=
name|m
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|)
expr_stmt|;
comment|/* authentication fields */
name|asoc
operator|->
name|authinfo
operator|.
name|random
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|active_keyid
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|assoc_key
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|assoc_keyid
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|recv_key
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|authinfo
operator|.
name|recv_keyid
operator|=
literal|0
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|shared_keys
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|marked_retrans
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoinit
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timodata
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timosack
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoshutdown
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoheartbeat
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timocookie
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|timoshutdownack
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|discontinuity_time
operator|=
name|asoc
operator|->
name|start_time
expr_stmt|;
comment|/* 	 * sa_ignore MEMLEAK {memory is put in the assoc mapping array and 	 * freed later when the association is freed. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_print_mapping_array
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|,
name|limit
decl_stmt|;
name|printf
argument_list|(
literal|"Mapping array size: %d, baseTSN: %8.8x, cumAck: %8.8x, highestTSN: (%8.8x, %8.8x).\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
expr_stmt|;
for|for
control|(
name|limit
operator|=
name|asoc
operator|->
name|mapping_array_size
init|;
name|limit
operator|>
literal|1
condition|;
name|limit
operator|--
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|mapping_array
index|[
name|limit
operator|-
literal|1
index|]
condition|)
block|{
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"Renegable mapping array (last %d entries are zero):\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
operator|-
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2.2x%c"
argument_list|,
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|16
operator|)
condition|?
literal|' '
else|:
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|limit
operator|=
name|asoc
operator|->
name|mapping_array_size
init|;
name|limit
operator|>
literal|1
condition|;
name|limit
operator|--
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
index|[
name|limit
operator|-
literal|1
index|]
condition|)
block|{
break|break;
block|}
block|}
name|printf
argument_list|(
literal|"Non renegable mapping array (last %d entries are zero):\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
operator|-
name|limit
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%2.2x%c"
argument_list|,
name|asoc
operator|->
name|nr_mapping_array
index|[
name|i
index|]
argument_list|,
operator|(
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|16
operator|)
condition|?
literal|' '
else|:
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|limit
operator|%
literal|16
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_expand_mapping_array
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|needed
parameter_list|)
block|{
comment|/* mapping array needs to grow */
name|uint8_t
modifier|*
name|new_array1
decl_stmt|,
modifier|*
name|new_array2
decl_stmt|;
name|uint32_t
name|new_size
decl_stmt|;
name|new_size
operator|=
name|asoc
operator|->
name|mapping_array_size
operator|+
operator|(
operator|(
name|needed
operator|+
literal|7
operator|)
operator|/
literal|8
operator|+
name|SCTP_MAPPING_ARRAY_INCR
operator|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_array1
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|new_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_array2
argument_list|,
name|uint8_t
operator|*
argument_list|,
name|new_size
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_array1
operator|==
name|NULL
operator|)
operator|||
operator|(
name|new_array2
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't get more, forget it */
name|SCTP_PRINTF
argument_list|(
literal|"No memory for expansion of SCTP mapping array %d\n"
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_array1
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|new_array1
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_array2
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|new_array2
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|new_array1
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|new_array2
argument_list|,
literal|0
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_array1
argument_list|,
name|asoc
operator|->
name|mapping_array
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_array2
argument_list|,
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|SCTP_M_MAP
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array
operator|=
name|new_array1
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array
operator|=
name|new_array2
expr_stmt|;
name|asoc
operator|->
name|mapping_array_size
operator|=
name|new_size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_iterator_work
parameter_list|(
name|struct
name|sctp_iterator
modifier|*
name|it
parameter_list|)
block|{
name|int
name|iteration_count
init|=
literal|0
decl_stmt|;
name|int
name|inp_skip
init|=
literal|0
decl_stmt|;
name|int
name|first_in
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|tinp
decl_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* iterator is complete */
name|done_with_iterator
label|:
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|function_atend
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|it
operator|->
name|function_atend
call|)
argument_list|(
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|it
argument_list|,
name|SCTP_M_ITER
argument_list|)
expr_stmt|;
return|return;
block|}
name|select_a_new_ep
label|:
if|if
condition|(
name|first_in
condition|)
block|{
name|first_in
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|it
operator|->
name|pcb_flags
operator|)
operator|&&
operator|(
operator|(
name|it
operator|->
name|inp
operator|->
name|sctp_flags
operator|&
name|it
operator|->
name|pcb_flags
operator|)
operator|!=
name|it
operator|->
name|pcb_flags
operator|)
operator|)
operator|||
operator|(
operator|(
name|it
operator|->
name|pcb_features
operator|)
operator|&&
operator|(
operator|(
name|it
operator|->
name|inp
operator|->
name|sctp_features
operator|&
name|it
operator|->
name|pcb_features
operator|)
operator|!=
name|it
operator|->
name|pcb_features
operator|)
operator|)
condition|)
block|{
comment|/* endpoint flags or features don't match, so keep looking */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done_with_iterator
goto|;
block|}
name|tinp
operator|=
name|it
operator|->
name|inp
expr_stmt|;
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* now go through each assoc which is in the desired state */
if|if
condition|(
name|it
operator|->
name|done_current_ep
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp
operator|!=
name|NULL
condition|)
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
name|it
operator|->
name|done_current_ep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* run the per instance function */
name|it
operator|->
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|it
operator|->
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp_skip
operator|)
operator|||
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp_end
operator|!=
name|NULL
condition|)
block|{
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp_end
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|no_stcb
goto|;
block|}
while|while
condition|(
name|it
operator|->
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|asoc_state
operator|&&
operator|(
operator|(
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|it
operator|->
name|asoc_state
operator|)
operator|!=
name|it
operator|->
name|asoc_state
operator|)
condition|)
block|{
comment|/* not in the right state... keep looking */
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|next_assoc
goto|;
block|}
comment|/* see if we have limited out the iterator loop */
name|iteration_count
operator|++
expr_stmt|;
if|if
condition|(
name|iteration_count
operator|>
name|SCTP_ITERATOR_MAX_AT_ONCE
condition|)
block|{
comment|/* Pause to let others grab the lock */
name|atomic_add_int
argument_list|(
operator|&
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
condition|)
block|{
comment|/* We won't be staying here */
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&
name|SCTP_ITERATOR_MUST_EXIT
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&
name|SCTP_ITERATOR_STOP_CUR_IT
condition|)
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&=
operator|~
name|SCTP_ITERATOR_STOP_CUR_IT
expr_stmt|;
goto|goto
name|done_with_iterator
goto|;
block|}
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&
name|SCTP_ITERATOR_STOP_CUR_INP
condition|)
block|{
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&=
operator|~
name|SCTP_ITERATOR_STOP_CUR_INP
expr_stmt|;
goto|goto
name|no_stcb
goto|;
block|}
comment|/* If we reach here huh? */
name|printf
argument_list|(
literal|"Unknown it ctl flag %x\n"
argument_list|,
name|sctp_it_ctl
operator|.
name|iterator_flags
argument_list|)
expr_stmt|;
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|iteration_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* run function on this one */
call|(
modifier|*
name|it
operator|->
name|function_assoc
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|stcb
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * we lie here, it really needs to have its own type but 		 * first I must verify that this won't effect things :-0 		 */
if|if
condition|(
name|it
operator|->
name|no_chunk_output
operator|==
literal|0
condition|)
name|sctp_chunk_output
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|next_assoc
label|:
name|it
operator|->
name|stcb
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Run last function */
if|if
condition|(
name|it
operator|->
name|function_inp_end
operator|!=
name|NULL
condition|)
block|{
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp_end
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|no_stcb
label|:
comment|/* done with all assocs on this endpoint, move on to next endpoint */
name|it
operator|->
name|done_current_ep
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
goto|goto
name|select_a_new_ep
goto|;
block|}
end_function

begin_function
name|void
name|sctp_iterator_worker
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|sctp_iterator
modifier|*
name|it
decl_stmt|,
modifier|*
name|nit
decl_stmt|;
comment|/* This function is called with the WQ lock in place */
name|sctp_it_ctl
operator|.
name|iterator_running
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|it
argument_list|,
argument|&sctp_it_ctl.iteratorhead
argument_list|,
argument|sctp_nxt_itr
argument_list|,
argument|nit
argument_list|)
block|{
name|sctp_it_ctl
operator|.
name|cur_it
operator|=
name|it
expr_stmt|;
comment|/* now lets work on this one */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sctp_it_ctl
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_UNLOCK
argument_list|()
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|it
operator|->
name|vn
argument_list|)
expr_stmt|;
name|sctp_iterator_work
argument_list|(
name|it
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|SCTP_IPI_ITERATOR_WQ_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|sctp_it_ctl
operator|.
name|iterator_flags
operator|&
name|SCTP_ITERATOR_MUST_EXIT
condition|)
block|{
name|sctp_it_ctl
operator|.
name|cur_it
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* sa_ignore FREED_MEMORY */
block|}
name|sctp_it_ctl
operator|.
name|iterator_running
operator|=
literal|0
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_addr_wq
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* deal with the ADDR wq from the rtsock calls */
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|,
modifier|*
name|nwi
decl_stmt|;
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asc
argument_list|,
expr|struct
name|sctp_asconf_iterator
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_iterator
argument_list|)
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
if|if
condition|(
name|asc
operator|==
name|NULL
condition|)
block|{
comment|/* Try later, no memory */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|asc
operator|->
name|list_of_work
argument_list|)
expr_stmt|;
name|asc
operator|->
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|wi
argument_list|,
argument|&SCTP_BASE_INFO(addr_wq)
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nwi
argument_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|asc
operator|->
name|list_of_work
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|asc
operator|->
name|cnt
operator|++
expr_stmt|;
block|}
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
literal|0
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asc
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sctp_initiate_iterator
argument_list|(
name|sctp_asconf_iterator_ep
argument_list|,
name|sctp_asconf_iterator_stcb
argument_list|,
name|NULL
argument_list|,
comment|/* No ep end for boundall */
name|SCTP_PCB_FLAGS_BOUNDALL
argument_list|,
name|SCTP_PCB_ANY_FEATURES
argument_list|,
name|SCTP_ASOC_ANY_STATE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|asc
argument_list|,
literal|0
argument_list|,
name|sctp_asconf_iterator_end
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|int
name|retcode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cur_oerr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_timeout_handler
parameter_list|(
name|void
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_timer
modifier|*
name|tmr
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|int
name|did_output
decl_stmt|,
name|type
decl_stmt|;
name|tmr
operator|=
operator|(
expr|struct
name|sctp_timer
operator|*
operator|)
name|t
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|tmr
operator|->
name|ep
expr_stmt|;
name|stcb
operator|=
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|tmr
operator|->
name|tcb
expr_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|tmr
operator|->
name|net
expr_stmt|;
name|CURVNET_SET
argument_list|(
operator|(
expr|struct
name|vnet
operator|*
operator|)
name|tmr
operator|->
name|vnet
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xF0
argument_list|,
operator|(
name|uint8_t
operator|)
name|tmr
operator|->
name|type
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|3
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* sanity checks... */
if|if
condition|(
name|tmr
operator|->
name|self
operator|!=
operator|(
name|void
operator|*
operator|)
name|tmr
condition|)
block|{
comment|/* 		 * SCTP_PRINTF("Stale SCTP timer fired (%p), ignoring...\n", 		 * tmr); 		 */
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa001
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_IS_TIMER_TYPE_VALID
argument_list|(
name|tmr
operator|->
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * SCTP_PRINTF("SCTP timer fired with invalid type: 0x%x\n", 		 * tmr->type); 		 */
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa002
expr_stmt|;
if|if
condition|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_ADDR_WQ
operator|)
operator|&&
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* if this is an iterator timeout, get the struct and clear inp */
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa003
expr_stmt|;
name|type
operator|=
name|tmr
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_socket
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_INPKILL
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_INIT
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SEND
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_RECV
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_HEARTBEAT
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SHUTDOWN
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SHUTDOWNACK
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
operator|)
operator|&&
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_ASOCKILL
operator|)
operator|)
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa004
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa005
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Timer type %d goes off\n"
argument_list|,
name|tmr
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_ACTIVE
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0xa006
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|SCTP_TIMER_TYPE_ASOCKILL
operator|)
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
comment|/* record in stopped what t-o occured */
name|tmr
operator|->
name|stopped_from
operator|=
name|tmr
operator|->
name|type
expr_stmt|;
comment|/* mark as being serviced now */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
comment|/* 		 * Callout has been rescheduled. 		 */
goto|goto
name|get_out
goto|;
block|}
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_ACTIVE
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
comment|/* 		 * Not active, so no action. 		 */
goto|goto
name|get_out
goto|;
block|}
name|SCTP_OS_TIMER_DEACTIVATE
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
expr_stmt|;
comment|/* call the handler for the appropriate timer type */
switch|switch
condition|(
name|tmr
operator|->
name|type
condition|)
block|{
case|case
name|SCTP_TIMER_TYPE_ZERO_COPY
case|:
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_ZCOPY_SENDQ
case|:
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_SENDQ_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_ADDR_WQ
case|:
name|sctp_handle_addr_wq
argument_list|()
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SEND
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timodata
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timodata
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|--
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|<
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|cur_oerr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
expr_stmt|;
name|retcode
operator|=
name|sctp_t3rxt_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
comment|/* 			 * safeguard. If there on some on the sent queue 			 * somewhere but no timers running something is 			 * wrong... so we start a timer on the first chunk 			 * on the send queue on whatever net it is sent to. 			 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_INIT
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoinit
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoinit
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_t1init_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
comment|/* We do output but not here */
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_RECV
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timosack
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timosack
operator|++
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SACK_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWN
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_shutdown_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoshutdown
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoshutdown
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SHUT_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_HEARTBEAT
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|int
name|cnt_of_unconf
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoheartbeat
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoheartbeat
operator|++
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
name|cnt_of_unconf
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_of_unconf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_heartbeat_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|lnet
argument_list|,
name|cnt_of_unconf
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|lnet
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lnet
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_HB_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_COOKIE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_cookie_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timocookie
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timocookie
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * We consider T3 and Cookie timer pretty much the same with 		 * respect to where from in chunk_output. 		 */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_NEWCOOKIE
case|:
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|secret
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timosecret
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|time_of_secret_change
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|last_secret_number
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|++
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|>=
name|SCTP_HOW_MANY_SECRETS
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
operator|=
literal|0
expr_stmt|;
block|}
name|secret
operator|=
operator|(
name|int
operator|)
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_OF_SECRETS
condition|;
name|i
operator|++
control|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|secret_key
index|[
name|secret
index|]
index|[
name|i
index|]
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_NEWCOOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PATHMTURAISE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timopathmtu
argument_list|)
expr_stmt|;
name|sctp_pathmtu_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNACK
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_shutdownack_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoshutdownack
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|timoshutdownack
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SHUT_ACK_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoshutdownguard
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SHUTDOWN_GUARD_EXPIRES
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
case|case
name|SCTP_TIMER_TYPE_STRRESET
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_strreset_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timostrmrst
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_STRRST_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_EARLYFR
case|:
comment|/* Need to do FR of things for net */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoearlyfr
argument_list|)
expr_stmt|;
name|sctp_early_fr_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASCONF
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|sctp_asconf_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* no need to unlock on tcb its gone */
goto|goto
name|out_decr
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoasconf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_ASCONF_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PRIM_DELETED
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|sctp_delete_prim_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timodelprim
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_AUTOCLOSE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoautoclose
argument_list|)
expr_stmt|;
name|sctp_autoclose_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_AUTOCLOSE_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|did_output
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASOCKILL
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
break|break;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoassockill
argument_list|)
expr_stmt|;
comment|/* Can we free it yet? */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * free asoc, always unlocks (or destroy's) so prevent 		 * duplicate unlock or unlock of a free mtx :-0 		 */
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_no_decr
goto|;
case|case
name|SCTP_TIMER_TYPE_INPKILL
case|:
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timoinpkill
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* 		 * special case, take away our increment since WE are the 		 * killer 		 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INPKILL
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_FROM_INPKILL_TIMER
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_no_decr
goto|;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"sctp_timeout_handler:unknown timer %d\n"
argument_list|,
name|tmr
operator|->
name|type
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xF1
argument_list|,
operator|(
name|uint8_t
operator|)
name|tmr
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|sctp_auditing
argument_list|(
literal|5
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|did_output
operator|)
operator|&&
name|stcb
condition|)
block|{
comment|/* 		 * Now we need to clean up the control chunk chain if an 		 * ECNE is on it. It must be marked as UNSENT again so next 		 * call will continue to send it until such time that we get 		 * a CWR, to remove it. It is, however, less likely that we 		 * will find a ecn echo on the chain though. 		 */
name|sctp_fix_ecn_echo
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
block|}
name|get_out
label|:
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|out_decr
label|:
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|out_no_decr
label|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Timer now complete (type %d)\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_timer_start
parameter_list|(
name|int
name|t_type
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|to_ticks
decl_stmt|;
name|struct
name|sctp_timer
modifier|*
name|tmr
decl_stmt|;
if|if
condition|(
operator|(
name|t_type
operator|!=
name|SCTP_TIMER_TYPE_ADDR_WQ
operator|)
operator|&&
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
return|return;
name|to_ticks
operator|=
literal|0
expr_stmt|;
name|tmr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t_type
condition|)
block|{
case|case
name|SCTP_TIMER_TYPE_ZERO_COPY
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_timer
expr_stmt|;
name|to_ticks
operator|=
name|SCTP_ZERO_COPY_TICK_DELAY
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ZCOPY_SENDQ
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_sendq_timer
expr_stmt|;
name|to_ticks
operator|=
name|SCTP_ZERO_COPY_SENDQ_TICK_DELAY
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ADDR_WQ
case|:
comment|/* Only 1 tick away :-) */
name|tmr
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq_timer
argument_list|)
expr_stmt|;
name|to_ticks
operator|=
name|SCTP_ADDRESS_TICK_DELAY
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SEND
case|:
comment|/* Here we use the RTO timer */
block|{
name|int
name|rto_val
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|rto_val
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
block|}
else|else
block|{
name|rto_val
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
block|}
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|rto_val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_INIT
case|:
comment|/* 		 * Here we use the INIT timer default usually about 1 		 * minute. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_RECV
case|:
comment|/* 		 * Here we use the Delayed-Ack timer value from the inp 		 * ususually about 200ms. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
expr_stmt|;
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWN
case|:
comment|/* Here we use the RTO of the destination. */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_HEARTBEAT
case|:
comment|/* 		 * the net is used here so that we can add in the RTO. Even 		 * though we use a different timer. We also add the HB timer 		 * PLUS a random jitter. 		 */
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
else|else
block|{
name|uint32_t
name|rndval
decl_stmt|;
name|uint8_t
name|this_random
decl_stmt|;
name|int
name|cnt_of_unconf
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
name|cnt_of_unconf
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_of_unconf
condition|)
block|{
name|net
operator|=
name|lnet
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_heartbeat_timer
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|lnet
argument_list|,
name|cnt_of_unconf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|>
literal|3
condition|)
block|{
name|rndval
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|,
operator|&
name|rndval
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|)
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|=
literal|0
expr_stmt|;
block|}
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
comment|/* 			 * this_random will be 0 - 256 ms RTO is in ms. 			 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_is_disabled
operator|)
operator|&&
operator|(
name|cnt_of_unconf
operator|==
literal|0
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
condition|)
block|{
name|int
name|delay
decl_stmt|;
name|delay
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_OUT_OF_SCOPE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
name|delay
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
comment|/* Never been checked */
name|to_ticks
operator|=
name|this_random
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
operator|+
name|delay
expr_stmt|;
block|}
else|else
block|{
comment|/* set rto_val to the ms */
name|to_ticks
operator|=
name|delay
operator|+
name|net
operator|->
name|RTO
operator|+
name|this_random
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cnt_of_unconf
condition|)
block|{
name|to_ticks
operator|=
name|this_random
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
operator|+
name|this_random
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
block|}
block|}
comment|/* 			 * Now we must convert the to_ticks that are now in 			 * ms to ticks. 			 */
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|to_ticks
argument_list|)
expr_stmt|;
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|hb_timer
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_COOKIE
case|:
comment|/* 		 * Here we can use the RTO timer from the network since one 		 * RTT was compelete. If a retran happened then we will be 		 * using the RTO initial value. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_NEWCOOKIE
case|:
comment|/* 		 * nothing needed but the endpoint here ususually about 60 		 * minutes. 		 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
name|to_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_SIGNATURE
index|]
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASOCKILL
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_ASOC_KILL_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_INPKILL
case|:
comment|/* 		 * The inp is setup to die. We re-use the signature_chage 		 * timer since that has stopped and we are in the GONE 		 * state. 		 */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|SCTP_INP_KILL_TIMEOUT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PATHMTURAISE
case|:
comment|/* 		 * Here we use the value found in the EP for PMTU ususually 		 * about 10 minutes. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|to_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_PMTU
index|]
expr_stmt|;
name|tmr
operator|=
operator|&
name|net
operator|->
name|pmtu_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNACK
case|:
comment|/* Here we use the RTO of the destination */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
case|:
comment|/* 		 * Here we use the endpoints shutdown guard timer usually 		 * about 3 minutes. 		 */
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|to_ticks
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_MAXSHUTDOWN
index|]
expr_stmt|;
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shut_guard_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_STRRESET
case|:
comment|/* 		 * Here the timer comes from the stcb but its value is from 		 * the net's RTO. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_EARLYFR
case|:
block|{
name|unsigned
name|int
name|msec
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* no need to start */
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|lastsa
operator|==
literal|0
condition|)
block|{
comment|/* Hmm no rtt estimate yet? */
name|msec
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|msec
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|msec
operator|<
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr_msec
argument_list|)
condition|)
block|{
name|msec
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr_msec
argument_list|)
expr_stmt|;
if|if
condition|(
name|msec
operator|<
name|SCTP_MINFR_MSEC_FLOOR
condition|)
block|{
name|msec
operator|=
name|SCTP_MINFR_MSEC_FLOOR
expr_stmt|;
block|}
block|}
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|msec
argument_list|)
expr_stmt|;
name|tmr
operator|=
operator|&
name|net
operator|->
name|fr_timer
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_TIMER_TYPE_ASCONF
case|:
comment|/* 		 * Here the timer comes from the stcb but its value is from 		 * the net's RTO. 		 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PRIM_DELETED
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|!=
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|delete_prim_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_AUTOCLOSE
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Really an error since stcb is NOT set to 			 * autoclose 			 */
return|return;
block|}
name|to_ticks
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
expr_stmt|;
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|autoclose_timer
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"%s: Unknown timer type %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|t_type
argument_list|)
expr_stmt|;
return|return;
break|break;
block|}
empty_stmt|;
if|if
condition|(
operator|(
name|to_ticks
operator|<=
literal|0
operator|)
operator|||
operator|(
name|tmr
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"%s: %d:software error to_ticks:%d tmr:%p not set ??\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|t_type
argument_list|,
name|to_ticks
argument_list|,
name|tmr
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
condition|)
block|{
comment|/* 		 * we do NOT allow you to have it already running. if it is 		 * we leave the current one up unchanged 		 */
return|return;
block|}
comment|/* At this point we can proceed */
if|if
condition|(
name|t_type
operator|==
name|SCTP_TIMER_TYPE_SEND
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|++
expr_stmt|;
block|}
name|tmr
operator|->
name|stopped_from
operator|=
literal|0
expr_stmt|;
name|tmr
operator|->
name|type
operator|=
name|t_type
expr_stmt|;
name|tmr
operator|->
name|ep
operator|=
operator|(
name|void
operator|*
operator|)
name|inp
expr_stmt|;
name|tmr
operator|->
name|tcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|tmr
operator|->
name|net
operator|=
operator|(
name|void
operator|*
operator|)
name|net
expr_stmt|;
name|tmr
operator|->
name|self
operator|=
operator|(
name|void
operator|*
operator|)
name|tmr
expr_stmt|;
name|tmr
operator|->
name|vnet
operator|=
operator|(
name|void
operator|*
operator|)
name|curvnet
expr_stmt|;
name|tmr
operator|->
name|ticks
operator|=
name|sctp_get_tick_count
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
name|tmr
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_timer_stop
parameter_list|(
name|int
name|t_type
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|from
parameter_list|)
block|{
name|struct
name|sctp_timer
modifier|*
name|tmr
decl_stmt|;
if|if
condition|(
operator|(
name|t_type
operator|!=
name|SCTP_TIMER_TYPE_ADDR_WQ
operator|)
operator|&&
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
return|return;
name|tmr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|t_type
condition|)
block|{
case|case
name|SCTP_TIMER_TYPE_ZERO_COPY
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ZCOPY_SENDQ
case|:
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|zero_copy_sendq_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ADDR_WQ
case|:
name|tmr
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq_timer
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_EARLYFR
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|fr_timer
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstop
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SEND
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_INIT
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_RECV
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWN
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_HEARTBEAT
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|hb_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_COOKIE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_NEWCOOKIE
case|:
comment|/* nothing needed but the endpoint here */
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
comment|/* 		 * We re-use the newcookie timer for the INP kill timer. We 		 * must assure that we do not kill it by accident. 		 */
break|break;
case|case
name|SCTP_TIMER_TYPE_ASOCKILL
case|:
comment|/* 		 * Stop the asoc kill timer. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_INPKILL
case|:
comment|/* 		 * The inp is setup to die. We re-use the signature_chage 		 * timer since that has stopped and we are in the GONE 		 * state. 		 */
name|tmr
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|signature_change
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PATHMTURAISE
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|pmtu_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNACK
case|:
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|net
operator|->
name|rxt_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shut_guard_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_STRRESET
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strreset_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_ASCONF
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_PRIM_DELETED
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|delete_prim_timer
expr_stmt|;
break|break;
case|case
name|SCTP_TIMER_TYPE_AUTOCLOSE
case|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tmr
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|autoclose_timer
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"%s: Unknown timer type %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|t_type
argument_list|)
expr_stmt|;
break|break;
block|}
empty_stmt|;
if|if
condition|(
name|tmr
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|tmr
operator|->
name|type
operator|!=
name|t_type
operator|)
operator|&&
name|tmr
operator|->
name|type
condition|)
block|{
comment|/* 		 * Ok we have a timer that is under joint use. Cookie timer 		 * per chance with the SEND timer. We therefore are NOT 		 * running the timer that the caller wants stopped.  So just 		 * return. 		 */
return|return;
block|}
if|if
condition|(
operator|(
name|t_type
operator|==
name|SCTP_TIMER_TYPE_SEND
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|--
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|<
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|tmr
operator|->
name|self
operator|=
name|NULL
expr_stmt|;
name|tmr
operator|->
name|stopped_from
operator|=
name|from
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|tmr
operator|->
name|timer
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|uint32_t
name|sctp_calculate_len
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|uint32_t
name|tlen
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|at
decl_stmt|;
name|at
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|at
condition|)
block|{
name|tlen
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|tlen
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_mtu_size_reset
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|mtu
parameter_list|)
block|{
comment|/* 	 * Reset the P-MTU size on this association, this involves changing 	 * the asoc MTU, going through ANY chunk+overhead larger than mtu to 	 * allow the DF flag to be cleared. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|unsigned
name|int
name|eff_mtu
decl_stmt|,
name|ovh
decl_stmt|;
name|asoc
operator|->
name|smallest_mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MIN_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
block|}
name|eff_mtu
operator|=
name|mtu
operator|-
name|ovh
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|send_size
operator|>
name|eff_mtu
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|send_size
operator|>
name|eff_mtu
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * given an association and starting time of the current RTT period return  * RTO in number of msecs net should point to the current network  */
end_comment

begin_function
name|uint32_t
name|sctp_calculate_rto
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|timeval
modifier|*
name|told
parameter_list|,
name|int
name|safe
parameter_list|)
block|{
comment|/*- 	 * given an association and the starting time of the current RTT 	 * period (in value1/value2) return RTO in number of msecs. 	 */
name|int
name|calc_time
init|=
literal|0
decl_stmt|;
name|int
name|o_calctime
decl_stmt|;
name|uint32_t
name|new_rto
init|=
literal|0
decl_stmt|;
name|int
name|first_measure
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|then
decl_stmt|,
modifier|*
name|old
decl_stmt|;
comment|/* Copy it out for sparc64 */
if|if
condition|(
name|safe
operator|==
name|sctp_align_unsafe_makecopy
condition|)
block|{
name|old
operator|=
operator|&
name|then
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|then
argument_list|,
name|told
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|safe
operator|==
name|sctp_align_safe_nocopy
condition|)
block|{
name|old
operator|=
name|told
expr_stmt|;
block|}
else|else
block|{
comment|/* error */
name|SCTP_PRINTF
argument_list|(
literal|"Huh, bad rto calc call\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/************************/
comment|/* 1. calculate new RTT */
comment|/************************/
comment|/* get the current time */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Record the real time of the last RTT for use in DC-CC. 	 */
name|net
operator|->
name|last_measured_rtt
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|net
operator|->
name|last_measured_rtt
argument_list|,
name|old
argument_list|)
expr_stmt|;
comment|/* compute the RTT value */
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_sec
operator|>
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_sec
condition|)
block|{
name|calc_time
operator|=
operator|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_sec
operator|-
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_sec
operator|)
operator|*
literal|1000
expr_stmt|;
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|>
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
condition|)
block|{
name|calc_time
operator|+=
operator|(
operator|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|-
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|<
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
condition|)
block|{
comment|/* Borrow 1,000ms from current calculation */
name|calc_time
operator|-=
literal|1000
expr_stmt|;
comment|/* Add in the slop over */
name|calc_time
operator|+=
operator|(
operator|(
name|int
operator|)
name|now
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
expr_stmt|;
comment|/* Add in the pre-second ms's */
name|calc_time
operator|+=
operator|(
operator|(
operator|(
name|int
operator|)
literal|1000000
operator|-
operator|(
name|int
operator|)
name|old
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_sec
operator|==
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_sec
condition|)
block|{
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|>
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
condition|)
block|{
name|calc_time
operator|=
operator|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|-
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|<
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
condition|)
block|{
comment|/* impossible .. garbage in nothing out */
goto|goto
name|calc_rto
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|u_long
operator|)
name|now
operator|.
name|tv_usec
operator|==
operator|(
name|u_long
operator|)
name|old
operator|->
name|tv_usec
condition|)
block|{
comment|/* 			 * We have to have 1 usec :-D this must be the 			 * loopback. 			 */
name|calc_time
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* impossible .. garbage in nothing out */
goto|goto
name|calc_rto
goto|;
block|}
block|}
else|else
block|{
comment|/* Clock wrapped? */
goto|goto
name|calc_rto
goto|;
block|}
comment|/***************************/
comment|/* 2. update RTTVAR& SRTT */
comment|/***************************/
name|net
operator|->
name|rtt
operator|=
name|o_calctime
operator|=
name|calc_time
expr_stmt|;
comment|/* this is Van Jacobson's integer version */
if|if
condition|(
name|net
operator|->
name|RTO_measured
condition|)
block|{
name|calc_time
operator|-=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
expr_stmt|;
comment|/* take away 1/8th when 								 * shift=3 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RTTVAR_LOGGING_ENABLE
condition|)
block|{
name|rto_logging
argument_list|(
name|net
argument_list|,
name|SCTP_LOG_RTTVAR
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|prev_rtt
operator|=
name|o_calctime
expr_stmt|;
name|net
operator|->
name|lastsa
operator|+=
name|calc_time
expr_stmt|;
comment|/* add 7/8th into sa when 						 * shift=3 */
if|if
condition|(
name|calc_time
operator|<
literal|0
condition|)
block|{
name|calc_time
operator|=
operator|-
name|calc_time
expr_stmt|;
block|}
name|calc_time
operator|-=
operator|(
name|net
operator|->
name|lastsv
operator|>>
name|SCTP_RTT_VAR_SHIFT
operator|)
expr_stmt|;
comment|/* take away 1/4 when 									 * VAR shift=2 */
name|net
operator|->
name|lastsv
operator|+=
name|calc_time
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|lastsv
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|lastsv
operator|=
name|SCTP_CLOCK_GRANULARITY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* First RTO measurment */
name|net
operator|->
name|RTO_measured
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|lastsa
operator|=
name|calc_time
operator|<<
name|SCTP_RTT_SHIFT
expr_stmt|;
comment|/* Multiply by 8 when 								 * shift=3 */
name|net
operator|->
name|lastsv
operator|=
name|calc_time
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|lastsv
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|lastsv
operator|=
name|SCTP_CLOCK_GRANULARITY
expr_stmt|;
block|}
name|first_measure
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|prev_rtt
operator|=
name|o_calctime
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RTTVAR_LOGGING_ENABLE
condition|)
block|{
name|rto_logging
argument_list|(
name|net
argument_list|,
name|SCTP_LOG_INITIAL_RTT
argument_list|)
expr_stmt|;
block|}
block|}
name|calc_rto
label|:
name|new_rto
operator|=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
operator|+
name|net
operator|->
name|lastsv
expr_stmt|;
if|if
condition|(
operator|(
name|new_rto
operator|>
name|SCTP_SAT_NETWORK_MIN
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sat_network_lockout
operator|==
literal|0
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|first_measure
operator|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sat_network_lockout
operator|=
literal|1
expr_stmt|;
block|}
comment|/* bound it, per C6/C7 in Section 5.3.1 */
if|if
condition|(
name|new_rto
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|new_rto
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|new_rto
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|new_rto
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
comment|/* we are now returning the RTO */
return|return
operator|(
name|new_rto
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return a pointer to a contiguous piece of data from the given mbuf chain  * starting at 'off' for 'len' bytes.  If the desired piece spans more than  * one mbuf, a copy is made at 'ptr'. caller must ensure that the buffer size  * is>= 'len' returns NULL if there there isn't 'len' bytes in the chain.  */
end_comment

begin_function
name|caddr_t
name|sctp_m_getptr
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|len
parameter_list|,
name|uint8_t
modifier|*
name|in_ptr
parameter_list|)
block|{
name|uint32_t
name|count
decl_stmt|;
name|uint8_t
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|in_ptr
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|<
literal|0
operator|)
operator|||
operator|(
name|len
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* find the desired start location */
while|while
condition|(
operator|(
name|m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|off
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|off
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
condition|)
break|break;
name|off
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* is the current mbuf large enough (eg. contiguous)? */
if|if
condition|(
operator|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|-
name|off
operator|)
operator|>=
name|len
condition|)
block|{
return|return
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
operator|)
return|;
block|}
else|else
block|{
comment|/* else, it spans more than one mbuf, so save a temp copy... */
while|while
condition|(
operator|(
name|m
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
block|{
name|count
operator|=
name|min
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|-
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|off
argument_list|,
name|ptr
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|len
operator|-=
name|count
expr_stmt|;
name|ptr
operator|+=
name|count
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|m
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|len
operator|>
literal|0
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
operator|(
name|caddr_t
operator|)
name|in_ptr
operator|)
return|;
block|}
block|}
end_function

begin_function
name|struct
name|sctp_paramhdr
modifier|*
name|sctp_get_next_param
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_paramhdr
modifier|*
name|pull
parameter_list|,
name|int
name|pull_limit
parameter_list|)
block|{
comment|/* This just provides a typed signature to Peter's Pull routine */
return|return
operator|(
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|pull_limit
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|pull
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_add_pad_tombuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|padlen
parameter_list|)
block|{
comment|/* 	 * add padlen bytes of 0 filled padding to the end of the mbuf. If 	 * padlen is> 3 this routine will fail. 	 */
name|uint8_t
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|padlen
operator|>
literal|3
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|padlen
operator|<=
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
condition|)
block|{
comment|/* 		 * The easy way. We hope the majority of the time we hit 		 * here :) 		 */
name|dp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|padlen
expr_stmt|;
block|}
else|else
block|{
comment|/* Hard way we must grow the mbuf */
name|struct
name|mbuf
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|padlen
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
comment|/* Out of space GAK! we are in big trouble. */
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
comment|/* setup and insert in middle */
name|SCTP_BUF_LEN
argument_list|(
name|tmp
argument_list|)
operator|=
name|padlen
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|tmp
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|tmp
expr_stmt|;
name|dp
operator|=
name|mtod
argument_list|(
name|tmp
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* zero out the pad */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|padlen
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dp
operator|=
literal|0
expr_stmt|;
name|dp
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_pad_lastmbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|padval
parameter_list|,
name|struct
name|mbuf
modifier|*
name|last_mbuf
parameter_list|)
block|{
comment|/* find the last mbuf in chain and pad it */
name|struct
name|mbuf
modifier|*
name|m_at
decl_stmt|;
name|m_at
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|last_mbuf
condition|)
block|{
return|return
operator|(
name|sctp_add_pad_tombuf
argument_list|(
name|last_mbuf
argument_list|,
name|padval
argument_list|)
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|m_at
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|sctp_add_pad_tombuf
argument_list|(
name|m_at
argument_list|,
name|padval
argument_list|)
operator|)
return|;
block|}
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_assoc_change
parameter_list|(
name|uint32_t
name|event
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_assoc_change
modifier|*
name|sac
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * For TCP model AND UDP connected sockets we will send an error up 	 * when an ABORT comes in. 	 */
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
operator|(
name|event
operator|==
name|SCTP_COMM_LOST
operator|)
operator|||
operator|(
name|event
operator|==
name|SCTP_CANT_STR_ASSOC
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNREFUSED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|ECONNREFUSED
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
comment|/* Wake ANY sleepers */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|socantrcvmore
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sac
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_assoc_change
operator|*
argument_list|)
expr_stmt|;
name|sac
operator|->
name|sac_type
operator|=
name|SCTP_ASSOC_CHANGE
expr_stmt|;
name|sac
operator|->
name|sac_flags
operator|=
literal|0
expr_stmt|;
name|sac
operator|->
name|sac_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
expr_stmt|;
name|sac
operator|->
name|sac_state
operator|=
name|event
expr_stmt|;
name|sac
operator|->
name|sac_error
operator|=
name|error
expr_stmt|;
comment|/* XXX verify these stream counts */
name|sac
operator|->
name|sac_outbound_streams
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
name|sac
operator|->
name|sac_inbound_streams
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
expr_stmt|;
name|sac
operator|->
name|sac_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_change
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|==
name|SCTP_COMM_LOST
condition|)
block|{
comment|/* Wake up any sleeper */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|sctp_sowwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_peer_addr_change
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|state
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint32_t
name|error
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_paddr_change
modifier|*
name|spc
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|spc
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_paddr_change
operator|*
argument_list|)
expr_stmt|;
name|spc
operator|->
name|spc_type
operator|=
name|SCTP_PEER_ADDR_CHANGE
expr_stmt|;
name|spc
operator|->
name|spc_flags
operator|=
literal|0
expr_stmt|;
name|spc
operator|->
name|spc_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|memcpy
argument_list|(
operator|&
name|spc
operator|->
name|spc_aaddr
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|spc
operator|->
name|spc_aaddr
argument_list|,
name|sa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|spc
operator|->
name|spc_aaddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
comment|/* recover scope_id for user */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* clear embedded scope_id for user */
name|in6_clearscope
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
name|spc
operator|->
name|spc_state
operator|=
name|state
expr_stmt|;
name|spc
operator|->
name|spc_error
operator|=
name|error
expr_stmt|;
name|spc
operator|->
name|spc_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddr_change
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_send_failed
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_send_failed
modifier|*
name|ssf
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
operator|+
name|chk
operator|->
name|send_size
expr_stmt|;
name|length
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ssf
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_send_failed
operator|*
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_type
operator|=
name|SCTP_SEND_FAILED
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|SCTP_NOTIFY_DATAGRAM_UNSENT
condition|)
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_UNSENT
expr_stmt|;
else|else
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_SENT
expr_stmt|;
name|ssf
operator|->
name|ssf_length
operator|=
name|length
expr_stmt|;
name|ssf
operator|->
name|ssf_error
operator|=
name|error
expr_stmt|;
comment|/* not exactly what the user sent in, but should be close :) */
name|bzero
argument_list|(
operator|&
name|ssf
operator|->
name|ssf_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ssf
operator|->
name|ssf_info
argument_list|)
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_stream
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ssn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_context
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
comment|/* 		 * trim off the sctp chunk header(it should be there) 		 */
if|if
condition|(
name|chk
operator|->
name|send_size
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
condition|)
block|{
name|m_adj
argument_list|(
name|chk
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_mbuf_crush
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
expr_stmt|;
comment|/* Steal off the mbuf */
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For this case, we check the actual socket buffer, since the assoc 	 * is going away we don't want to overfill the socket buffer for a 	 * non-reader 	 */
if|if
condition|(
name|sctp_sbspace_failedmsgs
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_send_failed2
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_send_failed
modifier|*
name|ssf
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|int
name|length
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
operator|+
name|sp
operator|->
name|length
expr_stmt|;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|ssf
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_send_failed
operator|*
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_type
operator|=
name|SCTP_SEND_FAILED
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|SCTP_NOTIFY_DATAGRAM_UNSENT
condition|)
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_UNSENT
expr_stmt|;
else|else
name|ssf
operator|->
name|ssf_flags
operator|=
name|SCTP_DATA_SENT
expr_stmt|;
name|ssf
operator|->
name|ssf_length
operator|=
name|length
expr_stmt|;
name|ssf
operator|->
name|ssf_error
operator|=
name|error
expr_stmt|;
comment|/* not exactly what the user sent in, but should be close :) */
name|bzero
argument_list|(
operator|&
name|ssf
operator|->
name|ssf_info
argument_list|,
sizeof|sizeof
argument_list|(
name|ssf
operator|->
name|ssf_info
argument_list|)
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_stream
operator|=
name|sp
operator|->
name|stream
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ssn
operator|=
name|sp
operator|->
name|strseq
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_flags
operator|=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
block|}
else|else
block|{
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_flags
operator|=
name|SCTP_DATA_NOT_FRAG
expr_stmt|;
block|}
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_ppid
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|ssf
operator|->
name|ssf_info
operator|.
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|ssf
operator|->
name|ssf_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_send_failed
argument_list|)
expr_stmt|;
comment|/* Steal off the mbuf */
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * For this case, we check the actual socket buffer, since the assoc 	 * is going away we don't want to overfill the socket buffer for a 	 * non-reader 	 */
if|if
condition|(
name|sctp_sbspace_failedmsgs
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_adaptation_layer
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_adaptation_event
modifier|*
name|sai
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaption_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sai
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_adaptation_event
operator|*
argument_list|)
expr_stmt|;
name|sai
operator|->
name|sai_type
operator|=
name|SCTP_ADAPTATION_INDICATION
expr_stmt|;
name|sai
operator|->
name|sai_flags
operator|=
literal|0
expr_stmt|;
name|sai
operator|->
name|sai_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_event
argument_list|)
expr_stmt|;
name|sai
operator|->
name|sai_adaptation_ind
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_adaptation
expr_stmt|;
name|sai
operator|->
name|sai_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This always must be called with the read-queue LOCKED in the INP */
end_comment

begin_function
specifier|static
name|void
name|sctp_notify_partial_delivery_indication
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_pdapi_event
modifier|*
name|pdapi
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sockbuf
modifier|*
name|sb
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_CANT_READ
condition|)
block|{
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|pdapi
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_pdapi_event
operator|*
argument_list|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_type
operator|=
name|SCTP_PARTIAL_DELIVERY_EVENT
expr_stmt|;
name|pdapi
operator|->
name|pdapi_flags
operator|=
literal|0
expr_stmt|;
name|pdapi
operator|->
name|pdapi_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_indication
operator|=
name|error
expr_stmt|;
name|pdapi
operator|->
name|pdapi_stream
operator|=
operator|(
name|val
operator|>>
literal|16
operator|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_seq
operator|=
operator|(
name|val
operator|&
literal|0x0000ffff
operator|)
expr_stmt|;
name|pdapi
operator|->
name|pdapi_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pdapi_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|sb
operator|=
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
name|sb
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
condition|)
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|read_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* we really should not see this case */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|&&
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
comment|/* This should always be the case */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_shutdown_event
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_shutdown_event
modifier|*
name|sse
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
comment|/* 	 * For TCP model AND UDP connected sockets we will send an error up 	 * when an SHUTDOWN completes 	 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* mark socket closed for read/write and wakeup! */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|socantsendmore
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|sse
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_shutdown_event
operator|*
argument_list|)
expr_stmt|;
name|sse
operator|->
name|sse_type
operator|=
name|SCTP_SHUTDOWN_EVENT
expr_stmt|;
name|sse
operator|->
name|sse_flags
operator|=
literal|0
expr_stmt|;
name|sse
operator|->
name|sse_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
expr_stmt|;
name|sse
operator|->
name|sse_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_sender_dry_event
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_sender_dry_event
modifier|*
name|event
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
block|{
comment|/* no space left */
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|event
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_sender_dry_event
operator|*
argument_list|)
expr_stmt|;
name|event
operator|->
name|sender_dry_type
operator|=
name|SCTP_SENDER_DRY_EVENT
expr_stmt|;
name|event
operator|->
name|sender_dry_flags
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|sender_dry_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
expr_stmt|;
name|event
operator|->
name|sender_dry_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sender_dry_event
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_stream_reset_add
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_stream_reset_event
modifier|*
name|strreset
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_event
argument_list|)
operator|+
operator|(
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* never enough room */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|strreset
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_stream_reset_event
operator|*
argument_list|)
expr_stmt|;
name|strreset
operator|->
name|strreset_type
operator|=
name|SCTP_STREAM_RESET_EVENT
expr_stmt|;
name|strreset
operator|->
name|strreset_flags
operator|=
name|SCTP_STRRESET_ADD_STREAM
operator||
name|flag
expr_stmt|;
name|strreset
operator|->
name|strreset_length
operator|=
name|len
expr_stmt|;
name|strreset
operator|->
name|strreset_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|strreset
operator|->
name|strreset_list
index|[
literal|0
index|]
operator|=
name|number_entries
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* no space */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_stream_reset_event
modifier|*
name|strreset
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
condition|)
block|{
comment|/* event not enabled */
return|return;
block|}
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_event
argument_list|)
operator|+
operator|(
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|M_TRAILINGSPACE
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* never enough room */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|strreset
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_stream_reset_event
operator|*
argument_list|)
expr_stmt|;
name|strreset
operator|->
name|strreset_type
operator|=
name|SCTP_STREAM_RESET_EVENT
expr_stmt|;
if|if
condition|(
name|number_entries
operator|==
literal|0
condition|)
block|{
name|strreset
operator|->
name|strreset_flags
operator|=
name|flag
operator||
name|SCTP_STRRESET_ALL_STREAMS
expr_stmt|;
block|}
else|else
block|{
name|strreset
operator|->
name|strreset_flags
operator|=
name|flag
operator||
name|SCTP_STRRESET_STREAM_LIST
expr_stmt|;
block|}
name|strreset
operator|->
name|strreset_length
operator|=
name|len
expr_stmt|;
name|strreset
operator|->
name|strreset_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|strreset
operator|->
name|strreset_list
index|[
name|i
index|]
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
operator|<
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
condition|)
block|{
comment|/* no space */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_ulp_notify
parameter_list|(
name|uint32_t
name|notification
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|error
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
comment|/* If the socket is gone we are out of here */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|notification
operator|==
name|SCTP_NOTIFY_INTERFACE_DOWN
operator|)
operator|||
operator|(
name|notification
operator|==
name|SCTP_NOTIFY_INTERFACE_UP
operator|)
operator|||
operator|(
name|notification
operator|==
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
operator|)
condition|)
block|{
comment|/* Don't report these in front states */
return|return;
block|}
block|}
switch|switch
condition|(
name|notification
condition|)
block|{
case|case
name|SCTP_NOTIFY_ASSOC_UP
case|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_up_sent
operator|==
literal|0
condition|)
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_COMM_UP
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|assoc_up_sent
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|adaptation_needed
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|adaptation_sent
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_notify_adaptation_layer
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|==
literal|0
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_NO_PEER_AUTH
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_ASSOC_DOWN
case|:
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_SHUTDOWN_COMP
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_INTERFACE_DOWN
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|data
expr_stmt|;
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_UNREACHABLE
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_INTERFACE_UP
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|data
expr_stmt|;
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_AVAILABLE
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|net
operator|=
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|data
expr_stmt|;
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_CONFIRMED
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
case|:
name|sctp_notify_send_failed2
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
expr|struct
name|sctp_stream_queue_pending
operator|*
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_DG_FAIL
case|:
name|sctp_notify_send_failed
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
expr|struct
name|sctp_tmit_chunk
operator|*
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
case|:
block|{
name|uint32_t
name|val
decl_stmt|;
name|val
operator|=
operator|*
operator|(
operator|(
name|uint32_t
operator|*
operator|)
name|data
operator|)
expr_stmt|;
name|sctp_notify_partial_delivery_indication
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
name|val
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_NOTIFY_STRDATA_ERR
case|:
break|break;
case|case
name|SCTP_NOTIFY_ASSOC_ABORTED
case|:
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
operator|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
operator|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|)
condition|)
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_CANT_STR_ASSOC
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_COMM_LOST
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_PEER_OPENED_STREAM
case|:
break|break;
case|case
name|SCTP_NOTIFY_STREAM_OPENED_OK
case|:
break|break;
case|case
name|SCTP_NOTIFY_ASSOC_RESTART
case|:
name|sctp_notify_assoc_change
argument_list|(
name|SCTP_RESTART
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
operator|==
literal|0
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_NO_PEER_AUTH
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_NOTIFY_HB_RESP
case|:
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_INSTREAM_ADD_OK
case|:
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
name|SCTP_STRRESET_INBOUND_STR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_ADD_OK
case|:
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
name|SCTP_STRRESET_OUTBOUND_STR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_ADD_FAIL
case|:
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
name|SCTP_STRRESET_FAILED
operator||
name|SCTP_STRRESET_OUTBOUND_STR
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_SEND
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
name|SCTP_STRRESET_OUTBOUND_STR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_RECV
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
name|SCTP_STRRESET_INBOUND_STR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_FAILED_OUT
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|(
name|SCTP_STRRESET_OUTBOUND_STR
operator||
name|SCTP_STRRESET_FAILED
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_STR_RESET_FAILED_IN
case|:
name|sctp_notify_stream_reset
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|data
operator|)
argument_list|,
operator|(
name|SCTP_STRRESET_INBOUND_STR
operator||
name|SCTP_STRRESET_FAILED
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_ADD_IP
case|:
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_ADDED
argument_list|,
name|data
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_DELETE_IP
case|:
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_REMOVED
argument_list|,
name|data
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_SET_PRIMARY
case|:
name|sctp_notify_peer_addr_change
argument_list|(
name|stcb
argument_list|,
name|SCTP_ADDR_MADE_PRIM
argument_list|,
name|data
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_SUCCESS
case|:
break|break;
case|case
name|SCTP_NOTIFY_ASCONF_FAILED
case|:
break|break;
case|case
name|SCTP_NOTIFY_PEER_SHUTDOWN
case|:
name|sctp_notify_shutdown_event
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_AUTH_NEW_KEY
case|:
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_NEWKEY
argument_list|,
name|error
argument_list|,
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_AUTH_FREE_KEY
case|:
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_FREE_KEY
argument_list|,
name|error
argument_list|,
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_NO_PEER_AUTH
case|:
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_NO_AUTH
argument_list|,
name|error
argument_list|,
operator|(
name|uint16_t
operator|)
operator|(
name|uintptr_t
operator|)
name|data
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFY_SENDER_DRY
case|:
name|sctp_notify_sender_dry_event
argument_list|(
name|stcb
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_UTIL1
argument_list|,
literal|"%s: unknown notification %xh (%u)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|notification
argument_list|,
name|notification
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end switch */
block|}
end_function

begin_function
name|void
name|sctp_report_all_outbound
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|holds_lock
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* already being freed */
return|return;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
return|return;
block|}
comment|/* now through all the gunk freeing chunks */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* sent queue SHOULD be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_SENT
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
comment|/* pending send queue SHOULD be empty */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_UNSENT
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* For each stream */
name|outs
operator|=
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
expr_stmt|;
comment|/* clean up any sends there */
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&outs->outqueue
argument_list|,
argument|next
argument_list|,
argument|nsp
argument_list|)
block|{
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_spbufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_UNSENT
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sp
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free the chunk */
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
block|}
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_abort_notification
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|error
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
return|return;
block|}
comment|/* Tell them we lost the asoc */
name|sctp_report_all_outbound
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|)
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_WAS_ABORTED
expr_stmt|;
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_ABORTED
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_abort_association
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|uint32_t
name|vtag
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|vtag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* We have a TCB to abort, send notification too */
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* get the assoc vrf id and table id */
name|vrf_id
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_WAS_ABORTED
expr_stmt|;
block|}
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|vtag
argument_list|,
name|op_err
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Ok, now lets free it */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
end_ifdef

begin_function
name|void
name|sctp_print_out_track_log
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NOSIY_PRINTS
name|int
name|i
decl_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"Last ep reason:%x\n"
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"IN bound TSN log-aaa\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_wrapped
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"None rcvd\n"
argument_list|)
expr_stmt|;
goto|goto
name|none_in
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_wrapped
condition|)
block|{
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
init|;
name|i
operator|<
name|SCTP_TSN_LOG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|tsn_in_at
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|in_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
name|none_in
label|:
name|SCTP_PRINTF
argument_list|(
literal|"OUT bound TSN log-aaa\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_wrapped
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"None sent\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_wrapped
condition|)
block|{
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
init|;
name|i
operator|<
name|SCTP_TSN_LOG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|tsn_out_at
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x strm:%d seq:%d flags:%x sz:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|strm
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|flgs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|out_tsnlog
index|[
name|i
index|]
operator|.
name|sz
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_abort_an_association
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|uint32_t
name|vtag
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Got to have a TCB */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_DIRECTLY_NOCMPSET
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_WAS_ABORTED
expr_stmt|;
block|}
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
comment|/* notify the ulp */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
name|error
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* notify the peer */
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"aborting an association"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
comment|/* now free the asoc */
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|sctp_print_out_track_log
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sctp_handle_ootb
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|unsigned
name|int
name|chk_length
decl_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_outoftheblue
argument_list|)
expr_stmt|;
comment|/* Generate a TO address for future reference */
if|if
condition|(
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
if|if
condition|(
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_DIRECTLY_NOCMPSET
argument_list|)
expr_stmt|;
block|}
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|NULL
condition|)
block|{
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
comment|/* break to abort land */
break|break;
block|}
switch|switch
condition|(
name|ch
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_COOKIE_ECHO
case|:
comment|/* We hit here only if the assoc is being freed */
return|return;
case|case
name|SCTP_PACKET_DROPPED
case|:
comment|/* we don't respond to pkt-dropped */
return|return;
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
comment|/* we don't respond with an ABORT to an ABORT */
return|return;
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
comment|/* 			 * we ignore it since we are not waiting for it and 			 * peer is gone 			 */
return|return;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
name|sctp_send_shutdown_complete2
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * check the inbound datagram to make sure there is not an abort inside it,  * if there is return 1, else return 0.  */
end_comment

begin_function
name|int
name|sctp_is_there_an_abort_here
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|uint32_t
modifier|*
name|vtagfill
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init_chk
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|unsigned
name|int
name|chk_length
decl_stmt|;
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|NULL
condition|)
block|{
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
comment|/* packet is probably corrupt */
break|break;
block|}
comment|/* we seem to be ok, is it an abort? */
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ABORT_ASSOCIATION
condition|)
block|{
comment|/* yep, tell them */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
condition|)
block|{
comment|/* need to update the Vtag */
name|init_chk
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|init_chk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_chk
operator|!=
name|NULL
condition|)
block|{
operator|*
name|vtagfill
operator|=
name|ntohl
argument_list|(
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Nope, move to the next chunk */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * currently (2/02), ifa_addr embeds scope_id's and don't have sin6_scope_id  * set (i.e. it's 0) so, create this function to compare link local scopes  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|uint32_t
name|sctp_is_same_scope
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|addr1
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|addr2
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|a
decl_stmt|,
name|b
decl_stmt|;
comment|/* save copies */
name|a
operator|=
operator|*
name|addr1
expr_stmt|;
name|b
operator|=
operator|*
name|addr2
expr_stmt|;
if|if
condition|(
name|a
operator|.
name|sin6_scope_id
operator|==
literal|0
condition|)
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|a
argument_list|)
condition|)
block|{
comment|/* can't get scope, so can't match */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|b
operator|.
name|sin6_scope_id
operator|==
literal|0
condition|)
if|if
condition|(
name|sa6_recoverscope
argument_list|(
operator|&
name|b
argument_list|)
condition|)
block|{
comment|/* can't get scope, so can't match */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|a
operator|.
name|sin6_scope_id
operator|!=
name|b
operator|.
name|sin6_scope_id
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns a sockaddr_in6 with embedded scope recovered and removed  */
end_comment

begin_function
name|struct
name|sockaddr_in6
modifier|*
name|sctp_recover_scope
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|addr
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|store
parameter_list|)
block|{
comment|/* check and strip embedded scope junk */
if|if
condition|(
name|addr
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
operator|*
name|store
operator|=
operator|*
name|addr
expr_stmt|;
if|if
condition|(
operator|!
name|sa6_recoverscope
argument_list|(
name|store
argument_list|)
condition|)
block|{
comment|/* use the recovered scope */
name|addr
operator|=
name|store
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* else, return the original "to" addr */
name|in6_clearscope
argument_list|(
operator|&
name|addr
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * are the two addresses the same?  currently a "scopeless" check returns: 1  * if same, 0 if not  */
end_comment

begin_function
name|int
name|sctp_cmpaddr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa1
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa2
parameter_list|)
block|{
comment|/* must be valid */
if|if
condition|(
name|sa1
operator|==
name|NULL
operator|||
name|sa2
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* must be the same family */
if|if
condition|(
name|sa1
operator|->
name|sa_family
operator|!=
name|sa2
operator|->
name|sa_family
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|sa1
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* IPv6 addresses */
name|struct
name|sockaddr_in6
modifier|*
name|sin6_1
decl_stmt|,
modifier|*
name|sin6_2
decl_stmt|;
name|sin6_1
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa1
expr_stmt|;
name|sin6_2
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa2
expr_stmt|;
return|return
operator|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sin6_1
argument_list|,
name|sin6_2
argument_list|)
operator|)
return|;
block|}
endif|#
directive|endif
case|case
name|AF_INET
case|:
block|{
comment|/* IPv4 addresses */
name|struct
name|sockaddr_in
modifier|*
name|sin_1
decl_stmt|,
modifier|*
name|sin_2
decl_stmt|;
name|sin_1
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa1
expr_stmt|;
name|sin_2
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa2
expr_stmt|;
return|return
operator|(
name|sin_1
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sin_2
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
return|;
block|}
default|default:
comment|/* we don't do these... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_print_address
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|char
name|ip6buf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|ip6buf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"IPv6 address: %s:port:%d scope:%u\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|ip6buf
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
argument_list|,
name|sin6
operator|->
name|sin6_scope_id
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
name|p
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|sin
operator|->
name|sin_addr
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"IPv4 address: %u.%u.%u.%u:%d\n"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|SCTP_PRINTF
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|void
name|sctp_print_address_pkt
parameter_list|(
name|struct
name|ip
modifier|*
name|iph
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|)
block|{
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
case|case
name|IPVERSION
case|:
block|{
name|struct
name|sockaddr_in
name|lsa
decl_stmt|,
name|fsa
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|lsa
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa
argument_list|)
argument_list|)
expr_stmt|;
name|lsa
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa
argument_list|)
expr_stmt|;
name|lsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|lsa
operator|.
name|sin_addr
operator|=
name|iph
operator|->
name|ip_src
expr_stmt|;
name|lsa
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fsa
argument_list|,
sizeof|sizeof
argument_list|(
name|fsa
argument_list|)
argument_list|)
expr_stmt|;
name|fsa
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|fsa
argument_list|)
expr_stmt|;
name|fsa
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|fsa
operator|.
name|sin_addr
operator|=
name|iph
operator|->
name|ip_dst
expr_stmt|;
name|fsa
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"src: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|lsa
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"dest: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|fsa
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
name|lsa6
decl_stmt|,
name|fsa6
decl_stmt|;
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|iph
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|lsa6
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa6
argument_list|)
argument_list|)
expr_stmt|;
name|lsa6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa6
argument_list|)
expr_stmt|;
name|lsa6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|lsa6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|lsa6
operator|.
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fsa6
argument_list|,
sizeof|sizeof
argument_list|(
name|fsa6
argument_list|)
argument_list|)
expr_stmt|;
name|fsa6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|fsa6
argument_list|)
expr_stmt|;
name|fsa6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|fsa6
operator|.
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|fsa6
operator|.
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"src: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|lsa6
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"dest: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|fsa6
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
end_function

begin_function
name|void
name|sctp_pull_off_control_to_new_inp
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|old_inp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|new_inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|waitflags
parameter_list|)
block|{
comment|/* 	 * go through our old INP and pull off any control structures that 	 * belong to stcb and move then to the new inp. 	 */
name|struct
name|socket
modifier|*
name|old_so
decl_stmt|,
modifier|*
name|new_so
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
name|struct
name|sctp_readhead
name|tmp_queue
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|old_so
operator|=
name|old_inp
operator|->
name|sctp_socket
expr_stmt|;
name|new_so
operator|=
name|new_inp
operator|->
name|sctp_socket
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|tmp_queue
argument_list|)
expr_stmt|;
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|waitflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * Gak, can't get sblock, we have a problem. data will be 		 * left stranded.. and we don't dare look at it since the 		 * other thread may be reading something. Oh well, its a 		 * screwed up app that does a peeloff OR a accept while 		 * reading from the main socket... actually its only the 		 * peeloff() case, since I think read will fail on a 		 * listening socket.. 		 */
return|return;
block|}
comment|/* lock the socket buffers */
name|SCTP_INP_READ_LOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&old_inp->read_queue
argument_list|,
argument|next
argument_list|,
argument|nctl
argument_list|)
block|{
comment|/* Pull off all for out target stcb */
if|if
condition|(
name|control
operator|->
name|stcb
operator|==
name|stcb
condition|)
block|{
comment|/* remove it we want it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|old_inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tmp_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sbfree
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|old_inp
argument_list|)
expr_stmt|;
comment|/* Remove the sb-lock on the old socket */
name|sbunlock
argument_list|(
operator|&
name|old_so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now we move them over to the new socket buffer */
name|SCTP_INP_READ_LOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&tmp_queue
argument_list|,
argument|next
argument_list|,
argument|nctl
argument_list|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|new_inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|new_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
operator|&
name|new_so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|new_so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|new_inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_add_to_readq
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|inp_read_lock_held
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/* 	 * Here we must place the control on the end of the socket read 	 * queue AND increment sb_cc so that select will work properly on 	 * read. 	 */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* Gak, TSNH!! */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Gak, inp NULL on add_to_readq"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_CANT_READ
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|inp
operator|->
name|total_recvs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|control
operator|->
name|do_not_ref_stcb
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|total_recvs
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip mbufs with NO length */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First one */
name|control
operator|->
name|data
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
continue|continue;
block|}
name|prev
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
name|sb
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
comment|/* Everything got collapsed out?? */
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_readq
argument_list|)
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|end
condition|)
block|{
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_read_lock_held
operator|==
literal|0
condition|)
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|&&
name|inp
operator|->
name|sctp_socket
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_append_to_readq
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|ctls_cumack
parameter_list|,
name|struct
name|sockbuf
modifier|*
name|sb
parameter_list|)
block|{
comment|/* 	 * A partial delivery API event is underway. OR we are appending on 	 * the reassembly queue. 	 *  	 * If PDAPI this means we need to add m to the end of the data. 	 * Increase the length in the control AND increment the sb_cc. 	 * Otherwise sb is NULL and all we need to do is put it at the end 	 * of the mbuf chain. 	 */
name|int
name|len
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|,
modifier|*
name|tail
init|=
name|NULL
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
name|get_out
label|:
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_CANT_READ
operator|)
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
comment|/* huh this one is complete? */
goto|goto
name|get_out
goto|;
block|}
name|mm
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
goto|goto
name|get_out
goto|;
block|}
while|while
condition|(
name|mm
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|mm
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip mbufs with NO lenght */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First one */
name|m
operator|=
name|sctp_m_free
argument_list|(
name|mm
argument_list|)
expr_stmt|;
name|mm
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
operator|=
name|sctp_m_free
argument_list|(
name|mm
argument_list|)
expr_stmt|;
name|mm
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|prev
operator|=
name|mm
expr_stmt|;
name|len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBALLOC
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|mm
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
name|sb
argument_list|,
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
name|sb
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|mm
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|tail
operator|=
name|prev
expr_stmt|;
block|}
else|else
block|{
comment|/* Really there should always be a prev */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Huh nothing left? */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Nothing left to add?"
argument_list|)
expr_stmt|;
else|#
directive|else
goto|goto
name|get_out
goto|;
endif|#
directive|endif
block|}
name|tail
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|tail_mbuf
condition|)
block|{
comment|/* append */
name|SCTP_BUF_NEXT
argument_list|(
name|control
operator|->
name|tail_mbuf
argument_list|)
operator|=
name|m
expr_stmt|;
name|control
operator|->
name|tail_mbuf
operator|=
name|tail
expr_stmt|;
block|}
else|else
block|{
comment|/* nothing there */
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"This should NOT happen"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|control
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|control
operator|->
name|tail_mbuf
operator|=
name|tail
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
comment|/* message is complete */
if|if
condition|(
name|stcb
operator|&&
operator|(
name|control
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
block|}
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|do_not_ref_stcb
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * When we are appending in partial delivery, the cum-ack is used 	 * for the actual pd-api highest tsn on this mbuf. The true cum-ack 	 * is populated in the outbound sinfo structure from the true cumack 	 * if the association exists... 	 */
name|control
operator|->
name|sinfo_tsn
operator|=
name|control
operator|->
name|sinfo_cumtsn
operator|=
name|ctls_cumack
expr_stmt|;
if|if
condition|(
name|inp
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|&&
name|inp
operator|->
name|sctp_socket
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ZERO_COPY_ACTIVE
argument_list|)
condition|)
block|{
name|SCTP_ZERO_COPY_EVENT
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*************HOLD THIS COMMENT FOR PATCH FILE OF  *************ALTERNATE ROUTING CODE  */
end_comment

begin_comment
comment|/*************HOLD THIS COMMENT FOR END OF PATCH FILE OF  *************ALTERNATE ROUTING CODE  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_generate_invmanparam
parameter_list|(
name|int
name|err
parameter_list|)
block|{
comment|/* Return a MBUF with a invalid mandatory parameter */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_MBCNT_LOGGING
end_ifdef

begin_function
name|void
name|sctp_free_bufspace
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
parameter_list|,
name|int
name|chk_cnt
parameter_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|->
name|chunks_on_out_queue
operator|-=
name|chk_cnt
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBCNT_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mbcnt
argument_list|(
name|SCTP_LOG_MBCNT_DECREASE
argument_list|,
name|asoc
operator|->
name|total_output_queue_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
literal|0
argument_list|,
name|tp1
operator|->
name|mbcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|total_output_queue_size
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|total_output_queue_size
argument_list|,
operator|-
name|tp1
operator|->
name|book_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|&&
operator|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_release_pr_sctp_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
parameter_list|,
name|int
name|reason
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|strq
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
init|=
name|NULL
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|uint16_t
name|stream
init|=
literal|0
decl_stmt|,
name|seq
init|=
literal|0
decl_stmt|;
name|uint8_t
name|foundeom
init|=
literal|0
decl_stmt|;
name|int
name|ret_sz
init|=
literal|0
decl_stmt|;
name|int
name|notdone
decl_stmt|;
name|int
name|do_wakeup_routine
init|=
literal|0
decl_stmt|;
name|stream
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|seq
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
do|do
block|{
name|ret_sz
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|reason
argument_list|,
name|tp1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|do_wakeup_routine
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_FORWARD_TSN_SKIP
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
comment|/* not frag'ed we ae done   */
name|notdone
operator|=
literal|0
expr_stmt|;
name|foundeom
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* end of frag, we are done */
name|notdone
operator|=
literal|0
expr_stmt|;
name|foundeom
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Its a begin or middle piece, we must mark all of 			 * it 			 */
name|notdone
operator|=
literal|1
expr_stmt|;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|tp1
operator|&&
name|notdone
condition|)
do|;
if|if
condition|(
name|foundeom
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The multi-part message was scattered across the send and 		 * sent queue. 		 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|tp2
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|stream
operator|)
operator|||
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|seq
operator|)
condition|)
block|{
break|break;
block|}
comment|/* 			 * save to chk in case we have some on stream out 			 * queue. If so and we have an un-transmitted one we 			 * don't have to fudge the TSN. 			 */
name|chk
operator|=
name|tp1
expr_stmt|;
name|ret_sz
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
name|reason
argument_list|,
name|tp1
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* No flight involved here book the size to 0 */
name|tp1
operator|->
name|book_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|foundeom
operator|=
literal|1
expr_stmt|;
block|}
name|do_wakeup_routine
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|sent
operator|=
name|SCTP_FORWARD_TSN_SKIP
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 			 * on to the sent queue so we can wait for it to be 			 * passed by. 			 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|send_queue_cnt
operator|--
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|foundeom
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Still no eom found. That means there is stuff left on the 		 * stream out queue.. yuck. 		 */
name|strq
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|stream
index|]
expr_stmt|;
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&strq->outqueue
argument_list|,
argument|next
argument_list|)
block|{
comment|/* FIXME: Shouldn't this be a serial number check? */
if|if
condition|(
name|sp
operator|->
name|strseq
operator|>
name|seq
condition|)
block|{
break|break;
block|}
comment|/* Check if its our SEQ */
if|if
condition|(
name|sp
operator|->
name|strseq
operator|==
name|seq
condition|)
block|{
name|sp
operator|->
name|discard_rest
operator|=
literal|1
expr_stmt|;
comment|/* 				 * We may need to put a chunk on the queue 				 * that holds the TSN that would have been 				 * sent with the LAST bit. 				 */
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* Yep, we have to */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* 						 * we are hosed. All we can 						 * do is nothing.. which 						 * will cause an abort if 						 * the peer is paying 						 * attention. 						 */
goto|goto
name|oh_well
goto|;
block|}
name|memset
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chk
argument_list|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_FORWARD_TSN_SKIP
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|=
name|sp
operator|->
name|strseq
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|=
name|sp
operator|->
name|stream
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
name|sp
operator|->
name|act_flags
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|net
condition|)
name|chk
operator|->
name|whoTo
operator|=
name|sp
operator|->
name|net
expr_stmt|;
else|else
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|pr_sctp_cnt
operator|++
expr_stmt|;
name|chk
operator|->
name|pr_sctp_on
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|pr_sctp_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator||=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
block|}
name|oh_well
label|:
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
comment|/* 					 * Pull any data to free up the SB 					 * and allow sender to "add more" 					 * whilc we will throw away :-) 					 */
name|sctp_free_spbufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|ret_sz
operator|+=
name|sp
operator|->
name|length
expr_stmt|;
name|do_wakeup_routine
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
comment|/* End tailq_foreach */
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_wakeup_routine
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_sz
operator|)
return|;
block|}
block|}
endif|#
directive|endif
name|sctp_sowwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|!
name|so_locked
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|ret_sz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * checks to see if the given address, sa, is one that is currently known by  * the kernel note: can't distinguish the same address on multiple interfaces  * and doesn't handle multiple addresses with different zone/scope id's note:  * ifa_ifwithaddr() compares the entire sockaddr struct  */
end_comment

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_find_ifa_in_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|holds_lock
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|!=
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|laddr
operator|->
name|ifa
operator|)
return|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
argument_list|)
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|laddr
operator|->
name|ifa
operator|)
return|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_get_ifa_hash_val
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|^
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|>>
literal|16
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|uint32_t
name|hash_of_addr
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
name|hash_of_addr
operator|=
operator|(
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|0
index|]
operator|+
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|1
index|]
operator|+
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|+
name|sin6
operator|->
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|3
index|]
operator|)
expr_stmt|;
name|hash_of_addr
operator|=
operator|(
name|hash_of_addr
operator|^
operator|(
name|hash_of_addr
operator|>>
literal|16
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|hash_of_addr
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_find_ifa_by_addr
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
name|holds_lock
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifalist
modifier|*
name|hash_head
decl_stmt|;
name|uint32_t
name|hash_of_addr
decl_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|stage_right
label|:
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hash_of_addr
operator|=
name|sctp_get_ifa_hash_val
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|hash_head
operator|=
operator|&
name|vrf
operator|->
name|vrf_addr_hash
index|[
operator|(
name|hash_of_addr
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
operator|)
index|]
expr_stmt|;
if|if
condition|(
name|hash_head
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"hash_of_addr:%x mask:%x table:%x - "
argument_list|,
name|hash_of_addr
argument_list|,
operator|(
name|uint32_t
operator|)
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|hash_of_addr
operator|&
name|vrf
operator|->
name|vrf_addr_hashmark
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"No such bucket for address\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|hash_head
argument_list|,
argument|next_bucket
argument_list|)
block|{
if|if
condition|(
name|sctp_ifap
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh LIST_FOREACH corrupt"
argument_list|)
expr_stmt|;
goto|goto
name|stage_right
goto|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"LIST corrupt of sctp_ifap's?\n"
argument_list|)
expr_stmt|;
goto|goto
name|stage_right
goto|;
endif|#
directive|endif
block|}
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|!=
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sctp_ifap
operator|)
return|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
argument_list|)
condition|)
block|{
comment|/* found him. */
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|sctp_ifap
operator|)
return|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_user_rcvd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
modifier|*
name|freed_so_far
parameter_list|,
name|int
name|hold_rlock
parameter_list|,
name|uint32_t
name|rwnd_req
parameter_list|)
block|{
comment|/* User pulled some data, do we need a rwnd update? */
name|int
name|r_unlocked
init|=
literal|0
decl_stmt|;
name|uint32_t
name|dif
decl_stmt|,
name|rwnd
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
operator|(
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator||
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator||
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* Pre-check If we are freeing no update */
goto|goto
name|no_lock
goto|;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|so
operator|=
name|stcb
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|freed_by_sorcv_sincelast
argument_list|,
operator|*
name|freed_so_far
argument_list|)
expr_stmt|;
comment|/* Have you have freed enough to look */
operator|*
name|freed_so_far
operator|=
literal|0
expr_stmt|;
comment|/* Yep, its worth a look and the lock overhead */
comment|/* Figure out what the rwnd would be */
name|rwnd
operator|=
name|sctp_calc_rwnd
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwnd
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|my_last_reported_rwnd
condition|)
block|{
name|dif
operator|=
name|rwnd
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|my_last_reported_rwnd
expr_stmt|;
block|}
else|else
block|{
name|dif
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|dif
operator|>=
name|rwnd_req
condition|)
block|{
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|r_unlocked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* 			 * One last check before we allow the guy possibly 			 * to get in. There is a race, where the guy has not 			 * reached the gate. In that case 			 */
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* No reports here */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_wu_sacks_sent
argument_list|)
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_RCVD
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
comment|/* make sure no timer is running */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Update how much we have pending */
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
name|dif
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|so
operator|&&
name|r_unlocked
operator|&&
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|no_lock
label|:
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|sctp_sorecvmsg
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|from
parameter_list|,
name|int
name|fromlen
parameter_list|,
name|int
modifier|*
name|msg_flags
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sinfo
parameter_list|,
name|int
name|filling_sinfo
parameter_list|)
block|{
comment|/* 	 * MSG flags we will look at MSG_DONTWAIT - non-blocking IO. 	 * MSG_PEEK - Look don't touch :-D (only valid with OUT mbuf copy 	 * mp=NULL thus uio is the copy method to userland) MSG_WAITALL - ?? 	 * On the way out we may send out any combination of: 	 * MSG_NOTIFICATION MSG_EOR 	 *  	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|int
name|my_len
init|=
literal|0
decl_stmt|;
name|int
name|cp_len
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
init|=
name|NULL
decl_stmt|,
modifier|*
name|ctl
init|=
name|NULL
decl_stmt|,
modifier|*
name|nxt
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|int
name|wakeup_read_socket
init|=
literal|0
decl_stmt|;
name|int
name|freecnt_applied
init|=
literal|0
decl_stmt|;
name|int
name|out_flags
init|=
literal|0
decl_stmt|,
name|in_flags
init|=
literal|0
decl_stmt|;
name|int
name|block_allowed
init|=
literal|1
decl_stmt|;
name|uint32_t
name|freed_so_far
init|=
literal|0
decl_stmt|;
name|uint32_t
name|copied_so_far
init|=
literal|0
decl_stmt|;
name|int
name|in_eeor_mode
init|=
literal|0
decl_stmt|;
name|int
name|no_rcv_needed
init|=
literal|0
decl_stmt|;
name|uint32_t
name|rwnd_req
init|=
literal|0
decl_stmt|;
name|int
name|hold_sblock
init|=
literal|0
decl_stmt|;
name|int
name|hold_rlock
init|=
literal|0
decl_stmt|;
name|int
name|slen
init|=
literal|0
decl_stmt|;
name|uint32_t
name|held_length
init|=
literal|0
decl_stmt|;
name|int
name|sockbuf_lock
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|uio
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|msg_flags
condition|)
block|{
name|in_flags
operator|=
operator|*
name|msg_flags
expr_stmt|;
if|if
condition|(
name|in_flags
operator|&
name|MSG_PEEK
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_read_peeks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|in_flags
operator|=
literal|0
expr_stmt|;
block|}
name|slen
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
comment|/* Pull in and set up our int flags */
if|if
condition|(
name|in_flags
operator|&
name|MSG_OOB
condition|)
block|{
comment|/* Out of band's NOT supported */
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|&&
operator|(
name|mp
operator|!=
name|NULL
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
operator|(
name|MSG_DONTWAIT
operator||
name|MSG_NBIO
operator|)
operator|)
operator|||
name|SCTP_SO_IS_NBIO
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|block_allowed
operator|=
literal|0
expr_stmt|;
block|}
comment|/* setup the endpoint */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
name|rwnd_req
operator|=
operator|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
operator|>>
name|SCTP_RWND_HIWAT_SHIFT
operator|)
expr_stmt|;
comment|/* Must be at least a MTU's worth */
if|if
condition|(
name|rwnd_req
operator|<
name|SCTP_MIN_RWND
condition|)
name|rwnd_req
operator|=
name|SCTP_MIN_RWND
expr_stmt|;
name|in_eeor_mode
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RECV_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_ENTER
argument_list|,
name|rwnd_req
argument_list|,
name|in_eeor_mode
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RECV_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_ENTERPL
argument_list|,
name|rwnd_req
argument_list|,
name|block_allowed
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sblock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
operator|(
name|block_allowed
condition|?
name|SBL_WAIT
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|sockbuf_lock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|release_unlocked
goto|;
block|}
name|restart
label|:
name|restart_nosblocks
label|:
if|if
condition|(
name|hold_sblock
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
comment|/* indicate EOF */
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|<=
name|held_length
operator|)
operator|&&
name|block_allowed
condition|)
block|{
comment|/* we need to wait for data */
if|if
condition|(
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * For active open side clear flags for 				 * re-use passive open is blocked by 				 * connect. 				 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAS_ABORTED
condition|)
block|{
comment|/* 					 * You were aborted, passive side 					 * always hits here 					 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
comment|/* 					 * You get this once if you are 					 * active open side 					 */
if|if
condition|(
operator|!
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* 						 * Remove flag if on the 						 * active open side 						 */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAS_ABORTED
expr_stmt|;
block|}
block|}
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator||
name|SS_ISCONNECTED
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAS_CONNECTED
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
block|}
block|}
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|held_length
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart_nosblocks
goto|;
block|}
elseif|else
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
block|{
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
name|so
operator|->
name|so_error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * For active open side clear flags 					 * for re-use passive open is 					 * blocked by connect. 					 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAS_ABORTED
condition|)
block|{
comment|/* 						 * You were aborted, passive 						 * side always hits here 						 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
comment|/* 						 * You get this once if you 						 * are active open side 						 */
if|if
condition|(
operator|!
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* 							 * Remove flag if on 							 * the active open 							 * side 							 */
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAS_ABORTED
expr_stmt|;
block|}
block|}
name|so
operator|->
name|so_state
operator|&=
operator|~
operator|(
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator||
name|SS_ISCONFIRMING
operator||
name|SS_ISCONNECTED
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAS_CONNECTED
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
block|}
block|}
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hold_sblock
operator|==
literal|1
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* we possibly have data we can read */
comment|/* sa_ignore FREED_MEMORY */
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This could be happening since the appender did the 		 * increment but as not yet did the tailq insert onto the 		 * read_queue 		 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
block|}
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh, its non zero and nothing on control?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|)
condition|)
block|{
comment|/* 		 * Clean up code for freeing assoc that left behind a 		 * pdapi.. maybe a peer in EEOR that just closed after 		 * sending and never indicated a EOR. 		 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|hold_rlock
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
comment|/* Hmm there is data here .. fix */
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|m_tmp
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m_tmp
condition|)
block|{
name|cnt
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|m_tmp
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
block|}
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|length
operator|=
name|cnt
expr_stmt|;
block|}
else|else
block|{
comment|/* remove it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Add back any hiddend data */
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|hold_rlock
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|end_added
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* 		 * Do we also need to check for (control->pdapi_aborted == 		 * 1)? 		 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|hold_rlock
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"control->data not null but control->length == 0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Strange, data left in the control buffer. Cleaning up.\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|control
operator|->
name|aux_data
condition|)
block|{
name|sctp_m_free
argument_list|(
name|control
operator|->
name|aux_data
argument_list|)
expr_stmt|;
name|control
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|hold_rlock
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|restart
goto|;
block|}
if|if
condition|(
name|control
operator|->
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
operator|)
operator|&&
operator|(
name|filling_sinfo
operator|)
condition|)
block|{
comment|/* find a more suitable one then this */
name|ctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
if|if
condition|(
operator|(
name|ctl
operator|->
name|stcb
operator|!=
name|control
operator|->
name|stcb
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|length
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|some_taken
operator|||
operator|(
name|ctl
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|||
operator|(
operator|(
name|ctl
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|ctl
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*- 					 * If we have a different TCB next, and there is data 					 * present. If we have already taken some (pdapi), OR we can 					 * ref the tcb and no delivery as started on this stream, we 					 * take it. Note we allow a notification on a different 					 * assoc to be delivered.. 					 */
name|control
operator|=
name|ctl
expr_stmt|;
goto|goto
name|found_one
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|length
operator|)
operator|&&
operator|(
operator|(
name|ctl
operator|->
name|some_taken
operator|)
operator|||
operator|(
operator|(
name|ctl
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ctl
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|ctl
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*- 					 * If we have the same tcb, and there is data present, and we 					 * have the strm interleave feature present. Then if we have 					 * taken some (pdapi) or we can refer to tht tcb AND we have 					 * not started a delivery for this stream, we can take it. 					 * Note we do NOT allow a notificaiton on the same assoc to 					 * be delivered. 					 */
name|control
operator|=
name|ctl
expr_stmt|;
goto|goto
name|found_one
goto|;
block|}
name|ctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * if we reach here, not suitable replacement is available 		 *<or> fragment interleave is NOT on. So stuff the sb_cc 		 * into the our held count, and its time to sleep again. 		 */
name|held_length
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
comment|/* Clear the held length since there is something to read */
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
name|found_one
label|:
comment|/* 	 * If we reach here, control has a some data for us to read off. 	 * Note that stcb COULD be NULL. 	 */
name|control
operator|->
name|some_taken
operator|++
expr_stmt|;
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
condition|)
block|{
if|if
condition|(
name|freecnt_applied
operator|==
literal|0
condition|)
name|stcb
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
condition|)
block|{
comment|/* you can't free it on me please */
comment|/* 			 * The lock on the socket buffer protects us so the 			 * free code will stop. But since we used the 			 * socketbuf lock and the sender uses the tcb_lock 			 * to increment, we need to use the atomic add to 			 * the refcnt 			 */
if|if
condition|(
name|freecnt_applied
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"refcnt already incremented"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"refcnt already incremented?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|freecnt_applied
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Setup to remember how much we have not yet told 			 * the peer our rwnd has opened up. Note we grab the 			 * value from the tcb from last time. Note too that 			 * sack sending clears this when a sack is sent, 			 * which is fine. Once we hit the rwnd_req, we then 			 * will go to the sctp_user_rcvd() that will not 			 * lock until it KNOWs it MUST send a WUP-SACK. 			 */
name|freed_so_far
operator|=
name|stcb
operator|->
name|freed_by_sorcv_sincelast
expr_stmt|;
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
operator|&&
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|1
expr_stmt|;
block|}
comment|/* First lets get off the sinfo and sockaddr info */
if|if
condition|(
operator|(
name|sinfo
operator|)
operator|&&
name|filling_sinfo
condition|)
block|{
name|memcpy
argument_list|(
name|sinfo
argument_list|,
name|control
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nonpad_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
name|nxt
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
condition|)
block|{
name|struct
name|sctp_extrcvinfo
modifier|*
name|s_extra
decl_stmt|;
name|s_extra
operator|=
operator|(
expr|struct
name|sctp_extrcvinfo
operator|*
operator|)
name|sinfo
expr_stmt|;
if|if
condition|(
operator|(
name|nxt
operator|)
operator|&&
operator|(
name|nxt
operator|->
name|length
operator|)
condition|)
block|{
name|s_extra
operator|->
name|sreinfo_next_flags
operator|=
name|SCTP_NEXT_MSG_AVAIL
expr_stmt|;
if|if
condition|(
name|nxt
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|s_extra
operator|->
name|sreinfo_next_flags
operator||=
name|SCTP_NEXT_MSG_IS_UNORDERED
expr_stmt|;
block|}
if|if
condition|(
name|nxt
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|s_extra
operator|->
name|sreinfo_next_flags
operator||=
name|SCTP_NEXT_MSG_IS_NOTIFICATION
expr_stmt|;
block|}
name|s_extra
operator|->
name|sreinfo_next_aid
operator|=
name|nxt
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_length
operator|=
name|nxt
operator|->
name|length
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_ppid
operator|=
name|nxt
operator|->
name|sinfo_ppid
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_stream
operator|=
name|nxt
operator|->
name|sinfo_stream
expr_stmt|;
if|if
condition|(
name|nxt
operator|->
name|tail_mbuf
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nxt
operator|->
name|end_added
condition|)
block|{
name|s_extra
operator|->
name|sreinfo_next_flags
operator||=
name|SCTP_NEXT_MSG_ISCOMPLETE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 				 * we explicitly 0 this, since the memcpy 				 * got some other things beyond the older 				 * sinfo_ that is on the control's structure 				 * :-D 				 */
name|nxt
operator|=
name|NULL
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_flags
operator|=
name|SCTP_NO_NEXT_MSG
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_aid
operator|=
literal|0
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_length
operator|=
literal|0
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_ppid
operator|=
literal|0
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_stream
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 		 * update off the real current cum-ack, if we have an stcb. 		 */
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
name|stcb
condition|)
name|sinfo
operator|->
name|sinfo_cumtsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
comment|/* 		 * mask off the high bits, we keep the actual chunk bits in 		 * there. 		 */
name|sinfo
operator|->
name|sinfo_flags
operator|&=
literal|0x00ff
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
name|sinfo
operator|->
name|sinfo_flags
operator||=
name|SCTP_UNORDERED
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
block|{
name|int
name|index
decl_stmt|,
name|newindex
decl_stmt|;
name|struct
name|sctp_pcbtsn_rlog
modifier|*
name|entry
decl_stmt|;
do|do
block|{
name|index
operator|=
name|inp
operator|->
name|readlog_index
expr_stmt|;
name|newindex
operator|=
name|index
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|newindex
operator|>=
name|SCTP_READ_LOG_SIZE
condition|)
block|{
name|newindex
operator|=
literal|0
expr_stmt|;
block|}
block|}
do|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|readlog_index
argument_list|,
name|index
argument_list|,
name|newindex
argument_list|)
operator|==
literal|0
condition|)
do|;
name|entry
operator|=
operator|&
name|inp
operator|->
name|readlog
index|[
name|index
index|]
expr_stmt|;
name|entry
operator|->
name|vtag
operator|=
name|control
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|entry
operator|->
name|strm
operator|=
name|control
operator|->
name|sinfo_stream
expr_stmt|;
name|entry
operator|->
name|seq
operator|=
name|control
operator|->
name|sinfo_ssn
expr_stmt|;
name|entry
operator|->
name|sz
operator|=
name|control
operator|->
name|length
expr_stmt|;
name|entry
operator|->
name|flgs
operator|=
name|control
operator|->
name|sinfo_flags
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fromlen
operator|&&
name|from
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|to
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|cp_len
operator|=
name|min
argument_list|(
operator|(
name|size_t
operator|)
name|fromlen
argument_list|,
operator|(
name|size_t
operator|)
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
operator|.
name|sin_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|from
argument_list|,
operator|&
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|from
operator|)
operator|->
name|sin_port
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
else|#
directive|else
comment|/* No AF_INET use AF_INET6 */
name|cp_len
operator|=
name|min
argument_list|(
operator|(
name|size_t
operator|)
name|fromlen
argument_list|,
operator|(
name|size_t
operator|)
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|from
argument_list|,
operator|&
name|control
operator|->
name|whoFrom
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|from
operator|)
operator|->
name|sin6_port
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
endif|#
directive|endif
name|to
operator|=
name|from
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
operator|)
operator|&&
operator|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|fromlen
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
operator|)
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
literal|0xffff
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|3
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr32
index|[
literal|3
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
name|memcpy
argument_list|(
name|from
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
block|{
name|struct
name|sockaddr_in6
name|lsa6
decl_stmt|,
modifier|*
name|to6
decl_stmt|;
name|to6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|sctp_recover_scope_mac
argument_list|(
name|to6
argument_list|,
operator|(
operator|&
name|lsa6
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* now copy out what data we can */
if|if
condition|(
name|mp
operator|==
name|NULL
condition|)
block|{
comment|/* copy out each mbuf in the chain up to length */
name|get_more_data
label|:
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
comment|/* Move out all we can */
name|cp_len
operator|=
operator|(
name|int
operator|)
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|my_len
operator|=
operator|(
name|int
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp_len
operator|>
name|my_len
condition|)
block|{
comment|/* not enough in this buf */
name|cp_len
operator|=
name|my_len
expr_stmt|;
block|}
if|if
condition|(
name|hold_rlock
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cp_len
operator|>
literal|0
condition|)
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|char
operator|*
argument_list|)
argument_list|,
name|cp_len
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* re-read */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
name|stcb
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|no_rcv_needed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* error we are out of here */
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|cp_len
operator|>=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|end_added
operator|==
literal|0
operator|)
operator|||
operator|(
name|control
operator|->
name|end_added
operator|&&
operator|(
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
operator|)
operator|)
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cp_len
operator|==
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|control
operator|->
name|end_added
operator|)
condition|)
block|{
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|out_flags
operator||=
name|MSG_NOTIFICATION
expr_stmt|;
block|}
comment|/* we ate up the mbuf */
if|if
condition|(
name|in_flags
operator|&
name|MSG_PEEK
condition|)
block|{
comment|/* just looking */
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
block|}
else|else
block|{
comment|/* dispose of the mbuf */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sbfree
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|MSIZE
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
comment|/* 					 * been through it all, must hold sb 					 * lock ok to null tail 					 */
if|if
condition|(
name|control
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|control
operator|->
name|end_added
operator|==
literal|0
operator|)
operator|||
operator|(
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 							 * If the end is not 							 * added, OR the 							 * next is NOT null 							 * we MUST have the 							 * lock. 							 */
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|inp
operator|->
name|inp_rdata_mtx
argument_list|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Hmm we don't own the lock?"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|control
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|control
operator|->
name|end_added
operator|)
operator|&&
operator|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"end_added, nothing left and no MSG_EOR"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
comment|/* Do we need to trim the mbuf? */
if|if
condition|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|out_flags
operator||=
name|MSG_NOTIFICATION
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_BUF_RESV_UF
argument_list|(
name|m
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|-=
name|cp_len
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
name|stcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
block|}
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|cp_len
expr_stmt|;
name|freed_so_far
operator|+=
name|MSIZE
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|cp_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|copied_so_far
operator|+=
name|cp_len
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
condition|)
block|{
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end while(m) */
comment|/* 		 * At this point we have looked at it all and we either have 		 * a MSG_EOR/or read all the user wants...<OR> 		 * control->length == 0. 		 */
if|if
condition|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|&&
operator|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we are done with this control */
if|if
condition|(
name|control
operator|->
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"control->data not null at read eor?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Strange, data left in the control buffer .. invarients would panic?\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
name|done_with_control
label|:
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * If we don't have a next we need a 					 * lock, if there is a next 					 * interrupt is filling ahead of us 					 * and we don't need a lock to 					 * remove this guy (which is the 					 * head of the queue). 					 */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* Add back any hiddend data */
if|if
condition|(
name|control
operator|->
name|held_length
condition|)
block|{
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|wakeup_read_socket
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|aux_data
condition|)
block|{
name|sctp_m_free
argument_list|(
name|control
operator|->
name|aux_data
argument_list|)
expr_stmt|;
name|control
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
block|}
name|no_rcv_needed
operator|=
name|control
operator|->
name|do_not_ref_stcb
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
operator|&&
operator|(
name|no_rcv_needed
operator|==
literal|0
operator|)
condition|)
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The user did not read all of this 				 * message, turn off the returned MSG_EOR 				 * since we are leaving more behind on the 				 * control to read. 				 */
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|end_added
operator|&&
operator|(
name|control
operator|->
name|data
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|control
operator|->
name|tail_mbuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"Gak, control->length is corrupt?"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|no_rcv_needed
operator|=
name|control
operator|->
name|do_not_ref_stcb
expr_stmt|;
name|out_flags
operator|&=
operator|~
name|MSG_EOR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|out_flags
operator|&
name|MSG_EOR
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|in_eeor_mode
operator|)
operator|&&
operator|(
name|copied_so_far
operator|>=
name|max
argument_list|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_lowat
argument_list|,
literal|1
argument_list|)
operator|)
operator|)
condition|)
block|{
goto|goto
name|release
goto|;
block|}
comment|/* 		 * If I hit here the receiver wants more and this message is 		 * NOT done (pd-api). So two questions. Can we block? if not 		 * we are done. Did the user NOT set MSG_WAITALL? 		 */
if|if
condition|(
name|block_allowed
operator|==
literal|0
condition|)
block|{
goto|goto
name|release
goto|;
block|}
comment|/* 		 * We need to wait for more data a few things: - We don't 		 * sbunlock() so we don't get someone else reading. - We 		 * must be sure to account for the case where what is added 		 * is NOT to our control when we wakeup. 		 */
comment|/* 		 * Do we need to tell the transport a rwnd update might be 		 * needed before we go to sleep? 		 */
if|if
condition|(
operator|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
name|no_rcv_needed
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
name|wait_some_more
label|:
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&
name|SBS_CANTRCVMORE
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
goto|goto
name|release
goto|;
if|if
condition|(
name|hold_rlock
operator|==
literal|1
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|copied_so_far
operator|)
operator|&&
operator|(
name|control
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|release
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|<=
name|control
operator|->
name|held_length
condition|)
block|{
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|release
goto|;
block|}
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|length
operator|==
literal|0
condition|)
block|{
comment|/* still nothing here */
if|if
condition|(
name|control
operator|->
name|end_added
operator|==
literal|1
condition|)
block|{
comment|/* he aborted, or is done i.e.did a shutdown */
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|pdapi_aborted
condition|)
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
name|out_flags
operator||=
name|MSG_TRUNC
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|done_with_control
goto|;
block|}
if|if
condition|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
name|held_length
condition|)
block|{
name|control
operator|->
name|held_length
operator|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
expr_stmt|;
name|held_length
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|wait_some_more
goto|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * we must re-sync since data is probably being 			 * added 			 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|>
literal|0
operator|)
operator|&&
operator|(
name|control
operator|->
name|data
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 				 * big trouble.. we have the lock and its 				 * corrupt? 				 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Impossible data==NULL length !=0"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
name|out_flags
operator||=
name|MSG_TRUNC
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done_with_control
goto|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* We will fall around to get more data */
block|}
goto|goto
name|get_more_data
goto|;
block|}
else|else
block|{
comment|/*- 		 * Give caller back the mbuf chain, 		 * store in uio_resid the length 		 */
name|wakeup_read_socket
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|end_added
operator|==
literal|0
operator|)
operator|||
operator|(
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Need to get rlock */
if|if
condition|(
name|hold_rlock
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
name|out_flags
operator||=
name|MSG_EOR
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
operator|)
operator|==
literal|0
operator|)
condition|)
name|control
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|spec_flags
operator|&
name|M_NOTIFICATION
condition|)
block|{
name|out_flags
operator||=
name|MSG_NOTIFICATION
expr_stmt|;
block|}
name|uio
operator|->
name|uio_resid
operator|=
name|control
operator|->
name|length
expr_stmt|;
operator|*
name|mp
operator|=
name|control
operator|->
name|data
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBFREE
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_sbfree
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|freed_so_far
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|freed_so_far
operator|+=
name|MSIZE
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SB_LOGGING_ENABLE
condition|)
block|{
name|sctp_sblog
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|do_not_ref_stcb
condition|?
name|NULL
else|:
name|stcb
argument_list|,
name|SCTP_LOG_SBRESULT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|data
operator|=
name|control
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|out_flags
operator|&
name|MSG_EOR
condition|)
block|{
comment|/* Done with this control */
goto|goto
name|done_with_control
goto|;
block|}
block|}
name|release
label|:
if|if
condition|(
name|hold_rlock
operator|==
literal|1
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
operator|==
literal|1
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sockbuf_lock
operator|=
literal|0
expr_stmt|;
name|release_unlocked
label|:
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|freed_so_far
operator|>=
name|rwnd_req
operator|)
operator|&&
operator|(
name|control
operator|&&
operator|(
name|control
operator|->
name|do_not_ref_stcb
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|no_rcv_needed
operator|==
literal|0
operator|)
condition|)
name|sctp_user_rcvd
argument_list|(
name|stcb
argument_list|,
operator|&
name|freed_so_far
argument_list|,
name|hold_rlock
argument_list|,
name|rwnd_req
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|msg_flags
condition|)
block|{
operator|*
name|msg_flags
operator|=
name|out_flags
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|out_flags
operator|&
name|MSG_EOR
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|in_flags
operator|&
name|MSG_PEEK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sinfo
operator|)
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
operator|)
condition|)
block|{
name|struct
name|sctp_extrcvinfo
modifier|*
name|s_extra
decl_stmt|;
name|s_extra
operator|=
operator|(
expr|struct
name|sctp_extrcvinfo
operator|*
operator|)
name|sinfo
expr_stmt|;
name|s_extra
operator|->
name|sreinfo_next_flags
operator|=
name|SCTP_NO_NEXT_MSG
expr_stmt|;
block|}
if|if
condition|(
name|hold_rlock
operator|==
literal|1
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hold_rlock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_sblock
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|hold_sblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sockbuf_lock
condition|)
block|{
name|sbunlock
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|freecnt_applied
condition|)
block|{
comment|/* 		 * The lock on the socket buffer protects us so the free 		 * code will stop. But since we used the socketbuf lock and 		 * the sender uses the tcb_lock to increment, we need to use 		 * the atomic add to the refcnt. 		 */
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"stcb for refcnt has gone NULL?"
argument_list|)
expr_stmt|;
goto|goto
name|stage_left
goto|;
else|#
directive|else
goto|goto
name|stage_left
goto|;
endif|#
directive|endif
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|freecnt_applied
operator|=
literal|0
expr_stmt|;
comment|/* Save the value back for next time */
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
name|freed_so_far
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_RECV_RWND_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_DONE
argument_list|,
name|freed_so_far
argument_list|,
operator|(
operator|(
name|uio
operator|)
condition|?
operator|(
name|slen
operator|-
name|uio
operator|->
name|uio_resid
operator|)
else|:
name|slen
operator|)
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SORECV_DONE
argument_list|,
name|freed_so_far
argument_list|,
operator|(
operator|(
name|uio
operator|)
condition|?
operator|(
name|slen
operator|-
name|uio
operator|->
name|uio_resid
operator|)
else|:
name|slen
operator|)
argument_list|,
literal|0
argument_list|,
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
block|}
name|stage_left
label|:
if|if
condition|(
name|wakeup_read_socket
condition|)
block|{
name|sctp_sorwakeup
argument_list|(
name|inp
argument_list|,
name|so
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
end_ifdef

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_m_free
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|m
argument_list|,
name|SCTP_MBUF_IFREE
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m_free
argument_list|(
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_m_freem
parameter_list|(
name|struct
name|mbuf
modifier|*
name|mb
parameter_list|)
block|{
while|while
condition|(
name|mb
operator|!=
name|NULL
condition|)
name|mb
operator|=
name|sctp_m_free
argument_list|(
name|mb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_dynamic_set_primary
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
comment|/* 	 * Given a local address. For all associations that holds the 	 * address, request a peer-set-primary. 	 */
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|,
name|vrf_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EADDRNOTAVAIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
comment|/* 	 * Now that we have the ifa we must awaken the iterator with this 	 * message. 	 */
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Now incr the count and int wi structure */
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|wi
operator|->
name|start_time
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|SCTP_SET_PRIM_ADDR
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now add it to the work queue */
name|SCTP_WQ_ADDR_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Should this really be a tailq? As it is we will process the 	 * newest first :-0 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|addr_wq
argument_list|)
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|SCTP_WQ_ADDR_UNLOCK
argument_list|()
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|psa
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp0
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fromlen
decl_stmt|;
name|uint8_t
name|sockbuf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
name|struct
name|sctp_extrcvinfo
name|sinfo
decl_stmt|;
name|int
name|filling_sinfo
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
comment|/* pickup the assoc we are reading from */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
operator|)
operator|||
operator|(
name|controlp
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* user does not want the sndrcv ctl */
name|filling_sinfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|psa
condition|)
block|{
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sockbuf
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|sockbuf
argument_list|)
expr_stmt|;
name|from
operator|->
name|sa_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|NULL
expr_stmt|;
name|fromlen
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|sctp_sorecvmsg
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
name|mp0
argument_list|,
name|from
argument_list|,
name|fromlen
argument_list|,
name|flagsp
argument_list|,
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|sinfo
argument_list|,
name|filling_sinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|controlp
operator|)
operator|&&
operator|(
name|filling_sinfo
operator|)
condition|)
block|{
comment|/* copy back the sinfo in a CMSG format */
if|if
condition|(
name|filling_sinfo
condition|)
operator|*
name|controlp
operator|=
name|sctp_build_ctl_nchunk
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|sinfo
argument_list|)
expr_stmt|;
else|else
operator|*
name|controlp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|psa
condition|)
block|{
comment|/* copy back the address info */
if|if
condition|(
name|from
operator|&&
name|from
operator|->
name|sa_len
condition|)
block|{
operator|*
name|psa
operator|=
name|sodupsockaddr
argument_list|(
name|from
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|psa
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_l_soreceive
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|name
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|char
modifier|*
modifier|*
name|controlp
parameter_list|,
name|int
modifier|*
name|controllen
parameter_list|,
name|int
modifier|*
name|flag
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|fromlen
decl_stmt|;
name|uint8_t
name|sockbuf
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from
decl_stmt|;
name|struct
name|sctp_extrcvinfo
name|sinfo
decl_stmt|;
name|int
name|filling_sinfo
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
comment|/* pickup the assoc we are reading from */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
operator|)
operator|||
operator|(
name|controlp
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* user does not want the sndrcv ctl */
name|filling_sinfo
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
name|from
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sockbuf
expr_stmt|;
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|sockbuf
argument_list|)
expr_stmt|;
name|from
operator|->
name|sa_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|NULL
expr_stmt|;
name|fromlen
operator|=
literal|0
expr_stmt|;
block|}
name|error
operator|=
name|sctp_sorecvmsg
argument_list|(
name|so
argument_list|,
name|uio
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|*
operator|)
name|NULL
argument_list|,
name|from
argument_list|,
name|fromlen
argument_list|,
name|flag
argument_list|,
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|sinfo
argument_list|,
name|filling_sinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|controlp
operator|)
operator|&&
operator|(
name|filling_sinfo
operator|)
condition|)
block|{
comment|/* 		 * copy back the sinfo in a CMSG format note that the caller 		 * has reponsibility for freeing the memory. 		 */
if|if
condition|(
name|filling_sinfo
condition|)
operator|*
name|controlp
operator|=
name|sctp_build_ctl_cchunk
argument_list|(
name|inp
argument_list|,
name|controllen
argument_list|,
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|sinfo
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|name
condition|)
block|{
comment|/* copy back the address info */
if|if
condition|(
name|from
operator|&&
name|from
operator|->
name|sa_len
condition|)
block|{
operator|*
name|name
operator|=
name|sodupsockaddr
argument_list|(
name|from
argument_list|,
name|M_WAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|name
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_connectx_helper_add
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|totaddr
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|size_t
name|incr
init|=
literal|0
decl_stmt|;
name|sa
operator|=
name|addr
expr_stmt|;
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totaddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
comment|/* assoc gone no un-lock */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|added
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
comment|/* assoc gone no un-lock */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|added
operator|++
expr_stmt|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
name|incr
operator|)
expr_stmt|;
block|}
name|out_now
label|:
return|return
operator|(
name|added
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_tcb
modifier|*
name|sctp_connectx_helper_find
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|totaddr
parameter_list|,
name|int
modifier|*
name|num_v4
parameter_list|,
name|int
modifier|*
name|num_v6
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|int
name|limit
parameter_list|,
name|int
modifier|*
name|bad_addr
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|size_t
name|incr
decl_stmt|,
name|at
decl_stmt|,
name|i
decl_stmt|;
name|at
operator|=
name|incr
operator|=
literal|0
expr_stmt|;
name|sa
operator|=
name|addr
expr_stmt|;
operator|*
name|error
operator|=
operator|*
name|num_v6
operator|=
operator|*
name|num_v4
operator|=
literal|0
expr_stmt|;
comment|/* account and validate addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|size_t
operator|)
operator|*
name|totaddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
operator|(
operator|*
name|num_v4
operator|)
operator|+=
literal|1
expr_stmt|;
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
name|incr
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|bad_addr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Must be non-mapped for connectx */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|bad_addr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
operator|*
name|num_v6
operator|)
operator|+=
literal|1
expr_stmt|;
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
name|incr
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
operator|*
name|bad_addr
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
operator|*
name|totaddr
operator|=
name|i
expr_stmt|;
comment|/* we are done */
break|break;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|at
operator|+
name|incr
operator|)
operator|>
operator|(
name|size_t
operator|)
name|limit
condition|)
block|{
operator|*
name|totaddr
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
name|incr
operator|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sctp_bindx(ADD) for one address.  * assumes all arguments are valid/checked by caller.  */
end_comment

begin_function
name|void
name|sctp_bindx_add_address
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|sctp_assoc_t
name|assoc_id
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr_touse
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
comment|/* see if we're bound all already! */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|addr_touse
operator|=
name|sa
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__Userspace__
argument_list|)
comment|/* TODO port in6_sin6_2_sin */
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* can only bind v6 on PF_INET6 sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_touse
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind v4-mapped on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind v4 on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Can't get proc for Net/Open BSD */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
operator|*
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr_touse
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * No locks required here since bind and mgmt_ep_sa all do their own 	 * locking. If we do something for the FIX: below we may need to 	 * lock in that case. 	 */
if|if
condition|(
name|assoc_id
operator|==
literal|0
condition|)
block|{
comment|/* add the address */
name|struct
name|sctp_inpcb
modifier|*
name|lep
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|lsin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_touse
decl_stmt|;
comment|/* validate the incoming port */
if|if
condition|(
operator|(
name|lsin
operator|->
name|sin_port
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|lsin
operator|->
name|sin_port
operator|!=
name|inp
operator|->
name|sctp_lport
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* user specified 0 port, set it to existing port */
name|lsin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
block|}
name|lep
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr_touse
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lep
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We must decrement the refcount since we have the 			 * ep already and are binding. No remove going on 			 * here. 			 */
name|SCTP_INP_DECR_REF
argument_list|(
name|lep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lep
operator|==
name|inp
condition|)
block|{
comment|/* already bound to it.. ok */
return|return;
block|}
elseif|else
if|if
condition|(
name|lep
operator|==
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_touse
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
operator|*
name|error
operator|=
name|sctp_addr_mgmt_ep_sa
argument_list|(
name|inp
argument_list|,
name|addr_touse
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|,
name|vrf_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|error
condition|)
return|return;
block|}
else|else
block|{
comment|/* 		 * FIX: decide whether we allow assoc based bindx 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * sctp_bindx(DELETE) for one address.  * assumes all arguments are valid/checked by caller.  */
end_comment

begin_function
name|void
name|sctp_bindx_delete_address
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|sctp_assoc_t
name|assoc_id
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr_touse
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
comment|/* see if we're bound all already! */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|addr_touse
operator|=
name|sa
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__Userspace__
argument_list|)
comment|/* TODO port in6_sin6_2_sin */
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* can only bind v6 on PF_INET6 sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_touse
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind mapped-v4 on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
comment|/* can't bind v4 on PF_INET sockets */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTPUTIL
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * No lock required mgmt_ep_sa does its own locking. If the FIX: 	 * below is ever changed we may need to lock before calling 	 * association level binding. 	 */
if|if
condition|(
name|assoc_id
operator|==
literal|0
condition|)
block|{
comment|/* delete the address */
operator|*
name|error
operator|=
name|sctp_addr_mgmt_ep_sa
argument_list|(
name|inp
argument_list|,
name|addr_touse
argument_list|,
name|SCTP_DEL_IP_ADDRESS
argument_list|,
name|vrf_id
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * FIX: decide whether we allow assoc based bindx 		 */
block|}
block|}
end_function

begin_comment
comment|/*  * returns the valid local address count for an assoc, taking into account  * all scoping rules  */
end_comment

begin_function
name|int
name|sctp_local_addr_count
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|int
name|loopback_scope
decl_stmt|,
name|ipv4_local_scope
decl_stmt|,
name|local_scope
decl_stmt|,
name|site_scope
decl_stmt|;
name|int
name|ipv4_addr_legal
decl_stmt|,
name|ipv6_addr_legal
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Turn on all the appropriate scopes */
name|loopback_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
expr_stmt|;
name|ipv4_local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
expr_stmt|;
name|local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
expr_stmt|;
name|site_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
expr_stmt|;
name|ipv4_addr_legal
operator|=
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
comment|/* no vrf, no addresses */
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* 		 * bound all case: go through all ifns on the vrf 		 */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
continue|continue;
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* 							 * skip unspecified 							 * addrs 							 */
continue|continue;
block|}
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* count this one */
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
continue|continue;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_scope
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|!=
literal|0
condition|)
comment|/* 									 *  									 * bad 									 *  									 * li 									 * nk 									 *  									 * loc 									 * al 									 *  									 * add 									 * re 									 * ss 									 * */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* count this one */
name|count
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * subset bound case 		 */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* count this one */
name|count
operator|++
expr_stmt|;
block|}
block|}
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SCTP_LOCAL_TRACE_BUF
argument_list|)
end_if

begin_function
name|void
name|sctp_log_trace
parameter_list|(
name|uint32_t
name|subsys
parameter_list|,
specifier|const
name|char
modifier|*
name|str
name|SCTP_UNUSED
parameter_list|,
name|uint32_t
name|a
parameter_list|,
name|uint32_t
name|b
parameter_list|,
name|uint32_t
name|c
parameter_list|,
name|uint32_t
name|d
parameter_list|,
name|uint32_t
name|e
parameter_list|,
name|uint32_t
name|f
parameter_list|)
block|{
name|uint32_t
name|saveindex
decl_stmt|,
name|newindex
decl_stmt|;
do|do
block|{
name|saveindex
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|saveindex
operator|>=
name|SCTP_MAX_LOGGING_SIZE
condition|)
block|{
name|newindex
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|newindex
operator|=
name|saveindex
operator|+
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|index
argument_list|,
name|saveindex
argument_list|,
name|newindex
argument_list|)
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|saveindex
operator|>=
name|SCTP_MAX_LOGGING_SIZE
condition|)
block|{
name|saveindex
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|timestamp
operator|=
name|SCTP_GET_CYCLECOUNT
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|subsys
operator|=
name|subsys
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|0
index|]
operator|=
name|a
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|1
index|]
operator|=
name|b
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|2
index|]
operator|=
name|c
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|3
index|]
operator|=
name|d
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|4
index|]
operator|=
name|e
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_log
argument_list|)
operator|.
name|entry
index|[
name|saveindex
index|]
operator|.
name|params
index|[
literal|5
index|]
operator|=
name|f
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We will need to add support  * to bind the ports and such here  * so we can do UDP tunneling. In  * the mean-time, we return error  */
end_comment

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/sctp6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|sctp_recv_udp_tunneled_packet
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|inpcb
modifier|*
name|ignored
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|sp
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uhdr
decl_stmt|;
name|uint16_t
name|port
init|=
literal|0
decl_stmt|,
name|len
decl_stmt|;
name|int
name|header_size
init|=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
decl_stmt|;
comment|/* 	 * Split out the mbuf chain. Leave the IP header in m, place the 	 * rest in the sp. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't handle one that is not a pkt hdr */
goto|goto
name|out
goto|;
block|}
comment|/* pull the src port */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|uhdr
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|iph
operator|+
name|off
operator|)
expr_stmt|;
name|port
operator|=
name|uhdr
operator|->
name|uh_sport
expr_stmt|;
name|sp
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* Gak, drop packet, we can't do a split */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sp
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|header_size
condition|)
block|{
comment|/* Gak, packet can't have an SCTP header in it - to small */
name|m_freem
argument_list|(
name|sp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* ok now pull up the UDP header and SCTP header together */
name|sp
operator|=
name|m_pullup
argument_list|(
name|sp
argument_list|,
name|header_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* Gak pullup failed */
goto|goto
name|out
goto|;
block|}
comment|/* trim out the UDP header */
name|m_adj
argument_list|(
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now reconstruct the mbuf chain */
comment|/* 1) find last one */
name|last
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|last
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
name|last
operator|->
name|m_next
expr_stmt|;
block|}
name|last
operator|->
name|m_next
operator|=
name|sp
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|sp
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|last
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|=
name|last
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* Now its ready for sctp_input or sctp6_input */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|iph
operator|->
name|ip_v
condition|)
block|{
case|case
name|IPVERSION
case|:
block|{
comment|/* its IPv4 */
name|len
operator|=
name|SCTP_GET_IPV4_LENGTH
argument_list|(
name|iph
argument_list|)
expr_stmt|;
name|len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
name|SCTP_GET_IPV4_LENGTH
argument_list|(
name|iph
argument_list|)
operator|=
name|len
expr_stmt|;
name|sctp_input_with_port
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|port
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET6
case|case
name|IPV6_VERSION
operator|>>
literal|4
case|:
block|{
comment|/* its IPv6 - NOT supported */
goto|goto
name|out
goto|;
break|break;
block|}
endif|#
directive|endif
default|default:
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
name|out
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_over_udp_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|socket
modifier|*
name|sop
decl_stmt|;
comment|/* 	 * This function assumes sysctl caller holds sctp_sysctl_info_lock() 	 * for writting! 	 */
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|udp_tun_socket
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* Nothing to do */
return|return;
block|}
name|sop
operator|=
name|SCTP_BASE_INFO
argument_list|(
name|udp_tun_socket
argument_list|)
expr_stmt|;
name|soclose
argument_list|(
name|sop
argument_list|)
expr_stmt|;
name|SCTP_BASE_INFO
argument_list|(
name|udp_tun_socket
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_over_udp_start
parameter_list|(
name|void
parameter_list|)
block|{
name|uint16_t
name|port
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|socket
modifier|*
name|sop
init|=
name|NULL
decl_stmt|;
name|struct
name|thread
modifier|*
name|th
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
comment|/* 	 * This function assumes sysctl caller holds sctp_sysctl_info_lock() 	 * for writting! 	 */
name|port
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
comment|/* Must have a port set */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|SCTP_BASE_INFO
argument_list|(
name|udp_tun_socket
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Already running -- must stop first */
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|th
operator|=
name|curthread
expr_stmt|;
name|cred
operator|=
name|th
operator|->
name|td_ucred
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|socreate
argument_list|(
name|PF_INET
argument_list|,
operator|&
name|sop
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|,
name|cred
argument_list|,
name|th
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|SCTP_BASE_INFO
argument_list|(
name|udp_tun_socket
argument_list|)
operator|=
name|sop
expr_stmt|;
comment|/* call the special UDP hook */
name|ret
operator|=
name|udp_set_kernel_tunneling
argument_list|(
name|sop
argument_list|,
name|sctp_recv_udp_tunneled_packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
goto|goto
name|exit_stage_left
goto|;
block|}
comment|/* Ok we have a socket, bind it to the port */
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sobind
argument_list|(
name|sop
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|th
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Close up we cant get the port */
name|exit_stage_left
label|:
name|sctp_over_udp_stop
argument_list|()
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * Ok we should now get UDP packets directly to our input routine 	 * sctp_recv_upd_tunneled_packet(). 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

