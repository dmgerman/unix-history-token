begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * $FreeBSD$  *  * Testing program for schedulers  *  * The framework include a simple controller which, at each  * iteration, decides whether we can enqueue and/or dequeue.  * Then the mainloop runs the required number of tests,  * keeping track of statistics.  */
end_comment

begin_include
include|#
directive|include
file|"dn_test.h"
end_include

begin_struct
struct|struct
name|q_list
block|{
name|struct
name|list_head
name|h
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|cfg_s
block|{
name|int
name|ac
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|av
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|loops
decl_stmt|;
name|struct
name|timeval
name|time
decl_stmt|;
comment|/* running counters */
name|uint32_t
name|_enqueue
decl_stmt|;
name|uint32_t
name|drop
decl_stmt|;
name|uint32_t
name|pending
decl_stmt|;
name|uint32_t
name|dequeue
decl_stmt|;
comment|/* generator parameters */
name|int
name|th_min
decl_stmt|,
name|th_max
decl_stmt|;
name|int
name|maxburst
decl_stmt|;
name|int
name|lmin
decl_stmt|,
name|lmax
decl_stmt|;
comment|/* packet len */
name|int
name|flows
decl_stmt|;
comment|/* number of flows */
name|int
name|flowsets
decl_stmt|;
comment|/* number of flowsets */
name|int
name|wsum
decl_stmt|;
comment|/* sum of weights of all flows */
name|int
name|max_y
decl_stmt|;
comment|/* max random number in the generation */
name|int
name|cur_y
decl_stmt|,
name|cur_fs
decl_stmt|;
comment|/* used in generation, between 0 and max_y - 1 */
specifier|const
name|char
modifier|*
name|fs_config
decl_stmt|;
comment|/* flowset config */
name|int
name|can_dequeue
decl_stmt|;
name|int
name|burst
decl_stmt|;
comment|/* count of packets sent in a burst */
name|struct
name|mbuf
modifier|*
name|tosend
decl_stmt|;
comment|/* packet to send -- also flag to enqueue */
name|struct
name|mbuf
modifier|*
name|freelist
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|head
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
comment|/* a simple tailq */
comment|/* scheduler hooks */
name|int
function_decl|(
modifier|*
name|enq
function_decl|)
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
parameter_list|,
name|struct
name|dn_queue
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
name|struct
name|mbuf
modifier|*
function_decl|(
modifier|*
name|deq
function_decl|)
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
parameter_list|)
function_decl|;
comment|/* size of the three fields including sched-specific areas */
name|int
name|schk_len
decl_stmt|;
name|int
name|q_len
decl_stmt|;
comment|/* size of a queue including sched-fields */
name|int
name|si_len
decl_stmt|;
comment|/* size of a sch_inst including sched-fields */
name|char
modifier|*
name|q
decl_stmt|;
comment|/* array of flow queues */
comment|/* use a char* because size is variable */
name|struct
name|dn_fsk
modifier|*
name|fs
decl_stmt|;
comment|/* array of flowsets */
name|struct
name|dn_sch_inst
modifier|*
name|si
decl_stmt|;
name|struct
name|dn_schk
modifier|*
name|sched
decl_stmt|;
comment|/* generator state */
name|int
name|state
decl_stmt|;
comment|/* 0 = going up, 1: going down */
comment|/* 	 * We keep lists for each backlog level, and always serve 	 * the one with shortest backlog. llmask contains a bitmap 	 * of lists, and ll are the heads of the lists. The last 	 * entry (BACKLOG) contains all entries considered 'full' 	 * XXX to optimize things, entry i could contain queues with 	 * 2^{i-1}+1 .. 2^i entries. 	 */
define|#
directive|define
name|BACKLOG
value|30
name|uint32_t
name|llmask
decl_stmt|;
name|struct
name|list_head
name|ll
index|[
name|BACKLOG
operator|+
literal|10
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* FI2Q and Q2FI converts from flow_id to dn_queue and back.  * We cannot easily use pointer arithmetic because it is variable size.   */
end_comment

begin_define
define|#
directive|define
name|FI2Q
parameter_list|(
name|c
parameter_list|,
name|i
parameter_list|)
value|((struct dn_queue *)((c)->q + (c)->q_len * (i)))
end_define

begin_define
define|#
directive|define
name|Q2FI
parameter_list|(
name|c
parameter_list|,
name|q
parameter_list|)
value|(((char *)(q) - (c)->q)/(c)->q_len)
end_define

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|dn_parms
name|dn_cfg
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|controller
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* release a packet: put the mbuf in the freelist, and the queue in  * the bucket.  */
end_comment

begin_function
name|int
name|drop
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
decl_stmt|;
name|int
name|i
decl_stmt|;
name|c
operator|->
name|drop
operator|++
expr_stmt|;
name|q
operator|=
name|FI2Q
argument_list|(
name|c
argument_list|,
name|m
operator|->
name|flow_id
argument_list|)
expr_stmt|;
name|i
operator|=
name|q
operator|->
name|ni
operator|.
name|length
expr_stmt|;
comment|// XXX or ffs...
name|ND
argument_list|(
literal|"q %p id %d current length %d"
argument_list|,
name|q
argument_list|,
name|m
operator|->
name|flow_id
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BACKLOG
condition|)
block|{
name|struct
name|list_head
modifier|*
name|h
init|=
operator|&
name|q
operator|->
name|ni
operator|.
name|h
decl_stmt|;
name|c
operator|->
name|llmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|c
operator|->
name|llmask
operator||=
operator|(
literal|1
operator|<<
operator|(
name|i
operator|)
operator|)
expr_stmt|;
name|list_del
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
name|h
argument_list|,
operator|&
name|c
operator|->
name|ll
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|c
operator|->
name|freelist
expr_stmt|;
name|c
operator|->
name|freelist
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* dequeue returns NON-NULL when a packet is dropped */
end_comment

begin_function
specifier|static
name|int
name|enqueue
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|,
name|void
modifier|*
name|_m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|_m
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|enq
condition|)
return|return
name|c
operator|->
name|enq
argument_list|(
name|c
operator|->
name|si
argument_list|,
name|FI2Q
argument_list|(
name|c
argument_list|,
name|m
operator|->
name|flow_id
argument_list|)
argument_list|,
name|m
argument_list|)
return|;
if|if
condition|(
name|c
operator|->
name|head
operator|==
name|NULL
condition|)
name|c
operator|->
name|head
operator|=
name|m
expr_stmt|;
else|else
name|c
operator|->
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|c
operator|->
name|tail
operator|=
name|m
expr_stmt|;
return|return
literal|0
return|;
comment|/* default - success */
block|}
end_function

begin_comment
comment|/* dequeue returns NON-NULL when a packet is available */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|dequeue
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|deq
condition|)
return|return
name|c
operator|->
name|deq
argument_list|(
name|c
operator|->
name|si
argument_list|)
return|;
if|if
condition|(
operator|(
name|m
operator|=
name|c
operator|->
name|head
operator|)
condition|)
block|{
name|m
operator|=
name|c
operator|->
name|head
expr_stmt|;
name|c
operator|->
name|head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mainloop
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|loops
condition|;
name|i
operator|++
control|)
block|{
comment|/* implement histeresis */
name|controller
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"loop %d enq %d send %p rx %d"
argument_list|,
name|i
argument_list|,
name|c
operator|->
name|_enqueue
argument_list|,
name|c
operator|->
name|tosend
argument_list|,
name|c
operator|->
name|can_dequeue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|c
operator|->
name|tosend
operator|)
condition|)
block|{
name|c
operator|->
name|_enqueue
operator|++
expr_stmt|;
if|if
condition|(
name|enqueue
argument_list|(
name|c
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|drop
argument_list|(
name|c
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|"loop %d enqueue fail"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ND
argument_list|(
literal|"enqueue ok"
argument_list|)
expr_stmt|;
name|c
operator|->
name|pending
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|->
name|can_dequeue
condition|)
block|{
name|c
operator|->
name|dequeue
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|dequeue
argument_list|(
name|c
argument_list|)
operator|)
condition|)
block|{
name|c
operator|->
name|pending
operator|--
expr_stmt|;
name|drop
argument_list|(
name|c
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|c
operator|->
name|drop
operator|--
expr_stmt|;
comment|/* compensate */
block|}
block|}
block|}
name|DX
argument_list|(
literal|1
argument_list|,
literal|"mainloop ends %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|dump
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dn_queue
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|flows
condition|;
name|i
operator|++
control|)
block|{
name|q
operator|=
name|FI2Q
argument_list|(
name|c
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|1
argument_list|,
literal|"queue %4d tot %10lld"
argument_list|,
name|i
argument_list|,
name|q
operator|->
name|ni
operator|.
name|tot_bytes
argument_list|)
expr_stmt|;
block|}
name|DX
argument_list|(
literal|1
argument_list|,
literal|"done %d loops\n"
argument_list|,
name|c
operator|->
name|loops
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* interpret a number in human form */
end_comment

begin_function
specifier|static
name|long
name|getnum
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
modifier|*
name|next
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|char
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|long
name|l
decl_stmt|;
if|if
condition|(
name|next
condition|)
comment|/* default */
operator|*
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|&&
operator|*
name|s
condition|)
block|{
name|DX
argument_list|(
literal|3
argument_list|,
literal|"token is<%s> %s"
argument_list|,
name|s
argument_list|,
name|key
condition|?
name|key
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|l
operator|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|DX
argument_list|(
literal|3
argument_list|,
literal|"empty string"
argument_list|)
expr_stmt|;
name|l
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|DX
argument_list|(
literal|2
argument_list|,
literal|"invalid %s for %s"
argument_list|,
name|s
condition|?
name|s
else|:
literal|"NULL"
argument_list|,
operator|(
name|key
condition|?
name|key
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|// invalid
block|}
if|if
condition|(
operator|!
name|end
operator|||
operator|!
operator|*
name|end
condition|)
return|return
name|l
return|;
if|if
condition|(
operator|*
name|end
operator|==
literal|'n'
condition|)
name|l
operator|=
operator|-
name|l
expr_stmt|;
comment|/* multiply by n */
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'K'
condition|)
name|l
operator|=
name|l
operator|*
literal|1000
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'M'
condition|)
name|l
operator|=
name|l
operator|*
literal|1000000
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'k'
condition|)
name|l
operator|=
name|l
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'m'
condition|)
name|l
operator|=
name|l
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|end
operator|==
literal|'w'
condition|)
empty_stmt|;
else|else
block|{
comment|/* not recognized */
name|D
argument_list|(
literal|"suffix %s for %s, next %p"
argument_list|,
name|end
argument_list|,
name|key
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|end
operator|--
expr_stmt|;
block|}
name|end
operator|++
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"suffix now %s for %s, next %p"
argument_list|,
name|end
argument_list|,
name|key
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|&&
operator|*
name|end
condition|)
block|{
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting next to %s for %s"
argument_list|,
name|end
argument_list|,
name|key
argument_list|)
expr_stmt|;
operator|*
name|next
operator|=
name|end
expr_stmt|;
block|}
return|return
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * flowsets are a comma-separated list of  *     weight:maxlen:flows  * indicating how many flows are hooked to that fs.  * Both weight and range can be min-max-steps.  * In a first pass we just count the number of flowsets and flows,  * in a second pass we complete the setup.  */
end_comment

begin_function
specifier|static
name|void
name|parse_flowsets
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|fs
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|n_flows
init|=
literal|0
decl_stmt|,
name|n_fs
init|=
literal|0
decl_stmt|,
name|wsum
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|struct
name|dn_fs
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"--- pass %d flows %d flowsets %d"
argument_list|,
name|pass
argument_list|,
name|c
operator|->
name|flows
argument_list|,
name|c
operator|->
name|flowsets
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|c
operator|->
name|fs_config
operator|=
name|fs
expr_stmt|;
name|s
operator|=
name|c
operator|->
name|fs_config
condition|?
name|strdup
argument_list|(
name|c
operator|->
name|fs_config
argument_list|)
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
name|D
argument_list|(
literal|"no fsconfig"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|next
operator|=
name|s
init|;
operator|(
name|cur
operator|=
name|strsep
argument_list|(
operator|&
name|next
argument_list|,
literal|","
argument_list|)
operator|)
condition|;
control|)
block|{
name|char
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|int
name|w
decl_stmt|,
name|w_h
decl_stmt|,
name|w_steps
decl_stmt|,
name|wi
decl_stmt|;
name|int
name|len
decl_stmt|,
name|len_h
decl_stmt|,
name|l_steps
decl_stmt|,
name|li
decl_stmt|;
name|int
name|flows
decl_stmt|;
name|w
operator|=
name|getnum
argument_list|(
name|strsep
argument_list|(
operator|&
name|cur
argument_list|,
literal|":"
argument_list|)
argument_list|,
operator|&
name|p
argument_list|,
literal|"weight"
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|<=
literal|0
condition|)
name|w
operator|=
literal|1
expr_stmt|;
name|w_h
operator|=
name|p
condition|?
name|getnum
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|"weight_max"
argument_list|)
else|:
name|w
expr_stmt|;
name|w_steps
operator|=
name|p
condition|?
name|getnum
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|"w_steps"
argument_list|)
else|:
operator|(
name|w_h
operator|==
name|w
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|len
operator|=
name|getnum
argument_list|(
name|strsep
argument_list|(
operator|&
name|cur
argument_list|,
literal|":"
argument_list|)
argument_list|,
operator|&
name|p
argument_list|,
literal|"len"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
name|len
operator|=
literal|1000
expr_stmt|;
name|len_h
operator|=
name|p
condition|?
name|getnum
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|"len_max"
argument_list|)
else|:
name|len
expr_stmt|;
name|l_steps
operator|=
name|p
condition|?
name|getnum
argument_list|(
name|p
operator|+
literal|1
argument_list|,
operator|&
name|p
argument_list|,
literal|"l_steps"
argument_list|)
else|:
operator|(
name|len_h
operator|==
name|len
condition|?
literal|1
else|:
literal|2
operator|)
expr_stmt|;
name|flows
operator|=
name|getnum
argument_list|(
name|strsep
argument_list|(
operator|&
name|cur
argument_list|,
literal|":"
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|"flows"
argument_list|)
expr_stmt|;
if|if
condition|(
name|flows
operator|==
literal|0
condition|)
name|flows
operator|=
literal|1
expr_stmt|;
name|DX
argument_list|(
literal|4
argument_list|,
literal|"weight %d..%d (%d) len %d..%d (%d) flows %d"
argument_list|,
name|w
argument_list|,
name|w_h
argument_list|,
name|w_steps
argument_list|,
name|len
argument_list|,
name|len_h
argument_list|,
name|l_steps
argument_list|,
name|flows
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
literal|0
operator|||
name|w_h
operator|<
name|w
operator|||
name|len
operator|==
literal|0
operator|||
name|len_h
operator|<
name|len
operator|||
name|flows
operator|==
literal|0
condition|)
block|{
name|DX
argument_list|(
literal|4
argument_list|,
literal|"wrong parameters %s"
argument_list|,
name|fs
argument_list|)
expr_stmt|;
return|return;
block|}
name|n_flows
operator|+=
name|flows
operator|*
name|w_steps
operator|*
name|l_steps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|w_steps
condition|;
name|i
operator|++
control|)
block|{
name|wi
operator|=
name|w
operator|+
operator|(
operator|(
name|w_h
operator|-
name|w
operator|)
operator|*
name|i
operator|)
operator|/
operator|(
name|w_steps
operator|==
literal|1
condition|?
literal|1
else|:
operator|(
name|w_steps
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|l_steps
condition|;
name|j
operator|++
operator|,
name|n_fs
operator|++
control|)
block|{
name|struct
name|dn_fs
modifier|*
name|fs
init|=
operator|&
name|c
operator|->
name|fs
index|[
name|n_fs
index|]
operator|.
name|fs
decl_stmt|;
comment|// tentative
name|int
name|x
decl_stmt|;
name|li
operator|=
name|len
operator|+
operator|(
operator|(
name|len_h
operator|-
name|len
operator|)
operator|*
name|j
operator|)
operator|/
operator|(
name|l_steps
operator|==
literal|1
condition|?
literal|1
else|:
operator|(
name|l_steps
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|x
operator|=
operator|(
name|wi
operator|*
literal|2048
operator|)
operator|/
name|li
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"----- fs %4d weight %4d lmax %4d X %4d flows %d"
argument_list|,
name|n_fs
argument_list|,
name|wi
argument_list|,
name|li
argument_list|,
name|x
argument_list|,
name|flows
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|c
operator|->
name|fs
operator|==
name|NULL
operator|||
name|c
operator|->
name|flowsets
operator|<=
name|n_fs
condition|)
block|{
name|D
argument_list|(
literal|"error in number of flowsets"
argument_list|)
expr_stmt|;
return|return;
block|}
name|wsum
operator|+=
name|wi
operator|*
name|flows
expr_stmt|;
name|fs
operator|->
name|par
index|[
literal|0
index|]
operator|=
name|wi
expr_stmt|;
name|fs
operator|->
name|par
index|[
literal|1
index|]
operator|=
name|li
expr_stmt|;
name|fs
operator|->
name|index
operator|=
name|n_fs
expr_stmt|;
name|fs
operator|->
name|n_flows
operator|=
name|flows
expr_stmt|;
name|fs
operator|->
name|cur
operator|=
name|fs
operator|->
name|first_flow
operator|=
name|prev
operator|==
name|NULL
condition|?
literal|0
else|:
name|prev
operator|->
name|next_flow
expr_stmt|;
name|fs
operator|->
name|next_flow
operator|=
name|fs
operator|->
name|first_flow
operator|+
name|fs
operator|->
name|n_flows
expr_stmt|;
name|fs
operator|->
name|y
operator|=
name|x
operator|*
name|flows
expr_stmt|;
name|fs
operator|->
name|base_y
operator|=
operator|(
name|prev
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|prev
operator|->
name|next_y
expr_stmt|;
name|fs
operator|->
name|next_y
operator|=
name|fs
operator|->
name|base_y
operator|+
name|fs
operator|->
name|y
expr_stmt|;
name|prev
operator|=
name|fs
expr_stmt|;
block|}
block|}
block|}
name|c
operator|->
name|max_y
operator|=
name|prev
condition|?
name|prev
operator|->
name|base_y
operator|+
name|prev
operator|->
name|y
else|:
literal|0
expr_stmt|;
name|c
operator|->
name|flows
operator|=
name|n_flows
expr_stmt|;
name|c
operator|->
name|flowsets
operator|=
name|n_fs
expr_stmt|;
name|c
operator|->
name|wsum
operator|=
name|wsum
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|0
condition|)
return|return;
comment|/* now link all flows to their parent flowsets */
name|DX
argument_list|(
literal|1
argument_list|,
literal|"%d flows on %d flowsets max_y %d"
argument_list|,
name|c
operator|->
name|flows
argument_list|,
name|c
operator|->
name|flowsets
argument_list|,
name|c
operator|->
name|max_y
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|flowsets
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dn_fs
modifier|*
name|fs
init|=
operator|&
name|c
operator|->
name|fs
index|[
name|i
index|]
operator|.
name|fs
decl_stmt|;
name|DX
argument_list|(
literal|1
argument_list|,
literal|"fs %3d w %5d l %4d flow %5d .. %5d y %6d .. %6d"
argument_list|,
name|i
argument_list|,
name|fs
operator|->
name|par
index|[
literal|0
index|]
argument_list|,
name|fs
operator|->
name|par
index|[
literal|1
index|]
argument_list|,
name|fs
operator|->
name|first_flow
argument_list|,
name|fs
operator|->
name|next_flow
argument_list|,
name|fs
operator|->
name|base_y
argument_list|,
name|fs
operator|->
name|next_y
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|fs
operator|->
name|first_flow
init|;
name|j
operator|<
name|fs
operator|->
name|next_flow
condition|;
name|j
operator|++
control|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
init|=
name|FI2Q
argument_list|(
name|c
argument_list|,
name|j
argument_list|)
decl_stmt|;
name|q
operator|->
name|fs
operator|=
operator|&
name|c
operator|->
name|fs
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|init
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|ac
init|=
name|c
operator|->
name|ac
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|av
init|=
name|c
operator|->
name|av
decl_stmt|;
name|c
operator|->
name|si_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_sch_inst
argument_list|)
expr_stmt|;
name|c
operator|->
name|q_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dn_queue
argument_list|)
expr_stmt|;
name|moduledata_t
modifier|*
name|mod
init|=
name|NULL
decl_stmt|;
name|struct
name|dn_alg
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|c
operator|->
name|th_min
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|th_max
operator|=
operator|-
literal|20
expr_stmt|;
comment|/* 20 packets per flow */
name|c
operator|->
name|lmin
operator|=
name|c
operator|->
name|lmax
operator|=
literal|1280
expr_stmt|;
comment|/* packet len */
name|c
operator|->
name|flows
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|flowsets
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|name
operator|=
literal|"null"
expr_stmt|;
name|ac
operator|--
expr_stmt|;
name|av
operator|++
expr_stmt|;
while|while
condition|(
name|ac
operator|>
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
name|c
operator|->
name|loops
operator|=
name|getnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
name|debug
operator|=
name|atoi
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-alg"
argument_list|)
condition|)
block|{
specifier|extern
name|moduledata_t
modifier|*
name|_g_dn_fifo
decl_stmt|;
specifier|extern
name|moduledata_t
modifier|*
name|_g_dn_wf2qp
decl_stmt|;
specifier|extern
name|moduledata_t
modifier|*
name|_g_dn_rr
decl_stmt|;
specifier|extern
name|moduledata_t
modifier|*
name|_g_dn_qfq
decl_stmt|;
ifdef|#
directive|ifdef
name|WITH_KPS
specifier|extern
name|moduledata_t
modifier|*
name|_g_dn_kps
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"rr"
argument_list|)
condition|)
name|mod
operator|=
name|_g_dn_rr
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"wf2qp"
argument_list|)
condition|)
name|mod
operator|=
name|_g_dn_wf2qp
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"fifo"
argument_list|)
condition|)
name|mod
operator|=
name|_g_dn_fifo
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"qfq"
argument_list|)
condition|)
name|mod
operator|=
name|_g_dn_qfq
expr_stmt|;
ifdef|#
directive|ifdef
name|WITH_KPS
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
literal|"kps"
argument_list|)
condition|)
name|mod
operator|=
name|_g_dn_kps
expr_stmt|;
endif|#
directive|endif
else|else
name|mod
operator|=
name|NULL
expr_stmt|;
name|c
operator|->
name|name
operator|=
name|mod
condition|?
name|mod
operator|->
name|name
else|:
literal|"NULL"
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"using scheduler %s"
argument_list|,
name|c
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-len"
argument_list|)
condition|)
block|{
name|c
operator|->
name|lmin
operator|=
name|getnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|c
operator|->
name|lmax
operator|=
name|c
operator|->
name|lmin
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting max to %d"
argument_list|,
name|c
operator|->
name|th_max
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-burst"
argument_list|)
condition|)
block|{
name|c
operator|->
name|maxburst
operator|=
name|getnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting max to %d"
argument_list|,
name|c
operator|->
name|th_max
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-qmax"
argument_list|)
condition|)
block|{
name|c
operator|->
name|th_max
operator|=
name|getnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting max to %d"
argument_list|,
name|c
operator|->
name|th_max
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-qmin"
argument_list|)
condition|)
block|{
name|c
operator|->
name|th_min
operator|=
name|getnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting min to %d"
argument_list|,
name|c
operator|->
name|th_min
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-flows"
argument_list|)
condition|)
block|{
name|c
operator|->
name|flows
operator|=
name|getnum
argument_list|(
name|av
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting flows to %d"
argument_list|,
name|c
operator|->
name|flows
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
operator|*
name|av
argument_list|,
literal|"-flowsets"
argument_list|)
condition|)
block|{
name|parse_flowsets
argument_list|(
name|c
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"setting flowsets to %d"
argument_list|,
name|c
operator|->
name|flowsets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|D
argument_list|(
literal|"option %s not recognised, ignore"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
name|ac
operator|-=
literal|2
expr_stmt|;
name|av
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|->
name|maxburst
operator|<=
literal|0
condition|)
name|c
operator|->
name|maxburst
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|loops
operator|<=
literal|0
condition|)
name|c
operator|->
name|loops
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flows
operator|<=
literal|0
condition|)
name|c
operator|->
name|flows
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|flowsets
operator|<=
literal|0
condition|)
name|c
operator|->
name|flowsets
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|lmin
operator|<=
literal|0
condition|)
name|c
operator|->
name|lmin
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|lmax
operator|<=
literal|0
condition|)
name|c
operator|->
name|lmax
operator|=
literal|1
expr_stmt|;
comment|/* multiply by N */
if|if
condition|(
name|c
operator|->
name|th_min
operator|<
literal|0
condition|)
name|c
operator|->
name|th_min
operator|=
name|c
operator|->
name|flows
operator|*
operator|-
name|c
operator|->
name|th_min
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|th_max
operator|<
literal|0
condition|)
name|c
operator|->
name|th_max
operator|=
name|c
operator|->
name|flows
operator|*
operator|-
name|c
operator|->
name|th_max
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|th_max
operator|<=
name|c
operator|->
name|th_min
condition|)
name|c
operator|->
name|th_max
operator|=
name|c
operator|->
name|th_min
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|mod
condition|)
block|{
name|p
operator|=
name|mod
operator|->
name|p
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"using module %s f %p p %p"
argument_list|,
name|mod
operator|->
name|name
argument_list|,
name|mod
operator|->
name|f
argument_list|,
name|mod
operator|->
name|p
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|3
argument_list|,
literal|"modname %s ty %d"
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|type
argument_list|)
expr_stmt|;
name|c
operator|->
name|enq
operator|=
name|p
operator|->
name|enqueue
expr_stmt|;
name|c
operator|->
name|deq
operator|=
name|p
operator|->
name|dequeue
expr_stmt|;
name|c
operator|->
name|si_len
operator|+=
name|p
operator|->
name|si_datalen
expr_stmt|;
name|c
operator|->
name|q_len
operator|+=
name|p
operator|->
name|q_datalen
expr_stmt|;
name|c
operator|->
name|schk_len
operator|+=
name|p
operator|->
name|schk_datalen
expr_stmt|;
block|}
comment|/* allocate queues, flowsets and one scheduler */
name|c
operator|->
name|q
operator|=
name|calloc
argument_list|(
name|c
operator|->
name|flows
argument_list|,
name|c
operator|->
name|q_len
argument_list|)
expr_stmt|;
name|c
operator|->
name|fs
operator|=
name|calloc
argument_list|(
name|c
operator|->
name|flowsets
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dn_fsk
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|->
name|si
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
name|c
operator|->
name|si_len
argument_list|)
expr_stmt|;
name|c
operator|->
name|sched
operator|=
name|calloc
argument_list|(
name|c
operator|->
name|flows
argument_list|,
name|c
operator|->
name|schk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|q
operator|==
name|NULL
operator|||
name|c
operator|->
name|fs
operator|==
name|NULL
condition|)
block|{
name|D
argument_list|(
literal|"error allocating memory for flows"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|si
operator|->
name|sched
operator|=
name|c
operator|->
name|sched
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|config
condition|)
name|p
operator|->
name|config
argument_list|(
name|c
operator|->
name|sched
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|new_sched
condition|)
name|p
operator|->
name|new_sched
argument_list|(
name|c
operator|->
name|si
argument_list|)
expr_stmt|;
block|}
comment|/* parse_flowsets links queues to their flowsets */
name|parse_flowsets
argument_list|(
name|c
argument_list|,
name|av
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* complete the work calling new_fsk */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|flowsets
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|fs
index|[
name|i
index|]
operator|.
name|fs
operator|.
name|par
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|c
operator|->
name|fs
index|[
name|i
index|]
operator|.
name|fs
operator|.
name|par
index|[
literal|1
index|]
operator|=
literal|1000
expr_stmt|;
comment|/* default pkt len */
name|c
operator|->
name|fs
index|[
name|i
index|]
operator|.
name|sched
operator|=
name|c
operator|->
name|sched
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|new_fsk
condition|)
name|p
operator|->
name|new_fsk
argument_list|(
operator|&
name|c
operator|->
name|fs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* initialize the lists for the generator, and put 	 * all flows in the list for backlog = 0 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|BACKLOG
operator|+
literal|5
condition|;
name|i
operator|++
control|)
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|c
operator|->
name|ll
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|flows
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
init|=
name|FI2Q
argument_list|(
name|c
argument_list|,
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|fs
operator|==
name|NULL
condition|)
name|q
operator|->
name|fs
operator|=
operator|&
name|c
operator|->
name|fs
index|[
literal|0
index|]
expr_stmt|;
comment|/* XXX */
name|q
operator|->
name|_si
operator|=
name|c
operator|->
name|si
expr_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|new_queue
condition|)
name|p
operator|->
name|new_queue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|INIT_LIST_HEAD
argument_list|(
operator|&
name|q
operator|->
name|ni
operator|.
name|h
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|q
operator|->
name|ni
operator|.
name|h
argument_list|,
operator|&
name|c
operator|->
name|ll
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|c
operator|->
name|llmask
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
name|av
index|[]
parameter_list|)
block|{
name|struct
name|cfg_s
name|c
decl_stmt|;
name|struct
name|timeval
name|end
decl_stmt|;
name|double
name|ll
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|msg
index|[
literal|40
index|]
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|.
name|ac
operator|=
name|ac
expr_stmt|;
name|c
operator|.
name|av
operator|=
name|av
expr_stmt|;
name|init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|c
operator|.
name|time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mainloop
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|end
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|end
operator|.
name|tv_sec
operator|-=
name|c
operator|.
name|time
operator|.
name|tv_sec
expr_stmt|;
name|end
operator|.
name|tv_usec
operator|-=
name|c
operator|.
name|time
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|end
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
name|end
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
name|end
operator|.
name|tv_sec
operator|--
expr_stmt|;
block|}
name|c
operator|.
name|time
operator|=
name|end
expr_stmt|;
name|ll
operator|=
name|end
operator|.
name|tv_sec
operator|*
literal|1000000
operator|+
name|end
operator|.
name|tv_usec
expr_stmt|;
name|ll
operator|*=
literal|1000
expr_stmt|;
comment|/* convert to nanoseconds */
name|ll
operator|/=
name|c
operator|.
name|_enqueue
expr_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"1::%d"
argument_list|,
name|c
operator|.
name|flows
argument_list|)
expr_stmt|;
name|D
argument_list|(
literal|"%-8s n %d %d time %d.%06d %8.3f qlen %d %d flows %s drops %d"
argument_list|,
name|c
operator|.
name|name
argument_list|,
name|c
operator|.
name|_enqueue
argument_list|,
name|c
operator|.
name|loops
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|time
operator|.
name|tv_sec
argument_list|,
operator|(
name|int
operator|)
name|c
operator|.
name|time
operator|.
name|tv_usec
argument_list|,
name|ll
argument_list|,
name|c
operator|.
name|th_min
argument_list|,
name|c
operator|.
name|th_max
argument_list|,
name|c
operator|.
name|fs_config
condition|?
name|c
operator|.
name|fs_config
else|:
name|msg
argument_list|,
name|c
operator|.
name|drop
argument_list|)
expr_stmt|;
name|dump
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|1
argument_list|,
literal|"done ac %d av %p"
argument_list|,
name|ac
argument_list|,
name|av
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ac
condition|;
name|i
operator|++
control|)
name|DX
argument_list|(
literal|1
argument_list|,
literal|"arg %d %s"
argument_list|,
name|i
argument_list|,
name|av
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The controller decides whether in this iteration we should send  * (the packet is in c->tosend) and/or receive (flag c->can_dequeue)  */
end_comment

begin_function
specifier|static
name|void
name|controller
parameter_list|(
name|struct
name|cfg_s
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|dn_fs
modifier|*
name|fs
decl_stmt|;
name|int
name|flow_id
decl_stmt|;
comment|/* histeresis between max and min */
if|if
condition|(
name|c
operator|->
name|state
operator|==
literal|0
operator|&&
name|c
operator|->
name|pending
operator|>=
name|c
operator|->
name|th_max
condition|)
name|c
operator|->
name|state
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|state
operator|==
literal|1
operator|&&
name|c
operator|->
name|pending
operator|<=
name|c
operator|->
name|th_min
condition|)
name|c
operator|->
name|state
operator|=
literal|0
expr_stmt|;
name|ND
argument_list|(
literal|1
argument_list|,
literal|"state %d pending %2d"
argument_list|,
name|c
operator|->
name|state
argument_list|,
name|c
operator|->
name|pending
argument_list|)
expr_stmt|;
name|c
operator|->
name|can_dequeue
operator|=
name|c
operator|->
name|state
expr_stmt|;
name|c
operator|->
name|tosend
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|state
condition|)
return|return;
if|if
condition|(
literal|1
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|dn_queue
modifier|*
name|q
decl_stmt|;
name|struct
name|list_head
modifier|*
name|h
decl_stmt|;
name|i
operator|=
name|ffs
argument_list|(
name|c
operator|->
name|llmask
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|DX
argument_list|(
literal|2
argument_list|,
literal|"no candidate"
argument_list|)
expr_stmt|;
name|c
operator|->
name|can_dequeue
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|h
operator|=
operator|&
name|c
operator|->
name|ll
index|[
name|i
index|]
expr_stmt|;
name|ND
argument_list|(
literal|1
argument_list|,
literal|"backlog %d p %p prev %p next %p"
argument_list|,
name|i
argument_list|,
name|h
argument_list|,
name|h
operator|->
name|prev
argument_list|,
name|h
operator|->
name|next
argument_list|)
expr_stmt|;
name|q
operator|=
name|list_first_entry
argument_list|(
name|h
argument_list|,
expr|struct
name|dn_queue
argument_list|,
name|ni
operator|.
name|h
argument_list|)
expr_stmt|;
name|list_del
argument_list|(
operator|&
name|q
operator|->
name|ni
operator|.
name|h
argument_list|)
expr_stmt|;
name|flow_id
operator|=
name|Q2FI
argument_list|(
name|c
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|DX
argument_list|(
literal|2
argument_list|,
literal|"extracted flow %p %d backlog %d"
argument_list|,
name|q
argument_list|,
name|flow_id
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_empty
argument_list|(
name|h
argument_list|)
condition|)
block|{
name|ND
argument_list|(
literal|2
argument_list|,
literal|"backlog %d empty"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|c
operator|->
name|llmask
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|ND
argument_list|(
literal|1
argument_list|,
literal|"before %d p %p prev %p next %p"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|h
operator|+
literal|1
argument_list|,
name|h
index|[
literal|1
index|]
operator|.
name|prev
argument_list|,
name|h
index|[
literal|1
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
name|list_add_tail
argument_list|(
operator|&
name|q
operator|->
name|ni
operator|.
name|h
argument_list|,
name|h
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ND
argument_list|(
literal|1
argument_list|,
literal|" after %d p %p prev %p next %p"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|h
operator|+
literal|1
argument_list|,
name|h
index|[
literal|1
index|]
operator|.
name|prev
argument_list|,
name|h
index|[
literal|1
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|BACKLOG
condition|)
block|{
name|ND
argument_list|(
literal|2
argument_list|,
literal|"backlog %d full"
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|c
operator|->
name|llmask
operator||=
literal|1
operator|<<
operator|(
literal|1
operator|+
name|i
operator|)
expr_stmt|;
block|}
name|fs
operator|=
operator|&
name|q
operator|->
name|fs
operator|->
name|fs
expr_stmt|;
name|c
operator|->
name|cur_fs
operator|=
name|q
operator|->
name|fs
operator|-
name|c
operator|->
name|fs
expr_stmt|;
name|fs
operator|->
name|cur
operator|=
name|flow_id
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX this does not work ? */
comment|/* now decide whom to send the packet, and the length */
comment|/* lookup in the flow table */
if|if
condition|(
name|c
operator|->
name|cur_y
operator|>=
name|c
operator|->
name|max_y
condition|)
block|{
comment|/* handle wraparound */
name|c
operator|->
name|cur_y
operator|=
literal|0
expr_stmt|;
name|c
operator|->
name|cur_fs
operator|=
literal|0
expr_stmt|;
block|}
name|fs
operator|=
operator|&
name|c
operator|->
name|fs
index|[
name|c
operator|->
name|cur_fs
index|]
operator|.
name|fs
expr_stmt|;
name|flow_id
operator|=
name|fs
operator|->
name|cur
operator|++
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|cur
operator|>=
name|fs
operator|->
name|next_flow
condition|)
name|fs
operator|->
name|cur
operator|=
name|fs
operator|->
name|first_flow
expr_stmt|;
name|c
operator|->
name|cur_y
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|cur_y
operator|>=
name|fs
operator|->
name|next_y
condition|)
name|c
operator|->
name|cur_fs
operator|++
expr_stmt|;
block|}
comment|/* construct a packet */
if|if
condition|(
name|c
operator|->
name|freelist
condition|)
block|{
name|m
operator|=
name|c
operator|->
name|tosend
operator|=
name|c
operator|->
name|freelist
expr_stmt|;
name|c
operator|->
name|freelist
operator|=
name|c
operator|->
name|freelist
operator|->
name|m_nextpkt
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|c
operator|->
name|tosend
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|m
operator|->
name|cfg
operator|=
name|c
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|fs
operator|->
name|par
index|[
literal|1
index|]
expr_stmt|;
comment|// XXX maxlen
name|m
operator|->
name|flow_id
operator|=
name|flow_id
expr_stmt|;
name|ND
argument_list|(
literal|2
argument_list|,
literal|"y %6d flow %5d fs %3d weight %4d len %4d"
argument_list|,
name|c
operator|->
name|cur_y
argument_list|,
name|m
operator|->
name|flow_id
argument_list|,
name|c
operator|->
name|cur_fs
argument_list|,
name|fs
operator|->
name|par
index|[
literal|0
index|]
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Packet allocation: to achieve a distribution that matches weights, for each X=w/lmax class we should generate a number of packets proportional to Y = X times the number of flows in the class. So we construct an array with the cumulative distribution of Y's, and use it to identify the flow via inverse mapping (if the Y's are not too many we can use an array for the lookup). In practice, each flow will have X entries [virtually] pointing to it.  */
end_comment

end_unit

