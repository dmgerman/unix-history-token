begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2010 Riccardo Panicucci, Universita` di Pisa  * Copyright (c) 2000-2002 Luigi Rizzo, Universita` di Pisa  * All rights reserved  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * $FreeBSD$  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_comment
comment|/* IFNAMSIZ */
end_comment

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_comment
comment|/* ipfw_rule_ref */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_comment
comment|/* flow_id */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ipfw/dn_heap.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ipfw/ip_dn_private.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ipfw/dn_sched.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dn_test.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX64
end_ifndef

begin_define
define|#
directive|define
name|MAX64
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(( (int64_t) ( (y)-(x) ))> 0 ) ? (y) : (x)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * timestamps are computed on 64 bit using fixed point arithmetic.  * LMAX_BITS, WMAX_BITS are the max number of bits for the packet len  * and sum of weights, respectively. FRAC_BITS is the number of  * fractional bits. We want FRAC_BITS>> WMAX_BITS to avoid too large  * errors when computing the inverse, FRAC_BITS< 32 so we can do 1/w  * using an unsigned 32-bit division, and to avoid wraparounds we need  * LMAX_BITS + WMAX_BITS + FRAC_BITS<< 64  * As an example  * FRAC_BITS = 26, LMAX_BITS=14, WMAX_BITS = 19  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FRAC_BITS
end_ifndef

begin_define
define|#
directive|define
name|FRAC_BITS
value|28
end_define

begin_comment
comment|/* shift for fixed point arithmetic */
end_comment

begin_define
define|#
directive|define
name|ONE_FP
value|(1UL<< FRAC_BITS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Private information for the scheduler instance:  * sch_heap (key is Finish time) returns the next queue to serve  * ne_heap (key is Start time) stores not-eligible queues  * idle_heap (key=start/finish time) stores idle flows. It must  *	support extract-from-middle.  * A flow is only in 1 of the three heaps.  * XXX todo: use a more efficient data structure, e.g. a tree sorted  * by F with min_subtree(S) in each node  */
end_comment

begin_struct
struct|struct
name|wf2qp_si
block|{
name|struct
name|dn_heap
name|sch_heap
decl_stmt|;
comment|/* top extract - key Finish  time */
name|struct
name|dn_heap
name|ne_heap
decl_stmt|;
comment|/* top extract - key Start   time */
name|struct
name|dn_heap
name|idle_heap
decl_stmt|;
comment|/* random extract - key Start=Finish time */
name|uint64_t
name|V
decl_stmt|;
comment|/* virtual time */
name|uint32_t
name|inv_wsum
decl_stmt|;
comment|/* inverse of sum of weights */
name|uint32_t
name|wsum
decl_stmt|;
comment|/* sum of weights */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|wf2qp_queue
block|{
name|struct
name|dn_queue
name|_q
decl_stmt|;
name|uint64_t
name|S
decl_stmt|,
name|F
decl_stmt|;
comment|/* start time, finish time */
name|uint32_t
name|inv_w
decl_stmt|;
comment|/* ONE_FP / weight */
name|int32_t
name|heap_pos
decl_stmt|;
comment|/* position (index) of struct in heap */
block|}
struct|;
end_struct

begin_comment
comment|/*  * This file implements a WF2Q+ scheduler as it has been in dummynet  * since 2000.  * The scheduler supports per-flow queues and has O(log N) complexity.  *  * WF2Q+ needs to drain entries from the idle heap so that we  * can keep the sum of weights up to date. We can do it whenever  * we get a chance, or periodically, or following some other  * strategy. The function idle_check() drains at most N elements  * from the idle heap.  */
end_comment

begin_function
specifier|static
name|void
name|idle_check
parameter_list|(
name|struct
name|wf2qp_si
modifier|*
name|si
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|dn_heap
modifier|*
name|h
init|=
operator|&
name|si
operator|->
name|idle_heap
decl_stmt|;
while|while
condition|(
name|n
operator|--
operator|>
literal|0
operator|&&
name|h
operator|->
name|elements
operator|>
literal|0
operator|&&
operator|(
name|force
operator|||
name|DN_KEY_LT
argument_list|(
name|HEAP_TOP
argument_list|(
name|h
argument_list|)
operator|->
name|key
argument_list|,
name|si
operator|->
name|V
argument_list|)
operator|)
condition|)
block|{
name|struct
name|dn_queue
modifier|*
name|q
init|=
name|HEAP_TOP
argument_list|(
name|h
argument_list|)
operator|->
name|object
decl_stmt|;
name|struct
name|wf2qp_queue
modifier|*
name|alg_fq
init|=
operator|(
expr|struct
name|wf2qp_queue
operator|*
operator|)
name|q
decl_stmt|;
name|heap_extract
argument_list|(
name|h
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX to let the flowset delete the queue we should 	 * mark it as 'unused' by the scheduler. 	 */
name|alg_fq
operator|->
name|S
operator|=
name|alg_fq
operator|->
name|F
operator|+
literal|1
expr_stmt|;
comment|/* Mark timestamp as invalid. */
name|si
operator|->
name|wsum
operator|-=
name|q
operator|->
name|fs
operator|->
name|fs
operator|.
name|par
index|[
literal|0
index|]
expr_stmt|;
comment|/* adjust sum of weights */
if|if
condition|(
name|si
operator|->
name|wsum
operator|>
literal|0
condition|)
name|si
operator|->
name|inv_wsum
operator|=
name|ONE_FP
operator|/
name|si
operator|->
name|wsum
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wf2qp_enqueue
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|,
name|struct
name|dn_queue
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|dn_fsk
modifier|*
name|fs
init|=
name|q
operator|->
name|fs
decl_stmt|;
name|struct
name|wf2qp_si
modifier|*
name|si
init|=
operator|(
expr|struct
name|wf2qp_si
operator|*
operator|)
operator|(
name|_si
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|wf2qp_queue
modifier|*
name|alg_fq
decl_stmt|;
name|uint64_t
name|len
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
if|if
condition|(
name|m
operator|!=
name|q
operator|->
name|mq
operator|.
name|head
condition|)
block|{
if|if
condition|(
name|dn_enqueue
argument_list|(
name|q
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* packet was dropped */
return|return
literal|1
return|;
if|if
condition|(
name|m
operator|!=
name|q
operator|->
name|mq
operator|.
name|head
condition|)
comment|/* queue was already busy */
return|return
literal|0
return|;
block|}
comment|/* If reach this point, queue q was idle */
name|alg_fq
operator|=
operator|(
expr|struct
name|wf2qp_queue
operator|*
operator|)
name|q
expr_stmt|;
if|if
condition|(
name|DN_KEY_LT
argument_list|(
name|alg_fq
operator|->
name|F
argument_list|,
name|alg_fq
operator|->
name|S
argument_list|)
condition|)
block|{
comment|/* F<S means timestamps are invalid ->brand new queue. */
name|alg_fq
operator|->
name|S
operator|=
name|si
operator|->
name|V
expr_stmt|;
comment|/* init start time */
name|si
operator|->
name|wsum
operator|+=
name|fs
operator|->
name|fs
operator|.
name|par
index|[
literal|0
index|]
expr_stmt|;
comment|/* add weight of new queue. */
name|si
operator|->
name|inv_wsum
operator|=
name|ONE_FP
operator|/
name|si
operator|->
name|wsum
expr_stmt|;
block|}
else|else
block|{
comment|/* if it was idle then it was in the idle heap */
name|heap_extract
argument_list|(
operator|&
name|si
operator|->
name|idle_heap
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|alg_fq
operator|->
name|S
operator|=
name|MAX64
argument_list|(
name|alg_fq
operator|->
name|F
argument_list|,
name|si
operator|->
name|V
argument_list|)
expr_stmt|;
comment|/* compute new S */
block|}
name|alg_fq
operator|->
name|F
operator|=
name|alg_fq
operator|->
name|S
operator|+
name|len
operator|*
name|alg_fq
operator|->
name|inv_w
expr_stmt|;
comment|/* if nothing is backlogged, make sure this flow is eligible */
if|if
condition|(
name|si
operator|->
name|ne_heap
operator|.
name|elements
operator|==
literal|0
operator|&&
name|si
operator|->
name|sch_heap
operator|.
name|elements
operator|==
literal|0
condition|)
name|si
operator|->
name|V
operator|=
name|MAX64
argument_list|(
name|alg_fq
operator|->
name|S
argument_list|,
name|si
operator|->
name|V
argument_list|)
expr_stmt|;
comment|/*      * Look at eligibility. A flow is not eligibile if S>V (when      * this happens, it means that there is some other flow already      * scheduled for the same pipe, so the sch_heap cannot be      * empty). If the flow is not eligible we just store it in the      * ne_heap. Otherwise, we store in the sch_heap.      * Note that for all flows in sch_heap (SCH), S_i<= V,      * and for all flows in ne_heap (NEH), S_i> V.      * So when we need to compute max(V, min(S_i)) forall i in      * SCH+NEH, we only need to look into NEH.      */
if|if
condition|(
name|DN_KEY_LT
argument_list|(
name|si
operator|->
name|V
argument_list|,
name|alg_fq
operator|->
name|S
argument_list|)
condition|)
block|{
comment|/* S>V means flow Not eligible. */
if|if
condition|(
name|si
operator|->
name|sch_heap
operator|.
name|elements
operator|==
literal|0
condition|)
name|D
argument_list|(
literal|"++ ouch! not eligible but empty scheduler!"
argument_list|)
expr_stmt|;
name|heap_insert
argument_list|(
operator|&
name|si
operator|->
name|ne_heap
argument_list|,
name|alg_fq
operator|->
name|S
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heap_insert
argument_list|(
operator|&
name|si
operator|->
name|sch_heap
argument_list|,
name|alg_fq
operator|->
name|F
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* XXX invariant: sch> 0 || V>= min(S in neh) */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|wf2qp_dequeue
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|)
block|{
comment|/* Access scheduler instance private data */
name|struct
name|wf2qp_si
modifier|*
name|si
init|=
operator|(
expr|struct
name|wf2qp_si
operator|*
operator|)
operator|(
name|_si
operator|+
literal|1
operator|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|dn_queue
modifier|*
name|q
decl_stmt|;
name|struct
name|dn_heap
modifier|*
name|sch
init|=
operator|&
name|si
operator|->
name|sch_heap
decl_stmt|;
name|struct
name|dn_heap
modifier|*
name|neh
init|=
operator|&
name|si
operator|->
name|ne_heap
decl_stmt|;
name|struct
name|wf2qp_queue
modifier|*
name|alg_fq
decl_stmt|;
if|if
condition|(
name|sch
operator|->
name|elements
operator|==
literal|0
operator|&&
name|neh
operator|->
name|elements
operator|==
literal|0
condition|)
block|{
comment|/* we have nothing to do. We could kill the idle heap 		 * altogether and reset V 		 */
name|idle_check
argument_list|(
name|si
argument_list|,
literal|0x7fffffff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|si
operator|->
name|V
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|wsum
operator|=
literal|0
expr_stmt|;
comment|/* should be set already */
return|return
name|NULL
return|;
comment|/* quick return if nothing to do */
block|}
name|idle_check
argument_list|(
name|si
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* drain something from the idle heap */
comment|/* make sure at least one element is eligible, bumping V 	 * and moving entries that have become eligible. 	 * We need to repeat the first part twice, before and 	 * after extracting the candidate, or enqueue() will 	 * find the data structure in a wrong state. 	 */
name|m
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 	 * Compute V = max(V, min(S_i)). Remember that all elements 	 * in sch have by definition S_i<= V so if sch is not empty, 	 * V is surely the max and we must not update it. Conversely, 	 * if sch is empty we only need to look at neh. 	 * We don't need to move the queues, as it will be done at the 	 * next enqueue 	 */
if|if
condition|(
name|sch
operator|->
name|elements
operator|==
literal|0
operator|&&
name|neh
operator|->
name|elements
operator|>
literal|0
condition|)
block|{
name|si
operator|->
name|V
operator|=
name|MAX64
argument_list|(
name|si
operator|->
name|V
argument_list|,
name|HEAP_TOP
argument_list|(
name|neh
argument_list|)
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|neh
operator|->
name|elements
operator|>
literal|0
operator|&&
name|DN_KEY_LEQ
argument_list|(
name|HEAP_TOP
argument_list|(
name|neh
argument_list|)
operator|->
name|key
argument_list|,
name|si
operator|->
name|V
argument_list|)
condition|)
block|{
name|q
operator|=
name|HEAP_TOP
argument_list|(
name|neh
argument_list|)
operator|->
name|object
expr_stmt|;
name|alg_fq
operator|=
operator|(
expr|struct
name|wf2qp_queue
operator|*
operator|)
name|q
expr_stmt|;
name|heap_extract
argument_list|(
name|neh
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|heap_insert
argument_list|(
name|sch
argument_list|,
name|alg_fq
operator|->
name|F
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
comment|/* pkt found in previous iteration */
break|break;
comment|/* ok we have at least one eligible pkt */
name|q
operator|=
name|HEAP_TOP
argument_list|(
name|sch
argument_list|)
operator|->
name|object
expr_stmt|;
name|alg_fq
operator|=
operator|(
expr|struct
name|wf2qp_queue
operator|*
operator|)
name|q
expr_stmt|;
name|m
operator|=
name|dn_dequeue
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|heap_extract
argument_list|(
name|sch
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Remove queue from heap. */
name|si
operator|->
name|V
operator|+=
call|(
name|uint64_t
call|)
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
operator|*
name|si
operator|->
name|inv_wsum
expr_stmt|;
name|alg_fq
operator|->
name|S
operator|=
name|alg_fq
operator|->
name|F
expr_stmt|;
comment|/* Update start time. */
if|if
condition|(
name|q
operator|->
name|mq
operator|.
name|head
operator|==
literal|0
condition|)
block|{
comment|/* not backlogged any more. */
name|heap_insert
argument_list|(
operator|&
name|si
operator|->
name|idle_heap
argument_list|,
name|alg_fq
operator|->
name|F
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Still backlogged. */
comment|/* Update F, store in neh or sch */
name|uint64_t
name|len
init|=
name|q
operator|->
name|mq
operator|.
name|head
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|alg_fq
operator|->
name|F
operator|+=
name|len
operator|*
name|alg_fq
operator|->
name|inv_w
expr_stmt|;
if|if
condition|(
name|DN_KEY_LEQ
argument_list|(
name|alg_fq
operator|->
name|S
argument_list|,
name|si
operator|->
name|V
argument_list|)
condition|)
block|{
name|heap_insert
argument_list|(
name|sch
argument_list|,
name|alg_fq
operator|->
name|F
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heap_insert
argument_list|(
name|neh
argument_list|,
name|alg_fq
operator|->
name|S
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wf2qp_new_sched
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|)
block|{
name|struct
name|wf2qp_si
modifier|*
name|si
init|=
operator|(
expr|struct
name|wf2qp_si
operator|*
operator|)
operator|(
name|_si
operator|+
literal|1
operator|)
decl_stmt|;
name|int
name|ofs
init|=
name|offsetof
argument_list|(
expr|struct
name|wf2qp_queue
argument_list|,
name|heap_pos
argument_list|)
decl_stmt|;
comment|/* all heaps support extract from middle */
if|if
condition|(
name|heap_init
argument_list|(
operator|&
name|si
operator|->
name|idle_heap
argument_list|,
literal|16
argument_list|,
name|ofs
argument_list|)
operator|||
name|heap_init
argument_list|(
operator|&
name|si
operator|->
name|sch_heap
argument_list|,
literal|16
argument_list|,
name|ofs
argument_list|)
operator|||
name|heap_init
argument_list|(
operator|&
name|si
operator|->
name|ne_heap
argument_list|,
literal|16
argument_list|,
name|ofs
argument_list|)
condition|)
block|{
name|heap_free
argument_list|(
operator|&
name|si
operator|->
name|ne_heap
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
operator|&
name|si
operator|->
name|sch_heap
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
operator|&
name|si
operator|->
name|idle_heap
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wf2qp_free_sched
parameter_list|(
name|struct
name|dn_sch_inst
modifier|*
name|_si
parameter_list|)
block|{
name|struct
name|wf2qp_si
modifier|*
name|si
init|=
operator|(
expr|struct
name|wf2qp_si
operator|*
operator|)
operator|(
name|_si
operator|+
literal|1
operator|)
decl_stmt|;
name|heap_free
argument_list|(
operator|&
name|si
operator|->
name|sch_heap
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
operator|&
name|si
operator|->
name|ne_heap
argument_list|)
expr_stmt|;
name|heap_free
argument_list|(
operator|&
name|si
operator|->
name|idle_heap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wf2qp_new_fsk
parameter_list|(
name|struct
name|dn_fsk
modifier|*
name|fs
parameter_list|)
block|{
name|ipdn_bound_var
argument_list|(
operator|&
name|fs
operator|->
name|fs
operator|.
name|par
index|[
literal|0
index|]
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
literal|"WF2Q+ weight"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wf2qp_new_queue
parameter_list|(
name|struct
name|dn_queue
modifier|*
name|_q
parameter_list|)
block|{
name|struct
name|wf2qp_queue
modifier|*
name|q
init|=
operator|(
expr|struct
name|wf2qp_queue
operator|*
operator|)
name|_q
decl_stmt|;
name|_q
operator|->
name|ni
operator|.
name|oid
operator|.
name|subtype
operator|=
name|DN_SCHED_WF2QP
expr_stmt|;
name|q
operator|->
name|F
operator|=
literal|0
expr_stmt|;
comment|/* not strictly necessary */
name|q
operator|->
name|S
operator|=
name|q
operator|->
name|F
operator|+
literal|1
expr_stmt|;
comment|/* mark timestamp as invalid. */
name|q
operator|->
name|inv_w
operator|=
name|ONE_FP
operator|/
name|_q
operator|->
name|fs
operator|->
name|fs
operator|.
name|par
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|_q
operator|->
name|mq
operator|.
name|head
operator|!=
name|NULL
condition|)
block|{
name|wf2qp_enqueue
argument_list|(
name|_q
operator|->
name|_si
argument_list|,
name|_q
argument_list|,
name|_q
operator|->
name|mq
operator|.
name|head
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Called when the infrastructure removes a queue (e.g. flowset  * is reconfigured). Nothing to do if we did not 'own' the queue,  * otherwise remove it from the right heap and adjust the sum  * of weights.  */
end_comment

begin_function
specifier|static
name|int
name|wf2qp_free_queue
parameter_list|(
name|struct
name|dn_queue
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|wf2qp_queue
modifier|*
name|alg_fq
init|=
operator|(
expr|struct
name|wf2qp_queue
operator|*
operator|)
name|q
decl_stmt|;
name|struct
name|wf2qp_si
modifier|*
name|si
init|=
operator|(
expr|struct
name|wf2qp_si
operator|*
operator|)
operator|(
name|q
operator|->
name|_si
operator|+
literal|1
operator|)
decl_stmt|;
if|if
condition|(
name|alg_fq
operator|->
name|S
operator|>=
name|alg_fq
operator|->
name|F
operator|+
literal|1
condition|)
return|return
literal|0
return|;
comment|/* nothing to do, not in any heap */
name|si
operator|->
name|wsum
operator|-=
name|q
operator|->
name|fs
operator|->
name|fs
operator|.
name|par
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|wsum
operator|>
literal|0
condition|)
name|si
operator|->
name|inv_wsum
operator|=
name|ONE_FP
operator|/
name|si
operator|->
name|wsum
expr_stmt|;
comment|/* extract from the heap. XXX TODO we may need to adjust V 	 * to make sure the invariants hold. 	 */
if|if
condition|(
name|q
operator|->
name|mq
operator|.
name|head
operator|==
name|NULL
condition|)
block|{
name|heap_extract
argument_list|(
operator|&
name|si
operator|->
name|idle_heap
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DN_KEY_LT
argument_list|(
name|si
operator|->
name|V
argument_list|,
name|alg_fq
operator|->
name|S
argument_list|)
condition|)
block|{
name|heap_extract
argument_list|(
operator|&
name|si
operator|->
name|ne_heap
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|heap_extract
argument_list|(
operator|&
name|si
operator|->
name|sch_heap
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * WF2Q+ scheduler descriptor  * contains the type of the scheduler, the name, the size of the  * structures and function pointers.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|dn_alg
name|wf2qp_desc
init|=
block|{
name|_SI
argument_list|(
argument|.type =
argument_list|)
name|DN_SCHED_WF2QP
block|,
name|_SI
argument_list|(
operator|.
name|name
operator|=
argument_list|)
literal|"WF2Q+"
block|,
name|_SI
argument_list|(
argument|.flags =
argument_list|)
name|DN_MULTIQUEUE
block|,
comment|/* we need extra space in the si and the queue */
name|_SI
argument_list|(
operator|.
name|schk_datalen
operator|=
argument_list|)
literal|0
block|,
name|_SI
argument_list|(
operator|.
name|si_datalen
operator|=
argument_list|)
sizeof|sizeof
argument_list|(
expr|struct
name|wf2qp_si
argument_list|)
block|,
name|_SI
argument_list|(
operator|.
name|q_datalen
operator|=
argument_list|)
sizeof|sizeof
argument_list|(
expr|struct
name|wf2qp_queue
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|dn_queue
argument_list|)
block|,
name|_SI
argument_list|(
argument|.enqueue =
argument_list|)
name|wf2qp_enqueue
block|,
name|_SI
argument_list|(
argument|.dequeue =
argument_list|)
name|wf2qp_dequeue
block|,
name|_SI
argument_list|(
argument|.config =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.destroy =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.new_sched =
argument_list|)
name|wf2qp_new_sched
block|,
name|_SI
argument_list|(
argument|.free_sched =
argument_list|)
name|wf2qp_free_sched
block|,
name|_SI
argument_list|(
argument|.new_fsk =
argument_list|)
name|wf2qp_new_fsk
block|,
name|_SI
argument_list|(
argument|.free_fsk =
argument_list|)
name|NULL
block|,
name|_SI
argument_list|(
argument|.new_queue =
argument_list|)
name|wf2qp_new_queue
block|,
name|_SI
argument_list|(
argument|.free_queue =
argument_list|)
name|wf2qp_free_queue
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_DNSCHED_MODULE
argument_list|(
name|dn_wf2qp
argument_list|,
operator|&
name|wf2qp_desc
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

