begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|SCTP_AUTH_DEBUG
value|(sctp_debug_on& SCTP_DEBUG_AUTH1)
end_define

begin_define
define|#
directive|define
name|SCTP_AUTH_DEBUG2
value|(sctp_debug_on& SCTP_DEBUG_AUTH2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCTP_DEBUG */
end_comment

begin_function
specifier|inline
name|void
name|sctp_clear_chunklist
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|chklist
parameter_list|)
block|{
name|bzero
argument_list|(
name|chklist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chklist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chklist->num_chunks = 0; */
block|}
end_function

begin_function
name|sctp_auth_chklist_t
modifier|*
name|sctp_alloc_chunklist
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_auth_chklist_t
modifier|*
name|chklist
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|chklist
argument_list|,
name|sctp_auth_chklist_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chklist
argument_list|)
argument_list|,
literal|"AUTH chklist"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chklist
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_AUTH_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_alloc_chunklist: failed to get memory!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
else|else
block|{
name|sctp_clear_chunklist
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|chklist
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_chunklist
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
name|SCTP_FREE
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|sctp_auth_chklist_t
modifier|*
name|sctp_copy_chunklist
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
name|sctp_auth_chklist_t
modifier|*
name|new_list
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* get a new list */
name|new_list
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* copy it */
name|bcopy
argument_list|(
name|list
argument_list|,
name|new_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add a chunk to the required chunks list  */
end_comment

begin_function
name|int
name|sctp_auth_add_chunk
parameter_list|(
name|uint8_t
name|chunk
parameter_list|,
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is chunk restricted? */
if|if
condition|(
operator|(
name|chunk
operator|==
name|SCTP_INITIATION
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_INITIATION_ACK
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_SHUTDOWN_COMPLETE
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_AUTHENTICATION
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|==
literal|0
condition|)
block|{
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|=
literal|1
expr_stmt|;
name|list
operator|->
name|num_chunks
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP: added chunk %u (0x%02x) to Auth list\n"
argument_list|,
name|chunk
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete a chunk from the required chunks list  */
end_comment

begin_function
name|int
name|sctp_auth_delete_chunk
parameter_list|(
name|uint8_t
name|chunk
parameter_list|,
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is chunk restricted? */
if|if
condition|(
operator|(
name|chunk
operator|==
name|SCTP_ASCONF
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_ASCONF_ACK
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|==
literal|1
condition|)
block|{
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|num_chunks
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP: deleted chunk %u (0x%02x) from Auth list\n"
argument_list|,
name|chunk
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|inline
name|size_t
name|sctp_auth_get_chklist_size
parameter_list|(
specifier|const
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|list
operator|->
name|num_chunks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the default list of chunks requiring AUTH  */
end_comment

begin_function
name|void
name|sctp_auth_set_default_chunks
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
name|sctp_auth_add_chunk
argument_list|(
name|SCTP_ASCONF
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|sctp_auth_add_chunk
argument_list|(
name|SCTP_ASCONF_ACK
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * return the current number and list of required chunks caller must  * guarantee ptr has space for up to 256 bytes  */
end_comment

begin_function
name|int
name|sctp_serialize_auth_chunks
parameter_list|(
specifier|const
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_pack_auth_chunks
parameter_list|(
specifier|const
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|list
operator|->
name|num_chunks
operator|<=
literal|32
condition|)
block|{
comment|/* just list them, one byte each */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|index
decl_stmt|,
name|offset
decl_stmt|;
comment|/* pack into a 32 byte bitfield */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|index
operator|=
name|i
operator|/
literal|8
expr_stmt|;
name|offset
operator|=
name|i
operator|%
literal|8
expr_stmt|;
name|ptr
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|offset
operator|)
expr_stmt|;
block|}
block|}
name|size
operator|=
literal|32
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_unpack_auth_chunks
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|num_chunks
parameter_list|,
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|num_chunks
operator|<=
literal|32
condition|)
block|{
comment|/* just pull them, one byte each */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
name|sctp_auth_add_chunk
argument_list|(
operator|*
name|ptr
operator|++
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|num_chunks
expr_stmt|;
block|}
else|else
block|{
name|int
name|index
decl_stmt|,
name|offset
decl_stmt|;
comment|/* unpack from a 32 byte bitfield */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|32
condition|;
name|index
operator|++
control|)
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|8
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|index
index|]
operator|&
operator|(
literal|1
operator|<<
name|offset
operator|)
condition|)
block|{
name|sctp_auth_add_chunk
argument_list|(
operator|(
name|index
operator|*
literal|8
operator|)
operator|+
name|offset
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|size
operator|=
literal|32
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocate structure space for a key of length keylen  */
end_comment

begin_function
name|sctp_key_t
modifier|*
name|sctp_alloc_key
parameter_list|(
name|uint32_t
name|keylen
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_key
argument_list|,
name|sctp_key_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_key
argument_list|)
operator|+
name|keylen
argument_list|,
literal|"AUTH key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|SCTP_FREE
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_print_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: [Null key]\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s: len %u, "
argument_list|,
name|str
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key
operator|->
name|keylen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|key
operator|->
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[Null key]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_show_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: [Null key]\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"%s: len %u, "
argument_list|,
name|str
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key
operator|->
name|keylen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|key
operator|->
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"[Null key]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|sctp_get_keylen
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
return|return
operator|(
name|key
operator|->
name|keylen
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate a new random key of length 'keylen'  */
end_comment

begin_function
name|sctp_key_t
modifier|*
name|sctp_generate_random_key
parameter_list|(
name|uint32_t
name|keylen
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
comment|/* validate keylen */
if|if
condition|(
name|keylen
operator|>
name|SCTP_AUTH_RANDOM_SIZE_MAX
condition|)
name|keylen
operator|=
name|SCTP_AUTH_RANDOM_SIZE_MAX
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_READ_RANDOM
argument_list|(
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|new_key
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|sctp_key_t
modifier|*
name|sctp_set_key
parameter_list|(
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|key
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given two keys of variable size, compute which key is "larger/smaller"  * returns: 1 if key1> key2 -1 if key1< key2 0 if key1 = key2  */
end_comment

begin_function
specifier|static
name|int
name|sctp_compare_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key1
parameter_list|,
name|sctp_key_t
modifier|*
name|key2
parameter_list|)
block|{
name|uint32_t
name|maxlen
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|key1len
decl_stmt|,
name|key2len
decl_stmt|;
name|uint8_t
modifier|*
name|key_1
decl_stmt|,
modifier|*
name|key_2
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_RANDOM_SIZE_MAX
index|]
decl_stmt|;
comment|/* sanity/length check */
name|key1len
operator|=
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
expr_stmt|;
name|key2len
operator|=
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key1len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|key2len
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|key1len
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|key2len
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|key1len
operator|!=
name|key2len
condition|)
block|{
if|if
condition|(
name|key1len
operator|>=
name|key2len
condition|)
name|maxlen
operator|=
name|key1len
expr_stmt|;
else|else
name|maxlen
operator|=
name|key2len
expr_stmt|;
name|bzero
argument_list|(
name|temp
argument_list|,
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|key1len
operator|<
name|maxlen
condition|)
block|{
comment|/* prepend zeroes to key1 */
name|bcopy
argument_list|(
name|key1
operator|->
name|key
argument_list|,
name|temp
operator|+
operator|(
name|maxlen
operator|-
name|key1len
operator|)
argument_list|,
name|key1len
argument_list|)
expr_stmt|;
name|key_1
operator|=
name|temp
expr_stmt|;
name|key_2
operator|=
name|key2
operator|->
name|key
expr_stmt|;
block|}
else|else
block|{
comment|/* prepend zeroes to key2 */
name|bcopy
argument_list|(
name|key2
operator|->
name|key
argument_list|,
name|temp
operator|+
operator|(
name|maxlen
operator|-
name|key2len
operator|)
argument_list|,
name|key2len
argument_list|)
expr_stmt|;
name|key_1
operator|=
name|key1
operator|->
name|key
expr_stmt|;
name|key_2
operator|=
name|temp
expr_stmt|;
block|}
block|}
else|else
block|{
name|maxlen
operator|=
name|key1len
expr_stmt|;
name|key_1
operator|=
name|key1
operator|->
name|key
expr_stmt|;
name|key_2
operator|=
name|key2
operator|->
name|key
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|key_1
operator|>
operator|*
name|key_2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|*
name|key_1
operator|<
operator|*
name|key_2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|key_1
operator|++
expr_stmt|;
name|key_2
operator|++
expr_stmt|;
block|}
comment|/* keys are equal value, so check lengths */
if|if
condition|(
name|key1len
operator|==
name|key2len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|key1len
operator|<
name|key2len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate the concatenated keying material based on the two keys and the  * shared key (if available). draft-ietf-tsvwg-auth specifies the specific  * order for concatenation  */
end_comment

begin_function
name|sctp_key_t
modifier|*
name|sctp_compute_hashkey
parameter_list|(
name|sctp_key_t
modifier|*
name|key1
parameter_list|,
name|sctp_key_t
modifier|*
name|key2
parameter_list|,
name|sctp_key_t
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|keylen
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint8_t
modifier|*
name|key_ptr
decl_stmt|;
name|keylen
operator|=
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
operator|+
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
operator|+
name|sctp_get_keylen
argument_list|(
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|>
literal|0
condition|)
block|{
comment|/* get space for the new key */
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
name|key_ptr
operator|=
name|new_key
operator|->
name|key
expr_stmt|;
block|}
else|else
block|{
comment|/* all keys empty/null?! */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* concatenate the keys */
if|if
condition|(
name|sctp_compare_key
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* key is key1 + shared + key2 */
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key1
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key1
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|key1
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|shared
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|shared
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|shared
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|shared
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key2
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key2
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|key2
operator|->
name|keylen
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* key is key2 + shared + key1 */
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key2
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key2
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|key2
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|shared
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|shared
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|shared
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|shared
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key1
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key1
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|key1
operator|->
name|keylen
expr_stmt|;
block|}
block|}
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|sctp_sharedkey_t
modifier|*
name|sctp_alloc_sharedkey
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|new_key
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_key
argument_list|,
name|sctp_sharedkey_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_key
argument_list|)
argument_list|,
literal|"AUTH skey"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|->
name|keyid
operator|=
literal|0
expr_stmt|;
name|new_key
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_sharedkey
parameter_list|(
name|sctp_sharedkey_t
modifier|*
name|skey
parameter_list|)
block|{
if|if
condition|(
name|skey
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|skey
operator|->
name|key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|skey
operator|->
name|key
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|skey
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|sctp_sharedkey_t
modifier|*
name|sctp_find_sharedkey
parameter_list|(
name|struct
name|sctp_keyhead
modifier|*
name|shared_keys
parameter_list|,
name|uint16_t
name|key_id
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|skey
argument_list|,
argument|shared_keys
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|skey
operator|->
name|keyid
operator|==
name|key_id
condition|)
return|return
operator|(
name|skey
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_insert_sharedkey
parameter_list|(
name|struct
name|sctp_keyhead
modifier|*
name|shared_keys
parameter_list|,
name|sctp_sharedkey_t
modifier|*
name|new_skey
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
operator|(
name|shared_keys
operator|==
name|NULL
operator|)
operator|||
operator|(
name|new_skey
operator|==
name|NULL
operator|)
condition|)
return|return;
comment|/* insert into an empty list? */
if|if
condition|(
name|SCTP_LIST_EMPTY
argument_list|(
name|shared_keys
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
name|shared_keys
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* insert into the existing list, ordered by key id */
name|LIST_FOREACH
argument_list|(
argument|skey
argument_list|,
argument|shared_keys
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|new_skey
operator|->
name|keyid
operator|<
name|skey
operator|->
name|keyid
condition|)
block|{
comment|/* insert it before here */
name|LIST_INSERT_BEFORE
argument_list|(
name|skey
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|new_skey
operator|->
name|keyid
operator|==
name|skey
operator|->
name|keyid
condition|)
block|{
comment|/* replace the existing key */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"replacing shared key id %u\n"
argument_list|,
name|new_skey
operator|->
name|keyid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|LIST_INSERT_BEFORE
argument_list|(
name|skey
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* belongs at the end of the list */
name|LIST_INSERT_AFTER
argument_list|(
name|skey
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|sctp_sharedkey_t
modifier|*
name|sctp_copy_sharedkey
parameter_list|(
specifier|const
name|sctp_sharedkey_t
modifier|*
name|skey
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|new_skey
decl_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new_skey
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_skey
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|skey
operator|->
name|key
operator|!=
name|NULL
condition|)
name|new_skey
operator|->
name|key
operator|=
name|sctp_set_key
argument_list|(
name|skey
operator|->
name|key
operator|->
name|key
argument_list|,
name|skey
operator|->
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
else|else
name|new_skey
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|new_skey
operator|->
name|keyid
operator|=
name|skey
operator|->
name|keyid
expr_stmt|;
return|return
operator|(
name|new_skey
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_copy_skeylist
parameter_list|(
specifier|const
name|struct
name|sctp_keyhead
modifier|*
name|src
parameter_list|,
name|struct
name|sctp_keyhead
modifier|*
name|dest
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|,
modifier|*
name|new_skey
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dest
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|skey
argument_list|,
argument|src
argument_list|,
argument|next
argument_list|)
block|{
name|new_skey
operator|=
name|sctp_copy_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_skey
operator|!=
name|NULL
condition|)
block|{
name|sctp_insert_sharedkey
argument_list|(
name|dest
argument_list|,
name|new_skey
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|sctp_hmaclist_t
modifier|*
name|sctp_alloc_hmaclist
parameter_list|(
name|uint8_t
name|num_hmacs
parameter_list|)
block|{
name|sctp_hmaclist_t
modifier|*
name|new_list
decl_stmt|;
name|int
name|alloc_size
decl_stmt|;
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
operator|+
name|num_hmacs
operator|*
sizeof|sizeof
argument_list|(
name|new_list
operator|->
name|hmac
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_list
argument_list|,
name|sctp_hmaclist_t
operator|*
argument_list|,
name|alloc_size
argument_list|,
literal|"AUTH HMAC list"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_list
operator|->
name|max_algo
operator|=
name|num_hmacs
expr_stmt|;
name|new_list
operator|->
name|num_algo
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_hmaclist
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_auth_add_hmacid
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|,
name|uint16_t
name|hmac_id
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|list
operator|->
name|num_algo
operator|==
name|list
operator|->
name|max_algo
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP: HMAC id list full, ignoring add %u\n"
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA1
operator|)
operator|&&
ifdef|#
directive|ifdef
name|HAVE_SHA224
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA224
operator|)
operator|&&
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SHA2
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA256
operator|)
operator|&&
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA384
operator|)
operator|&&
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA512
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_MD5
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP: add HMAC id %u to list\n"
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|list
operator|->
name|hmac
index|[
name|list
operator|->
name|num_algo
operator|++
index|]
operator|=
name|hmac_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|sctp_hmaclist_t
modifier|*
name|sctp_copy_hmaclist
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|)
block|{
name|sctp_hmaclist_t
modifier|*
name|new_list
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* get a new list */
name|new_list
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|list
operator|->
name|max_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* copy it */
name|new_list
operator|->
name|max_algo
operator|=
name|list
operator|->
name|max_algo
expr_stmt|;
name|new_list
operator|->
name|num_algo
operator|=
name|list
operator|->
name|num_algo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
name|new_list
operator|->
name|hmac
index|[
name|i
index|]
operator|=
name|list
operator|->
name|hmac
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_function
name|sctp_hmaclist_t
modifier|*
name|sctp_default_supported_hmaclist
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_hmaclist_t
modifier|*
name|new_list
decl_stmt|;
name|new_list
operator|=
name|sctp_alloc_hmaclist
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sctp_auth_add_hmacid
argument_list|(
name|new_list
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|)
expr_stmt|;
name|sctp_auth_add_hmacid
argument_list|(
name|new_list
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA256
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * HMAC algos are listed in priority/preference order find the best HMAC id  * to use for the peer based on local support  */
end_comment

begin_function
name|uint16_t
name|sctp_negotiate_hmacid
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|peer
parameter_list|,
name|sctp_hmaclist_t
modifier|*
name|local
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|local
operator|==
name|NULL
operator|)
operator|||
operator|(
name|peer
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|SCTP_AUTH_HMAC_ID_RSVD
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|peer
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|local
operator|->
name|num_algo
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|local
operator|->
name|hmac
index|[
name|j
index|]
condition|)
block|{
ifndef|#
directive|ifndef
name|SCTP_AUTH_DRAFT_04
comment|/* "skip" MD5 as it's been deprecated */
if|if
condition|(
name|peer
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|SCTP_AUTH_HMAC_ID_MD5
condition|)
continue|continue;
endif|#
directive|endif
comment|/* found the "best" one */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP: negotiated peer HMAC id %u\n"
argument_list|,
name|peer
operator|->
name|hmac
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|peer
operator|->
name|hmac
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
block|}
comment|/* didn't find one! */
return|return
operator|(
name|SCTP_AUTH_HMAC_ID_RSVD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * serialize the HMAC algo list and return space used caller must guarantee  * ptr has appropriate space  */
end_comment

begin_function
name|int
name|sctp_serialize_hmaclist
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|hmac_id
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
name|hmac_id
operator|=
name|htons
argument_list|(
name|list
operator|->
name|hmac
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|hmac_id
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|hmac_id
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|hmac_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|list
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|hmac_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_verify_hmac_param
parameter_list|(
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
parameter_list|,
name|uint32_t
name|num_hmacs
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|hmac_id
decl_stmt|;
name|uint32_t
name|sha1_supported
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hmacs
condition|;
name|i
operator|++
control|)
block|{
name|hmac_id
operator|=
name|ntohs
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmac_id
operator|==
name|SCTP_AUTH_HMAC_ID_SHA1
condition|)
name|sha1_supported
operator|=
literal|1
expr_stmt|;
block|}
comment|/* all HMAC id's are supported */
if|if
condition|(
name|sha1_supported
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|sctp_authinfo_t
modifier|*
name|sctp_alloc_authinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_authinfo_t
modifier|*
name|new_authinfo
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_authinfo
argument_list|,
name|sctp_authinfo_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_authinfo
argument_list|)
argument_list|,
literal|"AUTH info"
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_authinfo
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|new_authinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_authinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_authinfo
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_authinfo
parameter_list|(
name|sctp_authinfo_t
modifier|*
name|authinfo
parameter_list|)
block|{
if|if
condition|(
name|authinfo
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|authinfo
operator|->
name|random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|random
argument_list|)
expr_stmt|;
if|if
condition|(
name|authinfo
operator|->
name|peer_random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|peer_random
argument_list|)
expr_stmt|;
if|if
condition|(
name|authinfo
operator|->
name|assoc_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|assoc_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|authinfo
operator|->
name|recv_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|recv_key
argument_list|)
expr_stmt|;
comment|/* We are NOT dynamically allocating authinfo's right now... */
comment|/* SCTP_FREE(authinfo); */
block|}
end_function

begin_function
specifier|inline
name|uint32_t
name|sctp_get_auth_chunk_len
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk
argument_list|)
operator|+
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCTP_SIZE32
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_get_hmac_digest_len
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA1
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_MD5
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_MD5
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_SHA224
case|case
name|SCTP_AUTH_HMAC_ID_SHA224
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA224
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SHA2
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA256
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_SHA384
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA384
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_SHA512
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA512
operator|)
return|;
endif|#
directive|endif
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sctp_get_hmac_block_len
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
case|case
name|SCTP_AUTH_HMAC_ID_MD5
case|:
ifdef|#
directive|ifdef
name|HAVE_SHA224
case|case
name|SCTP_AUTH_HMAC_ID_SHA224
case|:
return|return
operator|(
literal|64
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SHA2
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_SHA384
case|:
case|case
name|SCTP_AUTH_HMAC_ID_SHA512
case|:
return|return
operator|(
literal|128
operator|)
return|;
endif|#
directive|endif
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hmac_init
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_hash_context_t
modifier|*
name|ctx
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
name|SHA1_Init
argument_list|(
operator|&
name|ctx
operator|->
name|sha1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_MD5
case|:
name|MD5_Init
argument_list|(
operator|&
name|ctx
operator|->
name|md5
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_SHA224
case|case
name|SCTP_AUTH_HMAC_ID_SHA224
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SHA2
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
name|SHA256_Init
argument_list|(
operator|&
name|ctx
operator|->
name|sha256
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA384
case|:
name|SHA384_Init
argument_list|(
operator|&
name|ctx
operator|->
name|sha384
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA512
case|:
name|SHA512_Init
argument_list|(
operator|&
name|ctx
operator|->
name|sha512
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hmac_update
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_hash_context_t
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
name|SHA1_Update
argument_list|(
operator|&
name|ctx
operator|->
name|sha1
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_MD5
case|:
name|MD5_Update
argument_list|(
operator|&
name|ctx
operator|->
name|md5
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_SHA224
case|case
name|SCTP_AUTH_HMAC_ID_SHA224
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SHA2
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
name|SHA256_Update
argument_list|(
operator|&
name|ctx
operator|->
name|sha256
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA384
case|:
name|SHA384_Update
argument_list|(
operator|&
name|ctx
operator|->
name|sha384
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA512
case|:
name|SHA512_Update
argument_list|(
operator|&
name|ctx
operator|->
name|sha512
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hmac_final
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_hash_context_t
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
name|SHA1_Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|sha1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_MD5
case|:
name|MD5_Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|md5
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAVE_SHA224
case|case
name|SCTP_AUTH_HMAC_ID_SHA224
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_SHA2
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
name|SHA256_Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|sha256
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA384
case|:
comment|/* SHA384 is truncated SHA512 */
name|SHA384_Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|sha384
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA512
case|:
name|SHA512_Final
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|sha512
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return;
block|}
comment|/* end switch */
block|}
end_function

begin_comment
comment|/*  * Keyed-Hashing for Message Authentication: FIPS 198 (RFC 2104)  *  * Compute the HMAC digest using the desired hash key, text, and HMAC  * algorithm.  Resulting digest is placed in 'digest' and digest length  * is returned, if the HMAC was performed.  *  * WARNING: it is up to the caller to supply sufficient space to hold the  * resultant digest.  */
end_comment

begin_function
name|uint32_t
name|sctp_hmac
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|ipad
index|[
literal|128
index|]
decl_stmt|,
name|opad
index|[
literal|128
index|]
decl_stmt|;
comment|/* keyed hash inner/outer pads */
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* sanity check the material and length */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keylen
operator|==
literal|0
operator|)
operator|||
operator|(
name|text
operator|==
name|NULL
operator|)
operator|||
operator|(
name|textlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set the hashed key as the key */
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|key
operator|=
name|temp
expr_stmt|;
block|}
comment|/* initialize the inner/outer pads with the key and "append" zeroes */
name|bzero
argument_list|(
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|ipad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|opad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
comment|/* XOR the key with ipad and opad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blocklen
condition|;
name|i
operator|++
control|)
block|{
name|ipad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
name|opad
index|[
name|i
index|]
operator|^=
literal|0x5c
expr_stmt|;
block|}
comment|/* perform inner hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* perform outer hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|digest
argument_list|)
expr_stmt|;
return|return
operator|(
name|digestlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mbuf version */
end_comment

begin_function
name|uint32_t
name|sctp_hmac_m
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|m_offset
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|ipad
index|[
literal|128
index|]
decl_stmt|,
name|opad
index|[
literal|128
index|]
decl_stmt|;
comment|/* keyed hash inner/outer pads */
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
comment|/* sanity check the material and length */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keylen
operator|==
literal|0
operator|)
operator|||
operator|(
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set the hashed key as the key */
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|key
operator|=
name|temp
expr_stmt|;
block|}
comment|/* initialize the inner/outer pads with the key and "append" zeroes */
name|bzero
argument_list|(
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|ipad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|opad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
comment|/* XOR the key with ipad and opad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blocklen
condition|;
name|i
operator|++
control|)
block|{
name|ipad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
name|opad
index|[
name|i
index|]
operator|^=
literal|0x5c
expr_stmt|;
block|}
comment|/* perform inner hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
comment|/* find the correct starting mbuf and offset (get start of text) */
name|m_tmp
operator|=
name|m
expr_stmt|;
while|while
condition|(
operator|(
name|m_tmp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|m_offset
operator|>=
operator|(
name|uint32_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|)
condition|)
block|{
name|m_offset
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
comment|/* now use the rest of the mbuf chain for the text */
while|while
condition|(
name|m_tmp
operator|!=
name|NULL
condition|)
block|{
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|mtod
argument_list|(
name|m_tmp
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m_offset
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|-
name|m_offset
argument_list|)
expr_stmt|;
comment|/* clear the offset since it's only for the first mbuf */
name|m_offset
operator|=
literal|0
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* perform outer hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|digest
argument_list|)
expr_stmt|;
return|return
operator|(
name|digestlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * verify the HMAC digest using the desired hash key, text, and HMAC  * algorithm. Returns -1 on error, 0 on success.  */
end_comment

begin_function
name|int
name|sctp_verify_hmac
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|,
name|uint32_t
name|digestlen
parameter_list|)
block|{
name|uint32_t
name|len
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* sanity check the material and length */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keylen
operator|==
literal|0
operator|)
operator|||
operator|(
name|text
operator|==
name|NULL
operator|)
operator|||
operator|(
name|textlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|len
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|digestlen
operator|!=
name|len
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* compute the expected hash */
if|if
condition|(
name|sctp_hmac
argument_list|(
name|hmac_algo
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|temp
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|digest
argument_list|,
name|temp
argument_list|,
name|digestlen
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * computes the requested HMAC using a key struct (which may be modified if  * the keylen exceeds the HMAC block len).  */
end_comment

begin_function
name|uint32_t
name|sctp_compute_hmac
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_key_t
modifier|*
name|key
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|text
operator|==
name|NULL
operator|)
operator|||
operator|(
name|textlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* save the hashed key as the new key */
name|key
operator|->
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sctp_hmac
argument_list|(
name|hmac_algo
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mbuf version */
end_comment

begin_function
name|uint32_t
name|sctp_compute_hmac_m
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_key_t
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|m_offset
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* save the hashed key as the new key */
name|key
operator|->
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sctp_hmac_m
argument_list|(
name|hmac_algo
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|,
name|m
argument_list|,
name|m_offset
argument_list|,
name|digest
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_auth_is_supported_hmac
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|,
name|uint16_t
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|list
operator|==
name|NULL
operator|)
operator|||
operator|(
name|id
operator|==
name|SCTP_AUTH_HMAC_ID_RSVD
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|list
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not in the list */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * clear any cached key(s) if they match the given key id on an association  * the cached key(s) will be recomputed and re-cached at next use. ASSUMES  * TCB_LOCK is already held  */
end_comment

begin_function
name|void
name|sctp_clear_cachedkeys
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
condition|)
block|{
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
condition|)
block|{
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * clear any cached key(s) if they match the given key id for all assocs on  * an association ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|void
name|sctp_clear_cachedkeys_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return;
comment|/* clear the cached keys on all assocs on this instance */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * delete a shared key from an association ASSUMES TCB_LOCK is already held  */
end_comment

begin_function
name|int
name|sctp_delete_sharedkey
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is the keyid the assoc active sending key */
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* does the key exist? */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* remove it */
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
comment|/* frees skey->key as well */
comment|/* clear any cached keys */
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * deletes a shared key from the endpoint ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|int
name|sctp_delete_sharedkey_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is the keyid the active sending key on the endpoint or any assoc */
if|if
condition|(
name|keyid
operator|==
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* does the key exist? */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* remove it */
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
comment|/* frees skey->key as well */
comment|/* clear any cached keys */
name|sctp_clear_cachedkeys_ep
argument_list|(
name|inp
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the active key on an association ASSUME TCB_LOCK is already held  */
end_comment

begin_function
name|int
name|sctp_auth_setactivekey
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
init|=
name|NULL
decl_stmt|;
name|sctp_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|int
name|using_ep_key
init|=
literal|0
decl_stmt|;
comment|/* find the key on the assoc */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* if not on the assoc, find the key on the endpoint */
name|SCTP_INP_RLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
name|using_ep_key
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* that key doesn't exist */
if|if
condition|(
name|using_ep_key
condition|)
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get the shared key text */
name|key
operator|=
name|skey
operator|->
name|key
expr_stmt|;
comment|/* free any existing cached key */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|)
expr_stmt|;
comment|/* compute a new assoc key and cache it */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|=
name|sctp_compute_hashkey
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
operator|=
name|keyid
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|sctp_print_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|,
literal|"Assoc Key"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|using_ep_key
condition|)
name|SCTP_INP_RUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * set the active key on an endpoint ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|int
name|sctp_auth_setactivekey_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
comment|/* find the key */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* that key doesn't exist */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
operator|=
name|keyid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get local authentication parameters from cookie (from INIT-ACK)  */
end_comment

begin_function
name|void
name|sctp_auth_get_cookie_params
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|length
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|tmp_param
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|,
name|ptype
decl_stmt|;
name|uint8_t
name|random_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_random
modifier|*
name|p_random
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|random_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hmacs_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|hmacs_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|chunks_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|num_chunks
init|=
literal|0
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint32_t
name|keylen
decl_stmt|;
comment|/* convert to upper bound */
name|length
operator|+=
name|offset
expr_stmt|;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
operator|!=
name|NULL
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plen
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|+
name|plen
operator|>
name|length
operator|)
condition|)
break|break;
if|if
condition|(
name|ptype
operator|==
name|SCTP_RANDOM
condition|)
block|{
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|random_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return;
comment|/* save the random and length for the key */
name|p_random
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
name|phdr
expr_stmt|;
name|random_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HMAC_LIST
condition|)
block|{
name|int
name|num_hmacs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|hmacs_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return;
comment|/* save the hmacs list and num for the key */
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
name|phdr
expr_stmt|;
name|hmacs_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
expr_stmt|;
name|num_hmacs
operator|=
name|hmacs_len
operator|/
sizeof|sizeof
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
name|sctp_free_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|num_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hmacs
condition|;
name|i
operator|++
control|)
block|{
name|sctp_auth_add_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
name|ntohs
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_CHUNK_LIST
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|chunks_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return;
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_chunks
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
comment|/* save chunks list and num for the key */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|!=
name|NULL
condition|)
name|sctp_clear_chunklist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
else|else
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
name|sctp_auth_add_chunk
argument_list|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get next parameter */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|>
name|length
condition|)
break|break;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
block|}
comment|/* concatenate the full random key */
ifdef|#
directive|ifdef
name|SCTP_AUTH_DRAFT_04
name|keylen
operator|=
name|random_len
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
comment|/* copy in the RANDOM */
if|if
condition|(
name|p_random
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|p_random
operator|->
name|random_data
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|random_len
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
comment|/* copy in the RANDOM */
if|if
condition|(
name|p_random
operator|!=
name|NULL
condition|)
block|{
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|bcopy
argument_list|(
name|p_random
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
block|}
comment|/* append in the AUTH chunks */
if|if
condition|(
name|chunks
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|chunks
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
expr_stmt|;
block|}
comment|/* append in the HMACs */
if|if
condition|(
name|hmacs
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|hmacs
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|=
name|new_key
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
operator|=
name|random_len
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUTH_DRAFT_04
comment|/* don't include the chunks and hmacs for draft -04 */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|->
name|keylen
operator|=
name|random_len
expr_stmt|;
endif|#
directive|endif
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
argument_list|)
expr_stmt|;
comment|/* negotiate what HMAC to use for the peer */
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
operator|=
name|sctp_negotiate_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
comment|/* copy defaults from the endpoint */
comment|/* FIX ME: put in cookie? */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|default_keyid
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * compute and fill in the HMAC digest for a packet  */
end_comment

begin_function
name|void
name|sctp_fill_hmac_digest_m
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|sctp_key_t
modifier|*
name|key
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|auth
operator|==
name|NULL
operator|)
condition|)
return|return;
comment|/* zero the digest + chunk padding */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|auth
operator|->
name|hmac
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|digestlen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is an assoc key cached? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|==
name|NULL
condition|)
block|{
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* not in the assoc list, so check the endpoint list */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
block|}
comment|/* the only way skey is NULL is if null key id 0 is used */
if|if
condition|(
name|skey
operator|!=
name|NULL
condition|)
name|key
operator|=
name|skey
operator|->
name|key
expr_stmt|;
else|else
name|key
operator|=
name|NULL
expr_stmt|;
comment|/* compute a new assoc key and cache it */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|=
name|sctp_compute_hashkey
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|,
name|key
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"caching key id %u\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
name|sctp_print_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|,
literal|"Assoc Key"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* set in the active key id */
name|auth
operator|->
name|shared_key_id
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
comment|/* compute and fill in the digest */
operator|(
name|void
operator|)
name|sctp_compute_hmac_m
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
operator|->
name|hmac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_bzero_m
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|m_offset
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* find the correct starting mbuf and offset (get start position) */
name|m_tmp
operator|=
name|m
expr_stmt|;
while|while
condition|(
operator|(
name|m_tmp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|m_offset
operator|>=
operator|(
name|uint32_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|)
condition|)
block|{
name|m_offset
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
comment|/* now use the rest of the mbuf chain */
while|while
condition|(
operator|(
name|m_tmp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|m_tmp
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m_offset
expr_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
name|uint32_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|data
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clear the offset since it's only for the first mbuf */
name|m_offset
operator|=
literal|0
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process the incoming Authentication chunk return codes: -1 on any  * authentication error 0 on authentication verification  */
end_comment

begin_function
name|int
name|sctp_handle_auth
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint16_t
name|chunklen
decl_stmt|;
name|uint16_t
name|shared_key_id
decl_stmt|;
name|uint16_t
name|hmac_id
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|uint32_t
name|digestlen
decl_stmt|;
name|uint8_t
name|digest
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|uint8_t
name|computed_digest
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* auth is checked for NULL by caller */
name|chunklen
operator|=
name|ntohs
argument_list|(
name|auth
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunklen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthfailed
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauth
argument_list|)
expr_stmt|;
comment|/* get the auth params */
name|shared_key_id
operator|=
name|ntohs
argument_list|(
name|auth
operator|->
name|shared_key_id
argument_list|)
expr_stmt|;
name|hmac_id
operator|=
name|ntohs
argument_list|(
name|auth
operator|->
name|hmac_id
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP AUTH Chunk: shared key %u, HMAC id %u\n"
argument_list|,
name|shared_key_id
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* is the indicated HMAC supported? */
if|if
condition|(
operator|!
name|sctp_auth_is_supported_hmac
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
name|hmac_id
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_err
decl_stmt|;
name|struct
name|sctp_auth_invalid_hmac
modifier|*
name|err
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvivalhmacid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP Auth: unsupported HMAC id %u\n"
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * report this in an Error Chunk: Unsupported HMAC 		 * Identifier 		 */
name|m_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|err
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_err
operator|!=
name|NULL
condition|)
block|{
comment|/* pre-reserve some space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in the error */
name|err
operator|=
name|mtod
argument_list|(
name|m_err
argument_list|,
expr|struct
name|sctp_auth_invalid_hmac
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|err
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNSUPPORTED_HMACID
argument_list|)
expr_stmt|;
name|err
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|->
name|hmac_id
operator|=
name|ntohs
argument_list|(
name|hmac_id
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|err
argument_list|)
expr_stmt|;
comment|/* queue it */
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|m_err
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get the indicated shared key, if available */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
operator|!=
name|shared_key_id
operator|)
condition|)
block|{
comment|/* find the shared key on the assoc first */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|shared_key_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* if not on the assoc, find it on the endpoint */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|shared_key_id
argument_list|)
expr_stmt|;
block|}
comment|/* if the shared key isn't found, discard the chunk */
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvivalkeyid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP Auth: unknown key id %u\n"
argument_list|,
name|shared_key_id
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* generate a notification if this is a new key id */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
operator|!=
name|shared_key_id
condition|)
comment|/* 			 * sctp_ulp_notify(SCTP_NOTIFY_AUTH_NEW_KEY, stcb, 			 * shared_key_id, (void 			 * *)stcb->asoc.authinfo.recv_keyid); 			 */
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_NEWKEY
argument_list|,
name|shared_key_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
argument_list|)
expr_stmt|;
comment|/* compute a new recv assoc key and cache it */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|=
name|sctp_compute_hashkey
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|,
name|skey
operator|->
name|key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
operator|=
name|shared_key_id
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|sctp_print_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|,
literal|"Recv Key"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* validate the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunklen
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
operator|+
name|digestlen
operator|)
condition|)
block|{
comment|/* invalid digest length */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthfailed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP Auth: chunk too short for HMAC\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* save a copy of the digest, zero the pseudo header, and validate */
name|bcopy
argument_list|(
name|auth
operator|->
name|hmac
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
name|sctp_bzero_m
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|digestlen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_compute_hmac_m
argument_list|(
name|hmac_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|computed_digest
argument_list|)
expr_stmt|;
comment|/* compare the computed digest with the one in the AUTH chunk */
if|if
condition|(
name|memcmp
argument_list|(
name|digest
argument_list|,
name|computed_digest
argument_list|,
name|digestlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthfailed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|printf
argument_list|(
literal|"SCTP Auth: HMAC digest check failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate NOTIFICATION  */
end_comment

begin_function
name|void
name|sctp_notify_authentication
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|indication
parameter_list|,
name|uint16_t
name|keyid
parameter_list|,
name|uint16_t
name|alt_keyid
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_authkey_event
modifier|*
name|auth
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
condition|)
comment|/* event not enabled */
return|return;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authkey_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|auth
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_authkey_event
operator|*
argument_list|)
expr_stmt|;
name|auth
operator|->
name|auth_type
operator|=
name|SCTP_AUTHENTICATION_EVENT
expr_stmt|;
name|auth
operator|->
name|auth_flags
operator|=
literal|0
expr_stmt|;
name|auth
operator|->
name|auth_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
expr_stmt|;
name|auth
operator|->
name|auth_keynumber
operator|=
name|keyid
expr_stmt|;
name|auth
operator|->
name|auth_altkeynumber
operator|=
name|alt_keyid
expr_stmt|;
name|auth
operator|->
name|auth_indication
operator|=
name|indication
expr_stmt|;
name|auth
operator|->
name|auth_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * validates the AUTHentication related parameters in an INIT/INIT-ACK  * Note: currently only used for INIT as INIT-ACK is handled inline  * with sctp_load_addresses_from_init()  */
end_comment

begin_function
name|int
name|sctp_validate_init_auth_params
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|parm_buf
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|int
name|peer_supports_asconf
init|=
literal|0
decl_stmt|;
name|int
name|peer_supports_auth
init|=
literal|0
decl_stmt|;
name|int
name|got_random
init|=
literal|0
decl_stmt|,
name|got_hmacs
init|=
literal|0
decl_stmt|,
name|got_chklist
init|=
literal|0
decl_stmt|;
comment|/* go through each of the params. */
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|plen
operator|>
name|limit
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ptype
operator|==
name|SCTP_SUPPORTED_CHUNK_EXT
condition|)
block|{
comment|/* A supported extension chunk */
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|uint8_t
name|local_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|num_ent
decl_stmt|,
name|i
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|local_store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|local_store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_ent
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ent
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pr_supported
operator|->
name|chunk_types
index|[
name|i
index|]
condition|)
block|{
case|case
name|SCTP_ASCONF
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHENTICATION
case|:
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* one we don't care about */
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_RANDOM
condition|)
block|{
name|got_random
operator|=
literal|1
expr_stmt|;
comment|/* enforce the random length */
if|if
condition|(
name|plen
operator|!=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_random
argument_list|)
operator|+
name|SCTP_AUTH_RANDOM_SIZE_REQUIRED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"SCTP: invalid RANDOM len\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HMAC_LIST
condition|)
block|{
name|uint8_t
name|store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
decl_stmt|;
name|int
name|num_hmacs
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|store
argument_list|,
name|min
argument_list|(
name|plen
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_hmacs
operator|=
operator|(
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* validate the hmac list */
if|if
condition|(
name|sctp_verify_hmac_param
argument_list|(
name|hmacs
argument_list|,
name|num_hmacs
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"SCTP: invalid HMAC param\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|got_hmacs
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_CHUNK_LIST
condition|)
block|{
comment|/* did the peer send a non-empty chunk list? */
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
name|got_chklist
operator|=
literal|1
expr_stmt|;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|parm_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|parm_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* validate authentication required parameters */
if|if
condition|(
name|got_random
operator|&&
name|got_hmacs
condition|)
block|{
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|peer_supports_auth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|peer_supports_auth
operator|&&
name|got_chklist
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"SCTP: peer sent chunk list w/o AUTH\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|sctp_asconf_auth_nochk
operator|&&
name|peer_supports_asconf
operator|&&
operator|!
name|peer_supports_auth
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"SCTP: peer supports ASCONF but not AUTH\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_initialize_auth_params
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|uint16_t
name|chunks_len
init|=
literal|0
decl_stmt|;
name|uint16_t
name|hmacs_len
init|=
literal|0
decl_stmt|;
name|uint16_t
name|random_len
init|=
name|SCTP_AUTH_RANDOM_SIZE_DEFAULT
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint16_t
name|keylen
decl_stmt|;
comment|/* initialize hmac list from endpoint */
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|=
name|sctp_copy_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
block|{
name|hmacs_len
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|->
name|hmac
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* initialize auth chunks list from endpoint */
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|=
name|sctp_copy_chunklist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|->
name|chunks
index|[
name|i
index|]
condition|)
name|chunks_len
operator|++
expr_stmt|;
block|}
block|}
comment|/* copy defaults from the endpoint */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
expr_stmt|;
comment|/* now set the concatenated key (random + chunks + hmacs) */
ifdef|#
directive|ifdef
name|SCTP_AUTH_DRAFT_04
comment|/* don't include the chunks and hmacs for draft -04 */
name|keylen
operator|=
name|random_len
expr_stmt|;
name|new_key
operator|=
name|sctp_generate_random_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* key includes parameter headers */
name|keylen
operator|=
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|+
name|random_len
operator|+
name|chunks_len
operator|+
name|hmacs_len
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|int
name|plen
decl_stmt|;
comment|/* generate and copy in the RANDOM */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|new_key
operator|->
name|key
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_RANDOM
argument_list|)
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|SCTP_READ_RANDOM
argument_list|(
name|new_key
operator|->
name|key
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
argument_list|,
name|random_len
argument_list|)
expr_stmt|;
name|keylen
operator|=
name|plen
expr_stmt|;
comment|/* append in the AUTH chunks */
comment|/* NOTE: currently we always have chunks to list */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|new_key
operator|->
name|key
operator|+
name|keylen
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CHUNK_LIST
argument_list|)
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
operator|+
name|chunks_len
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|->
name|chunks
index|[
name|i
index|]
condition|)
name|new_key
operator|->
name|key
index|[
name|keylen
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* append in the HMACs */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|new_key
operator|->
name|key
operator|+
name|keylen
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HMAC_LIST
argument_list|)
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
operator|+
name|hmacs_len
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
expr_stmt|;
name|sctp_serialize_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|=
name|new_key
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
operator|=
name|random_len
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_HMAC_TEST
end_ifdef

begin_comment
comment|/*  * HMAC and key concatenation tests  */
end_comment

begin_function
specifier|static
name|void
name|sctp_print_digest
parameter_list|(
name|uint8_t
modifier|*
name|digest
parameter_list|,
name|uint32_t
name|digestlen
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s: 0x"
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|digestlen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|digest
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_test_hmac
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|uint16_t
name|hmac_id
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|,
name|uint32_t
name|digestlen
parameter_list|)
block|{
name|uint8_t
name|computed_digest
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|printf
argument_list|(
literal|"\n%s:"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|sctp_hmac
argument_list|(
name|hmac_id
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|computed_digest
argument_list|)
expr_stmt|;
name|sctp_print_digest
argument_list|(
name|digest
argument_list|,
name|digestlen
argument_list|,
literal|"Expected digest"
argument_list|)
expr_stmt|;
name|sctp_print_digest
argument_list|(
name|computed_digest
argument_list|,
name|digestlen
argument_list|,
literal|"Computed digest"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|digest
argument_list|,
name|computed_digest
argument_list|,
name|digestlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nFAILED"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nPASSED"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * RFC 2202: HMAC-SHA1 test cases  */
end_comment

begin_function
name|void
name|sctp_test_hmac_sha1
parameter_list|(
name|void
parameter_list|)
block|{
name|uint8_t
modifier|*
name|digest
decl_stmt|;
name|uint8_t
name|key
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|keylen
decl_stmt|;
name|uint8_t
name|text
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|textlen
decl_stmt|;
name|uint32_t
name|digestlen
init|=
literal|20
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
comment|/* 	 * test_case =     1 key = 	 * 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b key_len =       20 	 * data =          "Hi There" data_len =      8 digest = 	 * 0xb617318655057264e28bc0b6fb378c8ef146be00 	 */
name|keylen
operator|=
literal|20
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0x0b
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Hi There"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\xb6\x17\x31\x86\x55\x05\x72\x64\xe2\x8b\xc0\xb6\xfb\x37\x8c\x8e\xf1\x46\xbe\x00"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 1"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     2 key =           "Jefe" key_len =       4 data = 	 * "what do ya want for nothing?" data_len =      28 digest = 	 * 0xeffcdf6ae5eb2fa2d27416d5f184df9c259a7c79 	 */
name|keylen
operator|=
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|key
argument_list|,
literal|"Jefe"
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|28
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"what do ya want for nothing?"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\xef\xfc\xdf\x6a\xe5\xeb\x2f\xa2\xd2\x74\x16\xd5\xf1\x84\xdf\x9c\x25\x9a\x7c\x79"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 2"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     3 key = 	 * 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa key_len =       20 	 * data =          0xdd repeated 50 times data_len =      50 digest 	 * = 0x125d7342b9ac11cd91a39af48aa17b4f63f175d3 	 */
name|keylen
operator|=
literal|20
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0xaa
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|50
expr_stmt|;
name|memset
argument_list|(
name|text
argument_list|,
literal|0xdd
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x12\x5d\x73\x42\xb9\xac\x11\xcd\x91\xa3\x9a\xf4\x8a\xa1\x7b\x4f\x63\xf1\x75\xd3"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 3"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     4 key = 	 * 0x0102030405060708090a0b0c0d0e0f10111213141516171819 key_len = 25 	 * data =          0xcd repeated 50 times data_len =      50 digest 	 * =        0x4c9007f4026250c6bc8414f9bf50c86c2d7235da 	 */
name|keylen
operator|=
literal|25
expr_stmt|;
name|memcpy
argument_list|(
name|key
argument_list|,
literal|"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19"
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|50
expr_stmt|;
name|memset
argument_list|(
name|text
argument_list|,
literal|0xcd
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x4c\x90\x07\xf4\x02\x62\x50\xc6\xbc\x84\x14\xf9\xbf\x50\xc8\x6c\x2d\x72\x35\xda"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 4"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     5 key = 	 * 0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c key_len =       20 	 * data =          "Test With Truncation" data_len =      20 digest 	 * = 0x4c1a03424b55e07fe7f27be1d58bb9324a9a5a04 digest-96 = 	 * 0x4c1a03424b55e07fe7f27be1 	 */
name|keylen
operator|=
literal|20
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0x0c
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|20
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Test With Truncation"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x4c\x1a\x03\x42\x4b\x55\xe0\x7f\xe7\xf2\x7b\xe1\xd5\x8b\xb9\x32\x4a\x9a\x5a\x04"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 5"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     6 key =           0xaa repeated 80 times key_len 	 * = 80 data =          "Test Using Larger Than Block-Size Key - 	 * Hash Key First" data_len =      54 digest = 	 * 0xaa4ae5e15272d00e95705637ce8a3b55ed402112 	 */
name|keylen
operator|=
literal|80
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0xaa
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|54
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Test Using Larger Than Block-Size Key - Hash Key First"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\xaa\x4a\xe5\xe1\x52\x72\xd0\x0e\x95\x70\x56\x37\xce\x8a\x3b\x55\xed\x40\x21\x12"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 6"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     7 key =           0xaa repeated 80 times key_len 	 * = 80 data =          "Test Using Larger Than Block-Size Key and 	 * Larger Than One Block-Size Data" data_len =      73 digest = 	 * 0xe8e99d0f45237d786d6bbaa7965c7808bbff1a91 	 */
name|keylen
operator|=
literal|80
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0xaa
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|73
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\xe8\xe9\x9d\x0f\x45\x23\x7d\x78\x6d\x6b\xba\xa7\x96\x5c\x78\x08\xbb\xff\x1a\x91"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"SHA1 test case 7"
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* done with all tests */
if|if
condition|(
name|failed
condition|)
name|printf
argument_list|(
literal|"\nSHA1 test results: %d cases failed"
argument_list|,
name|failed
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\nSHA1 test results: all test cases passed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * RFC 2202: HMAC-MD5 test cases  */
end_comment

begin_function
name|void
name|sctp_test_hmac_md5
parameter_list|(
name|void
parameter_list|)
block|{
name|uint8_t
modifier|*
name|digest
decl_stmt|;
name|uint8_t
name|key
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|keylen
decl_stmt|;
name|uint8_t
name|text
index|[
literal|128
index|]
decl_stmt|;
name|uint32_t
name|textlen
decl_stmt|;
name|uint32_t
name|digestlen
init|=
literal|16
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
comment|/* 	 * test_case =     1 key = 0x0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b 	 * key_len =       16 data = "Hi There" data_len =      8 digest = 	 * 0x9294727a3638bb1c13f48ef8158bfc9d 	 */
name|keylen
operator|=
literal|16
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0x0b
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|8
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Hi There"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x92\x94\x72\x7a\x36\x38\xbb\x1c\x13\xf4\x8e\xf8\x15\x8b\xfc\x9d"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 1"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     2 key =           "Jefe" key_len =       4 data = 	 * "what do ya want for nothing?" data_len =      28 digest = 	 * 0x750c783e6ab0b503eaa86e310a5db738 	 */
name|keylen
operator|=
literal|4
expr_stmt|;
name|strcpy
argument_list|(
name|key
argument_list|,
literal|"Jefe"
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|28
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"what do ya want for nothing?"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x75\x0c\x78\x3e\x6a\xb0\xb5\x03\xea\xa8\x6e\x31\x0a\x5d\xb7\x38"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 2"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     3 key = 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa 	 * key_len =       16 data = 0xdd repeated 50 times data_len = 50 	 * digest = 0x56be34521d144c88dbb8c733f0e8b3f6 	 */
name|keylen
operator|=
literal|16
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0xaa
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|50
expr_stmt|;
name|memset
argument_list|(
name|text
argument_list|,
literal|0xdd
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x56\xbe\x34\x52\x1d\x14\x4c\x88\xdb\xb8\xc7\x33\xf0\xe8\xb3\xf6"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 3"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     4 key = 	 * 0x0102030405060708090a0b0c0d0e0f10111213141516171819 key_len = 25 	 * data =          0xcd repeated 50 times data_len =      50 digest 	 * =        0x697eaf0aca3a3aea3a75164746ffaa79 	 */
name|keylen
operator|=
literal|25
expr_stmt|;
name|memcpy
argument_list|(
name|key
argument_list|,
literal|"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19"
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|50
expr_stmt|;
name|memset
argument_list|(
name|text
argument_list|,
literal|0xcd
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x69\x7e\xaf\x0a\xca\x3a\x3a\xea\x3a\x75\x16\x47\x46\xff\xaa\x79"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 4"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     5 key = 0x0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c0c 	 * key_len =       16 data = "Test With Truncation" data_len = 20 	 * digest = 0x56461ef2342edc00f9bab995690efd4c digest-96 	 * 0x56461ef2342edc00f9bab995 	 */
name|keylen
operator|=
literal|16
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0x0c
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|20
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Test With Truncation"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x56\x46\x1e\xf2\x34\x2e\xdc\x00\xf9\xba\xb9\x95\x69\x0e\xfd\x4c"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 5"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     6 key =           0xaa repeated 80 times key_len 	 * = 80 data =          "Test Using Larger Than Block-Size Key - 	 * Hash Key First" data_len =      54 digest = 	 * 0x6b1ab7fe4bd7bf8f0b62e6ce61b9d0cd 	 */
name|keylen
operator|=
literal|80
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0xaa
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|54
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Test Using Larger Than Block-Size Key - Hash Key First"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x6b\x1a\xb7\xfe\x4b\xd7\xbf\x8f\x0b\x62\xe6\xce\x61\xb9\xd0\xcd"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 6"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* 	 * test_case =     7 key =           0xaa repeated 80 times key_len 	 * = 80 data =          "Test Using Larger Than Block-Size Key and 	 * Larger Than One Block-Size Data" data_len =      73 digest = 	 * 0x6f630fad67cda0ee1fb1f562db3aa53e 	 */
name|keylen
operator|=
literal|80
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0xaa
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|textlen
operator|=
literal|73
expr_stmt|;
name|strcpy
argument_list|(
name|text
argument_list|,
literal|"Test Using Larger Than Block-Size Key and Larger Than One Block-Size Data"
argument_list|)
expr_stmt|;
name|digest
operator|=
literal|"\x6f\x63\x0f\xad\x67\xcd\xa0\xee\x1f\xb1\xf5\x62\xdb\x3a\xa5\x3e"
expr_stmt|;
if|if
condition|(
name|sctp_test_hmac
argument_list|(
literal|"MD5 test case 7"
argument_list|,
name|SCTP_AUTH_HMAC_ID_MD5
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* done with all tests */
if|if
condition|(
name|failed
condition|)
name|printf
argument_list|(
literal|"\nMD5 test results: %d cases failed"
argument_list|,
name|failed
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\nMD5 test results: all test cases passed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * test assoc key concatenation  */
end_comment

begin_function
specifier|static
name|int
name|sctp_test_key_concatenation
parameter_list|(
name|sctp_key_t
modifier|*
name|key1
parameter_list|,
name|sctp_key_t
modifier|*
name|key2
parameter_list|,
name|sctp_key_t
modifier|*
name|expected_key
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|key
decl_stmt|;
name|int
name|ret_val
decl_stmt|;
name|sctp_show_key
argument_list|(
name|key1
argument_list|,
literal|"\nkey1"
argument_list|)
expr_stmt|;
name|sctp_show_key
argument_list|(
name|key2
argument_list|,
literal|"\nkey2"
argument_list|)
expr_stmt|;
name|key
operator|=
name|sctp_compute_hashkey
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sctp_show_key
argument_list|(
name|expected_key
argument_list|,
literal|"\nExpected"
argument_list|)
expr_stmt|;
name|sctp_show_key
argument_list|(
name|key
argument_list|,
literal|"\nComputed"
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|key
argument_list|,
name|expected_key
argument_list|,
name|expected_key
operator|->
name|keylen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\nFAILED"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\nPASSED"
argument_list|)
expr_stmt|;
name|ret_val
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_free_key
argument_list|(
name|key1
argument_list|)
expr_stmt|;
name|sctp_free_key
argument_list|(
name|key2
argument_list|)
expr_stmt|;
name|sctp_free_key
argument_list|(
name|expected_key
argument_list|)
expr_stmt|;
name|sctp_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_test_authkey
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|key1
decl_stmt|,
modifier|*
name|key2
decl_stmt|,
modifier|*
name|expected_key
decl_stmt|;
name|int
name|failed
init|=
literal|0
decl_stmt|;
comment|/* test case 1 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01\x01\x01\x01"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01\x02\x03\x04"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01\x01\x01\x01\x01\x02\x03\x04"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* test case 2 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x01"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x02"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x01\x02"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* test case 3 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x02"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01\x00\x00\x00\x02"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* test case 4 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x01"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01\x00\x00\x00\x01"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* test case 5 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x01"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x01\x00\x00\x00\x01"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* test case 6 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x08"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x08"
argument_list|,
literal|22
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* test case 7 */
name|key1
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x08"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|key2
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07"
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|expected_key
operator|=
name|sctp_set_key
argument_list|(
literal|"\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x08"
argument_list|,
literal|22
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_test_key_concatenation
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|,
name|expected_key
argument_list|)
operator|<
literal|0
condition|)
name|failed
operator|++
expr_stmt|;
comment|/* done with all tests */
if|if
condition|(
name|failed
condition|)
name|printf
argument_list|(
literal|"\nKey concatenation test results: %d cases failed"
argument_list|,
name|failed
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"\nKey concatenation test results: all test cases passed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|STANDALONE_HMAC_TEST
argument_list|)
end_if

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_test_hmac_sha1
argument_list|()
expr_stmt|;
name|sctp_test_hmac_md5
argument_list|()
expr_stmt|;
name|sctp_test_authkey
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STANDALONE_HMAC_TEST */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCTP_HMAC_TEST */
end_comment

end_unit

