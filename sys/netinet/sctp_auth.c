begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|SCTP_AUTH_DEBUG
value|(SCTP_BASE_SYSCTL(sctp_debug_on)& SCTP_DEBUG_AUTH1)
end_define

begin_define
define|#
directive|define
name|SCTP_AUTH_DEBUG2
value|(SCTP_BASE_SYSCTL(sctp_debug_on)& SCTP_DEBUG_AUTH2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCTP_DEBUG */
end_comment

begin_function
name|void
name|sctp_clear_chunklist
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|chklist
parameter_list|)
block|{
name|bzero
argument_list|(
name|chklist
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chklist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* chklist->num_chunks = 0; */
block|}
end_function

begin_function
name|sctp_auth_chklist_t
modifier|*
name|sctp_alloc_chunklist
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_auth_chklist_t
modifier|*
name|chklist
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|chklist
argument_list|,
name|sctp_auth_chklist_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chklist
argument_list|)
argument_list|,
name|SCTP_M_AUTH_CL
argument_list|)
expr_stmt|;
if|if
condition|(
name|chklist
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"sctp_alloc_chunklist: failed to get memory!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_clear_chunklist
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|chklist
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_chunklist
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
name|SCTP_FREE
argument_list|(
name|list
argument_list|,
name|SCTP_M_AUTH_CL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|sctp_auth_chklist_t
modifier|*
name|sctp_copy_chunklist
parameter_list|(
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
name|sctp_auth_chklist_t
modifier|*
name|new_list
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* get a new list */
name|new_list
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* copy it */
name|bcopy
argument_list|(
name|list
argument_list|,
name|new_list
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add a chunk to the required chunks list  */
end_comment

begin_function
name|int
name|sctp_auth_add_chunk
parameter_list|(
name|uint8_t
name|chunk
parameter_list|,
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is chunk restricted? */
if|if
condition|(
operator|(
name|chunk
operator|==
name|SCTP_INITIATION
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_INITIATION_ACK
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_SHUTDOWN_COMPLETE
operator|)
operator|||
operator|(
name|chunk
operator|==
name|SCTP_AUTHENTICATION
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|==
literal|0
condition|)
block|{
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|=
literal|1
expr_stmt|;
name|list
operator|->
name|num_chunks
operator|++
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: added chunk %u (0x%02x) to Auth list\n"
argument_list|,
name|chunk
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * delete a chunk from the required chunks list  */
end_comment

begin_function
name|int
name|sctp_auth_delete_chunk
parameter_list|(
name|uint8_t
name|chunk
parameter_list|,
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|==
literal|1
condition|)
block|{
name|list
operator|->
name|chunks
index|[
name|chunk
index|]
operator|=
literal|0
expr_stmt|;
name|list
operator|->
name|num_chunks
operator|--
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: deleted chunk %u (0x%02x) from Auth list\n"
argument_list|,
name|chunk
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|sctp_auth_get_chklist_size
parameter_list|(
specifier|const
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|list
operator|->
name|num_chunks
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * return the current number and list of required chunks caller must  * guarantee ptr has space for up to 256 bytes  */
end_comment

begin_function
name|int
name|sctp_serialize_auth_chunks
parameter_list|(
specifier|const
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_pack_auth_chunks
parameter_list|(
specifier|const
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|size
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|list
operator|->
name|num_chunks
operator|<=
literal|32
condition|)
block|{
comment|/* just list them, one byte each */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
name|i
expr_stmt|;
name|size
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|int
name|index
decl_stmt|,
name|offset
decl_stmt|;
comment|/* pack into a 32 byte bitfield */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|chunks
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|index
operator|=
name|i
operator|/
literal|8
expr_stmt|;
name|offset
operator|=
name|i
operator|%
literal|8
expr_stmt|;
name|ptr
index|[
name|index
index|]
operator||=
operator|(
literal|1
operator|<<
name|offset
operator|)
expr_stmt|;
block|}
block|}
name|size
operator|=
literal|32
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_unpack_auth_chunks
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|ptr
parameter_list|,
name|uint8_t
name|num_chunks
parameter_list|,
name|sctp_auth_chklist_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|size
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|num_chunks
operator|<=
literal|32
condition|)
block|{
comment|/* just pull them, one byte each */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sctp_auth_add_chunk
argument_list|(
operator|*
name|ptr
operator|++
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
name|num_chunks
expr_stmt|;
block|}
else|else
block|{
name|int
name|index
decl_stmt|,
name|offset
decl_stmt|;
comment|/* unpack from a 32 byte bitfield */
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|32
condition|;
name|index
operator|++
control|)
block|{
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
literal|8
condition|;
name|offset
operator|++
control|)
block|{
if|if
condition|(
name|ptr
index|[
name|index
index|]
operator|&
operator|(
literal|1
operator|<<
name|offset
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_auth_add_chunk
argument_list|(
operator|(
name|index
operator|*
literal|8
operator|)
operator|+
name|offset
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|size
operator|=
literal|32
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * allocate structure space for a key of length keylen  */
end_comment

begin_function
name|sctp_key_t
modifier|*
name|sctp_alloc_key
parameter_list|(
name|uint32_t
name|keylen
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_key
argument_list|,
name|sctp_key_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_key
argument_list|)
operator|+
name|keylen
argument_list|,
name|SCTP_M_AUTH_KY
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
name|SCTP_FREE
argument_list|(
name|key
argument_list|,
name|SCTP_M_AUTH_KY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_print_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"%s: [Null key]\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"%s: len %u, "
argument_list|,
name|str
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key
operator|->
name|keylen
condition|;
name|i
operator|++
control|)
name|SCTP_PRINTF
argument_list|(
literal|"%02x"
argument_list|,
name|key
operator|->
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"[Null key]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_show_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"%s: [Null key]\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"%s: len %u, "
argument_list|,
name|str
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|key
operator|->
name|keylen
condition|;
name|i
operator|++
control|)
name|SCTP_PRINTF
argument_list|(
literal|"%02x"
argument_list|,
name|key
operator|->
name|key
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"[Null key]\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|sctp_get_keylen
parameter_list|(
name|sctp_key_t
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
return|return
operator|(
name|key
operator|->
name|keylen
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate a new random key of length 'keylen'  */
end_comment

begin_function
name|sctp_key_t
modifier|*
name|sctp_generate_random_key
parameter_list|(
name|uint32_t
name|keylen
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_READ_RANDOM
argument_list|(
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|new_key
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|sctp_key_t
modifier|*
name|sctp_set_key
parameter_list|(
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|)
block|{
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bcopy
argument_list|(
name|key
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * given two keys of variable size, compute which key is "larger/smaller"  * returns:  1 if key1> key2  *          -1 if key1< key2  *           0 if key1 = key2  */
end_comment

begin_function
specifier|static
name|int
name|sctp_compare_key
parameter_list|(
name|sctp_key_t
modifier|*
name|key1
parameter_list|,
name|sctp_key_t
modifier|*
name|key2
parameter_list|)
block|{
name|uint32_t
name|maxlen
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|uint32_t
name|key1len
decl_stmt|,
name|key2len
decl_stmt|;
name|uint8_t
modifier|*
name|key_1
decl_stmt|,
modifier|*
name|key_2
decl_stmt|;
name|uint8_t
name|val1
decl_stmt|,
name|val2
decl_stmt|;
comment|/* sanity/length check */
name|key1len
operator|=
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
expr_stmt|;
name|key2len
operator|=
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|key1len
operator|==
literal|0
operator|)
operator|&&
operator|(
name|key2len
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|key1len
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|key2len
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|key1len
operator|<
name|key2len
condition|)
block|{
name|maxlen
operator|=
name|key2len
expr_stmt|;
block|}
else|else
block|{
name|maxlen
operator|=
name|key1len
expr_stmt|;
block|}
name|key_1
operator|=
name|key1
operator|->
name|key
expr_stmt|;
name|key_2
operator|=
name|key2
operator|->
name|key
expr_stmt|;
comment|/* check for numeric equality */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxlen
condition|;
name|i
operator|++
control|)
block|{
comment|/* left-pad with zeros */
name|val1
operator|=
operator|(
name|i
operator|<
operator|(
name|maxlen
operator|-
name|key1len
operator|)
operator|)
condition|?
literal|0
else|:
operator|*
operator|(
name|key_1
operator|++
operator|)
expr_stmt|;
name|val2
operator|=
operator|(
name|i
operator|<
operator|(
name|maxlen
operator|-
name|key2len
operator|)
operator|)
condition|?
literal|0
else|:
operator|*
operator|(
name|key_2
operator|++
operator|)
expr_stmt|;
if|if
condition|(
name|val1
operator|>
name|val2
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|val1
operator|<
name|val2
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* keys are equal value, so check lengths */
if|if
condition|(
name|key1len
operator|==
name|key2len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|key1len
operator|<
name|key2len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate the concatenated keying material based on the two keys and the  * shared key (if available). draft-ietf-tsvwg-auth specifies the specific  * order for concatenation  */
end_comment

begin_function
name|sctp_key_t
modifier|*
name|sctp_compute_hashkey
parameter_list|(
name|sctp_key_t
modifier|*
name|key1
parameter_list|,
name|sctp_key_t
modifier|*
name|key2
parameter_list|,
name|sctp_key_t
modifier|*
name|shared
parameter_list|)
block|{
name|uint32_t
name|keylen
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint8_t
modifier|*
name|key_ptr
decl_stmt|;
name|keylen
operator|=
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
operator|+
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
operator|+
name|sctp_get_keylen
argument_list|(
name|shared
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|>
literal|0
condition|)
block|{
comment|/* get space for the new key */
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|->
name|keylen
operator|=
name|keylen
expr_stmt|;
name|key_ptr
operator|=
name|new_key
operator|->
name|key
expr_stmt|;
block|}
else|else
block|{
comment|/* all keys empty/null?! */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* concatenate the keys */
if|if
condition|(
name|sctp_compare_key
argument_list|(
name|key1
argument_list|,
name|key2
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* key is shared + key1 + key2 */
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|shared
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|shared
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|shared
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|shared
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key1
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key1
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|key1
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key2
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key2
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* key is shared + key2 + key1 */
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|shared
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|shared
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|shared
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|shared
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key2
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key2
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key2
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|key_ptr
operator|+=
name|key2
operator|->
name|keylen
expr_stmt|;
block|}
if|if
condition|(
name|sctp_get_keylen
argument_list|(
name|key1
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|key1
operator|->
name|key
argument_list|,
name|key_ptr
argument_list|,
name|key1
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|sctp_sharedkey_t
modifier|*
name|sctp_alloc_sharedkey
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|new_key
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_key
argument_list|,
name|sctp_sharedkey_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_key
argument_list|)
argument_list|,
name|SCTP_M_AUTH_KY
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_key
operator|->
name|keyid
operator|=
literal|0
expr_stmt|;
name|new_key
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|new_key
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|new_key
operator|->
name|deactivated
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new_key
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_sharedkey
parameter_list|(
name|sctp_sharedkey_t
modifier|*
name|skey
parameter_list|)
block|{
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|SCTP_DECREMENT_AND_CHECK_REFCOUNT
argument_list|(
operator|&
name|skey
operator|->
name|refcount
argument_list|)
condition|)
block|{
if|if
condition|(
name|skey
operator|->
name|key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|skey
operator|->
name|key
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|skey
argument_list|,
name|SCTP_M_AUTH_KY
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|sctp_sharedkey_t
modifier|*
name|sctp_find_sharedkey
parameter_list|(
name|struct
name|sctp_keyhead
modifier|*
name|shared_keys
parameter_list|,
name|uint16_t
name|key_id
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|skey
argument_list|,
argument|shared_keys
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|skey
operator|->
name|keyid
operator|==
name|key_id
condition|)
return|return
operator|(
name|skey
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_insert_sharedkey
parameter_list|(
name|struct
name|sctp_keyhead
modifier|*
name|shared_keys
parameter_list|,
name|sctp_sharedkey_t
modifier|*
name|new_skey
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
operator|(
name|shared_keys
operator|==
name|NULL
operator|)
operator|||
operator|(
name|new_skey
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* insert into an empty list? */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
name|shared_keys
argument_list|)
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
name|shared_keys
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* insert into the existing list, ordered by key id */
name|LIST_FOREACH
argument_list|(
argument|skey
argument_list|,
argument|shared_keys
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|new_skey
operator|->
name|keyid
operator|<
name|skey
operator|->
name|keyid
condition|)
block|{
comment|/* insert it before here */
name|LIST_INSERT_BEFORE
argument_list|(
name|skey
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|new_skey
operator|->
name|keyid
operator|==
name|skey
operator|->
name|keyid
condition|)
block|{
comment|/* replace the existing key */
comment|/* verify this key *can* be replaced */
if|if
condition|(
operator|(
name|skey
operator|->
name|deactivated
operator|)
operator|&&
operator|(
name|skey
operator|->
name|refcount
operator|>
literal|1
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"can't replace shared key id %u\n"
argument_list|,
name|new_skey
operator|->
name|keyid
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"replacing shared key id %u\n"
argument_list|,
name|new_skey
operator|->
name|keyid
argument_list|)
expr_stmt|;
name|LIST_INSERT_BEFORE
argument_list|(
name|skey
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* belongs at the end of the list */
name|LIST_INSERT_AFTER
argument_list|(
name|skey
argument_list|,
name|new_skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* shouldn't reach here */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_auth_key_acquire
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|key_id
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
comment|/* find the shared key */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
comment|/* bump the ref count */
if|if
condition|(
name|skey
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|skey
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH2
argument_list|,
literal|"%s: stcb %p key %u refcount acquire to %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|,
name|key_id
argument_list|,
name|skey
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_auth_key_release
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|key_id
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
comment|/* find the shared key */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
comment|/* decrement the ref count */
if|if
condition|(
name|skey
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH2
argument_list|,
literal|"%s: stcb %p key %u refcount release to %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|,
name|key_id
argument_list|,
name|skey
operator|->
name|refcount
argument_list|)
expr_stmt|;
comment|/* see if a notification should be generated */
if|if
condition|(
operator|(
name|skey
operator|->
name|refcount
operator|<=
literal|2
operator|)
operator|&&
operator|(
name|skey
operator|->
name|deactivated
operator|)
condition|)
block|{
comment|/* notify ULP that key is no longer used */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_AUTH_FREE_KEY
argument_list|,
name|stcb
argument_list|,
name|key_id
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH2
argument_list|,
literal|"%s: stcb %p key %u no longer used, %d\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|,
name|key_id
argument_list|,
name|skey
operator|->
name|refcount
argument_list|)
expr_stmt|;
block|}
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|sctp_sharedkey_t
modifier|*
name|sctp_copy_sharedkey
parameter_list|(
specifier|const
name|sctp_sharedkey_t
modifier|*
name|skey
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|new_skey
decl_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|new_skey
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|new_skey
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|skey
operator|->
name|key
operator|!=
name|NULL
condition|)
name|new_skey
operator|->
name|key
operator|=
name|sctp_set_key
argument_list|(
name|skey
operator|->
name|key
operator|->
name|key
argument_list|,
name|skey
operator|->
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
else|else
name|new_skey
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|new_skey
operator|->
name|keyid
operator|=
name|skey
operator|->
name|keyid
expr_stmt|;
return|return
operator|(
name|new_skey
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_copy_skeylist
parameter_list|(
specifier|const
name|struct
name|sctp_keyhead
modifier|*
name|src
parameter_list|,
name|struct
name|sctp_keyhead
modifier|*
name|dest
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|,
modifier|*
name|new_skey
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|src
operator|==
name|NULL
operator|)
operator|||
operator|(
name|dest
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|skey
argument_list|,
argument|src
argument_list|,
argument|next
argument_list|)
block|{
name|new_skey
operator|=
name|sctp_copy_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_skey
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|sctp_insert_sharedkey
argument_list|(
name|dest
argument_list|,
name|new_skey
argument_list|)
condition|)
block|{
name|sctp_free_sharedkey
argument_list|(
name|new_skey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|sctp_hmaclist_t
modifier|*
name|sctp_alloc_hmaclist
parameter_list|(
name|uint16_t
name|num_hmacs
parameter_list|)
block|{
name|sctp_hmaclist_t
modifier|*
name|new_list
decl_stmt|;
name|int
name|alloc_size
decl_stmt|;
name|alloc_size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|new_list
argument_list|)
operator|+
name|num_hmacs
operator|*
sizeof|sizeof
argument_list|(
name|new_list
operator|->
name|hmac
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_list
argument_list|,
name|sctp_hmaclist_t
operator|*
argument_list|,
name|alloc_size
argument_list|,
name|SCTP_M_AUTH_HL
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_list
operator|->
name|max_algo
operator|=
name|num_hmacs
expr_stmt|;
name|new_list
operator|->
name|num_algo
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_hmaclist
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|)
block|{
if|if
condition|(
name|list
operator|!=
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|list
argument_list|,
name|SCTP_M_AUTH_HL
argument_list|)
expr_stmt|;
name|list
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_auth_add_hmacid
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|,
name|uint16_t
name|hmac_id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|list
operator|->
name|num_algo
operator|==
name|list
operator|->
name|max_algo
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: HMAC id list full, ignoring add %u\n"
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA1
operator|)
operator|&&
operator|(
name|hmac_id
operator|!=
name|SCTP_AUTH_HMAC_ID_SHA256
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Now is it already in the list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|list
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|hmac_id
condition|)
block|{
comment|/* already in list */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: add HMAC id %u to list\n"
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
name|list
operator|->
name|hmac
index|[
name|list
operator|->
name|num_algo
operator|++
index|]
operator|=
name|hmac_id
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|sctp_hmaclist_t
modifier|*
name|sctp_copy_hmaclist
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|)
block|{
name|sctp_hmaclist_t
modifier|*
name|new_list
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* get a new list */
name|new_list
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|list
operator|->
name|max_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* copy it */
name|new_list
operator|->
name|max_algo
operator|=
name|list
operator|->
name|max_algo
expr_stmt|;
name|new_list
operator|->
name|num_algo
operator|=
name|list
operator|->
name|num_algo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
name|new_list
operator|->
name|hmac
index|[
name|i
index|]
operator|=
name|list
operator|->
name|hmac
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_function
name|sctp_hmaclist_t
modifier|*
name|sctp_default_supported_hmaclist
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_hmaclist_t
modifier|*
name|new_list
decl_stmt|;
name|new_list
operator|=
name|sctp_alloc_hmaclist
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* We prefer SHA256, so list it first */
operator|(
name|void
operator|)
name|sctp_auth_add_hmacid
argument_list|(
name|new_list
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA256
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_auth_add_hmacid
argument_list|(
name|new_list
argument_list|,
name|SCTP_AUTH_HMAC_ID_SHA1
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_list
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * HMAC algos are listed in priority/preference order  * find the best HMAC id to use for the peer based on local support  */
end_comment

begin_function
name|uint16_t
name|sctp_negotiate_hmacid
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|peer
parameter_list|,
name|sctp_hmaclist_t
modifier|*
name|local
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|local
operator|==
name|NULL
operator|)
operator|||
operator|(
name|peer
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|SCTP_AUTH_HMAC_ID_RSVD
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|peer
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|local
operator|->
name|num_algo
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|peer
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|local
operator|->
name|hmac
index|[
name|j
index|]
condition|)
block|{
comment|/* found the "best" one */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: negotiated peer HMAC id %u\n"
argument_list|,
name|peer
operator|->
name|hmac
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|peer
operator|->
name|hmac
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
block|}
comment|/* didn't find one! */
return|return
operator|(
name|SCTP_AUTH_HMAC_ID_RSVD
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * serialize the HMAC algo list and return space used  * caller must guarantee ptr has appropriate space  */
end_comment

begin_function
name|int
name|sctp_serialize_hmaclist
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|,
name|uint8_t
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|hmac_id
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
name|hmac_id
operator|=
name|htons
argument_list|(
name|list
operator|->
name|hmac
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|hmac_id
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|hmac_id
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|hmac_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|list
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|hmac_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_verify_hmac_param
parameter_list|(
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
parameter_list|,
name|uint32_t
name|num_hmacs
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hmacs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
name|i
index|]
argument_list|)
operator|==
name|SCTP_AUTH_HMAC_ID_SHA1
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|sctp_authinfo_t
modifier|*
name|sctp_alloc_authinfo
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_authinfo_t
modifier|*
name|new_authinfo
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|new_authinfo
argument_list|,
name|sctp_authinfo_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_authinfo
argument_list|)
argument_list|,
name|SCTP_M_AUTH_IF
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_authinfo
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|new_authinfo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_authinfo
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_authinfo
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_free_authinfo
parameter_list|(
name|sctp_authinfo_t
modifier|*
name|authinfo
parameter_list|)
block|{
if|if
condition|(
name|authinfo
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|authinfo
operator|->
name|random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|random
argument_list|)
expr_stmt|;
if|if
condition|(
name|authinfo
operator|->
name|peer_random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|peer_random
argument_list|)
expr_stmt|;
if|if
condition|(
name|authinfo
operator|->
name|assoc_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|assoc_key
argument_list|)
expr_stmt|;
if|if
condition|(
name|authinfo
operator|->
name|recv_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|authinfo
operator|->
name|recv_key
argument_list|)
expr_stmt|;
comment|/* We are NOT dynamically allocating authinfo's right now... */
comment|/* SCTP_FREE(authinfo, SCTP_M_AUTH_??); */
block|}
end_function

begin_function
name|uint32_t
name|sctp_get_auth_chunk_len
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk
argument_list|)
operator|+
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCTP_SIZE32
argument_list|(
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_get_hmac_digest_len
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA1
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
return|return
operator|(
name|SCTP_AUTH_DIGEST_LEN_SHA256
operator|)
return|;
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|sctp_get_hmac_block_len
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
return|return
operator|(
literal|64
operator|)
return|;
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hmac_init
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_hash_context_t
modifier|*
name|ctx
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
name|SCTP_SHA1_INIT
argument_list|(
operator|&
name|ctx
operator|->
name|sha1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
name|SCTP_SHA256_INIT
argument_list|(
operator|&
name|ctx
operator|->
name|sha256
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hmac_update
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_hash_context_t
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
name|SCTP_SHA1_UPDATE
argument_list|(
operator|&
name|ctx
operator|->
name|sha1
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
name|SCTP_SHA256_UPDATE
argument_list|(
operator|&
name|ctx
operator|->
name|sha256
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return;
block|}
comment|/* end switch */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hmac_final
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_hash_context_t
modifier|*
name|ctx
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
switch|switch
condition|(
name|hmac_algo
condition|)
block|{
case|case
name|SCTP_AUTH_HMAC_ID_SHA1
case|:
name|SCTP_SHA1_FINAL
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|sha1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_SHA256
case|:
name|SCTP_SHA256_FINAL
argument_list|(
name|digest
argument_list|,
operator|&
name|ctx
operator|->
name|sha256
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTH_HMAC_ID_RSVD
case|:
default|default:
comment|/* unknown HMAC algorithm: can't do anything */
return|return;
block|}
comment|/* end switch */
block|}
end_function

begin_comment
comment|/*-  * Keyed-Hashing for Message Authentication: FIPS 198 (RFC 2104)  *  * Compute the HMAC digest using the desired hash key, text, and HMAC  * algorithm.  Resulting digest is placed in 'digest' and digest length  * is returned, if the HMAC was performed.  *  * WARNING: it is up to the caller to supply sufficient space to hold the  * resultant digest.  */
end_comment

begin_function
name|uint32_t
name|sctp_hmac
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|ipad
index|[
literal|128
index|]
decl_stmt|,
name|opad
index|[
literal|128
index|]
decl_stmt|;
comment|/* keyed hash inner/outer pads */
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
comment|/* sanity check the material and length */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keylen
operator|==
literal|0
operator|)
operator|||
operator|(
name|text
operator|==
name|NULL
operator|)
operator|||
operator|(
name|textlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set the hashed key as the key */
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|key
operator|=
name|temp
expr_stmt|;
block|}
comment|/* initialize the inner/outer pads with the key and "append" zeroes */
name|bzero
argument_list|(
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|ipad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|opad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
comment|/* XOR the key with ipad and opad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blocklen
condition|;
name|i
operator|++
control|)
block|{
name|ipad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
name|opad
index|[
name|i
index|]
operator|^=
literal|0x5c
expr_stmt|;
block|}
comment|/* perform inner hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* perform outer hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|digest
argument_list|)
expr_stmt|;
return|return
operator|(
name|digestlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mbuf version */
end_comment

begin_function
name|uint32_t
name|sctp_hmac_m
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|m_offset
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|,
name|uint32_t
name|trailer
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|ipad
index|[
literal|128
index|]
decl_stmt|,
name|opad
index|[
literal|128
index|]
decl_stmt|;
comment|/* keyed hash inner/outer pads */
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
comment|/* sanity check the material and length */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keylen
operator|==
literal|0
operator|)
operator|||
operator|(
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* set the hashed key as the key */
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|key
operator|=
name|temp
expr_stmt|;
block|}
comment|/* initialize the inner/outer pads with the key and "append" zeroes */
name|bzero
argument_list|(
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|ipad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|key
argument_list|,
name|opad
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
comment|/* XOR the key with ipad and opad values */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|blocklen
condition|;
name|i
operator|++
control|)
block|{
name|ipad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
name|opad
index|[
name|i
index|]
operator|^=
literal|0x5c
expr_stmt|;
block|}
comment|/* perform inner hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|ipad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
comment|/* find the correct starting mbuf and offset (get start of text) */
name|m_tmp
operator|=
name|m
expr_stmt|;
while|while
condition|(
operator|(
name|m_tmp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|m_offset
operator|>=
operator|(
name|uint32_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|)
condition|)
block|{
name|m_offset
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
comment|/* now use the rest of the mbuf chain for the text */
while|while
condition|(
name|m_tmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
name|trailer
condition|)
block|{
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|mtod
argument_list|(
name|m_tmp
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m_offset
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|-
operator|(
name|trailer
operator|+
name|m_offset
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|mtod
argument_list|(
name|m_tmp
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m_offset
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|-
name|m_offset
argument_list|)
expr_stmt|;
block|}
comment|/* clear the offset since it's only for the first mbuf */
name|m_offset
operator|=
literal|0
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* perform outer hash */
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|opad
argument_list|,
name|blocklen
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|digest
argument_list|)
expr_stmt|;
return|return
operator|(
name|digestlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * verify the HMAC digest using the desired hash key, text, and HMAC  * algorithm.  * Returns -1 on error, 0 on success.  */
end_comment

begin_function
name|int
name|sctp_verify_hmac
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|uint8_t
modifier|*
name|key
parameter_list|,
name|uint32_t
name|keylen
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|,
name|uint32_t
name|digestlen
parameter_list|)
block|{
name|uint32_t
name|len
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* sanity check the material and length */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|keylen
operator|==
literal|0
operator|)
operator|||
operator|(
name|text
operator|==
name|NULL
operator|)
operator|||
operator|(
name|textlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|len
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|digestlen
operator|!=
name|len
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* compute the expected hash */
if|if
condition|(
name|sctp_hmac
argument_list|(
name|hmac_algo
argument_list|,
name|key
argument_list|,
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|temp
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|digest
argument_list|,
name|temp
argument_list|,
name|digestlen
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * computes the requested HMAC using a key struct (which may be modified if  * the keylen exceeds the HMAC block len).  */
end_comment

begin_function
name|uint32_t
name|sctp_compute_hmac
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_key_t
modifier|*
name|key
parameter_list|,
name|uint8_t
modifier|*
name|text
parameter_list|,
name|uint32_t
name|textlen
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|text
operator|==
name|NULL
operator|)
operator|||
operator|(
name|textlen
operator|==
literal|0
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* save the hashed key as the new key */
name|key
operator|->
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sctp_hmac
argument_list|(
name|hmac_algo
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|,
name|text
argument_list|,
name|textlen
argument_list|,
name|digest
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* mbuf version */
end_comment

begin_function
name|uint32_t
name|sctp_compute_hmac_m
parameter_list|(
name|uint16_t
name|hmac_algo
parameter_list|,
name|sctp_key_t
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|m_offset
parameter_list|,
name|uint8_t
modifier|*
name|digest
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|uint32_t
name|blocklen
decl_stmt|;
name|sctp_hash_context_t
name|ctx
decl_stmt|;
name|uint8_t
name|temp
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
operator|(
name|key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|m
operator|==
name|NULL
operator|)
operator|||
operator|(
name|digest
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* can't do HMAC with empty key or text or digest store */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* validate the hmac algo and get the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|digestlen
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hash the key if it is longer than the hash block size */
name|blocklen
operator|=
name|sctp_get_hmac_block_len
argument_list|(
name|hmac_algo
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|keylen
operator|>
name|blocklen
condition|)
block|{
name|sctp_hmac_init
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|sctp_hmac_update
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
name|sctp_hmac_final
argument_list|(
name|hmac_algo
argument_list|,
operator|&
name|ctx
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* save the hashed key as the new key */
name|key
operator|->
name|keylen
operator|=
name|digestlen
expr_stmt|;
name|bcopy
argument_list|(
name|temp
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|sctp_hmac_m
argument_list|(
name|hmac_algo
argument_list|,
name|key
operator|->
name|key
argument_list|,
name|key
operator|->
name|keylen
argument_list|,
name|m
argument_list|,
name|m_offset
argument_list|,
name|digest
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_auth_is_supported_hmac
parameter_list|(
name|sctp_hmaclist_t
modifier|*
name|list
parameter_list|,
name|uint16_t
name|id
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|list
operator|==
name|NULL
operator|)
operator|||
operator|(
name|id
operator|==
name|SCTP_AUTH_HMAC_ID_RSVD
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|list
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|id
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* not in the list */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * clear any cached key(s) if they match the given key id on an association.  * the cached key(s) will be recomputed and re-cached at next use.  * ASSUMES TCB_LOCK is already held  */
end_comment

begin_function
name|void
name|sctp_clear_cachedkeys
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
condition|)
block|{
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
condition|)
block|{
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * clear any cached key(s) if they match the given key id for all assocs on  * an endpoint.  * ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|void
name|sctp_clear_cachedkeys_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return;
comment|/* clear the cached keys on all assocs on this instance */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * delete a shared key from an association  * ASSUMES TCB_LOCK is already held  */
end_comment

begin_function
name|int
name|sctp_delete_sharedkey
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is the keyid the assoc active sending key */
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* does the key exist? */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* are there other refcount holders on the key? */
if|if
condition|(
name|skey
operator|->
name|refcount
operator|>
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* remove it */
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
comment|/* frees skey->key as well */
comment|/* clear any cached keys */
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * deletes a shared key from the endpoint  * ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|int
name|sctp_delete_sharedkey_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is the keyid the active sending key on the endpoint */
if|if
condition|(
name|keyid
operator|==
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* does the key exist? */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* endpoint keys are not refcounted */
comment|/* remove it */
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
comment|/* frees skey->key as well */
comment|/* clear any cached keys */
name|sctp_clear_cachedkeys_ep
argument_list|(
name|inp
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * set the active key on an association  * ASSUMES TCB_LOCK is already held  */
end_comment

begin_function
name|int
name|sctp_auth_setactivekey
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
init|=
name|NULL
decl_stmt|;
comment|/* find the key on the assoc */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* that key doesn't exist */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|skey
operator|->
name|deactivated
operator|)
operator|&&
operator|(
name|skey
operator|->
name|refcount
operator|>
literal|1
operator|)
condition|)
block|{
comment|/* can't reactivate a deactivated key with other refcounts */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* set the (new) active key */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
operator|=
name|keyid
expr_stmt|;
comment|/* reset the deactivated flag */
name|skey
operator|->
name|deactivated
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * set the active key on an endpoint  * ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|int
name|sctp_auth_setactivekey_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
comment|/* find the key */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
comment|/* that key doesn't exist */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
operator|=
name|keyid
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * deactivates a shared key from the association  * ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|int
name|sctp_deact_sharedkey
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is the keyid the assoc active sending key */
if|if
condition|(
name|keyid
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* does the key exist? */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* are there other refcount holders on the key? */
if|if
condition|(
name|skey
operator|->
name|refcount
operator|==
literal|1
condition|)
block|{
comment|/* no other users, send a notification for this key */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_AUTH_FREE_KEY
argument_list|,
name|stcb
argument_list|,
name|keyid
argument_list|,
literal|0
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
comment|/* mark the key as deactivated */
name|skey
operator|->
name|deactivated
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * deactivates a shared key from the endpoint  * ASSUMES INP_WLOCK is already held  */
end_comment

begin_function
name|int
name|sctp_deact_sharedkey_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* is the keyid the active sending key on the endpoint */
if|if
condition|(
name|keyid
operator|==
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* does the key exist? */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* endpoint keys are not refcounted */
comment|/* remove it */
name|LIST_REMOVE
argument_list|(
name|skey
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_sharedkey
argument_list|(
name|skey
argument_list|)
expr_stmt|;
comment|/* frees skey->key as well */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * get local authentication parameters from cookie (from INIT-ACK)  */
end_comment

begin_function
name|void
name|sctp_auth_get_cookie_params
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|length
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|tmp_param
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|,
name|ptype
decl_stmt|;
name|uint8_t
name|random_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_random
modifier|*
name|p_random
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|random_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|hmacs_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|hmacs_len
init|=
literal|0
decl_stmt|;
name|uint8_t
name|chunks_store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|num_chunks
init|=
literal|0
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint32_t
name|keylen
decl_stmt|;
comment|/* convert to upper bound */
name|length
operator|+=
name|offset
expr_stmt|;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
operator|!=
name|NULL
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plen
operator|==
literal|0
operator|)
operator|||
operator|(
name|offset
operator|+
name|plen
operator|>
name|length
operator|)
condition|)
break|break;
if|if
condition|(
name|ptype
operator|==
name|SCTP_RANDOM
condition|)
block|{
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|random_store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|random_store
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return;
comment|/* save the random and length for the key */
name|p_random
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
name|phdr
expr_stmt|;
name|random_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HMAC_LIST
condition|)
block|{
name|uint16_t
name|num_hmacs
decl_stmt|;
name|uint16_t
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|hmacs_store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|hmacs_store
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return;
comment|/* save the hmacs list and num for the key */
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
name|phdr
expr_stmt|;
name|hmacs_len
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
expr_stmt|;
name|num_hmacs
operator|=
name|hmacs_len
operator|/
sizeof|sizeof
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
name|sctp_free_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|num_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_hmacs
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sctp_auth_add_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
name|ntohs
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_CHUNK_LIST
condition|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
condition|)
break|break;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|chunks_store
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
return|return;
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_chunks
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
comment|/* save chunks list and num for the key */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|!=
name|NULL
condition|)
name|sctp_clear_chunklist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
else|else
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|=
name|sctp_alloc_chunklist
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|sctp_auth_add_chunk
argument_list|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get next parameter */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|>
name|length
condition|)
break|break;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
block|}
comment|/* concatenate the full random key */
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
expr_stmt|;
if|if
condition|(
name|chunks
operator|!=
name|NULL
condition|)
block|{
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
expr_stmt|;
block|}
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
comment|/* copy in the RANDOM */
if|if
condition|(
name|p_random
operator|!=
name|NULL
condition|)
block|{
name|keylen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|p_random
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|bcopy
argument_list|(
name|p_random
argument_list|,
name|new_key
operator|->
name|key
argument_list|,
name|keylen
argument_list|)
expr_stmt|;
block|}
comment|/* append in the AUTH chunks */
if|if
condition|(
name|chunks
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|chunks
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
operator|+
name|num_chunks
expr_stmt|;
block|}
comment|/* append in the HMACs */
if|if
condition|(
name|hmacs
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|hmacs
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|+
name|hmacs_len
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|=
name|new_key
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
operator|=
name|random_len
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
argument_list|)
expr_stmt|;
comment|/* negotiate what HMAC to use for the peer */
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
operator|=
name|sctp_negotiate_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
comment|/* copy defaults from the endpoint */
comment|/* FIX ME: put in cookie? */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|default_keyid
expr_stmt|;
comment|/* copy out the shared key list (by reference) from the endpoint */
operator|(
name|void
operator|)
name|sctp_copy_skeylist
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * compute and fill in the HMAC digest for a packet  */
end_comment

begin_function
name|void
name|sctp_fill_hmac_digest_m
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|keyid
parameter_list|)
block|{
name|uint32_t
name|digestlen
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|sctp_key_t
modifier|*
name|key
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|auth
operator|==
name|NULL
operator|)
condition|)
return|return;
comment|/* zero the digest + chunk padding */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|auth
operator|->
name|hmac
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|digestlen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is the desired key cached? */
if|if
condition|(
operator|(
name|keyid
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|!=
name|NULL
condition|)
block|{
comment|/* free the old cached key */
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|)
expr_stmt|;
block|}
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|keyid
argument_list|)
expr_stmt|;
comment|/* the only way skey is NULL is if null key id 0 is used */
if|if
condition|(
name|skey
operator|!=
name|NULL
condition|)
name|key
operator|=
name|skey
operator|->
name|key
expr_stmt|;
else|else
name|key
operator|=
name|NULL
expr_stmt|;
comment|/* compute a new assoc key and cache it */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
operator|=
name|sctp_compute_hashkey
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
operator|=
name|keyid
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"caching key id %u\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|sctp_print_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|,
literal|"Assoc Key"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* set in the active key id */
name|auth
operator|->
name|shared_key_id
operator|=
name|htons
argument_list|(
name|keyid
argument_list|)
expr_stmt|;
comment|/* compute and fill in the digest */
operator|(
name|void
operator|)
name|sctp_compute_hmac_m
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_key
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
operator|->
name|hmac
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_bzero_m
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|m_offset
parameter_list|,
name|uint32_t
name|size
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
name|uint8_t
modifier|*
name|data
decl_stmt|;
comment|/* sanity check */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
comment|/* find the correct starting mbuf and offset (get start position) */
name|m_tmp
operator|=
name|m
expr_stmt|;
while|while
condition|(
operator|(
name|m_tmp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|m_offset
operator|>=
operator|(
name|uint32_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
operator|)
condition|)
block|{
name|m_offset
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
comment|/* now use the rest of the mbuf chain */
while|while
condition|(
operator|(
name|m_tmp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|size
operator|>
literal|0
operator|)
condition|)
block|{
name|data
operator|=
name|mtod
argument_list|(
name|m_tmp
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m_offset
expr_stmt|;
if|if
condition|(
name|size
operator|>
operator|(
name|uint32_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|data
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clear the offset since it's only for the first mbuf */
name|m_offset
operator|=
literal|0
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-  * process the incoming Authentication chunk  * return codes:  *   -1 on any authentication error  *    0 on authentication verification  */
end_comment

begin_function
name|int
name|sctp_handle_auth
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|)
block|{
name|uint16_t
name|chunklen
decl_stmt|;
name|uint16_t
name|shared_key_id
decl_stmt|;
name|uint16_t
name|hmac_id
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|skey
decl_stmt|;
name|uint32_t
name|digestlen
decl_stmt|;
name|uint8_t
name|digest
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
name|uint8_t
name|computed_digest
index|[
name|SCTP_AUTH_DIGEST_LEN_MAX
index|]
decl_stmt|;
comment|/* auth is checked for NULL by caller */
name|chunklen
operator|=
name|ntohs
argument_list|(
name|auth
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunklen
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthfailed
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauth
argument_list|)
expr_stmt|;
comment|/* get the auth params */
name|shared_key_id
operator|=
name|ntohs
argument_list|(
name|auth
operator|->
name|shared_key_id
argument_list|)
expr_stmt|;
name|hmac_id
operator|=
name|ntohs
argument_list|(
name|auth
operator|->
name|hmac_id
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP AUTH Chunk: shared key %u, HMAC id %u\n"
argument_list|,
name|shared_key_id
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
comment|/* is the indicated HMAC supported? */
if|if
condition|(
operator|!
name|sctp_auth_is_supported_hmac
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
name|hmac_id
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_error_auth_invalid_hmac
modifier|*
name|cause
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvivalhmacid
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP Auth: unsupported HMAC id %u\n"
argument_list|,
name|hmac_id
argument_list|)
expr_stmt|;
comment|/* 		 * report this in an Error Chunk: Unsupported HMAC 		 * Identifier 		 */
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_auth_invalid_hmac
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|!=
name|NULL
condition|)
block|{
comment|/* pre-reserve some space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in the error */
name|cause
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_error_auth_invalid_hmac
operator|*
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNSUPPORTED_HMACID
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_auth_invalid_hmac
argument_list|)
argument_list|)
expr_stmt|;
name|cause
operator|->
name|hmac_id
operator|=
name|ntohs
argument_list|(
name|hmac_id
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_auth_invalid_hmac
argument_list|)
expr_stmt|;
comment|/* queue it */
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get the indicated shared key, if available */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
operator|!=
name|shared_key_id
operator|)
condition|)
block|{
comment|/* find the shared key on the assoc first */
name|skey
operator|=
name|sctp_find_sharedkey
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|,
name|shared_key_id
argument_list|)
expr_stmt|;
comment|/* if the shared key isn't found, discard the chunk */
if|if
condition|(
name|skey
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvivalkeyid
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP Auth: unknown key id %u\n"
argument_list|,
name|shared_key_id
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* generate a notification if this is a new key id */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
operator|!=
name|shared_key_id
condition|)
comment|/* 			 * sctp_ulp_notify(SCTP_NOTIFY_AUTH_NEW_KEY, stcb, 			 * shared_key_id, (void 			 * *)stcb->asoc.authinfo.recv_keyid); 			 */
name|sctp_notify_authentication
argument_list|(
name|stcb
argument_list|,
name|SCTP_AUTH_NEW_KEY
argument_list|,
name|shared_key_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* compute a new recv assoc key and cache it */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
operator|=
name|sctp_compute_hashkey
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|peer_random
argument_list|,
name|skey
operator|->
name|key
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_keyid
operator|=
name|shared_key_id
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_AUTH_DEBUG
condition|)
name|sctp_print_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|,
literal|"Recv Key"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* validate the digest length */
name|digestlen
operator|=
name|sctp_get_hmac_digest_len
argument_list|(
name|hmac_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunklen
operator|<
operator|(
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
operator|+
name|digestlen
operator|)
condition|)
block|{
comment|/* invalid digest length */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthfailed
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP Auth: chunk too short for HMAC\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* save a copy of the digest, zero the pseudo header, and validate */
name|bcopy
argument_list|(
name|auth
operator|->
name|hmac
argument_list|,
name|digest
argument_list|,
name|digestlen
argument_list|)
expr_stmt|;
name|sctp_bzero_m
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|digestlen
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_compute_hmac_m
argument_list|(
name|hmac_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|recv_key
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|computed_digest
argument_list|)
expr_stmt|;
comment|/* compare the computed digest with the one in the AUTH chunk */
if|if
condition|(
name|memcmp
argument_list|(
name|digest
argument_list|,
name|computed_digest
argument_list|,
name|digestlen
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthfailed
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP Auth: HMAC digest check failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate NOTIFICATION  */
end_comment

begin_function
name|void
name|sctp_notify_authentication
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|indication
parameter_list|,
name|uint16_t
name|keyid
parameter_list|,
name|uint16_t
name|alt_keyid
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_notify
decl_stmt|;
name|struct
name|sctp_authkey_event
modifier|*
name|auth
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
comment|/* If the socket is gone we are out of here */
return|return;
block|}
if|if
condition|(
name|sctp_stcb_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
condition|)
comment|/* event not enabled */
return|return;
name|m_notify
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authkey_event
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_notify
operator|==
name|NULL
condition|)
comment|/* no space left */
return|return;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
literal|0
expr_stmt|;
name|auth
operator|=
name|mtod
argument_list|(
name|m_notify
argument_list|,
expr|struct
name|sctp_authkey_event
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|auth
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authkey_event
argument_list|)
argument_list|)
expr_stmt|;
name|auth
operator|->
name|auth_type
operator|=
name|SCTP_AUTHENTICATION_EVENT
expr_stmt|;
name|auth
operator|->
name|auth_flags
operator|=
literal|0
expr_stmt|;
name|auth
operator|->
name|auth_length
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
expr_stmt|;
name|auth
operator|->
name|auth_keynumber
operator|=
name|keyid
expr_stmt|;
name|auth
operator|->
name|auth_altkeynumber
operator|=
name|alt_keyid
expr_stmt|;
name|auth
operator|->
name|auth_indication
operator|=
name|indication
expr_stmt|;
name|auth
operator|->
name|auth_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_notify
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* append to socket */
name|control
operator|=
name|sctp_build_readq_entry
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|m_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|spec_flags
operator|=
name|M_NOTIFICATION
expr_stmt|;
name|control
operator|->
name|length
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_notify
argument_list|)
expr_stmt|;
comment|/* not that we need this */
name|control
operator|->
name|tail_mbuf
operator|=
name|m_notify
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * validates the AUTHentication related parameters in an INIT/INIT-ACK  * Note: currently only used for INIT as INIT-ACK is handled inline  * with sctp_load_addresses_from_init()  */
end_comment

begin_function
name|int
name|sctp_validate_init_auth_params
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|param_buf
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|int
name|peer_supports_asconf
init|=
literal|0
decl_stmt|;
name|int
name|peer_supports_auth
init|=
literal|0
decl_stmt|;
name|int
name|got_random
init|=
literal|0
decl_stmt|,
name|got_hmacs
init|=
literal|0
decl_stmt|,
name|got_chklist
init|=
literal|0
decl_stmt|;
name|uint8_t
name|saw_asconf
init|=
literal|0
decl_stmt|;
name|uint8_t
name|saw_asconf_ack
init|=
literal|0
decl_stmt|;
comment|/* go through each of the params. */
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|param_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|param_buf
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|plen
operator|>
name|limit
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|ptype
operator|==
name|SCTP_SUPPORTED_CHUNK_EXT
condition|)
block|{
comment|/* A supported extension chunk */
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|uint8_t
name|local_store
index|[
name|SCTP_SMALL_CHUNK_STORE
index|]
decl_stmt|;
name|int
name|num_ent
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|local_store
argument_list|)
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|local_store
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_ent
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_ent
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pr_supported
operator|->
name|chunk_types
index|[
name|i
index|]
condition|)
block|{
case|case
name|SCTP_ASCONF
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* one we don't care about */
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_RANDOM
condition|)
block|{
comment|/* enforce the random length */
if|if
condition|(
name|plen
operator|!=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_random
argument_list|)
operator|+
name|SCTP_AUTH_RANDOM_SIZE_REQUIRED
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: invalid RANDOM len\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|got_random
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_HMAC_LIST
condition|)
block|{
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
decl_stmt|;
name|uint8_t
name|store
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|num_hmacs
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|store
argument_list|)
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|store
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_hmacs
operator|=
operator|(
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|hmacs
operator|->
name|hmac_ids
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* validate the hmac list */
if|if
condition|(
name|sctp_verify_hmac_param
argument_list|(
name|hmacs
argument_list|,
name|num_hmacs
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: invalid HMAC param\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|got_hmacs
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_CHUNK_LIST
condition|)
block|{
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
decl_stmt|;
name|uint8_t
name|chunks_store
index|[
name|SCTP_SMALL_CHUNK_STORE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_chunks
decl_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|chunks_store
argument_list|)
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|chunks_store
argument_list|,
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*- 			 * Flip through the list and mark that the 			 * peer supports asconf/asconf_ack. 			 */
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
name|phdr
expr_stmt|;
name|num_chunks
operator|=
name|plen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chunks
condition|;
name|i
operator|++
control|)
block|{
comment|/* record asconf/asconf-ack if listed */
if|if
condition|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
operator|==
name|SCTP_ASCONF
condition|)
name|saw_asconf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|chunks
operator|->
name|chunk_types
index|[
name|i
index|]
operator|==
name|SCTP_ASCONF_ACK
condition|)
name|saw_asconf_ack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|num_chunks
condition|)
name|got_chklist
operator|=
literal|1
expr_stmt|;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|limit
condition|)
block|{
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
operator|&
name|param_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|param_buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* validate authentication required parameters */
if|if
condition|(
name|got_random
operator|&&
name|got_hmacs
condition|)
block|{
name|peer_supports_auth
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|peer_supports_auth
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|peer_supports_auth
operator|&&
name|got_chklist
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: peer sent chunk list w/o AUTH\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|peer_supports_asconf
operator|&&
operator|!
name|peer_supports_auth
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"SCTP: peer supports ASCONF but not AUTH\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|peer_supports_asconf
operator|)
operator|&&
operator|(
name|peer_supports_auth
operator|)
operator|&&
operator|(
operator|(
name|saw_asconf
operator|==
literal|0
operator|)
operator|||
operator|(
name|saw_asconf_ack
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_initialize_auth_params
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|uint16_t
name|chunks_len
init|=
literal|0
decl_stmt|;
name|uint16_t
name|hmacs_len
init|=
literal|0
decl_stmt|;
name|uint16_t
name|random_len
init|=
name|SCTP_AUTH_RANDOM_SIZE_DEFAULT
decl_stmt|;
name|sctp_key_t
modifier|*
name|new_key
decl_stmt|;
name|uint16_t
name|keylen
decl_stmt|;
comment|/* initialize hmac list from endpoint */
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|=
name|sctp_copy_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
condition|)
block|{
name|hmacs_len
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|->
name|hmac
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* initialize auth chunks list from endpoint */
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|=
name|sctp_copy_chunklist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|->
name|chunks
index|[
name|i
index|]
condition|)
name|chunks_len
operator|++
expr_stmt|;
block|}
block|}
comment|/* copy defaults from the endpoint */
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
expr_stmt|;
comment|/* copy out the shared key list (by reference) from the endpoint */
operator|(
name|void
operator|)
name|sctp_copy_skeylist
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
argument_list|)
expr_stmt|;
comment|/* now set the concatenated key (random + chunks + hmacs) */
comment|/* key includes parameter headers */
name|keylen
operator|=
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|+
name|random_len
operator|+
name|chunks_len
operator|+
name|hmacs_len
expr_stmt|;
name|new_key
operator|=
name|sctp_alloc_key
argument_list|(
name|keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_key
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|int
name|plen
decl_stmt|;
comment|/* generate and copy in the RANDOM */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|new_key
operator|->
name|key
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_RANDOM
argument_list|)
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|SCTP_READ_RANDOM
argument_list|(
name|new_key
operator|->
name|key
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
argument_list|,
name|random_len
argument_list|)
expr_stmt|;
name|keylen
operator|=
name|plen
expr_stmt|;
comment|/* append in the AUTH chunks */
comment|/* NOTE: currently we always have chunks to list */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|new_key
operator|->
name|key
operator|+
name|keylen
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CHUNK_LIST
argument_list|)
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
operator|+
name|chunks_len
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
operator|->
name|chunks
index|[
name|i
index|]
condition|)
name|new_key
operator|->
name|key
index|[
name|keylen
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* append in the HMACs */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|new_key
operator|->
name|key
operator|+
name|keylen
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HMAC_LIST
argument_list|)
expr_stmt|;
name|plen
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
operator|+
name|hmacs_len
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|keylen
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ph
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_serialize_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
name|new_key
operator|->
name|key
operator|+
name|keylen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|!=
name|NULL
condition|)
name|sctp_free_key
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|=
name|new_key
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
operator|=
name|random_len
expr_stmt|;
block|}
end_function

end_unit

