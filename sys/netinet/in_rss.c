begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Juniper Networks, Inc.  * All rights reserved.  *  * This software was developed by Robert N. M. Watson under contract  * to Juniper Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_pcbgroup.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|PCBGROUP
end_ifndef

begin_error
error|#
directive|error
literal|"options RSS depends on options PCBGROUP"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/toeplitz.h>
end_include

begin_comment
comment|/* for software rss hash support */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_comment
comment|/*-  * Operating system parts of receiver-side scaling (RSS), which allows  * network cards to direct flows to particular receive queues based on hashes  * of header tuples.  This implementation aligns RSS buckets with connection  * groups at the TCP/IP layer, so each bucket is associated with exactly one  * group.  As a result, the group lookup structures (and lock) should have an  * effective affinity with exactly one CPU.  *  * Network device drivers needing to configure RSS will query this framework  * for parameters, such as the current RSS key, hashing policies, number of  * bits, and indirection table mapping hashes to buckets and CPUs.  They may  * provide their own supplementary information, such as queue<->CPU bindings.  * It is the responsibility of the network device driver to inject packets  * into the stack on as close to the right CPU as possible, if playing by RSS  * rules.  *  * TODO:  *  * - Synchronization for rss_key and other future-configurable parameters.  * - Event handler drivers can register to pick up RSS configuration changes.  * - Should we allow rss_basecpu to be configured?  * - Randomize key on boot.  * - IPv6 support.  * - Statistics on how often there's a misalignment between hardware  *   placement and pcbgroup expectations.  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet
argument_list|,
name|OID_AUTO
argument_list|,
name|rss
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"Receive-side steering"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Toeplitz is the only required hash function in the RSS spec, so use it by  * default.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|rss_hashalgo
init|=
name|RSS_HASH_TOEPLITZ
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|hashalgo
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|rss_hashalgo
argument_list|,
literal|0
argument_list|,
literal|"RSS hash algorithm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Size of the indirection table; at most 128 entries per the RSS spec.  We  * size it to at least 2 times the number of CPUs by default to allow useful  * rebalancing.  If not set explicitly with a loader tunable, we tune based  * on the number of CPUs present.  *  * XXXRW: buckets might be better to use for the tunable than bits.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|rss_bits
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|bits
argument_list|,
name|CTLFLAG_RDTUN
argument_list|,
operator|&
name|rss_bits
argument_list|,
literal|0
argument_list|,
literal|"RSS bits"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|u_int
name|rss_mask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|mask
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rss_mask
argument_list|,
literal|0
argument_list|,
literal|"RSS mask"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|rss_maxbits
init|=
name|RSS_MAXBITS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|maxbits
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|__DECONST
argument_list|(
name|int
operator|*
argument_list|,
operator|&
name|rss_maxbits
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"RSS maximum bits"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * RSS's own count of the number of CPUs it could be using for processing.  * Bounded to 64 by RSS constants.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|rss_ncpus
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|ncpus
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rss_ncpus
argument_list|,
literal|0
argument_list|,
literal|"Number of CPUs available to RSS"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|RSS_MAXCPUS
value|(1<< (RSS_MAXBITS - 1))
end_define

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|rss_maxcpus
init|=
name|RSS_MAXCPUS
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|maxcpus
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|__DECONST
argument_list|(
name|int
operator|*
argument_list|,
operator|&
name|rss_maxcpus
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"RSS maximum CPUs that can be used"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Variable exists just for reporting rss_bits in a user-friendly way.  */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|rss_buckets
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|buckets
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|rss_buckets
argument_list|,
literal|0
argument_list|,
literal|"RSS buckets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Base CPU number; devices will add this to all CPU numbers returned by the  * RSS indirection table.  Currently unmodifable in FreeBSD.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|rss_basecpu
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|basecpu
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|__DECONST
argument_list|(
name|int
operator|*
argument_list|,
operator|&
name|rss_basecpu
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"RSS base CPU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * RSS secret key, intended to prevent attacks on load-balancing.  Its  * effectiveness may be limited by algorithm choice and available entropy  * during the boot.  *  * XXXRW: And that we don't randomize it yet!  *  * This is the default Microsoft RSS specification key which is also  * the Chelsio T5 firmware default key.  */
end_comment

begin_decl_stmt
specifier|static
name|uint8_t
name|rss_key
index|[
name|RSS_KEYSIZE
index|]
init|=
block|{
literal|0x6d
block|,
literal|0x5a
block|,
literal|0x56
block|,
literal|0xda
block|,
literal|0x25
block|,
literal|0x5b
block|,
literal|0x0e
block|,
literal|0xc2
block|,
literal|0x41
block|,
literal|0x67
block|,
literal|0x25
block|,
literal|0x3d
block|,
literal|0x43
block|,
literal|0xa3
block|,
literal|0x8f
block|,
literal|0xb0
block|,
literal|0xd0
block|,
literal|0xca
block|,
literal|0x2b
block|,
literal|0xcb
block|,
literal|0xae
block|,
literal|0x7b
block|,
literal|0x30
block|,
literal|0xb4
block|,
literal|0x77
block|,
literal|0xcb
block|,
literal|0x2d
block|,
literal|0xa3
block|,
literal|0x80
block|,
literal|0x30
block|,
literal|0xf2
block|,
literal|0x0c
block|,
literal|0x6a
block|,
literal|0x42
block|,
literal|0xb7
block|,
literal|0x3b
block|,
literal|0xbe
block|,
literal|0xac
block|,
literal|0x01
block|,
literal|0xfa
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * RSS hash->CPU table, which maps hashed packet headers to particular CPUs.  * Drivers may supplement this table with a seperate CPU<->queue table when  * programming devices.  */
end_comment

begin_struct
struct|struct
name|rss_table_entry
block|{
name|uint8_t
name|rte_cpu
decl_stmt|;
comment|/* CPU affinity of bucket. */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|rss_table_entry
name|rss_table
index|[
name|RSS_TABLE_MAXLEN
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
specifier|inline
name|u_int
name|rss_gethashconfig_local
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|rss_init
parameter_list|(
name|__unused
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_int
name|i
decl_stmt|;
name|u_int
name|cpuid
decl_stmt|;
comment|/* 	 * Validate tunables, coerce to sensible values. 	 */
switch|switch
condition|(
name|rss_hashalgo
condition|)
block|{
case|case
name|RSS_HASH_TOEPLITZ
case|:
case|case
name|RSS_HASH_NAIVE
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: invalid RSS hashalgo %u, coercing to %u"
argument_list|,
name|__func__
argument_list|,
name|rss_hashalgo
argument_list|,
name|RSS_HASH_TOEPLITZ
argument_list|)
expr_stmt|;
name|rss_hashalgo
operator|=
name|RSS_HASH_TOEPLITZ
expr_stmt|;
block|}
comment|/* 	 * Count available CPUs. 	 * 	 * XXXRW: Note incorrect assumptions regarding contiguity of this set 	 * elsewhere. 	 */
name|rss_ncpus
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|mp_maxid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CPU_ABSENT
argument_list|(
name|i
argument_list|)
condition|)
continue|continue;
name|rss_ncpus
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|rss_ncpus
operator|>
name|RSS_MAXCPUS
condition|)
name|rss_ncpus
operator|=
name|RSS_MAXCPUS
expr_stmt|;
comment|/* 	 * Tune RSS table entries to be no less than 2x the number of CPUs 	 * -- unless we're running uniprocessor, in which case there's not 	 * much point in having buckets to rearrange for load-balancing! 	 */
if|if
condition|(
name|rss_ncpus
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|rss_bits
operator|==
literal|0
condition|)
name|rss_bits
operator|=
name|fls
argument_list|(
name|rss_ncpus
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Microsoft limits RSS table entries to 128, so apply that 		 * limit to both auto-detected CPU counts and user-configured 		 * ones. 		 */
if|if
condition|(
name|rss_bits
operator|==
literal|0
operator|||
name|rss_bits
operator|>
name|RSS_MAXBITS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: RSS bits %u not valid, coercing to  %u"
argument_list|,
name|__func__
argument_list|,
name|rss_bits
argument_list|,
name|RSS_MAXBITS
argument_list|)
expr_stmt|;
name|rss_bits
operator|=
name|RSS_MAXBITS
expr_stmt|;
block|}
comment|/* 		 * Figure out how many buckets to use; warn if less than the 		 * number of configured CPUs, although this is not a fatal 		 * problem. 		 */
name|rss_buckets
operator|=
operator|(
literal|1
operator|<<
name|rss_bits
operator|)
expr_stmt|;
if|if
condition|(
name|rss_buckets
operator|<
name|rss_ncpus
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: rss_buckets (%u) less than "
literal|"rss_ncpus (%u)\n"
argument_list|,
name|__func__
argument_list|,
name|rss_buckets
argument_list|,
name|rss_ncpus
argument_list|)
expr_stmt|;
name|rss_mask
operator|=
name|rss_buckets
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rss_bits
operator|=
literal|0
expr_stmt|;
name|rss_buckets
operator|=
literal|1
expr_stmt|;
name|rss_mask
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Set up initial CPU assignments: round-robin by default. 	 */
name|cpuid
operator|=
name|CPU_FIRST
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rss_buckets
condition|;
name|i
operator|++
control|)
block|{
name|rss_table
index|[
name|i
index|]
operator|.
name|rte_cpu
operator|=
name|cpuid
expr_stmt|;
name|cpuid
operator|=
name|CPU_NEXT
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Randomize rrs_key. 	 * 	 * XXXRW: Not yet.  If nothing else, will require an rss_isbadkey() 	 * loop to check for "bad" RSS keys. 	 */
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|rss_init
argument_list|,
name|SI_SUB_SOFTINTR
argument_list|,
name|SI_ORDER_SECOND
argument_list|,
name|rss_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint32_t
name|rss_naive_hash
parameter_list|(
name|u_int
name|keylen
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|key
parameter_list|,
name|u_int
name|datalen
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
name|uint32_t
name|v
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|v
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keylen
condition|;
name|i
operator|++
control|)
name|v
operator|+=
name|key
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|datalen
condition|;
name|i
operator|++
control|)
name|v
operator|+=
name|data
index|[
name|i
index|]
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|rss_hash
parameter_list|(
name|u_int
name|datalen
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|rss_hashalgo
condition|)
block|{
case|case
name|RSS_HASH_TOEPLITZ
case|:
return|return
operator|(
name|toeplitz_hash
argument_list|(
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
name|rss_key
argument_list|,
name|datalen
argument_list|,
name|data
argument_list|)
operator|)
return|;
case|case
name|RSS_HASH_NAIVE
case|:
return|return
operator|(
name|rss_naive_hash
argument_list|(
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|,
name|rss_key
argument_list|,
name|datalen
argument_list|,
name|data
argument_list|)
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"%s: unsupported/unknown hashalgo %d"
argument_list|,
name|__func__
argument_list|,
name|rss_hashalgo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Hash an IPv4 2-tuple.  */
end_comment

begin_function
name|uint32_t
name|rss_hash_ip4_2tuple
parameter_list|(
name|struct
name|in_addr
name|src
parameter_list|,
name|struct
name|in_addr
name|dst
parameter_list|)
block|{
name|uint8_t
name|data
index|[
sizeof|sizeof
argument_list|(
name|src
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
index|]
decl_stmt|;
name|u_int
name|datalen
decl_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|rss_hash
argument_list|(
name|datalen
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hash an IPv4 4-tuple.  */
end_comment

begin_function
name|uint32_t
name|rss_hash_ip4_4tuple
parameter_list|(
name|struct
name|in_addr
name|src
parameter_list|,
name|u_short
name|srcport
parameter_list|,
name|struct
name|in_addr
name|dst
parameter_list|,
name|u_short
name|dstport
parameter_list|)
block|{
name|uint8_t
name|data
index|[
sizeof|sizeof
argument_list|(
name|src
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|srcport
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dstport
argument_list|)
index|]
decl_stmt|;
name|u_int
name|datalen
decl_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|srcport
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|srcport
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|srcport
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dstport
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dstport
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|dstport
argument_list|)
expr_stmt|;
return|return
operator|(
name|rss_hash
argument_list|(
name|datalen
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * Hash an IPv6 2-tuple.  */
end_comment

begin_function
name|uint32_t
name|rss_hash_ip6_2tuple
parameter_list|(
name|struct
name|in6_addr
name|src
parameter_list|,
name|struct
name|in6_addr
name|dst
parameter_list|)
block|{
name|uint8_t
name|data
index|[
sizeof|sizeof
argument_list|(
name|src
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
index|]
decl_stmt|;
name|u_int
name|datalen
decl_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
return|return
operator|(
name|rss_hash
argument_list|(
name|datalen
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Hash an IPv6 4-tuple.  */
end_comment

begin_function
name|uint32_t
name|rss_hash_ip6_4tuple
parameter_list|(
name|struct
name|in6_addr
name|src
parameter_list|,
name|u_short
name|srcport
parameter_list|,
name|struct
name|in6_addr
name|dst
parameter_list|,
name|u_short
name|dstport
parameter_list|)
block|{
name|uint8_t
name|data
index|[
sizeof|sizeof
argument_list|(
name|src
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|srcport
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|dstport
argument_list|)
index|]
decl_stmt|;
name|u_int
name|datalen
decl_stmt|;
name|datalen
operator|=
literal|0
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|src
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dst
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|srcport
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|srcport
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|srcport
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|dstport
argument_list|,
operator|&
name|data
index|[
name|datalen
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dstport
argument_list|)
argument_list|)
expr_stmt|;
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|dstport
argument_list|)
expr_stmt|;
return|return
operator|(
name|rss_hash
argument_list|(
name|datalen
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_comment
comment|/*  * Query the number of RSS bits in use.  */
end_comment

begin_function
name|u_int
name|rss_getbits
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rss_bits
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the RSS bucket associated with an RSS hash.  */
end_comment

begin_function
name|u_int
name|rss_getbucket
parameter_list|(
name|u_int
name|hash
parameter_list|)
block|{
return|return
operator|(
name|hash
operator|&
name|rss_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the RSS layer bucket associated with the given  * entry in the RSS hash space.  *  * The RSS indirection table is 0 .. rss_buckets-1,  * covering the low 'rss_bits' of the total 128 slot  * RSS indirection table.  So just mask off rss_bits and  * return that.  *  * NIC drivers can then iterate over the 128 slot RSS  * indirection table and fetch which RSS bucket to  * map it to.  This will typically be a CPU queue  */
end_comment

begin_function
name|u_int
name|rss_get_indirection_to_bucket
parameter_list|(
name|u_int
name|index
parameter_list|)
block|{
return|return
operator|(
name|index
operator|&
name|rss_mask
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the RSS CPU associated with an RSS bucket.  */
end_comment

begin_function
name|u_int
name|rss_getcpu
parameter_list|(
name|u_int
name|bucket
parameter_list|)
block|{
return|return
operator|(
name|rss_table
index|[
name|bucket
index|]
operator|.
name|rte_cpu
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * netisr CPU affinity lookup given just the hash and hashtype.  */
end_comment

begin_function
name|u_int
name|rss_hash2cpuid
parameter_list|(
name|uint32_t
name|hash_val
parameter_list|,
name|uint32_t
name|hash_type
parameter_list|)
block|{
switch|switch
condition|(
name|hash_type
condition|)
block|{
case|case
name|M_HASHTYPE_RSS_IPV4
case|:
case|case
name|M_HASHTYPE_RSS_TCP_IPV4
case|:
case|case
name|M_HASHTYPE_RSS_UDP_IPV4
case|:
case|case
name|M_HASHTYPE_RSS_IPV6
case|:
case|case
name|M_HASHTYPE_RSS_TCP_IPV6
case|:
case|case
name|M_HASHTYPE_RSS_UDP_IPV6
case|:
return|return
operator|(
name|rss_getcpu
argument_list|(
name|rss_getbucket
argument_list|(
name|hash_val
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|NETISR_CPUID_NONE
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Query the RSS bucket associated with the given hash value and  * type.  */
end_comment

begin_function
name|int
name|rss_hash2bucket
parameter_list|(
name|uint32_t
name|hash_val
parameter_list|,
name|uint32_t
name|hash_type
parameter_list|,
name|uint32_t
modifier|*
name|bucket_id
parameter_list|)
block|{
switch|switch
condition|(
name|hash_type
condition|)
block|{
case|case
name|M_HASHTYPE_RSS_IPV4
case|:
case|case
name|M_HASHTYPE_RSS_TCP_IPV4
case|:
case|case
name|M_HASHTYPE_RSS_UDP_IPV4
case|:
case|case
name|M_HASHTYPE_RSS_IPV6
case|:
case|case
name|M_HASHTYPE_RSS_TCP_IPV6
case|:
case|case
name|M_HASHTYPE_RSS_UDP_IPV6
case|:
operator|*
name|bucket_id
operator|=
name|rss_getbucket
argument_list|(
name|hash_val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * netisr CPU affinity lookup routine for use by protocols.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|rss_m2cpuid
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|u_int
modifier|*
name|cpuid
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
operator|*
name|cpuid
operator|=
name|rss_hash2cpuid
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rss_m2bucket
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
modifier|*
name|bucket_id
parameter_list|)
block|{
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|rss_hash2bucket
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
name|bucket_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate an appropriate ipv4 2-tuple or 4-tuple given the given  * IPv4 source/destination address, UDP or TCP source/destination ports  * and the protocol type.  *  * The protocol code may wish to do a software hash of the given  * tuple.  This depends upon the currently configured RSS hash types.  *  * This assumes that the packet in question isn't a fragment.  *  * It also assumes the packet source/destination address  * are in "incoming" packet order (ie, source is "far" address.)  */
end_comment

begin_function
name|int
name|rss_proto_software_hash_v4
parameter_list|(
name|struct
name|in_addr
name|s
parameter_list|,
name|struct
name|in_addr
name|d
parameter_list|,
name|u_short
name|sp
parameter_list|,
name|u_short
name|dp
parameter_list|,
name|int
name|proto
parameter_list|,
name|uint32_t
modifier|*
name|hashval
parameter_list|,
name|uint32_t
modifier|*
name|hashtype
parameter_list|)
block|{
name|uint32_t
name|hash
decl_stmt|;
comment|/* 	 * Next, choose the hash type depending upon the protocol 	 * identifier. 	 */
if|if
condition|(
operator|(
name|proto
operator|==
name|IPPROTO_TCP
operator|)
operator|&&
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
operator|)
condition|)
block|{
name|hash
operator|=
name|rss_hash_ip4_4tuple
argument_list|(
name|s
argument_list|,
name|sp
argument_list|,
name|d
argument_list|,
name|dp
argument_list|)
expr_stmt|;
operator|*
name|hashval
operator|=
name|hash
expr_stmt|;
operator|*
name|hashtype
operator|=
name|M_HASHTYPE_RSS_TCP_IPV4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|proto
operator|==
name|IPPROTO_UDP
operator|)
operator|&&
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
operator|)
condition|)
block|{
name|hash
operator|=
name|rss_hash_ip4_4tuple
argument_list|(
name|s
argument_list|,
name|sp
argument_list|,
name|d
argument_list|,
name|dp
argument_list|)
expr_stmt|;
operator|*
name|hashval
operator|=
name|hash
expr_stmt|;
operator|*
name|hashtype
operator|=
name|M_HASHTYPE_RSS_UDP_IPV4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
block|{
comment|/* RSS doesn't hash on other protocols like SCTP; so 2-tuple */
name|hash
operator|=
name|rss_hash_ip4_2tuple
argument_list|(
name|s
argument_list|,
name|d
argument_list|)
expr_stmt|;
operator|*
name|hashval
operator|=
name|hash
expr_stmt|;
operator|*
name|hashtype
operator|=
name|M_HASHTYPE_RSS_IPV4
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No configured available hashtypes! */
name|printf
argument_list|(
literal|"%s: no available hashtypes!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do a software calculation of the RSS for the given mbuf.  *  * This is typically used by the input path to recalculate the RSS after  * some form of packet processing (eg de-capsulation, IP fragment reassembly.)  *  * dir is the packet direction - RSS_HASH_PKT_INGRESS for incoming and  * RSS_HASH_PKT_EGRESS for outgoing.  *  * Returns 0 if a hash was done, -1 if no hash was done, +1 if  * the mbuf already had a valid RSS flowid.  *  * This function doesn't modify the mbuf.  It's up to the caller to  * assign flowid/flowtype as appropriate.  */
end_comment

begin_function
name|int
name|rss_mbuf_software_hash_v4
parameter_list|(
specifier|const
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|dir
parameter_list|,
name|uint32_t
modifier|*
name|hashval
parameter_list|,
name|uint32_t
modifier|*
name|hashtype
parameter_list|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|const
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
specifier|const
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|uint8_t
name|proto
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|int
name|is_frag
init|=
literal|0
decl_stmt|;
comment|/* 	 * XXX For now this only handles hashing on incoming mbufs. 	 */
if|if
condition|(
name|dir
operator|!=
name|RSS_HASH_PKT_INGRESS
condition|)
block|{
name|printf
argument_list|(
literal|"%s: called on EGRESS packet!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * First, validate that the mbuf we have is long enough 	 * to have an IPv4 header in it. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: short mbuf pkthdr\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: short mbuf len\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Ok, let's dereference that */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|proto
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|iphlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
comment|/* 	 * If this is a fragment then it shouldn't be four-tuple 	 * hashed just yet.  Once it's reassembled into a full 	 * frame it should be re-hashed. 	 */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
name|is_frag
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If the mbuf flowid/flowtype matches the packet type, 	 * and we don't support the 4-tuple version of the given protocol, 	 * then signal to the owner that it can trust the flowid/flowtype 	 * details. 	 * 	 * This is a little picky - eg, if TCPv4 / UDPv4 hashing 	 * is supported but we got a TCP/UDP frame only 2-tuple hashed, 	 * then we shouldn't just "trust" the 2-tuple hash.  We need 	 * a 4-tuple hash. 	 */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
block|{
name|uint32_t
name|flowid
decl_stmt|,
name|flowtype
decl_stmt|;
name|flowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|flowtype
operator|=
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|proto
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
operator|)
operator|&&
operator|(
name|flowtype
operator|==
name|M_HASHTYPE_RSS_UDP_IPV4
operator|)
operator|&&
operator|(
name|is_frag
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * Only allow 2-tuple for UDP frames if we don't also 			 * support 4-tuple for UDP. 			 */
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_IPV4
operator|)
operator|&&
operator|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
operator|)
operator|==
literal|0
operator|)
operator|&&
name|flowtype
operator|==
name|M_HASHTYPE_RSS_IPV4
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
name|IPPROTO_TCP
case|:
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
operator|)
operator|&&
operator|(
name|flowtype
operator|==
name|M_HASHTYPE_RSS_TCP_IPV4
operator|)
operator|&&
operator|(
name|is_frag
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 			 * Only allow 2-tuple for TCP frames if we don't also 			 * support 2-tuple for TCP. 			 */
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_IPV4
operator|)
operator|&&
operator|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
operator|)
operator|==
literal|0
operator|)
operator|&&
name|flowtype
operator|==
name|M_HASHTYPE_RSS_IPV4
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
default|default:
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_IPV4
operator|)
operator|&&
name|flowtype
operator|==
name|M_HASHTYPE_RSS_IPV4
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
block|}
comment|/* 	 * Decode enough information to make a hash decision. 	 * 	 * XXX TODO: does the hardware hash on 4-tuple if IP 	 *    options are present? 	 */
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_TCP_IPV4
operator|)
operator|&&
operator|(
name|proto
operator|==
name|IPPROTO_TCP
operator|)
operator|&&
operator|(
name|is_frag
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|tcphdr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: short TCP frame?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|th
operator|=
operator|(
expr|struct
name|tcphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
return|return
name|rss_proto_software_hash_v4
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|th
operator|->
name|th_sport
argument_list|,
name|th
operator|->
name|th_dport
argument_list|,
name|proto
argument_list|,
name|hashval
argument_list|,
name|hashtype
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_UDP_IPV4
operator|)
operator|&&
operator|(
name|proto
operator|==
name|IPPROTO_UDP
operator|)
operator|&&
operator|(
name|is_frag
operator|==
literal|0
operator|)
condition|)
block|{
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: short UDP frame?\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
name|rss_proto_software_hash_v4
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|uh
operator|->
name|uh_sport
argument_list|,
name|uh
operator|->
name|uh_dport
argument_list|,
name|proto
argument_list|,
name|hashval
argument_list|,
name|hashtype
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|rss_gethashconfig_local
argument_list|()
operator|&
name|RSS_HASHTYPE_RSS_IPV4
condition|)
block|{
comment|/* Default to 2-tuple hash */
return|return
name|rss_proto_software_hash_v4
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
literal|0
argument_list|,
comment|/* source port */
literal|0
argument_list|,
comment|/* destination port */
literal|0
argument_list|,
comment|/* IPPROTO_IP */
name|hashval
argument_list|,
name|hashtype
argument_list|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: no available hashtypes!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Similar to rss_m2cpuid, but designed to be used by the IP NETISR  * on incoming frames.  *  * If an existing RSS hash exists and it matches what the configured  * hashing is, then use it.  *  * If there's an existing RSS hash but the desired hash is different,  * or if there's no useful RSS hash, then calculate it via  * the software path.  *  * XXX TODO: definitely want statistics here!  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|rss_soft_m2cpuid
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uintptr_t
name|source
parameter_list|,
name|u_int
modifier|*
name|cpuid
parameter_list|)
block|{
name|uint32_t
name|hash_val
decl_stmt|,
name|hash_type
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ret
operator|=
name|rss_mbuf_software_hash_v4
argument_list|(
name|m
argument_list|,
name|RSS_HASH_PKT_INGRESS
argument_list|,
operator|&
name|hash_val
argument_list|,
operator|&
name|hash_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
comment|/* mbuf has a valid hash already; don't need to modify it */
operator|*
name|cpuid
operator|=
name|rss_hash2cpuid
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* hash was done; update */
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|hash_val
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|hash_type
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
operator|*
name|cpuid
operator|=
name|rss_hash2cpuid
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ret< 0 */
comment|/* no hash was done */
operator|*
name|cpuid
operator|=
name|NETISR_CPUID_NONE
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the RSS hash algorithm.  */
end_comment

begin_function
name|u_int
name|rss_gethashalgo
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rss_hashalgo
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the current RSS key; likely to be used by device drivers when  * configuring hardware RSS.  Caller must pass an array of size RSS_KEYSIZE.  *  * XXXRW: Perhaps we should do the accept-a-length-and-truncate thing?  */
end_comment

begin_function
name|void
name|rss_getkey
parameter_list|(
name|uint8_t
modifier|*
name|key
parameter_list|)
block|{
name|bcopy
argument_list|(
name|rss_key
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|rss_key
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query the number of buckets; this may be used by both network device  * drivers, which will need to populate hardware shadows of the software  * indirection table, and the network stack itself (such as when deciding how  * many connection groups to allocate).  */
end_comment

begin_function
name|u_int
name|rss_getnumbuckets
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rss_buckets
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Query the number of CPUs in use by RSS; may be useful to device drivers  * trying to figure out how to map a larger number of CPUs into a smaller  * number of receive queues.  */
end_comment

begin_function
name|u_int
name|rss_getnumcpus
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rss_ncpus
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_int
name|rss_gethashconfig_local
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Return 4-tuple for TCP; 2-tuple for others */
comment|/* 	 * UDP may fragment more often than TCP and thus we'll end up with 	 * NICs returning 2-tuple fragments. 	 * udp_init() and udplite_init() both currently initialise things 	 * as 2-tuple. 	 * So for now disable UDP 4-tuple hashing until all of the other 	 * pieces are in place. 	 */
return|return
operator|(
name|RSS_HASHTYPE_RSS_IPV4
operator||
name|RSS_HASHTYPE_RSS_TCP_IPV4
operator||
name|RSS_HASHTYPE_RSS_IPV6
operator||
name|RSS_HASHTYPE_RSS_TCP_IPV6
operator||
name|RSS_HASHTYPE_RSS_IPV6_EX
operator||
name|RSS_HASHTYPE_RSS_TCP_IPV6_EX
if|#
directive|if
literal|0
expr||    RSS_HASHTYPE_RSS_UDP_IPV4 	|    RSS_HASHTYPE_RSS_UDP_IPV4_EX 	|    RSS_HASHTYPE_RSS_UDP_IPV6 	|    RSS_HASHTYPE_RSS_UDP_IPV6_EX
endif|#
directive|endif
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the supported RSS hash configuration.  *  * NICs should query this to determine what to configure in their redirection  * matching table.  */
end_comment

begin_function
name|u_int
name|rss_gethashconfig
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|rss_gethashconfig_local
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXXRW: Confirm that sysctl -a won't dump this keying material, don't want  * it appearing in debugging output unnecessarily.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_rss_key
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint8_t
name|temp_rss_key
index|[
name|RSS_KEYSIZE
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|req
operator|->
name|td
argument_list|,
name|PRIV_NETINET_HASHKEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bcopy
argument_list|(
name|rss_key
argument_list|,
name|temp_rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_rss_key
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_opaque
argument_list|(
name|oidp
argument_list|,
name|temp_rss_key
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_rss_key
argument_list|)
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
comment|/* XXXRW: Not yet. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|key
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_rss_key
argument_list|,
literal|""
argument_list|,
literal|"RSS keying material"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_rss_bucket_mapping
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|sbuf
modifier|*
name|sb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|i
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sb
operator|=
name|sbuf_new_for_sysctl
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|512
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|sb
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rss_buckets
condition|;
name|i
operator|++
control|)
block|{
name|sbuf_printf
argument_list|(
name|sb
argument_list|,
literal|"%s%d:%d"
argument_list|,
name|i
operator|==
literal|0
condition|?
literal|""
else|:
literal|" "
argument_list|,
name|i
argument_list|,
name|rss_getcpu
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|sbuf_finish
argument_list|(
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_rss
argument_list|,
name|OID_AUTO
argument_list|,
name|bucket_mapping
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_rss_bucket_mapping
argument_list|,
literal|""
argument_list|,
literal|"RSS bucket -> CPU mapping"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

