begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2015 Patrick Kelsey  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This is a server-side implementation of TCP Fast Open (TFO) [RFC7413].  *  * This implementation is currently considered to be experimental and is not  * included in kernel builds by default.  To include this code, add the  * following line to your kernel config:  *  * options TCP_RFC7413  *  * The generated TFO cookies are the 64-bit output of  * SipHash24(<16-byte-key><client-ip>).  Multiple concurrent valid keys are  * supported so that time-based rolling cookie invalidation policies can be  * implemented in the system.  The default number of concurrent keys is 2.  * This can be adjusted in the kernel config as follows:  *  * options TCP_RFC7413_MAX_KEYS=<num-keys>  *  *  * The following TFO-specific sysctls are defined:  *  * net.inet.tcp.fastopen.acceptany (RW, default 0)  *     When non-zero, all client-supplied TFO cookies will be considered to  *     be valid.  *  * net.inet.tcp.fastopen.autokey (RW, default 120)  *     When this and net.inet.tcp.fastopen.enabled are non-zero, a new key  *     will be automatically generated after this many seconds.  *  * net.inet.tcp.fastopen.enabled (RW, default 0)  *     When zero, no new TFO connections can be created.  On the transition  *     from enabled to disabled, all installed keys are removed.  On the   *     transition from disabled to enabled, if net.inet.tcp.fastopen.autokey  *     is non-zero and there are no keys installed, a new key will be   *     generated immediately.  The transition from enabled to disabled does  *     not affect any TFO connections in progress; it only prevents new ones  *     from being made.  *  * net.inet.tcp.fastopen.keylen (RO)  *     The key length in bytes.  *  * net.inet.tcp.fastopen.maxkeys (RO)  *     The maximum number of keys supported.  *  * net.inet.tcp.fastopen.numkeys (RO)  *     The current number of keys installed.  *  * net.inet.tcp.fastopen.setkey (WO)  *     Install a new key by writing net.inet.tcp.fastopen.keylen bytes to this  *     sysctl.  *  *  * In order for TFO connections to be created via a listen socket, that  * socket must have the TCP_FASTOPEN socket option set on it.  This option  * can be set on the socket either before or after the listen() is invoked.  * Clearing this option on a listen socket after it has been set has no  * effect on existing TFO connections or TFO connections in progress; it  * only prevents new TFO connections from being made.  *  * For passively-created sockets, the TCP_FASTOPEN socket option can be  * queried to determine whether the connection was established using TFO.  * Note that connections that are established via a TFO SYN, but that fall  * back to using a non-TFO SYN|ACK will have the TCP_FASTOPEN socket option  * set.  *  * Per the RFC, this implementation limits the number of TFO connections  * that can be in the SYN_RECEIVED state on a per listen-socket basis.  * Whenever this limit is exceeded, requests for new TFO connections are  * serviced as non-TFO requests.  Without such a limit, given a valid TFO  * cookie, an attacker could keep the listen queue in an overflow condition  * using a TFO SYN flood.  This implementation sets the limit at half the  * configured listen backlog.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<crypto/siphash/siphash.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fastopen.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_define
define|#
directive|define
name|TCP_FASTOPEN_KEY_LEN
value|SIPHASH_KEY_LENGTH
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|TCP_RFC7413_MAX_KEYS
argument_list|)
operator|||
operator|(
name|TCP_RFC7413_MAX_KEYS
operator|<
literal|1
operator|)
end_if

begin_define
define|#
directive|define
name|TCP_FASTOPEN_MAX_KEYS
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TCP_FASTOPEN_MAX_KEYS
value|TCP_RFC7413_MAX_KEYS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|tcp_fastopen_keylist
block|{
name|unsigned
name|int
name|newest
decl_stmt|;
name|uint8_t
name|key
index|[
name|TCP_FASTOPEN_MAX_KEYS
index|]
index|[
name|TCP_FASTOPEN_KEY_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tcp_fastopen_callout
block|{
name|struct
name|callout
name|c
decl_stmt|;
name|struct
name|vnet
modifier|*
name|v
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|fastopen
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TCP Fast Open"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|tcp_fastopen_acceptany
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_fastopen_acceptany
value|VNET(tcp_fastopen_acceptany)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|acceptany
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_fastopen_acceptany
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Accept any non-empty cookie"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
argument|unsigned int
argument_list|,
argument|tcp_fastopen_autokey
argument_list|)
operator|=
literal|120
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_fastopen_autokey
value|VNET(tcp_fastopen_autokey)
end_define

begin_function_decl
specifier|static
name|int
name|sysctl_net_inet_tcp_fastopen_autokey
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|autokey
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_net_inet_tcp_fastopen_autokey
argument_list|,
literal|"IU"
argument_list|,
literal|"Number of seconds between auto-generation of a new key; zero disables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|VNET_DEFINE
argument_list|(
argument|unsigned int
argument_list|,
argument|tcp_fastopen_enabled
argument_list|)
end_macro

begin_expr_stmt
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_net_inet_tcp_fastopen_enabled
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|enabled
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_net_inet_tcp_fastopen_enabled
argument_list|,
literal|"IU"
argument_list|,
literal|"Enable/disable TCP Fast Open processing"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|keylen
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
name|TCP_FASTOPEN_KEY_LEN
argument_list|,
literal|"Key length in bytes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|maxkeys
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|SYSCTL_NULL_INT_PTR
argument_list|,
name|TCP_FASTOPEN_MAX_KEYS
argument_list|,
literal|"Maximum number of keys supported"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
argument|unsigned int
argument_list|,
argument|tcp_fastopen_numkeys
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_fastopen_numkeys
value|VNET(tcp_fastopen_numkeys)
end_define

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|numkeys
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|tcp_fastopen_numkeys
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Number of keys installed"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|sysctl_net_inet_tcp_fastopen_setkey
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_tcp_fastopen
argument_list|,
name|OID_AUTO
argument_list|,
name|setkey
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_WR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sysctl_net_inet_tcp_fastopen_setkey
argument_list|,
literal|""
argument_list|,
literal|"Install a new key"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|rmlock
argument_list|,
name|tcp_fastopen_keylock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_fastopen_keylock
value|VNET(tcp_fastopen_keylock)
end_define

begin_define
define|#
directive|define
name|TCP_FASTOPEN_KEYS_RLOCK
parameter_list|(
name|t
parameter_list|)
value|rm_rlock(&V_tcp_fastopen_keylock, (t))
end_define

begin_define
define|#
directive|define
name|TCP_FASTOPEN_KEYS_RUNLOCK
parameter_list|(
name|t
parameter_list|)
value|rm_runlock(&V_tcp_fastopen_keylock, (t))
end_define

begin_define
define|#
directive|define
name|TCP_FASTOPEN_KEYS_WLOCK
parameter_list|()
value|rm_wlock(&V_tcp_fastopen_keylock)
end_define

begin_define
define|#
directive|define
name|TCP_FASTOPEN_KEYS_WUNLOCK
parameter_list|()
value|rm_wunlock(&V_tcp_fastopen_keylock)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|tcp_fastopen_keylist
argument_list|,
name|tcp_fastopen_keys
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_fastopen_keys
value|VNET(tcp_fastopen_keys)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
expr|struct
name|tcp_fastopen_callout
argument_list|,
name|tcp_fastopen_autokey_ctx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_tcp_fastopen_autokey_ctx
value|VNET(tcp_fastopen_autokey_ctx)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|counter_zone
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_counter_zone
value|VNET(counter_zone)
end_define

begin_function
name|void
name|tcp_fastopen_init
parameter_list|(
name|void
parameter_list|)
block|{
name|V_counter_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"tfo"
argument_list|,
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rm_init
argument_list|(
operator|&
name|V_tcp_fastopen_keylock
argument_list|,
literal|"tfo_keylock"
argument_list|)
expr_stmt|;
name|callout_init_rm
argument_list|(
operator|&
name|V_tcp_fastopen_autokey_ctx
operator|.
name|c
argument_list|,
operator|&
name|V_tcp_fastopen_keylock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|V_tcp_fastopen_keys
operator|.
name|newest
operator|=
name|TCP_FASTOPEN_MAX_KEYS
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tcp_fastopen_destroy
parameter_list|(
name|void
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|V_tcp_fastopen_autokey_ctx
operator|.
name|c
argument_list|)
expr_stmt|;
name|rm_destroy
argument_list|(
operator|&
name|V_tcp_fastopen_keylock
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_counter_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|unsigned
name|int
modifier|*
name|tcp_fastopen_alloc_counter
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
modifier|*
name|counter
decl_stmt|;
name|counter
operator|=
name|uma_zalloc
argument_list|(
name|V_counter_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|counter
condition|)
operator|*
name|counter
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|counter
operator|)
return|;
block|}
end_function

begin_function
name|void
name|tcp_fastopen_decrement_counter
parameter_list|(
name|unsigned
name|int
modifier|*
name|counter
parameter_list|)
block|{
if|if
condition|(
operator|*
name|counter
operator|==
literal|1
condition|)
name|uma_zfree
argument_list|(
name|V_counter_zone
argument_list|,
name|counter
argument_list|)
expr_stmt|;
else|else
name|atomic_subtract_int
argument_list|(
name|counter
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tcp_fastopen_addkey_locked
parameter_list|(
name|uint8_t
modifier|*
name|key
parameter_list|)
block|{
name|V_tcp_fastopen_keys
operator|.
name|newest
operator|++
expr_stmt|;
if|if
condition|(
name|V_tcp_fastopen_keys
operator|.
name|newest
operator|==
name|TCP_FASTOPEN_MAX_KEYS
condition|)
name|V_tcp_fastopen_keys
operator|.
name|newest
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|V_tcp_fastopen_keys
operator|.
name|key
index|[
name|V_tcp_fastopen_keys
operator|.
name|newest
index|]
argument_list|,
name|key
argument_list|,
name|TCP_FASTOPEN_KEY_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_tcp_fastopen_numkeys
operator|<
name|TCP_FASTOPEN_MAX_KEYS
condition|)
name|V_tcp_fastopen_numkeys
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tcp_fastopen_autokey_locked
parameter_list|(
name|void
parameter_list|)
block|{
name|uint8_t
name|newkey
index|[
name|TCP_FASTOPEN_KEY_LEN
index|]
decl_stmt|;
name|arc4rand
argument_list|(
name|newkey
argument_list|,
name|TCP_FASTOPEN_KEY_LEN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tcp_fastopen_addkey_locked
argument_list|(
name|newkey
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tcp_fastopen_autokey_callout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|tcp_fastopen_callout
modifier|*
name|ctx
init|=
name|arg
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|ctx
operator|->
name|v
argument_list|)
expr_stmt|;
name|tcp_fastopen_autokey_locked
argument_list|()
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ctx
operator|->
name|c
argument_list|,
name|V_tcp_fastopen_autokey
operator|*
name|hz
argument_list|,
name|tcp_fastopen_autokey_callout
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|tcp_fastopen_make_cookie
parameter_list|(
name|uint8_t
name|key
index|[
name|SIPHASH_KEY_LENGTH
index|]
parameter_list|,
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|)
block|{
name|SIPHASH_CTX
name|ctx
decl_stmt|;
name|uint64_t
name|siphash
decl_stmt|;
name|SipHash24_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|SipHash_SetKey
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inc
operator|->
name|inc_flags
operator|&
name|INC_ISIPV6
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
literal|0
case|:
name|SipHash_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|inc
operator|->
name|inc_faddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inc
operator|->
name|inc_faddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|INC_ISIPV6
case|:
name|SipHash_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|inc
operator|->
name|inc6_faddr
argument_list|,
sizeof|sizeof
argument_list|(
name|inc
operator|->
name|inc6_faddr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|SipHash_Final
argument_list|(
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|siphash
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
name|siphash
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return values:  *	-1	the cookie is invalid and no valid cookie is available  *	 0	the cookie is invalid and the latest cookie has been returned  *	 1	the cookie is valid and the latest cookie has been returned  */
end_comment

begin_function
name|int
name|tcp_fastopen_check_cookie
parameter_list|(
name|struct
name|in_conninfo
modifier|*
name|inc
parameter_list|,
name|uint8_t
modifier|*
name|cookie
parameter_list|,
name|unsigned
name|int
name|len
parameter_list|,
name|uint64_t
modifier|*
name|latest_cookie
parameter_list|)
block|{
name|struct
name|rm_priotracker
name|tracker
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|key_index
decl_stmt|;
name|uint64_t
name|cur_cookie
decl_stmt|;
if|if
condition|(
name|V_tcp_fastopen_acceptany
condition|)
block|{
operator|*
name|latest_cookie
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
name|TCP_FASTOPEN_COOKIE_LEN
condition|)
block|{
if|if
condition|(
name|V_tcp_fastopen_numkeys
operator|>
literal|0
condition|)
block|{
operator|*
name|latest_cookie
operator|=
name|tcp_fastopen_make_cookie
argument_list|(
name|V_tcp_fastopen_keys
operator|.
name|key
index|[
name|V_tcp_fastopen_keys
operator|.
name|newest
index|]
argument_list|,
name|inc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check against each available key, from newest to oldest. 	 */
name|TCP_FASTOPEN_KEYS_RLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
name|key_index
operator|=
name|V_tcp_fastopen_keys
operator|.
name|newest
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|V_tcp_fastopen_numkeys
condition|;
name|i
operator|++
control|)
block|{
name|cur_cookie
operator|=
name|tcp_fastopen_make_cookie
argument_list|(
name|V_tcp_fastopen_keys
operator|.
name|key
index|[
name|key_index
index|]
argument_list|,
name|inc
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|*
name|latest_cookie
operator|=
name|cur_cookie
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|cookie
argument_list|,
operator|&
name|cur_cookie
argument_list|,
name|TCP_FASTOPEN_COOKIE_LEN
argument_list|)
operator|==
literal|0
condition|)
block|{
name|TCP_FASTOPEN_KEYS_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|key_index
operator|==
literal|0
condition|)
name|key_index
operator|=
name|TCP_FASTOPEN_MAX_KEYS
operator|-
literal|1
expr_stmt|;
else|else
name|key_index
operator|--
expr_stmt|;
block|}
name|TCP_FASTOPEN_KEYS_RUNLOCK
argument_list|(
operator|&
name|tracker
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_net_inet_tcp_fastopen_autokey
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|new
decl_stmt|;
name|new
operator|=
name|V_tcp_fastopen_autokey
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
if|if
condition|(
name|new
operator|>
operator|(
name|INT_MAX
operator|/
name|hz
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|TCP_FASTOPEN_KEYS_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_tcp_fastopen_enabled
condition|)
block|{
if|if
condition|(
name|V_tcp_fastopen_autokey
operator|&&
operator|!
name|new
condition|)
name|callout_stop
argument_list|(
operator|&
name|V_tcp_fastopen_autokey_ctx
operator|.
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|new
condition|)
name|callout_reset
argument_list|(
operator|&
name|V_tcp_fastopen_autokey_ctx
operator|.
name|c
argument_list|,
name|new
operator|*
name|hz
argument_list|,
name|tcp_fastopen_autokey_callout
argument_list|,
operator|&
name|V_tcp_fastopen_autokey_ctx
argument_list|)
expr_stmt|;
block|}
name|V_tcp_fastopen_autokey
operator|=
name|new
expr_stmt|;
name|TCP_FASTOPEN_KEYS_WUNLOCK
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_net_inet_tcp_fastopen_enabled
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|new
decl_stmt|;
name|new
operator|=
name|V_tcp_fastopen_enabled
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
condition|)
block|{
if|if
condition|(
name|V_tcp_fastopen_enabled
operator|&&
operator|!
name|new
condition|)
block|{
comment|/* enabled -> disabled */
name|TCP_FASTOPEN_KEYS_WLOCK
argument_list|()
expr_stmt|;
name|V_tcp_fastopen_numkeys
operator|=
literal|0
expr_stmt|;
name|V_tcp_fastopen_keys
operator|.
name|newest
operator|=
name|TCP_FASTOPEN_MAX_KEYS
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|V_tcp_fastopen_autokey
condition|)
name|callout_stop
argument_list|(
operator|&
name|V_tcp_fastopen_autokey_ctx
operator|.
name|c
argument_list|)
expr_stmt|;
name|V_tcp_fastopen_enabled
operator|=
literal|0
expr_stmt|;
name|TCP_FASTOPEN_KEYS_WUNLOCK
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|V_tcp_fastopen_enabled
operator|&&
name|new
condition|)
block|{
comment|/* disabled -> enabled */
name|TCP_FASTOPEN_KEYS_WLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|V_tcp_fastopen_autokey
operator|&&
operator|(
name|V_tcp_fastopen_numkeys
operator|==
literal|0
operator|)
condition|)
block|{
name|tcp_fastopen_autokey_locked
argument_list|()
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|V_tcp_fastopen_autokey_ctx
operator|.
name|c
argument_list|,
name|V_tcp_fastopen_autokey
operator|*
name|hz
argument_list|,
name|tcp_fastopen_autokey_callout
argument_list|,
operator|&
name|V_tcp_fastopen_autokey_ctx
argument_list|)
expr_stmt|;
block|}
name|V_tcp_fastopen_enabled
operator|=
literal|1
expr_stmt|;
name|TCP_FASTOPEN_KEYS_WUNLOCK
argument_list|()
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_net_inet_tcp_fastopen_setkey
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint8_t
name|newkey
index|[
name|TCP_FASTOPEN_KEY_LEN
index|]
decl_stmt|;
if|if
condition|(
name|req
operator|->
name|oldptr
operator|!=
name|NULL
operator|||
name|req
operator|->
name|oldlen
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|newlen
operator|!=
sizeof|sizeof
argument_list|(
name|newkey
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|newkey
argument_list|,
sizeof|sizeof
argument_list|(
name|newkey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|TCP_FASTOPEN_KEYS_WLOCK
argument_list|()
expr_stmt|;
name|tcp_fastopen_addkey_locked
argument_list|(
name|newkey
argument_list|)
expr_stmt|;
name|TCP_FASTOPEN_KEYS_WUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

