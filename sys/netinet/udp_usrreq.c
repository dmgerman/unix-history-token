begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1995  *	The Regents of the University of California.  * Copyright (c) 2008 Robert N. M. Watson  * Copyright (c) 2010-2011 Juniper Networks, Inc.  * Copyright (c) 2014 Kevin Lo  * All rights reserved.  *  * Portions of this software were developed by Robert N. M. Watson under  * contract to Juniper Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)udp_usrreq.c	8.6 (Berkeley) 5/23/95  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_kdtrace.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_options.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udplite.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec_support.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_comment
comment|/*  * UDP and UDP-Lite protocols implementation.  * Per RFC 768, August, 1980.  * Per RFC 3828, July, 2004.  */
end_comment

begin_comment
comment|/*  * BSD 4.2 defaulted the udp checksum to be off.  Turning off udp checksums  * removes the only data integrity mechanism for packets and malformed  * packets that would otherwise be discarded due to bad checksums, and may  * cause problems (especially for NFS data blocks).  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|udp_cksum
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_udp
argument_list|,
name|UDPCTL_CHECKSUM
argument_list|,
name|checksum
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|udp_cksum
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"compute udp checksum"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|udp_log_in_vain
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_udp
argument_list|,
name|OID_AUTO
argument_list|,
name|log_in_vain
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|udp_log_in_vain
argument_list|,
literal|0
argument_list|,
literal|"Log all incoming UDP packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|udp_blackhole
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_udp
argument_list|,
name|OID_AUTO
argument_list|,
name|blackhole
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|udp_blackhole
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Do not send port unreachables for refused connects"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|udp_sendspace
init|=
literal|9216
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* really max datagram size */
end_comment

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_udp
argument_list|,
name|UDPCTL_MAXDGRAM
argument_list|,
name|maxdgram
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|udp_sendspace
argument_list|,
literal|0
argument_list|,
literal|"Maximum outgoing UDP datagram size"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|u_long
name|udp_recvspace
init|=
literal|40
operator|*
operator|(
literal|1024
operator|+
ifdef|#
directive|ifdef
name|INET6
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
else|#
directive|else
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
endif|#
directive|endif
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 40 1K datagrams */
end_comment

begin_expr_stmt
name|SYSCTL_ULONG
argument_list|(
name|_net_inet_udp
argument_list|,
name|UDPCTL_RECVSPACE
argument_list|,
name|recvspace
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|udp_recvspace
argument_list|,
literal|0
argument_list|,
literal|"Maximum space for incoming UDP datagrams"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|inpcbhead
argument_list|,
name|udb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* from udp_var.h */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|inpcbinfo
argument_list|,
name|udbinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|inpcbhead
argument_list|,
name|ulitecb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|inpcbinfo
argument_list|,
name|ulitecbinfo
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|udpcb_zone
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_udpcb_zone
value|VNET(udpcb_zone)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UDBHASHSIZE
end_ifndef

begin_define
define|#
directive|define
name|UDBHASHSIZE
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|udpstat
argument_list|,
name|udpstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* from udp_var.h */
end_comment

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|udpstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_udp
argument_list|,
name|UDPCTL_STATS
argument_list|,
name|stats
argument_list|,
expr|struct
name|udpstat
argument_list|,
name|udpstat
argument_list|,
literal|"UDP statistics (struct udpstat, netinet/udp_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|udpstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function_decl
specifier|static
name|void
name|udp_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|udp_output
parameter_list|(
name|struct
name|inpcb
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|thread
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|udp_zone_change
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uma_zone_set_max
argument_list|(
name|V_udbinfo
operator|.
name|ipi_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|V_udpcb_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_inpcb_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
name|mem
expr_stmt|;
name|INP_LOCK_INIT
argument_list|(
name|inp
argument_list|,
literal|"inp"
argument_list|,
literal|"udpinp"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udplite_inpcb_init
parameter_list|(
name|void
modifier|*
name|mem
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
name|mem
expr_stmt|;
name|INP_LOCK_INIT
argument_list|(
name|inp
argument_list|,
literal|"inp"
argument_list|,
literal|"udpliteinp"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|udp_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * For now default to 2-tuple UDP hashing - until the fragment 	 * reassembly code can also update the flowid. 	 * 	 * Once we can calculate the flowid that way and re-establish 	 * a 4-tuple, flip this to 4-tuple. 	 */
name|in_pcbinfo_init
argument_list|(
operator|&
name|V_udbinfo
argument_list|,
literal|"udp"
argument_list|,
operator|&
name|V_udb
argument_list|,
name|UDBHASHSIZE
argument_list|,
name|UDBHASHSIZE
argument_list|,
literal|"udp_inpcb"
argument_list|,
name|udp_inpcb_init
argument_list|,
name|IPI_HASHFIELDS_2TUPLE
argument_list|)
expr_stmt|;
name|V_udpcb_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"udpcb"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udpcb
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uma_zone_set_max
argument_list|(
name|V_udpcb_zone
argument_list|,
name|maxsockets
argument_list|)
expr_stmt|;
name|uma_zone_set_warning
argument_list|(
name|V_udpcb_zone
argument_list|,
literal|"kern.ipc.maxsockets limit reached"
argument_list|)
expr_stmt|;
name|EVENTHANDLER_REGISTER
argument_list|(
name|maxsockets_change
argument_list|,
name|udp_zone_change
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|udplite_init
parameter_list|(
name|void
parameter_list|)
block|{
name|in_pcbinfo_init
argument_list|(
operator|&
name|V_ulitecbinfo
argument_list|,
literal|"udplite"
argument_list|,
operator|&
name|V_ulitecb
argument_list|,
name|UDBHASHSIZE
argument_list|,
name|UDBHASHSIZE
argument_list|,
literal|"udplite_inpcb"
argument_list|,
name|udplite_inpcb_init
argument_list|,
name|IPI_HASHFIELDS_2TUPLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Kernel module interface for updating udpstat.  The argument is an index  * into udpstat treated as an array of u_long.  While this encodes the  * general layout of udpstat into the caller, it doesn't encode its location,  * so that future changes to add, for example, per-CPU stats support won't  * cause binary compatibility problems for kernel modules.  */
end_comment

begin_function
name|void
name|kmod_udpstat_inc
parameter_list|(
name|int
name|statnum
parameter_list|)
block|{
name|counter_u64_add
argument_list|(
name|VNET
argument_list|(
name|udpstat
argument_list|)
index|[
name|statnum
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|udp_newudpcb
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|up
operator|=
name|uma_zalloc
argument_list|(
name|V_udpcb_zone
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|inp
operator|->
name|inp_ppcb
operator|=
name|up
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|udp_discardcb
parameter_list|(
name|struct
name|udpcb
modifier|*
name|up
parameter_list|)
block|{
name|uma_zfree
argument_list|(
name|V_udpcb_zone
argument_list|,
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
specifier|static
name|void
name|udp_destroy
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|in_pcbinfo_destroy
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_udpcb_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|udp
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_FOURTH
argument_list|,
name|udp_destroy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|udplite_destroy
parameter_list|(
name|void
modifier|*
name|unused
name|__unused
parameter_list|)
block|{
name|in_pcbinfo_destroy
argument_list|(
operator|&
name|V_ulitecbinfo
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|VNET_SYSUNINIT
argument_list|(
name|udplite
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_FOURTH
argument_list|,
name|udplite_destroy
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_comment
comment|/*  * Subroutine of udp_input(), which appends the provided mbuf chain to the  * passed pcb/socket.  The caller must provide a sockaddr_in via udp_in that  * contains the source address.  If the socket ends up being an IPv6 socket,  * udp_append() will convert to a sockaddr_in6 before passing the address  * into the socket code.  *  * In the normal case udp_append() will return 0, indicating that you  * must unlock the inp. However if a tunneling protocol is in place we increment  * the inpcb refcnt and unlock the inp, on return from the tunneling protocol we  * then decrement the reference count. If the inp_rele returns 1, indicating the  * inp is gone, we return that to the caller to tell them *not* to unlock  * the inp. In the case of multi-cast this will cause the distribution  * to stop (though most tunneling protocols known currently do *not* use  * multicast).  */
end_comment

begin_function
specifier|static
name|int
name|udp_append
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|mbuf
modifier|*
name|n
parameter_list|,
name|int
name|off
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|udp_in
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|append_sa
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|tmpopts
decl_stmt|,
modifier|*
name|opts
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|udp_in6
decl_stmt|;
endif|#
directive|endif
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 	 * Engage the tunneling protocol. 	 */
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|u_tun_func
operator|!=
name|NULL
condition|)
block|{
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|up
operator|->
name|u_tun_func
call|)
argument_list|(
name|n
argument_list|,
name|off
argument_list|,
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|udp_in
index|[
literal|0
index|]
argument_list|,
name|up
operator|->
name|u_tun_ctx
argument_list|)
expr_stmt|;
name|INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|in_pcbrele_rlocked
argument_list|(
name|inp
argument_list|)
operator|)
return|;
block|}
name|off
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
comment|/* Check AH/ESP integrity. */
if|if
condition|(
name|IPSEC_ENABLED
argument_list|(
name|ipv4
argument_list|)
operator|&&
name|IPSEC_CHECK_POLICY
argument_list|(
name|ipv4
argument_list|,
name|n
argument_list|,
name|inp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|up
operator|->
name|u_flags
operator|&
name|UF_ESPINUDP
condition|)
block|{
comment|/* IPSec UDP encaps. */
if|if
condition|(
name|IPSEC_ENABLED
argument_list|(
name|ipv4
argument_list|)
operator|&&
name|UDPENCAP_INPUT
argument_list|(
name|n
argument_list|,
name|off
argument_list|,
name|AF_INET
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Consumed. */
block|}
endif|#
directive|endif
comment|/* IPSEC */
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_inpcb_check_deliver
argument_list|(
name|inp
argument_list|,
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* MAC */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_CONTROLOPTS
operator|||
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
operator|(
name|SO_TIMESTAMP
operator||
name|SO_BINTIME
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
operator|(
name|void
operator|)
name|ip6_savecontrol_v4
argument_list|(
name|inp
argument_list|,
name|n
argument_list|,
operator|&
name|opts
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INET6 */
name|ip_savecontrol
argument_list|(
name|inp
argument_list|,
operator|&
name|opts
argument_list|,
name|ip
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|&&
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_ORIGDSTADDR
operator|)
condition|)
block|{
name|tmpopts
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|udp_in
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|,
name|IP_ORIGDSTADDR
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpopts
condition|)
block|{
if|if
condition|(
name|opts
condition|)
block|{
name|tmpopts
operator|->
name|m_next
operator|=
name|opts
expr_stmt|;
name|opts
operator|=
name|tmpopts
expr_stmt|;
block|}
else|else
name|opts
operator|=
name|tmpopts
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|udp_in6
argument_list|,
sizeof|sizeof
argument_list|(
name|udp_in6
argument_list|)
argument_list|)
expr_stmt|;
name|udp_in6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|udp_in6
argument_list|)
expr_stmt|;
name|udp_in6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|in6_sin_2_v4mapsin6
argument_list|(
operator|&
name|udp_in
index|[
literal|0
index|]
argument_list|,
operator|&
name|udp_in6
argument_list|)
expr_stmt|;
name|append_sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|udp_in6
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* INET6 */
name|append_sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|udp_in
index|[
literal|0
index|]
expr_stmt|;
name|m_adj
argument_list|(
name|n
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|so
operator|=
name|inp
operator|->
name|inp_socket
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbappendaddr_locked
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|,
name|append_sa
argument_list|,
name|n
argument_list|,
name|opts
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|opts
condition|)
name|m_freem
argument_list|(
name|opts
argument_list|)
expr_stmt|;
name|UDPSTAT_INC
argument_list|(
name|udps_fullsock
argument_list|)
expr_stmt|;
block|}
else|else
name|sorwakeup_locked
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|udp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|uint16_t
name|len
decl_stmt|,
name|ip_len
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|ip
name|save_ip
decl_stmt|;
name|struct
name|sockaddr_in
name|udp_in
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|fwd_tag
decl_stmt|;
name|int
name|cscov_partial
decl_stmt|,
name|iphlen
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|iphlen
operator|=
operator|*
name|offp
expr_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
name|UDPSTAT_INC
argument_list|(
name|udps_ipackets
argument_list|)
expr_stmt|;
comment|/* 	 * Strip IP options, if any; should skip this, make available to 	 * user, and use on returned packets, but we don't yet have a way to 	 * check the checksum with options still present. 	 */
if|if
condition|(
name|iphlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|ip_stripoptions
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|iphlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get IP and UDP header together in first mbuf. 	 */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|UDPSTAT_INC
argument_list|(
name|udps_hdrops
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|cscov_partial
operator|=
operator|(
name|proto
operator|==
name|IPPROTO_UDPLITE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* 	 * Destination port of 0 is illegal, based on RFC768. 	 */
if|if
condition|(
name|uh
operator|->
name|uh_dport
operator|==
literal|0
condition|)
goto|goto
name|badunlocked
goto|;
comment|/* 	 * Construct sockaddr format source address.  Stuff source address 	 * and datagram in user buffer. 	 */
name|bzero
argument_list|(
operator|&
name|udp_in
index|[
literal|0
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|udp_in
index|[
literal|0
index|]
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|udp_in
index|[
literal|0
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|udp_in
index|[
literal|0
index|]
operator|.
name|sin_port
operator|=
name|uh
operator|->
name|uh_sport
expr_stmt|;
name|udp_in
index|[
literal|0
index|]
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|udp_in
index|[
literal|1
index|]
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|udp_in
index|[
literal|1
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|udp_in
index|[
literal|1
index|]
operator|.
name|sin_port
operator|=
name|uh
operator|->
name|uh_dport
expr_stmt|;
name|udp_in
index|[
literal|1
index|]
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
comment|/* 	 * Make mbuf data length reflect UDP length.  If not enough data to 	 * reflect UDP length, drop. 	 */
name|len
operator|=
name|ntohs
argument_list|(
operator|(
name|u_short
operator|)
name|uh
operator|->
name|uh_ulen
argument_list|)
expr_stmt|;
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|iphlen
expr_stmt|;
if|if
condition|(
name|proto
operator|==
name|IPPROTO_UDPLITE
operator|&&
operator|(
name|len
operator|==
literal|0
operator|||
name|len
operator|==
name|ip_len
operator|)
condition|)
block|{
comment|/* Zero means checksum over the complete packet. */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|ip_len
expr_stmt|;
name|cscov_partial
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ip_len
operator|!=
name|len
condition|)
block|{
if|if
condition|(
name|len
operator|>
name|ip_len
operator|||
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
condition|)
block|{
name|UDPSTAT_INC
argument_list|(
name|udps_badlen
argument_list|)
expr_stmt|;
goto|goto
name|badunlocked
goto|;
block|}
if|if
condition|(
name|proto
operator|==
name|IPPROTO_UDP
condition|)
name|m_adj
argument_list|(
name|m
argument_list|,
name|len
operator|-
name|ip_len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Save a copy of the IP header in case we want restore it for 	 * sending an ICMP error message in response. 	 */
if|if
condition|(
operator|!
name|V_udp_blackhole
condition|)
name|save_ip
operator|=
operator|*
name|ip
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|save_ip
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|save_ip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Checksum extended UDP header and data. 	 */
if|if
condition|(
name|uh
operator|->
name|uh_sum
condition|)
block|{
name|u_short
name|uh_sum
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_DATA_VALID
operator|)
operator|&&
operator|!
name|cscov_partial
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_PSEUDO_HDR
condition|)
name|uh_sum
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
else|else
name|uh_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|htonl
argument_list|(
operator|(
name|u_short
operator|)
name|len
operator|+
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|uh_sum
operator|^=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
name|char
name|b
index|[
literal|9
index|]
decl_stmt|;
name|bcopy
argument_list|(
operator|(
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
operator|)
operator|->
name|ih_x1
argument_list|,
name|b
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
operator|)
operator|->
name|ih_x1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
operator|)
operator|->
name|ih_len
operator|=
operator|(
name|proto
operator|==
name|IPPROTO_UDP
operator|)
condition|?
name|uh
operator|->
name|uh_ulen
else|:
name|htons
argument_list|(
name|ip_len
argument_list|)
expr_stmt|;
name|uh_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|b
argument_list|,
operator|(
operator|(
expr|struct
name|ipovly
operator|*
operator|)
name|ip
operator|)
operator|->
name|ih_x1
argument_list|,
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uh_sum
condition|)
block|{
name|UDPSTAT_INC
argument_list|(
name|udps_badsum
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|proto
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|UDPSTAT_INC
argument_list|(
name|udps_nosum
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* UDPLite requires a checksum */
comment|/* XXX: What is the right UDPLite MIB counter here? */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
operator|||
name|in_broadcast
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|ifp
argument_list|)
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|last
decl_stmt|;
name|struct
name|inpcbhead
modifier|*
name|pcblist
decl_stmt|;
name|struct
name|ip_moptions
modifier|*
name|imo
decl_stmt|;
name|INP_INFO_RLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|pcblist
operator|=
name|udp_get_pcblist
argument_list|(
name|proto
argument_list|)
expr_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|pcblist
argument_list|,
argument|inp_list
argument_list|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_lport
operator|!=
name|uh
operator|->
name|uh_dport
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV4
operator|)
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|&&
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|!=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
continue|continue;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
operator|&&
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
condition|)
continue|continue;
if|if
condition|(
name|inp
operator|->
name|inp_fport
operator|!=
literal|0
operator|&&
name|inp
operator|->
name|inp_fport
operator|!=
name|uh
operator|->
name|uh_sport
condition|)
continue|continue;
name|INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 			 * XXXRW: Because we weren't holding either the inpcb 			 * or the hash lock when we checked for a match 			 * before, we should probably recheck now that the 			 * inpcb lock is held. 			 */
comment|/* 			 * Handle socket delivery policy for any-source 			 * and source-specific multicast. [RFC3678] 			 */
name|imo
operator|=
name|inp
operator|->
name|inp_moptions
expr_stmt|;
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|group
decl_stmt|;
name|int
name|blocked
decl_stmt|;
if|if
condition|(
name|imo
operator|==
name|NULL
condition|)
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bzero
argument_list|(
operator|&
name|group
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|group
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|group
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|blocked
operator|=
name|imo_multi_filter
argument_list|(
name|imo
argument_list|,
name|ifp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|group
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|udp_in
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked
operator|!=
name|MCAST_PASS
condition|)
block|{
if|if
condition|(
name|blocked
operator|==
name|MCAST_NOTGMEMBER
condition|)
name|IPSTAT_INC
argument_list|(
name|ips_notmember
argument_list|)
expr_stmt|;
if|if
condition|(
name|blocked
operator|==
name|MCAST_NOTSMEMBER
operator|||
name|blocked
operator|==
name|MCAST_MUTED
condition|)
name|UDPSTAT_INC
argument_list|(
name|udps_filtermcast
argument_list|)
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|last
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|m_copym
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UDP_PROBE
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|last
argument_list|,
name|ip
argument_list|,
name|last
argument_list|,
name|uh
argument_list|)
expr_stmt|;
if|if
condition|(
name|udp_append
argument_list|(
name|last
argument_list|,
name|ip
argument_list|,
name|n
argument_list|,
name|iphlen
argument_list|,
name|udp_in
argument_list|)
condition|)
block|{
goto|goto
name|inp_lost
goto|;
block|}
block|}
name|INP_RUNLOCK
argument_list|(
name|last
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|inp
expr_stmt|;
comment|/* 			 * Don't look for additional matches if this one does 			 * not have either the SO_REUSEPORT or SO_REUSEADDR 			 * socket options set.  This heuristic avoids 			 * searching through all pcbs in the common case of a 			 * non-shared port.  It assumes that an application 			 * will never clear these options after setting them. 			 */
if|if
condition|(
operator|(
name|last
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
operator|(
name|SO_REUSEPORT
operator||
name|SO_REUSEADDR
operator|)
operator|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * No matching pcb found; discard datagram.  (No need 			 * to send an ICMP Port Unreachable for a broadcast 			 * or multicast datgram.) 			 */
name|UDPSTAT_INC
argument_list|(
name|udps_noportbcast
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
condition|)
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
goto|goto
name|badunlocked
goto|;
block|}
name|UDP_PROBE
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|last
argument_list|,
name|ip
argument_list|,
name|last
argument_list|,
name|uh
argument_list|)
expr_stmt|;
if|if
condition|(
name|udp_append
argument_list|(
name|last
argument_list|,
name|ip
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|udp_in
argument_list|)
operator|==
literal|0
condition|)
name|INP_RUNLOCK
argument_list|(
name|last
argument_list|)
expr_stmt|;
name|inp_lost
label|:
name|INP_INFO_RUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 	 * Locate pcb for datagram. 	 */
comment|/* 	 * Grab info from PACKET_TAG_IPFORWARD tag prepended to the chain. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_IP_NEXTHOP
operator|)
operator|&&
operator|(
name|fwd_tag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPFORWARD
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|next_hop
decl_stmt|;
name|next_hop
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|fwd_tag
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 		 * Transparently forwarded. Pretend to be the destination. 		 * Already got one like this? 		 */
name|inp
operator|=
name|in_pcblookup_mbuf
argument_list|(
name|pcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|uh
operator|->
name|uh_sport
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|uh
operator|->
name|uh_dport
argument_list|,
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
comment|/* 			 * It's new.  Try to find the ambushing socket. 			 * Because we've rewritten the destination address, 			 * any hardware-generated hash is ignored. 			 */
name|inp
operator|=
name|in_pcblookup
argument_list|(
name|pcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|uh
operator|->
name|uh_sport
argument_list|,
name|next_hop
operator|->
name|sin_addr
argument_list|,
name|next_hop
operator|->
name|sin_port
condition|?
name|htons
argument_list|(
name|next_hop
operator|->
name|sin_port
argument_list|)
else|:
name|uh
operator|->
name|uh_dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the tag from the packet. We don't need it anymore. */
name|m_tag_delete
argument_list|(
name|m
argument_list|,
name|fwd_tag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_IP_NEXTHOP
expr_stmt|;
block|}
else|else
name|inp
operator|=
name|in_pcblookup_mbuf
argument_list|(
name|pcbinfo
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|uh
operator|->
name|uh_sport
argument_list|,
name|ip
operator|->
name|ip_dst
argument_list|,
name|uh
operator|->
name|uh_dport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|udp_log_in_vain
condition|)
block|{
name|char
name|src
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|;
name|char
name|dst
index|[
name|INET_ADDRSTRLEN
index|]
decl_stmt|;
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Connection attempt to UDP %s:%d from %s:%d\n"
argument_list|,
name|inet_ntoa_r
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|dst
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_dport
argument_list|)
argument_list|,
name|inet_ntoa_r
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|,
name|src
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|uh
operator|->
name|uh_sport
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|UDPSTAT_INC
argument_list|(
name|udps_noport
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
block|{
name|UDPSTAT_INC
argument_list|(
name|udps_noportbcast
argument_list|)
expr_stmt|;
goto|goto
name|badunlocked
goto|;
block|}
if|if
condition|(
name|V_udp_blackhole
condition|)
goto|goto
name|badunlocked
goto|;
if|if
condition|(
name|badport_bandlim
argument_list|(
name|BANDLIM_ICMP_UNREACH
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|badunlocked
goto|;
operator|*
name|ip
operator|=
name|save_ip
expr_stmt|;
name|icmp_error
argument_list|(
name|m
argument_list|,
name|ICMP_UNREACH
argument_list|,
name|ICMP_UNREACH_PORT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* 	 * Check the minimum TTL for socket. 	 */
name|INP_RLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_ip_minttl
operator|&&
name|inp
operator|->
name|inp_ip_minttl
operator|>
name|ip
operator|->
name|ip_ttl
condition|)
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
if|if
condition|(
name|cscov_partial
condition|)
block|{
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|u_rxcslen
operator|==
literal|0
operator|||
name|up
operator|->
name|u_rxcslen
operator|>
name|len
condition|)
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
name|UDP_PROBE
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|inp
argument_list|,
name|ip
argument_list|,
name|inp
argument_list|,
name|uh
argument_list|)
expr_stmt|;
if|if
condition|(
name|udp_append
argument_list|(
name|inp
argument_list|,
name|ip
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|udp_in
argument_list|)
operator|==
literal|0
condition|)
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
name|badunlocked
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_comment
comment|/*  * Notify a udp user of an asynchronous error; just wake up so that they can  * collect error status.  */
end_comment

begin_function
name|struct
name|inpcb
modifier|*
name|udp_notify
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|int
name|errno
parameter_list|)
block|{
comment|/* 	 * While udp_ctlinput() always calls udp_notify() with a read lock 	 * when invoking it directly, in_pcbnotifyall() currently uses write 	 * locks due to sharing code with TCP.  For now, accept either a read 	 * or a write lock, but a read lock is sufficient. 	 */
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errno
operator|==
name|EHOSTUNREACH
operator|||
name|errno
operator|==
name|ENETUNREACH
operator|||
name|errno
operator|==
name|EHOSTDOWN
operator|)
operator|&&
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
operator|(
expr|struct
name|rtentry
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
name|inp
operator|->
name|inp_socket
operator|->
name|so_error
operator|=
name|errno
expr_stmt|;
name|sorwakeup
argument_list|(
name|inp
operator|->
name|inp_socket
argument_list|)
expr_stmt|;
name|sowwakeup
argument_list|(
name|inp
operator|->
name|inp_socket
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|udp_common_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|vip
parameter_list|,
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|vip
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|uh
decl_stmt|;
name|struct
name|in_addr
name|faddr
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|faddr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
name|faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
return|return;
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
comment|/* signal EHOSTDOWN, as it flushes the cached route */
name|in_pcbnotifyall
argument_list|(
operator|&
name|V_udbinfo
argument_list|,
name|faddr
argument_list|,
name|EHOSTDOWN
argument_list|,
name|udp_notify
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Hostdead is ugly because it goes linearly through all PCBs. 	 * 	 * XXX: We never get this from ICMP, otherwise it makes an excellent 	 * DoS attack on machines with many connections. 	 */
if|if
condition|(
name|cmd
operator|==
name|PRC_HOSTDEAD
condition|)
name|ip
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cmd
operator|>=
name|PRC_NCMDS
operator|||
name|inetctlerrmap
index|[
name|cmd
index|]
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|uh
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|inp
operator|=
name|in_pcblookup
argument_list|(
name|pcbinfo
argument_list|,
name|faddr
argument_list|,
name|uh
operator|->
name|uh_dport
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|uh
operator|->
name|uh_sport
argument_list|,
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|INP_RLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|!=
name|NULL
condition|)
block|{
name|udp_notify
argument_list|(
name|inp
argument_list|,
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
block|}
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|=
name|in_pcblookup
argument_list|(
name|pcbinfo
argument_list|,
name|faddr
argument_list|,
name|uh
operator|->
name|uh_dport
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|,
name|uh
operator|->
name|uh_sport
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|->
name|u_icmp_func
operator|!=
name|NULL
condition|)
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
call|(
modifier|*
name|up
operator|->
name|u_icmp_func
call|)
argument_list|(
name|cmd
argument_list|,
name|sa
argument_list|,
name|vip
argument_list|,
name|up
operator|->
name|u_tun_ctx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
name|in_pcbnotifyall
argument_list|(
name|pcbinfo
argument_list|,
name|faddr
argument_list|,
name|inetctlerrmap
index|[
name|cmd
index|]
argument_list|,
name|udp_notify
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|udp_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|vip
parameter_list|)
block|{
return|return
operator|(
name|udp_common_ctlinput
argument_list|(
name|cmd
argument_list|,
name|sa
argument_list|,
name|vip
argument_list|,
operator|&
name|V_udbinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|udplite_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|void
modifier|*
name|vip
parameter_list|)
block|{
return|return
operator|(
name|udp_common_ctlinput
argument_list|(
name|cmd
argument_list|,
name|sa
argument_list|,
name|vip
argument_list|,
operator|&
name|V_ulitecbinfo
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_function
specifier|static
name|int
name|udp_pcblist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|,
modifier|*
modifier|*
name|inp_list
decl_stmt|;
name|inp_gen_t
name|gencnt
decl_stmt|;
name|struct
name|xinpgen
name|xig
decl_stmt|;
comment|/* 	 * The process of preparing the PCB list is too time-consuming and 	 * resource-intensive to repeat twice on every request. 	 */
if|if
condition|(
name|req
operator|->
name|oldptr
operator|==
literal|0
condition|)
block|{
name|n
operator|=
name|V_udbinfo
operator|.
name|ipi_count
expr_stmt|;
name|n
operator|+=
name|imax
argument_list|(
name|n
operator|/
literal|8
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|req
operator|->
name|oldidx
operator|=
literal|2
operator|*
operator|(
sizeof|sizeof
name|xig
operator|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xinpcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|newptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|EPERM
operator|)
return|;
comment|/* 	 * OK, now we're committed to doing something. 	 */
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
name|gencnt
operator|=
name|V_udbinfo
operator|.
name|ipi_gencnt
expr_stmt|;
name|n
operator|=
name|V_udbinfo
operator|.
name|ipi_count
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|2
operator|*
operator|(
sizeof|sizeof
name|xig
operator|)
operator|+
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|xinpcb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|xig
operator|.
name|xig_len
operator|=
sizeof|sizeof
name|xig
expr_stmt|;
name|xig
operator|.
name|xig_count
operator|=
name|n
expr_stmt|;
name|xig
operator|.
name|xig_gen
operator|=
name|gencnt
expr_stmt|;
name|xig
operator|.
name|xig_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xig
argument_list|,
sizeof|sizeof
name|xig
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|inp_list
operator|=
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
expr|*
name|inp_list
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_list
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|inp
operator|=
name|LIST_FIRST
argument_list|(
name|V_udbinfo
operator|.
name|ipi_listhead
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|inp
operator|&&
name|i
operator|<
name|n
condition|;
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|inp
argument_list|,
name|inp_list
argument_list|)
control|)
block|{
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_gencnt
operator|<=
name|gencnt
operator|&&
name|cr_canseeinpcb
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|inp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|in_pcbref
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp_list
index|[
name|i
operator|++
index|]
operator|=
name|inp
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
name|n
operator|=
name|i
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|inp
operator|=
name|inp_list
index|[
name|i
index|]
expr_stmt|;
name|INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_gencnt
operator|<=
name|gencnt
condition|)
block|{
name|struct
name|xinpcb
name|xi
decl_stmt|;
name|in_pcbtoxinpcb
argument_list|(
name|inp
argument_list|,
operator|&
name|xi
argument_list|)
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xi
argument_list|,
sizeof|sizeof
name|xi
argument_list|)
expr_stmt|;
block|}
else|else
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|INP_INFO_WLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|inp
operator|=
name|inp_list
index|[
name|i
index|]
expr_stmt|;
name|INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_pcbrele_rlocked
argument_list|(
name|inp
argument_list|)
condition|)
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|INP_INFO_WUNLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
comment|/* 		 * Give the user an updated idea of our state.  If the 		 * generation differs from what we told her before, she knows 		 * that something happened while we were processing this 		 * request, and it might be necessary to retry. 		 */
name|INP_INFO_RLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
name|xig
operator|.
name|xig_gen
operator|=
name|V_udbinfo
operator|.
name|ipi_gencnt
expr_stmt|;
name|xig
operator|.
name|xig_sogen
operator|=
name|so_gencnt
expr_stmt|;
name|xig
operator|.
name|xig_count
operator|=
name|V_udbinfo
operator|.
name|ipi_count
expr_stmt|;
name|INP_INFO_RUNLOCK
argument_list|(
operator|&
name|V_udbinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xig
argument_list|,
sizeof|sizeof
name|xig
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|inp_list
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_udp
argument_list|,
name|UDPCTL_PCBLIST
argument_list|,
name|pcblist
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|udp_pcblist
argument_list|,
literal|"S,xinpcb"
argument_list|,
literal|"List of active UDP sockets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|int
name|udp_getcred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|xucred
name|xuc
decl_stmt|;
name|struct
name|sockaddr_in
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|req
operator|->
name|td
argument_list|,
name|PRIV_NETINET_GETCRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|inp
operator|=
name|in_pcblookup
argument_list|(
operator|&
name|V_udbinfo
argument_list|,
name|addrs
index|[
literal|1
index|]
operator|.
name|sin_addr
argument_list|,
name|addrs
index|[
literal|1
index|]
operator|.
name|sin_port
argument_list|,
name|addrs
index|[
literal|0
index|]
operator|.
name|sin_addr
argument_list|,
name|addrs
index|[
literal|0
index|]
operator|.
name|sin_port
argument_list|,
name|INPLOOKUP_WILDCARD
operator||
name|INPLOOKUP_RLOCKPCB
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|INP_RLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|==
name|NULL
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|cr_canseeinpcb
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|cru2x
argument_list|(
name|inp
operator|->
name|inp_cred
argument_list|,
operator|&
name|xuc
argument_list|)
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xuc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xucred
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_udp
argument_list|,
name|OID_AUTO
argument_list|,
name|getcred
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_PRISON
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|udp_getcred
argument_list|,
literal|"S,xucred"
argument_list|,
literal|"Get the xucred of a UDP connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_function
name|int
name|udp_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|int
name|isudplite
decl_stmt|,
name|error
decl_stmt|,
name|optval
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|isudplite
operator|=
operator|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|==
name|IPPROTO_UDPLITE
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|INP_CHECK_SOCKAF
argument_list|(
name|so
argument_list|,
name|AF_INET6
argument_list|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip6_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
switch|switch
condition|(
name|sopt
operator|->
name|sopt_dir
condition|)
block|{
case|case
name|SOPT_SET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
ifdef|#
directive|ifdef
name|INET
case|case
name|UDP_ENCAP
case|:
if|if
condition|(
operator|!
name|IPSEC_ENABLED
argument_list|(
name|ipv4
argument_list|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
name|error
operator|=
name|UDPENCAP_PCBCTL
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
endif|#
directive|endif
comment|/* IPSEC */
case|case
name|UDPLITE_SEND_CSCOV
case|:
case|case
name|UDPLITE_RECV_CSCOV
case|:
if|if
condition|(
operator|!
name|isudplite
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: inp == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|up
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: up == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|optval
operator|!=
literal|0
operator|&&
name|optval
operator|<
literal|8
operator|)
operator|||
operator|(
name|optval
operator|>
literal|65535
operator|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|UDPLITE_SEND_CSCOV
condition|)
name|up
operator|->
name|u_txcslen
operator|=
name|optval
expr_stmt|;
else|else
name|up
operator|->
name|u_rxcslen
operator|=
name|optval
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|SOPT_GET
case|:
switch|switch
condition|(
name|sopt
operator|->
name|sopt_name
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPSEC
argument_list|)
operator|||
name|defined
argument_list|(
name|IPSEC_SUPPORT
argument_list|)
ifdef|#
directive|ifdef
name|INET
case|case
name|UDP_ENCAP
case|:
if|if
condition|(
operator|!
name|IPSEC_ENABLED
argument_list|(
name|ipv4
argument_list|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
name|error
operator|=
name|UDPENCAP_PCBCTL
argument_list|(
name|inp
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* INET */
endif|#
directive|endif
comment|/* IPSEC */
case|case
name|UDPLITE_SEND_CSCOV
case|:
case|case
name|UDPLITE_RECV_CSCOV
case|:
if|if
condition|(
operator|!
name|isudplite
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|up
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: up == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_name
operator|==
name|UDPLITE_SEND_CSCOV
condition|)
name|optval
operator|=
name|up
operator|->
name|u_txcslen
expr_stmt|;
else|else
name|optval
operator|=
name|up
operator|->
name|u_rxcslen
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
operator|&
name|optval
argument_list|,
sizeof|sizeof
argument_list|(
name|optval
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_define
define|#
directive|define
name|UH_WLOCKED
value|2
end_define

begin_define
define|#
directive|define
name|UH_RLOCKED
value|1
end_define

begin_define
define|#
directive|define
name|UH_UNLOCKED
value|0
end_define

begin_function
specifier|static
name|int
name|udp_output
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|udpiphdr
modifier|*
name|ui
decl_stmt|;
name|int
name|len
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
decl_stmt|;
name|struct
name|in_addr
name|faddr
decl_stmt|,
name|laddr
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cm
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
name|src
decl_stmt|;
name|int
name|cscov_partial
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|ipflags
decl_stmt|;
name|u_short
name|fport
decl_stmt|,
name|lport
decl_stmt|;
name|int
name|unlock_udbinfo
decl_stmt|,
name|unlock_inp
decl_stmt|;
name|u_char
name|tos
decl_stmt|;
name|uint8_t
name|pr
decl_stmt|;
name|uint16_t
name|cscov
init|=
literal|0
decl_stmt|;
name|uint32_t
name|flowid
init|=
literal|0
decl_stmt|;
name|uint8_t
name|flowtype
init|=
name|M_HASHTYPE_NONE
decl_stmt|;
comment|/* 	 * udp_output() may need to temporarily bind or connect the current 	 * inpcb.  As such, we don't know up front whether we will need the 	 * pcbinfo lock or not.  Do any work to decide what is needed up 	 * front before acquiring any locks. 	 */
if|if
condition|(
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udpiphdr
argument_list|)
operator|>
name|IP_MAXPACKET
condition|)
block|{
if|if
condition|(
name|control
condition|)
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
block|}
name|src
operator|.
name|sin_family
operator|=
literal|0
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
operator|||
operator|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|&&
name|inp
operator|->
name|inp_lport
operator|==
literal|0
operator|)
condition|)
block|{
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|unlock_inp
operator|=
name|UH_WLOCKED
expr_stmt|;
block|}
else|else
block|{
name|INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|unlock_inp
operator|=
name|UH_RLOCKED
expr_stmt|;
block|}
name|tos
operator|=
name|inp
operator|->
name|inp_ip_tos
expr_stmt|;
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * XXX: Currently, we assume all the optional information is 		 * stored in a single mbuf. 		 */
if|if
condition|(
name|control
operator|->
name|m_next
condition|)
block|{
if|if
condition|(
name|unlock_inp
operator|==
name|UH_WLOCKED
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
else|else
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
for|for
control|(
init|;
name|control
operator|->
name|m_len
operator|>
literal|0
condition|;
name|control
operator|->
name|m_data
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cm
operator|->
name|cmsg_len
argument_list|)
operator|,
name|control
operator|->
name|m_len
operator|-=
name|CMSG_ALIGN
argument_list|(
name|cm
operator|->
name|cmsg_len
argument_list|)
control|)
block|{
name|cm
operator|=
name|mtod
argument_list|(
name|control
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|cm
argument_list|)
operator|||
name|cm
operator|->
name|cmsg_len
operator|==
literal|0
operator|||
name|cm
operator|->
name|cmsg_len
operator|>
name|control
operator|->
name|m_len
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cm
operator|->
name|cmsg_level
operator|!=
name|IPPROTO_IP
condition|)
continue|continue;
switch|switch
condition|(
name|cm
operator|->
name|cmsg_type
condition|)
block|{
case|case
name|IP_SENDSRCADDR
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
operator|&
name|src
argument_list|,
sizeof|sizeof
argument_list|(
name|src
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_port
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
name|src
operator|.
name|sin_addr
operator|=
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_TOS
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|tos
operator|=
operator|*
operator|(
name|u_char
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_FLOWID
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|flowid
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
case|case
name|IP_FLOWTYPE
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|flowtype
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cm
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|RSS
case|case
name|IP_RSSBUCKETID
case|:
if|if
condition|(
name|cm
operator|->
name|cmsg_len
operator|!=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* This is just a placeholder for now */
break|break;
endif|#
directive|endif
comment|/* RSS */
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|unlock_inp
operator|==
name|UH_WLOCKED
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
else|else
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Depending on whether or not the application has bound or connected 	 * the socket, we may have to do varying levels of work.  The optimal 	 * case is for a connected UDP socket, as a global lock isn't 	 * required at all. 	 * 	 * In order to decide which we need, we require stability of the 	 * inpcb binding, which we ensure by acquiring a read lock on the 	 * inpcb.  This doesn't strictly follow the lock order, so we play 	 * the trylock and retry game; note that we may end up with more 	 * conservative locks than required the second time around, so later 	 * assertions have to accept that.  Further analysis of the number of 	 * misses under contention is required. 	 * 	 * XXXRW: Check that hash locking update here is correct. 	 */
name|pr
operator|=
name|inp
operator|->
name|inp_socket
operator|->
name|so_proto
operator|->
name|pr_protocol
expr_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|!=
name|NULL
operator|&&
operator|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|&&
name|inp
operator|->
name|inp_lport
operator|==
literal|0
operator|)
condition|)
block|{
name|INP_HASH_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|unlock_udbinfo
operator|=
name|UH_WLOCKED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|sin
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
operator|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|inp
operator|->
name|inp_lport
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|src
operator|.
name|sin_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
name|INP_HASH_RLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|unlock_udbinfo
operator|=
name|UH_RLOCKED
expr_stmt|;
block|}
else|else
name|unlock_udbinfo
operator|=
name|UH_UNLOCKED
expr_stmt|;
comment|/* 	 * If the IP_SENDSRCADDR control message was specified, override the 	 * source address for this datagram.  Its use is invalidated if the 	 * address thus specified is incomplete or clobbers other inpcbs. 	 */
name|laddr
operator|=
name|inp
operator|->
name|inp_laddr
expr_stmt|;
name|lport
operator|=
name|inp
operator|->
name|inp_lport
expr_stmt|;
if|if
condition|(
name|src
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|INP_HASH_LOCK_ASSERT
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lport
operator|==
literal|0
operator|)
operator|||
operator|(
name|laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|&&
name|src
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|error
operator|=
name|in_pcbbind_setup
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
operator|&
name|laddr
operator|.
name|s_addr
argument_list|,
operator|&
name|lport
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
block|}
comment|/* 	 * If a UDP socket has been connected, then a local address/port will 	 * have been selected and bound. 	 * 	 * If a UDP socket has not been connected to, then an explicit 	 * destination address must be used, in which case a local 	 * address/port may not have been selected and bound. 	 */
if|if
condition|(
name|sin
operator|!=
name|NULL
condition|)
block|{
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|error
operator|=
name|EISCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
comment|/* 		 * Jail may rewrite the destination address, so let it do 		 * that before we use it. 		 */
name|error
operator|=
name|prison_remote_ip4
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
comment|/* 		 * If a local address or port hasn't yet been selected, or if 		 * the destination address needs to be rewritten due to using 		 * a special INADDR_ constant, invoke in_pcbconnect_setup() 		 * to do the heavy lifting.  Once a port is selected, we 		 * commit the binding back to the socket; we also commit the 		 * binding of the address if in jail. 		 * 		 * If we already have a valid binding and we're not 		 * requesting a destination address rewrite, use a fast path. 		 */
if|if
condition|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|||
name|inp
operator|->
name|inp_lport
operator|==
literal|0
operator|||
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|||
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
condition|)
block|{
name|INP_HASH_LOCK_ASSERT
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|in_pcbconnect_setup
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
operator|&
name|laddr
operator|.
name|s_addr
argument_list|,
operator|&
name|lport
argument_list|,
operator|&
name|faddr
operator|.
name|s_addr
argument_list|,
operator|&
name|fport
argument_list|,
name|NULL
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|release
goto|;
comment|/* 			 * XXXRW: Why not commit the port if the address is 			 * !INADDR_ANY? 			 */
comment|/* Commit the local port if newly assigned. */
if|if
condition|(
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|&&
name|inp
operator|->
name|inp_lport
operator|==
literal|0
condition|)
block|{
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_HASH_WLOCK_ASSERT
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
comment|/* 				 * Remember addr if jailed, to prevent 				 * rebinding. 				 */
if|if
condition|(
name|prison_flag
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
name|PR_IP4
argument_list|)
condition|)
name|inp
operator|->
name|inp_laddr
operator|=
name|laddr
expr_stmt|;
name|inp
operator|->
name|inp_lport
operator|=
name|lport
expr_stmt|;
if|if
condition|(
name|in_pcbinshash
argument_list|(
name|inp
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|inp
operator|->
name|inp_lport
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|inp
operator|->
name|inp_flags
operator||=
name|INP_ANONPORT
expr_stmt|;
block|}
block|}
else|else
block|{
name|faddr
operator|=
name|sin
operator|->
name|sin_addr
expr_stmt|;
name|fport
operator|=
name|sin
operator|->
name|sin_port
expr_stmt|;
block|}
block|}
else|else
block|{
name|INP_LOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|faddr
operator|=
name|inp
operator|->
name|inp_faddr
expr_stmt|;
name|fport
operator|=
name|inp
operator|->
name|inp_fport
expr_stmt|;
if|if
condition|(
name|faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|release
goto|;
block|}
block|}
comment|/* 	 * Calculate data length and get a mbuf for UDP, IP, and possible 	 * link-layer headers.  Immediate slide the data pointer back forward 	 * since we won't use that space at this layer. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udpiphdr
argument_list|)
operator|+
name|max_linkhdr
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|release
goto|;
block|}
name|m
operator|->
name|m_data
operator|+=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|max_linkhdr
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|max_linkhdr
expr_stmt|;
comment|/* 	 * Fill in mbuf with extended UDP header and addresses and length put 	 * into network format. 	 */
name|ui
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|udpiphdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ui
operator|->
name|ui_x1
argument_list|,
sizeof|sizeof
argument_list|(
name|ui
operator|->
name|ui_x1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX still needed? */
name|ui
operator|->
name|ui_pr
operator|=
name|pr
expr_stmt|;
name|ui
operator|->
name|ui_src
operator|=
name|laddr
expr_stmt|;
name|ui
operator|->
name|ui_dst
operator|=
name|faddr
expr_stmt|;
name|ui
operator|->
name|ui_sport
operator|=
name|lport
expr_stmt|;
name|ui
operator|->
name|ui_dport
operator|=
name|fport
expr_stmt|;
name|ui
operator|->
name|ui_ulen
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|IPPROTO_UDPLITE
condition|)
block|{
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|;
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|cscov
operator|=
name|up
operator|->
name|u_txcslen
expr_stmt|;
name|plen
operator|=
operator|(
name|u_short
operator|)
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cscov
operator|>=
name|plen
condition|)
name|cscov
operator|=
literal|0
expr_stmt|;
name|ui
operator|->
name|ui_len
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|ui
operator|->
name|ui_ulen
operator|=
name|htons
argument_list|(
name|cscov
argument_list|)
expr_stmt|;
comment|/* 		 * For UDP-Lite, checksum coverage length of zero means 		 * the entire UDPLite packet is covered by the checksum. 		 */
name|cscov_partial
operator|=
operator|(
name|cscov
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
block|}
else|else
name|ui
operator|->
name|ui_v
operator|=
name|IPVERSION
operator|<<
literal|4
expr_stmt|;
comment|/* 	 * Set the Don't Fragment bit in the IP header. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DONTFRAG
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|&
name|ui
operator|->
name|ui_i
expr_stmt|;
name|ip
operator|->
name|ip_off
operator||=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
block|}
name|ipflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_DONTROUTE
condition|)
name|ipflags
operator||=
name|IP_ROUTETOIF
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_BROADCAST
condition|)
name|ipflags
operator||=
name|IP_ALLOWBROADCAST
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_ONESBCAST
condition|)
name|ipflags
operator||=
name|IP_SENDONES
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_inpcb_create_mbuf
argument_list|(
name|inp
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Set up checksum and output datagram. 	 */
name|ui
operator|->
name|ui_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|IPPROTO_UDPLITE
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_ONESBCAST
condition|)
name|faddr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
if|if
condition|(
name|cscov_partial
condition|)
block|{
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|cscov
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ui
operator|->
name|ui_sum
operator|=
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ui
operator|->
name|ui_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|udpiphdr
argument_list|)
operator|+
name|len
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ui
operator|->
name|ui_sum
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|V_udp_cksum
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_ONESBCAST
condition|)
name|faddr
operator|.
name|s_addr
operator|=
name|INADDR_BROADCAST
expr_stmt|;
name|ui
operator|->
name|ui_sum
operator|=
name|in_pseudo
argument_list|(
name|ui
operator|->
name|ui_src
operator|.
name|s_addr
argument_list|,
name|faddr
operator|.
name|s_addr
argument_list|,
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
name|pr
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_UDP
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|offsetof
argument_list|(
expr|struct
name|udphdr
argument_list|,
name|uh_sum
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ui
operator|)
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|udpiphdr
argument_list|)
operator|+
name|len
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ui
operator|)
operator|->
name|ip_ttl
operator|=
name|inp
operator|->
name|inp_ip_ttl
expr_stmt|;
comment|/* XXX */
operator|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ui
operator|)
operator|->
name|ip_tos
operator|=
name|tos
expr_stmt|;
comment|/* XXX */
name|UDPSTAT_INC
argument_list|(
name|udps_opackets
argument_list|)
expr_stmt|;
comment|/* 	 * Setup flowid / RSS information for outbound socket. 	 * 	 * Once the UDP code decides to set a flowid some other way, 	 * this allows the flowid to be overridden by userland. 	 */
if|if
condition|(
name|flowtype
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|flowid
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|flowtype
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
block|}
else|else
block|{
name|uint32_t
name|hash_val
decl_stmt|,
name|hash_type
decl_stmt|;
comment|/* 		 * Calculate an appropriate RSS hash for UDP and 		 * UDP Lite. 		 * 		 * The called function will take care of figuring out 		 * whether a 2-tuple or 4-tuple hash is required based 		 * on the currently configured scheme. 		 * 		 * Later later on connected socket values should be 		 * cached in the inpcb and reused, rather than constantly 		 * re-calculating it. 		 * 		 * UDP Lite is a different protocol number and will 		 * likely end up being hashed as a 2-tuple until 		 * RSS / NICs grow UDP Lite protocol awareness. 		 */
if|if
condition|(
name|rss_proto_software_hash_v4
argument_list|(
name|faddr
argument_list|,
name|laddr
argument_list|,
name|fport
argument_list|,
name|lport
argument_list|,
name|pr
argument_list|,
operator|&
name|hash_val
argument_list|,
operator|&
name|hash_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|hash_val
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|hash_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|RSS
comment|/* 	 * Don't override with the inp cached flowid value. 	 * 	 * Depending upon the kind of send being done, the inp 	 * flowid/flowtype values may actually not be appropriate 	 * for this particular socket send. 	 * 	 * We should either leave the flowid at zero (which is what is 	 * currently done) or set it to some software generated 	 * hash value based on the packet contents. 	 */
name|ipflags
operator||=
name|IP_NODEFAULTFLOWID
expr_stmt|;
endif|#
directive|endif
comment|/* RSS */
if|if
condition|(
name|unlock_udbinfo
operator|==
name|UH_WLOCKED
condition|)
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlock_udbinfo
operator|==
name|UH_RLOCKED
condition|)
name|INP_HASH_RUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|UDP_PROBE
argument_list|(
name|send
argument_list|,
name|NULL
argument_list|,
name|inp
argument_list|,
operator|&
name|ui
operator|->
name|ui_i
argument_list|,
name|inp
argument_list|,
operator|&
name|ui
operator|->
name|ui_u
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
name|inp
operator|->
name|inp_options
argument_list|,
operator|(
name|unlock_inp
operator|==
name|UH_WLOCKED
condition|?
operator|&
name|inp
operator|->
name|inp_route
else|:
name|NULL
operator|)
argument_list|,
name|ipflags
argument_list|,
name|inp
operator|->
name|inp_moptions
argument_list|,
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock_inp
operator|==
name|UH_WLOCKED
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
else|else
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|release
label|:
if|if
condition|(
name|unlock_udbinfo
operator|==
name|UH_WLOCKED
condition|)
block|{
name|KASSERT
argument_list|(
name|unlock_inp
operator|==
name|UH_WLOCKED
argument_list|,
operator|(
literal|"%s: excl udbinfo lock, shared inp lock"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlock_udbinfo
operator|==
name|UH_RLOCKED
condition|)
block|{
name|KASSERT
argument_list|(
name|unlock_inp
operator|==
name|UH_RLOCKED
argument_list|,
operator|(
literal|"%s: shared udbinfo lock, excl inp lock"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|INP_HASH_RUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlock_inp
operator|==
name|UH_WLOCKED
condition|)
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
else|else
name|INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udp_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_abort: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|INP_HASH_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|in_pcbdisconnect
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|==
name|NULL
argument_list|,
operator|(
literal|"udp_attach: inp != NULL"
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|udp_sendspace
argument_list|,
name|udp_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|INP_INFO_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|in_pcballoc
argument_list|(
name|so
argument_list|,
name|pcbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|INP_INFO_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|inp
operator|->
name|inp_ip_ttl
operator|=
name|V_ip_defttl
expr_stmt|;
name|error
operator|=
name|udp_newudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|in_pcbdetach
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|in_pcbfree
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_function
name|int
name|udp_set_kernel_tunneling
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|udp_tun_func_t
name|f
parameter_list|,
name|udp_tun_icmp_t
name|i
parameter_list|,
name|void
modifier|*
name|ctx
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|KASSERT
argument_list|(
name|so
operator|->
name|so_type
operator|==
name|SOCK_DGRAM
argument_list|,
operator|(
literal|"udp_set_kernel_tunneling: !dgram"
operator|)
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_set_kernel_tunneling: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|up
operator|->
name|u_tun_func
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|up
operator|->
name|u_icmp_func
operator|!=
name|NULL
operator|)
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|up
operator|->
name|u_tun_func
operator|=
name|f
expr_stmt|;
name|up
operator|->
name|u_icmp_func
operator|=
name|i
expr_stmt|;
name|up
operator|->
name|u_tun_ctx
operator|=
name|ctx
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|int
name|udp_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_bind: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_HASH_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|in_pcbbind
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udp_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_close: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|INP_HASH_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|in_pcbdisconnect
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|soisdisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|nam
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|error
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_connect: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|!=
name|INADDR_ANY
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EISCONN
operator|)
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|nam
expr_stmt|;
name|error
operator|=
name|prison_remote_ip4
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|INP_HASH_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|error
operator|=
name|in_pcbconnect
argument_list|(
name|inp
argument_list|,
name|nam
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|udp_detach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|udpcb
modifier|*
name|up
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_detach: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
argument_list|,
operator|(
literal|"udp_detach: not disconnected"
operator|)
argument_list|)
expr_stmt|;
name|INP_INFO_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|up
operator|=
name|intoudpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|up
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: up == NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_ppcb
operator|=
name|NULL
expr_stmt|;
name|in_pcbdetach
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|in_pcbfree
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|INP_INFO_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|udp_discardcb
argument_list|(
name|up
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|pcbinfo
operator|=
name|udp_get_inpcbinfo
argument_list|(
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
argument_list|)
expr_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_disconnect: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|INP_HASH_WLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|in_pcbdisconnect
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_laddr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|INP_HASH_WUNLOCK
argument_list|(
name|pcbinfo
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_state
operator|&=
operator|~
name|SS_ISCONNECTED
expr_stmt|;
comment|/* XXX */
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|udp_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_send: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|udp_output
argument_list|(
name|inp
argument_list|,
name|m
argument_list|,
name|addr
argument_list|,
name|control
argument_list|,
name|td
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_function
name|int
name|udp_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
name|sotoinpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|inp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"udp_shutdown: inp == NULL"
operator|)
argument_list|)
expr_stmt|;
name|INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_decl_stmt
name|struct
name|pr_usrreqs
name|udp_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|udp_abort
block|,
operator|.
name|pru_attach
operator|=
name|udp_attach
block|,
operator|.
name|pru_bind
operator|=
name|udp_bind
block|,
operator|.
name|pru_connect
operator|=
name|udp_connect
block|,
operator|.
name|pru_control
operator|=
name|in_control
block|,
operator|.
name|pru_detach
operator|=
name|udp_detach
block|,
operator|.
name|pru_disconnect
operator|=
name|udp_disconnect
block|,
operator|.
name|pru_peeraddr
operator|=
name|in_getpeeraddr
block|,
operator|.
name|pru_send
operator|=
name|udp_send
block|,
operator|.
name|pru_soreceive
operator|=
name|soreceive_dgram
block|,
operator|.
name|pru_sosend
operator|=
name|sosend_dgram
block|,
operator|.
name|pru_shutdown
operator|=
name|udp_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|in_getsockaddr
block|,
operator|.
name|pru_sosetlabel
operator|=
name|in_pcbsosetlabel
block|,
operator|.
name|pru_close
operator|=
name|udp_close
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

end_unit

