begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*      $NetBSD: if_atm.c,v 1.6 1996/10/13 02:03:01 christos Exp $       */
end_comment

begin_comment
comment|/*  *  * Copyright (c) 1996 Charles D. Cranor and Washington University.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by Charles D. Cranor and   *	Washington University.  * 4. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * IP<=> ATM address resolution.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_natm.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_atm.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NATM
end_ifdef

begin_include
include|#
directive|include
file|<netnatm/natm.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SDL
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_dl *)s)
end_define

begin_comment
comment|/*  * atm_rtrequest: handle ATM rt request (in support of generic code)  *   inputs: "req" = request code  *           "rt" = route entry  *           "sa" = sockaddr  */
end_comment

begin_function
name|void
name|atm_rtrequest
parameter_list|(
name|req
parameter_list|,
name|rt
parameter_list|,
name|sa
parameter_list|)
name|int
name|req
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr
modifier|*
name|gate
init|=
name|rt
operator|->
name|rt_gateway
decl_stmt|;
name|struct
name|atm_pseudoioctl
name|api
decl_stmt|;
ifdef|#
directive|ifdef
name|NATM
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|natmpcb
modifier|*
name|npcb
init|=
name|NULL
decl_stmt|;
name|struct
name|atm_pseudohdr
modifier|*
name|aph
decl_stmt|;
endif|#
directive|endif
specifier|static
name|struct
name|sockaddr_dl
name|null_sdl
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
comment|/* link level requests only */
return|return;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_RESOLVE
case|:
comment|/* resolve: only happens when cloning */
name|printf
argument_list|(
literal|"atm_rtrequest: RTM_RESOLVE request detected?\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|RTM_ADD
case|:
comment|/* 		 * route added by a command (e.g. ifconfig, route, arp...). 		 * 		 * first check to see if this is not a host route, in which 		 * case we are being called via "ifconfig" to set the address. 		 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_HOST
operator|)
operator|==
literal|0
condition|)
block|{
name|rt_setgate
argument_list|(
name|rt
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|null_sdl
argument_list|)
expr_stmt|;
name|gate
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_index
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atm_rtrequest: cloning route detected?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|gate
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|||
name|gate
operator|->
name|sa_len
operator|<
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"atm_rtrequest: bad gateway value"
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_ioctl
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"atm null ioctl"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NATM
comment|/* 		 * let native ATM know we are using this VCI/VPI 		 * (i.e. reserve it) 		 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
goto|goto
name|failed
goto|;
name|aph
operator|=
operator|(
expr|struct
name|atm_pseudohdr
operator|*
operator|)
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
expr_stmt|;
name|npcb
operator|=
name|npcb_add
argument_list|(
name|NULL
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|,
name|ATM_PH_VCI
argument_list|(
name|aph
argument_list|)
argument_list|,
name|ATM_PH_VPI
argument_list|(
name|aph
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|npcb
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|npcb
operator|->
name|npcb_flags
operator||=
name|NPCB_IP
expr_stmt|;
name|npcb
operator|->
name|ipaddr
operator|.
name|s_addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* XXX: move npcb to llinfo when ATM ARP is ready */
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|npcb
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_LLINFO
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * let the lower level know this circuit is active 		 */
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
argument_list|,
operator|&
name|api
operator|.
name|aph
argument_list|,
sizeof|sizeof
argument_list|(
name|api
operator|.
name|aph
argument_list|)
argument_list|)
expr_stmt|;
name|api
operator|.
name|rxhand
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|->
name|if_ioctl
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
name|SIOCATMENA
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|api
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"atm: couldn't add VC\n"
argument_list|)
expr_stmt|;
goto|goto
name|failed
goto|;
block|}
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|rt
operator|->
name|rt_ifp
operator|->
name|if_index
expr_stmt|;
break|break;
name|failed
label|:
ifdef|#
directive|ifdef
name|NATM
if|if
condition|(
name|npcb
condition|)
block|{
name|npcb_free
argument_list|(
name|npcb
argument_list|,
name|NPCB_DESTROY
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
name|NULL
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
block|}
endif|#
directive|endif
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RTM_DELETE
case|:
ifdef|#
directive|ifdef
name|NATM
comment|/* 		 * tell native ATM we are done with this VC 		 */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
condition|)
block|{
name|npcb_free
argument_list|(
operator|(
expr|struct
name|natmpcb
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
argument_list|,
name|NPCB_DESTROY
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
name|NULL
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * tell the lower layer to disable this circuit 		 */
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
argument_list|,
operator|&
name|api
operator|.
name|aph
argument_list|,
sizeof|sizeof
argument_list|(
name|api
operator|.
name|aph
argument_list|)
argument_list|)
expr_stmt|;
name|api
operator|.
name|rxhand
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|rt
operator|->
name|rt_ifp
operator|->
name|if_ioctl
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
name|SIOCATMDIS
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|api
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * atmresolve:  *   inputs:  *     [1] "rt" = the link level route to use (or null if need to look one up)  *     [2] "m" = mbuf containing the data to be sent  *     [3] "dst" = sockaddr_in (IP) address of dest.  *   output:  *     [4] "desten" = ATM pseudo header which we will fill in VPI/VCI info  *   return:   *     0 == resolve FAILED; note that "m" gets m_freem'd in this case  *     1 == resolve OK; desten contains result  *  *   XXX: will need more work if we wish to support ATMARP in the kernel,  *   but this is enough for PVCs entered via the "route" command.  */
end_comment

begin_function
name|int
name|atmresolve
parameter_list|(
name|rt
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|desten
parameter_list|)
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
specifier|register
name|struct
name|atm_pseudohdr
modifier|*
name|desten
decl_stmt|;
comment|/* OUT */
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
condition|)
block|{
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"atmresolve: BCAST/MCAST packet detected/dumped"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|rt
operator|=
name|RTALLOC1
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* failed */
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
comment|/* don't keep LL references */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|!=
literal|0
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
operator|||
comment|/* XXX: are we using LLINFO? */
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * note that rt_gateway is a sockaddr_dl which contains the  	 * atm_pseudohdr data structure for this route.   we currently 	 * don't need any rt_llinfo info (but will if we want to support 	 * ATM ARP [c.f. if_ether.c]). 	 */
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
comment|/* 	 * Check the address family and length is valid, the address 	 * is resolved; otherwise, try to resolve. 	 */
if|if
condition|(
name|sdl
operator|->
name|sdl_family
operator|==
name|AF_LINK
operator|&&
name|sdl
operator|->
name|sdl_alen
operator|==
sizeof|sizeof
argument_list|(
operator|*
name|desten
argument_list|)
condition|)
block|{
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|desten
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* ok, go for it! */
block|}
comment|/* 	 * we got an entry, but it doesn't have valid link address 	 * info in it (it is prob. the interface route, which has 	 * sdl_alen == 0).    dump packet.  (fall through to "bad"). 	 */
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

end_unit

