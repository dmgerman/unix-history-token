begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_IP_VHL
end_define

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_audit_retranmission_queue
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Audit invoked on send queue cnt:%d onqueue:%d\n"
argument_list|,
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|,
name|asoc
operator|->
name|sent_queue_cnt
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sent_queue_cnt
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->asconf_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Audit completes retran:%d onqueue:%d\n"
argument_list|,
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|,
name|asoc
operator|->
name|sent_queue_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_threshold_management
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint16_t
name|threshold
parameter_list|)
block|{
if|if
condition|(
name|net
condition|)
block|{
name|net
operator|->
name|error_count
operator|++
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Error count for %p now %d thresh:%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|net
operator|->
name|error_count
argument_list|,
name|net
operator|->
name|failure_threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|error_count
operator|>
name|net
operator|->
name|failure_threshold
condition|)
block|{
comment|/* We had a threshold failure */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REQ_PRIMARY
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|net
operator|->
name|pf_threshold
operator|<
name|net
operator|->
name|failure_threshold
operator|)
operator|&&
operator|(
name|net
operator|->
name|error_count
operator|>
name|net
operator|->
name|pf_threshold
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_PF
expr_stmt|;
name|net
operator|->
name|last_active
operator|=
name|sctp_get_tick_count
argument_list|()
expr_stmt|;
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_INCR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|+
literal|1
operator|)
argument_list|,
name|SCTP_FROM_SCTP_TIMER
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_INCR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|+
literal|1
operator|)
argument_list|,
name|SCTP_FROM_SCTP_TIMER
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|++
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Overall error count for %p now %d thresh:%u state:%x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
operator|(
name|uint32_t
operator|)
name|threshold
argument_list|,
operator|(
operator|(
name|net
operator|==
name|NULL
operator|)
condition|?
operator|(
name|uint32_t
operator|)
literal|0
else|:
operator|(
name|uint32_t
operator|)
name|net
operator|->
name|dest_state
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We specifically do not do>= to give the assoc one more change 	 * before we fail it. 	 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|>
name|threshold
condition|)
block|{
comment|/* Abort notification sends a ULP notify */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Association error counter exceeded"
argument_list|)
expr_stmt|;
name|inp
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_2
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sctp_find_alternate_net() returns a non-NULL pointer as long  * the argument net is non-NULL.  */
end_comment

begin_function
name|struct
name|sctp_nets
modifier|*
name|sctp_find_alternate_net
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* Find and return an alternate network if possible */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|,
modifier|*
name|mnet
decl_stmt|,
modifier|*
name|min_errors_net
init|=
name|NULL
decl_stmt|,
modifier|*
name|max_cwnd_net
init|=
name|NULL
decl_stmt|;
name|int
name|once
decl_stmt|;
comment|/* JRS 5/14/07 - Initialize min_errors to an impossible value. */
name|int
name|min_errors
init|=
operator|-
literal|1
decl_stmt|;
name|uint32_t
name|max_cwnd
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|==
literal|1
condition|)
block|{
comment|/* No others but net */
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * JRS 5/14/07 - If mode is set to 2, use the CMT PF find alternate 	 * net algorithm. This algorithm chooses the active destination (not 	 * in PF state) with the largest cwnd value. If all destinations are 	 * in PF state, unreachable, or unconfirmed, choose the desination 	 * that is in PF state with the lowest error count. In case of a 	 * tie, choose the destination that was most recently active. 	 */
if|if
condition|(
name|mode
operator|==
literal|2
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|mnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 			 * JRS 5/14/07 - If the destination is unreachable 			 * or unconfirmed, skip it. 			 */
if|if
condition|(
operator|(
operator|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|!=
name|SCTP_ADDR_REACHABLE
operator|)
operator|||
operator|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* 			 * JRS 5/14/07 -  If the destination is reachable 			 * but in PF state, compare the error count of the 			 * destination to the minimum error count seen thus 			 * far. Store the destination with the lower error 			 * count.  If the error counts are equal, store the 			 * destination that was most recently active. 			 */
if|if
condition|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
comment|/* 				 * JRS 5/14/07 - If the destination under 				 * consideration is the current destination, 				 * work as if the error count is one higher. 				 * The actual error count will not be 				 * incremented until later in the t3 				 * handler. 				 */
if|if
condition|(
name|mnet
operator|==
name|net
condition|)
block|{
if|if
condition|(
name|min_errors
operator|==
operator|-
literal|1
condition|)
block|{
name|min_errors
operator|=
name|mnet
operator|->
name|error_count
operator|+
literal|1
expr_stmt|;
name|min_errors_net
operator|=
name|mnet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mnet
operator|->
name|error_count
operator|+
literal|1
operator|<
name|min_errors
condition|)
block|{
name|min_errors
operator|=
name|mnet
operator|->
name|error_count
operator|+
literal|1
expr_stmt|;
name|min_errors_net
operator|=
name|mnet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mnet
operator|->
name|error_count
operator|+
literal|1
operator|==
name|min_errors
operator|&&
name|mnet
operator|->
name|last_active
operator|>
name|min_errors_net
operator|->
name|last_active
condition|)
block|{
name|min_errors_net
operator|=
name|mnet
expr_stmt|;
name|min_errors
operator|=
name|mnet
operator|->
name|error_count
operator|+
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|min_errors
operator|==
operator|-
literal|1
condition|)
block|{
name|min_errors
operator|=
name|mnet
operator|->
name|error_count
expr_stmt|;
name|min_errors_net
operator|=
name|mnet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mnet
operator|->
name|error_count
operator|<
name|min_errors
condition|)
block|{
name|min_errors
operator|=
name|mnet
operator|->
name|error_count
expr_stmt|;
name|min_errors_net
operator|=
name|mnet
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mnet
operator|->
name|error_count
operator|==
name|min_errors
operator|&&
name|mnet
operator|->
name|last_active
operator|>
name|min_errors_net
operator|->
name|last_active
condition|)
block|{
name|min_errors_net
operator|=
name|mnet
expr_stmt|;
name|min_errors
operator|=
name|mnet
operator|->
name|error_count
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|/* 			 * JRS 5/14/07 - If the destination is reachable and 			 * not in PF state, compare the cwnd of the 			 * destination to the highest cwnd seen thus far. 			 * Store the destination with the higher cwnd value. 			 * If the cwnd values are equal, randomly choose one 			 * of the two destinations. 			 */
if|if
condition|(
name|max_cwnd
operator|<
name|mnet
operator|->
name|cwnd
condition|)
block|{
name|max_cwnd_net
operator|=
name|mnet
expr_stmt|;
name|max_cwnd
operator|=
name|mnet
operator|->
name|cwnd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max_cwnd
operator|==
name|mnet
operator|->
name|cwnd
condition|)
block|{
name|uint32_t
name|rndval
decl_stmt|;
name|uint8_t
name|this_random
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|>
literal|3
condition|)
block|{
name|rndval
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|,
operator|&
name|rndval
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|)
argument_list|)
expr_stmt|;
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this_random
operator|%
literal|2
operator|==
literal|1
condition|)
block|{
name|max_cwnd_net
operator|=
name|mnet
expr_stmt|;
name|max_cwnd
operator|=
name|mnet
operator|->
name|cwnd
expr_stmt|;
comment|/* Useless? */
block|}
block|}
block|}
if|if
condition|(
name|max_cwnd_net
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|min_errors_net
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|net
operator|)
return|;
block|}
return|return
operator|(
name|min_errors_net
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|max_cwnd_net
operator|)
return|;
block|}
block|}
comment|/* JRS 5/14/07 - If mode is set to 1, use the 				 * CMT policy for choosing an alternate net. */
elseif|else
if|if
condition|(
name|mode
operator|==
literal|1
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|mnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|!=
name|SCTP_ADDR_REACHABLE
operator|)
operator|||
operator|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
condition|)
block|{
comment|/* 				 * will skip ones that are not-reachable or 				 * unconfirmed 				 */
continue|continue;
block|}
if|if
condition|(
name|max_cwnd
operator|<
name|mnet
operator|->
name|cwnd
condition|)
block|{
name|max_cwnd_net
operator|=
name|mnet
expr_stmt|;
name|max_cwnd
operator|=
name|mnet
operator|->
name|cwnd
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|max_cwnd
operator|==
name|mnet
operator|->
name|cwnd
condition|)
block|{
name|uint32_t
name|rndval
decl_stmt|;
name|uint8_t
name|this_random
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|>
literal|3
condition|)
block|{
name|rndval
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|,
operator|&
name|rndval
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|)
argument_list|)
expr_stmt|;
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this_random
operator|%
literal|2
condition|)
block|{
name|max_cwnd_net
operator|=
name|mnet
expr_stmt|;
name|max_cwnd
operator|=
name|mnet
operator|->
name|cwnd
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|max_cwnd_net
condition|)
block|{
return|return
operator|(
name|max_cwnd_net
operator|)
return|;
block|}
block|}
name|mnet
operator|=
name|net
expr_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mnet
operator|==
name|NULL
condition|)
block|{
name|mnet
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|mnet
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|alt
operator|=
name|TAILQ_NEXT
argument_list|(
name|mnet
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
name|once
operator|++
expr_stmt|;
if|if
condition|(
name|once
operator|>
literal|1
condition|)
block|{
break|break;
block|}
name|alt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|alt
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|alt
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|alt
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|alt
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|alt
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|alt
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_REACHABLE
operator|)
operator|&&
operator|(
name|alt
operator|->
name|ro
operator|.
name|ro_rt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
operator|(
name|alt
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
condition|)
block|{
comment|/* Found a reachable address */
break|break;
block|}
name|mnet
operator|=
name|alt
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
comment|/* Case where NO insv network exists (dormant state) */
comment|/* we rotate destinations */
name|once
operator|=
literal|0
expr_stmt|;
name|mnet
operator|=
name|net
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|mnet
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
operator|)
return|;
block|}
name|alt
operator|=
name|TAILQ_NEXT
argument_list|(
name|mnet
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
name|once
operator|++
expr_stmt|;
if|if
condition|(
name|once
operator|>
literal|1
condition|)
block|{
break|break;
block|}
name|alt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|alt
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
operator|&&
operator|(
name|alt
operator|!=
name|net
operator|)
condition|)
block|{
comment|/* Found an alternate address */
break|break;
block|}
name|mnet
operator|=
name|alt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|net
operator|)
return|;
block|}
return|return
operator|(
name|alt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_backoff_on_timeout
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|win_probe
parameter_list|,
name|int
name|num_marked
parameter_list|,
name|int
name|num_abandoned
parameter_list|)
block|{
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|RTO_measured
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
block|}
block|}
name|net
operator|->
name|RTO
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|win_probe
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_marked
operator|||
name|num_abandoned
operator|)
condition|)
block|{
comment|/* We don't apply penalty to window probe scenarios */
comment|/* JRS - Use the congestion control given in the CC module */
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_after_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|INVARIANTS
end_ifndef

begin_function
specifier|static
name|void
name|sctp_recover_sent_list
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Found chk:%p tsn:%x<= last_acked_seq:%x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chk
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|asoc
operator|->
name|last_acked_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|state
operator|==
name|SCTP_STREAM_RESET_PENDING
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|trigger_reset
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|PR_SCTP_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|!=
literal|0
condition|)
name|asoc
operator|->
name|pr_sctp_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|prsctp_supported
operator|&&
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_PRINTF
argument_list|(
literal|"after recover order is as follows\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"chk:%p TSN:%x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|chk
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sctp_mark_all_for_resend
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|alt
parameter_list|,
name|int
name|window_probe
parameter_list|,
name|int
modifier|*
name|num_marked
parameter_list|,
name|int
modifier|*
name|num_abandoned
parameter_list|)
block|{
comment|/* 	 * Mark all chunks (well not all) that were sent to *net for 	 * retransmission. Move them to alt for there destination as well... 	 * We only mark chunks that have been outstanding long enough to 	 * have received feed-back. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnets
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|min_wait
decl_stmt|,
name|tv
decl_stmt|;
name|int
name|cur_rto
decl_stmt|;
name|int
name|cnt_abandoned
decl_stmt|;
name|int
name|audit_tf
decl_stmt|,
name|num_mk
decl_stmt|,
name|fir
decl_stmt|;
name|unsigned
name|int
name|cnt_mk
decl_stmt|;
name|uint32_t
name|orig_flight
decl_stmt|,
name|orig_tf
decl_stmt|;
name|uint32_t
name|tsnlast
decl_stmt|,
name|tsnfirst
decl_stmt|;
name|int
name|recovery_cnt
init|=
literal|0
decl_stmt|;
comment|/* none in flight now */
name|audit_tf
operator|=
literal|0
expr_stmt|;
name|fir
operator|=
literal|0
expr_stmt|;
comment|/* 	 * figure out how long a data chunk must be pending before we can 	 * mark it .. 	 */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* get cur rto in micro-seconds */
name|cur_rto
operator|=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
operator|+
name|net
operator|->
name|lastsv
expr_stmt|;
name|cur_rto
operator|*=
literal|1000
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|cur_rto
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|window_probe
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
name|sctp_log_fr
argument_list|(
name|net
operator|->
name|flight_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_CWND_REPORT
argument_list|)
expr_stmt|;
name|sctp_log_fr
argument_list|(
name|net
operator|->
name|flight_size
argument_list|,
name|net
operator|->
name|cwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|SCTP_FR_CWND_REPORT
argument_list|)
expr_stmt|;
block|}
name|tv
operator|.
name|tv_sec
operator|=
name|cur_rto
operator|/
literal|1000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|cur_rto
operator|%
literal|1000000
expr_stmt|;
name|min_wait
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|min_wait
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_wait
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|min_wait
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
comment|/* 		 * if we hit here, we don't have enough seconds on the clock 		 * to account for the RTO. We just let the lower seconds be 		 * the bounds and don't worry about it. This may mean we 		 * will mark a lot more than we should. 		 */
name|min_wait
operator|.
name|tv_sec
operator|=
name|min_wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|cur_rto
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
name|min_wait
operator|.
name|tv_sec
argument_list|,
name|min_wait
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Our rwnd will be incorrect here since we are not adding back the 	 * cnt * mbuf but we will fix that down below. 	 */
name|orig_flight
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
name|orig_tf
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
name|net
operator|->
name|fast_retran_ip
operator|=
literal|0
expr_stmt|;
comment|/* Now on to each chunk */
name|cnt_abandoned
operator|=
literal|0
expr_stmt|;
name|num_mk
operator|=
name|cnt_mk
operator|=
literal|0
expr_stmt|;
name|tsnfirst
operator|=
name|tsnlast
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|INVARIANTS
name|start_again
label|:
endif|#
directive|endif
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
comment|/* Strange case our list got out of order? */
name|SCTP_PRINTF
argument_list|(
literal|"Our list is out of order? last_acked:%x chk:%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|recovery_cnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"last acked>= chk on sent-Q"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Recover attempts a restart cnt:%d\n"
argument_list|,
name|recovery_cnt
argument_list|)
expr_stmt|;
name|sctp_recover_sent_list
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|recovery_cnt
operator|<
literal|10
condition|)
block|{
goto|goto
name|start_again
goto|;
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Recovery fails %d times??\n"
argument_list|,
name|recovery_cnt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
operator|)
condition|)
block|{
comment|/* 			 * found one to mark: If it is less than 			 * DATAGRAM_ACKED it MUST not be a skipped or marked 			 * TSN but instead one that is either already set 			 * for retransmission OR one that needs 			 * retransmission. 			 */
comment|/* validate its been outstanding long enough */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|>
name|min_wait
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|window_probe
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * we have reached a chunk that was sent 				 * some seconds past our min.. forget it we 				 * will find no more to send. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_STOPPED
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|==
name|min_wait
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|window_probe
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * we must look at the micro seconds to 				 * know. 				 */
if|if
condition|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
operator|>=
name|min_wait
operator|.
name|tv_usec
condition|)
block|{
comment|/* 					 * ok it was sent after our boundary 					 * time. 					 */
continue|continue;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|&&
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* Is it expired? */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|cnt_abandoned
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|&&
name|PR_SCTP_RTX_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* Has it been retransmitted tv_sec times? */
if|if
condition|(
name|chk
operator|->
name|snd_count
operator|>
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|cnt_abandoned
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|num_mk
operator|++
expr_stmt|;
if|if
condition|(
name|fir
operator|==
literal|0
condition|)
block|{
name|fir
operator|=
literal|1
expr_stmt|;
name|tsnfirst
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
name|tsnlast
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_T3_MARKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|chk
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|chk
operator|->
name|book_size
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|net
operator|->
name|marked_retrans
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|marked_retrans
operator|++
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_RSND_TO
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|chk
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|chk
operator|->
name|whoTo
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_markedretrans
argument_list|)
expr_stmt|;
comment|/* reset the TSN for striking and other FR stuff */
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
comment|/* Clear any time so NO RTT is being done */
if|if
condition|(
name|chk
operator|->
name|do_rtt
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|->
name|rto_needed
operator|==
literal|0
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|chk
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
condition|)
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
block|}
comment|/* 			 * CMT: Do not allow FRs on retransmitted TSNs. 			 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|>
literal|0
condition|)
block|{
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|THIS_SHOULD_NOT_BE_DONE
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* remember highest acked one */
name|could_be_sent
operator|=
name|chk
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|cnt_mk
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|orig_flight
operator|-
name|net
operator|->
name|flight_size
operator|)
operator|!=
operator|(
name|orig_tf
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
condition|)
block|{
comment|/* we did not subtract the same things? */
name|audit_tf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|tsnfirst
argument_list|,
name|tsnlast
argument_list|,
name|num_mk
argument_list|,
name|SCTP_FR_T3_TIMEOUT
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|num_mk
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"LAST TSN marked was %x\n"
argument_list|,
name|tsnlast
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Num marked for retransmission was %d peer-rwd:%u\n"
argument_list|,
name|num_mk
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|num_marked
operator|=
name|num_mk
expr_stmt|;
operator|*
name|num_abandoned
operator|=
name|cnt_abandoned
expr_stmt|;
comment|/* 	 * Now check for a ECN Echo that may be stranded And include the 	 * cnt_mk'd to have all resends in the control queue. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|cnt_mk
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|cnt_mk
operator|++
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|THIS_SHOULD_NOT_BE_DONE
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|could_be_sent
operator|)
condition|)
block|{
comment|/* fix it so we retransmit the highest acked anyway */
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|cnt_mk
operator|++
expr_stmt|;
name|could_be_sent
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|!=
name|cnt_mk
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|SCTP_PRINTF
argument_list|(
literal|"Local Audit says there are %d for retran asoc cnt:%d we marked:%d this time\n"
argument_list|,
name|cnt_mk
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|,
name|num_mk
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SCTP_AUDITING_ENABLED
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
name|cnt_mk
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|audit_tf
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Audit total flight due to negative value net:%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|=
literal|0
expr_stmt|;
comment|/* Clear all networks flight size */
name|TAILQ_FOREACH
argument_list|(
argument|lnets
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|lnets
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Net:%p c-f cwnd:%d ssthresh:%d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|lnets
argument_list|,
name|lnets
operator|->
name|cwnd
argument_list|,
name|lnets
operator|->
name|ssthresh
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|chk
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|chk
operator|->
name|whoTo
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* We return 1 if we only have a window probe outstanding */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_t3rxt_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|int
name|win_probe
decl_stmt|,
name|num_mk
decl_stmt|,
name|num_abandoned
decl_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_T3_TIMEOUT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|==
name|lnet
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|1
argument_list|,
name|SCTP_CWND_LOG_FROM_T3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FROM_T3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Find an alternate and mark those for retransmission */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|<
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timowindowprobe
argument_list|)
expr_stmt|;
name|win_probe
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|win_probe
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|win_probe
operator|==
literal|0
condition|)
block|{
comment|/* We don't do normal threshold management on window probes */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Association was destroyed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* send a immediate HB if our RTO is stale */
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|int
name|ms_goneby
decl_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
condition|)
block|{
name|ms_goneby
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|ms_goneby
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ms_goneby
operator|>
name|net
operator|->
name|RTO
operator|)
operator|||
operator|(
name|net
operator|->
name|RTO
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 						 * no recent feed back in an 						 * RTO or more, request a 						 * RTT update 						 */
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * For a window probe we don't penalize the net's but only 		 * the association. This may fail it if SACKs are not coming 		 * back. If sack's are coming with rwnd locked at 0, we will 		 * continue to hold things waiting for rwnd to raise 		 */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Association was destroyed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|pf_threshold
operator|<
name|net
operator|->
name|failure_threshold
condition|)
block|{
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * CMT: Using RTX_SSTHRESH policy for CMT. If CMT is 			 * being used, then pick dest with largest ssthresh 			 * for any retransmission. 			 */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * CUCv2: If a different dest is picked for the 			 * retransmission, then new (rtx-)pseudo_cumack 			 * needs to be tracked for orig dest. Let CUCv2 			 * track new (rtx-) pseudo-cumack always. 			 */
name|net
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|num_mk
operator|=
literal|0
expr_stmt|;
name|num_abandoned
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_mark_all_for_resend
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|alt
argument_list|,
name|win_probe
argument_list|,
operator|&
name|num_mk
argument_list|,
operator|&
name|num_abandoned
argument_list|)
expr_stmt|;
comment|/* FR Loss recovery just ended with the T3. */
name|stcb
operator|->
name|asoc
operator|.
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
comment|/* CMT FR loss recovery ended with the T3 */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_new_transmission_begins
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|==
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_new_transmission_begins
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * setup the sat loss recovery that prevents satellite cwnd advance. 	 */
name|stcb
operator|->
name|asoc
operator|.
name|sat_t3_loss_recovery
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sat_t3_recovery_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
comment|/* Backoff the timer and cwnd */
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|win_probe
argument_list|,
name|num_mk
argument_list|,
name|num_abandoned
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|)
operator|||
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
comment|/* Move all pending over too */
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 		 * Get the address that failed, to force a new src address 		 * selecton and a route allocation. 		 */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
comment|/* Force a route allocation too */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Was it our primary? */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|==
name|net
operator|)
operator|&&
operator|(
name|alt
operator|!=
name|net
operator|)
condition|)
block|{
comment|/* 			 * Yes, note it as such and find an alternate note: 			 * this means HB code must use this to resent the 			 * primary if it goes active AND if someone does a 			 * change-primary then this flag must be cleared 			 * from any net structures. 			 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Special case for cookie-echo'ed case, we don't do output but must 	 * await the COOKIE-ACK before retransmission 	 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* 		 * Here we just reset the timer and start again since we 		 * have not established the asoc 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|advanced_peer_ack_point
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|)
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_MONITOR_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
argument_list|,
name|SCTP_CWND_LOG_FROM_RTX
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_t1init_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* bump the thresholds */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
condition|)
block|{
comment|/* 		 * special hook for delayed connection. The library did NOT 		 * complete the rest of its sends. 		 */
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|=
literal|0
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|(
operator|&
name|stcb
operator|->
name|asoc
operator|)
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_init_times
argument_list|)
condition|)
block|{
comment|/* Association was destroyed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|=
literal|0
expr_stmt|;
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_init_rto_max
operator|<
name|net
operator|->
name|RTO
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_init_rto_max
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|>
literal|1
condition|)
block|{
comment|/* If we have more than one addr use it */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|alt
expr_stmt|;
block|}
block|}
comment|/* Send out a new init */
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For cookie and asconf we actually need to find and mark for resend, then  * increment the resend counter (after all the threshold management stuff of  * course).  */
end_comment

begin_function
name|int
name|sctp_cookie_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|cookie
decl_stmt|;
comment|/* first before all else we must find the cookie */
name|TAILQ_FOREACH
argument_list|(
argument|cookie
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|cookie
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cookie
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* FOOBAR! */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Cookie timer expired, but no cookie"
argument_list|)
expr_stmt|;
name|inp
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_3
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Cookie timer expires in wrong state?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Strange in state %d not cookie-echoed yet c-e timer expires?\n"
argument_list|,
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Ok we found the cookie, threshold management next */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|cookie
operator|->
name|whoTo
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_init_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Cleared threshold management, now lets backoff the address and 	 * select an alternate 	 */
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|=
literal|0
expr_stmt|;
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|cookie
operator|->
name|whoTo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|cookie
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|cookie
operator|->
name|whoTo
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|cookie
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|cookie
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now mark the retran info */
if|if
condition|(
name|cookie
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|cookie
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|cookie
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
comment|/* 	 * Now call the output routine to kick out the cookie again, Note we 	 * don't mark any chunks for retran so that FR will need to kick in 	 * to move these (or a send timer). 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_strreset_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|strrst
init|=
name|NULL
decl_stmt|,
modifier|*
name|chk
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* find the existing STRRESET, we use the seq number we sent out on */
operator|(
name|void
operator|)
name|sctp_find_stream_reset
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
argument_list|,
operator|&
name|strrst
argument_list|)
expr_stmt|;
if|if
condition|(
name|strrst
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* do threshold management */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Cleared threshold management, now lets backoff the address and 	 * select an alternate 	 */
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|strrst
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|strrst
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* See if a ECN Echo is also stranded */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
comment|/* 		 * If the address went un-reachable, we need to move to 		 * alternates for ALL chk's in queue 		 */
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* mark the retran info */
if|if
condition|(
name|strrst
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|strrst
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|strrst
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
comment|/* restart the timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_asconf_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|asconf
decl_stmt|,
modifier|*
name|chk
decl_stmt|;
comment|/* is this a first send, or a retransmission? */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_send_queue
argument_list|)
condition|)
block|{
comment|/* compose a new ASCONF chunk and send it */
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Retransmission of the existing ASCONF is needed 		 */
comment|/* find the existing ASCONF */
name|asconf
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|asconf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* do threshold management */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asconf
operator|->
name|whoTo
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|asconf
operator|->
name|snd_count
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
condition|)
block|{
comment|/* 			 * Something is rotten: our peer is not responding 			 * to ASCONFs but apparently is to other chunks. 			 * i.e. it is not properly handling the chunk type 			 * upper bits. Mark this peer as ASCONF incapable 			 * and cleanup. 			 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"asconf_timer: Peer has not responded to our repeated ASCONFs\n"
argument_list|)
expr_stmt|;
name|sctp_asconf_cleanup
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * cleared threshold management, so now backoff the net and 		 * select an alternate 		 */
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|asconf
operator|->
name|whoTo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|asconf
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|asconf
operator|->
name|whoTo
operator|!=
name|alt
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|asconf
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|asconf
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* See if an ECN Echo is also stranded */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.asconf_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|alt
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asconf
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
operator|&&
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
comment|/* 			 * If the address went un-reachable, we need to move 			 * to the alternate for ALL chunks in queue 			 */
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* mark the retran info */
if|if
condition|(
name|asconf
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|asconf
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|asconf
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
comment|/* send another ASCONF if any and we can do */
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Mobility adaptation */
end_comment

begin_function
name|void
name|sctp_delete_prim_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
name|SCTP_UNUSED
parameter_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"delete_prim_timer: deleted_primary is not stored...\n"
argument_list|)
expr_stmt|;
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"delete_prim_timer: finished to keep deleted primary "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
operator|=
name|NULL
expr_stmt|;
name|sctp_mobility_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * For the shutdown and shutdown-ack, we do not keep one around on the  * control queue. This means we must generate a new one and call the general  * chunk output routine, AFTER having done threshold management.  * It is assumed that net is non-NULL.  */
end_comment

begin_function
name|int
name|sctp_shutdown_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* first threshold management */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* second select an alternative */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* third generate a shutdown into the queue for out net */
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
comment|/* fourth restart timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_shutdownack_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* first threshold management */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* second select an alternative */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* third generate a shutdown into the queue for out net */
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
comment|/* fourth restart timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_audit_stream_queues_for_size
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|chks_in_queue
init|=
literal|0
decl_stmt|;
name|int
name|being_filled
init|=
literal|0
decl_stmt|;
comment|/* 	 * This function is ONLY called when the send/sent queues are empty. 	 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
return|return;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Hmm, sent_queue_retran_cnt is non-zero %d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_is_empty
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
condition|)
block|{
comment|/* No stream scheduler information, initialize scheduler */
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_is_empty
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
condition|)
block|{
comment|/* yep, we lost a stream or two */
name|SCTP_PRINTF
argument_list|(
literal|"Found additional streams NOT managed by scheduler, corrected\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no streams lost */
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Check to see if some data queued, if so report it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&stcb->asoc.strmout[i].outqueue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
name|being_filled
operator|++
expr_stmt|;
name|chks_in_queue
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|chks_in_queue
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Hmm, stream queue cnt at %d I counted %d in stream out wheel\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
name|chks_in_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chks_in_queue
condition|)
block|{
comment|/* call the output queue function */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Probably should go in and make it go back through 			 * and add fragments allowed 			 */
if|if
condition|(
name|being_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Still nothing moved %d chunks are stuck\n"
argument_list|,
name|chks_in_queue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Found no chunks on any queue tot:%lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_heartbeat_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint8_t
name|net_was_pf
decl_stmt|;
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
name|net_was_pf
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|net_was_pf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|hb_responded
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
comment|/* 			 * Invalidate the src address if we did not get a 			 * response last time. 			 */
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Zero PBA, if it needs it */
if|if
condition|(
name|net
operator|->
name|partial_bytes_acked
condition|)
block|{
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
name|sctp_audit_stream_queues_for_size
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
operator|)
operator|&&
operator|!
operator|(
operator|(
name|net_was_pf
operator|==
literal|0
operator|)
operator|&&
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|)
condition|)
block|{
comment|/* 		 * when move to PF during threshold mangement, a HB has been 		 * queued in that routine 		 */
name|uint32_t
name|ms_gone_by
decl_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|>
literal|0
operator|)
operator|||
operator|(
name|net
operator|->
name|last_sent_time
operator|.
name|tv_usec
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|timeval
name|diff
decl_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|diff
argument_list|)
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|diff
argument_list|,
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
name|ms_gone_by
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|diff
operator|.
name|tv_sec
operator|*
literal|1000
argument_list|)
operator|+
call|(
name|uint32_t
call|)
argument_list|(
name|diff
operator|.
name|tv_usec
operator|/
literal|1000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ms_gone_by
operator|=
literal|0xffffffff
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ms_gone_by
operator|>=
name|net
operator|->
name|heart_beat_delay
operator|)
operator|||
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_pathmtu_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|next_mtu
decl_stmt|,
name|mtu
decl_stmt|;
name|next_mtu
operator|=
name|sctp_get_next_mtu
argument_list|(
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|next_mtu
operator|>
name|net
operator|->
name|mtu
operator|)
operator|&&
operator|(
name|net
operator|->
name|port
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
operator|)
operator|||
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
operator|)
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_EMBEDDED_V6_SCOPE
argument_list|)
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
decl_stmt|;
comment|/* KAME hack: embed scopeid */
operator|(
name|void
operator|)
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_EMBEDDED_V6_SCOPE
argument_list|)
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
decl_stmt|;
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
block|}
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|mtu
operator|=
name|SCTP_GATHER_MTU_FROM_ROUTE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|.
name|sa
argument_list|,
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|net
operator|->
name|port
condition|)
block|{
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|mtu
operator|>
name|next_mtu
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|next_mtu
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|mtu
operator|=
name|mtu
expr_stmt|;
block|}
block|}
block|}
comment|/* restart the timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_autoclose_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|timeval
name|tn
decl_stmt|,
modifier|*
name|tim_touse
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|ticks_gone_by
decl_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
comment|/* Auto close is on */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* pick the time to use */
if|if
condition|(
name|asoc
operator|->
name|time_last_rcvd
operator|.
name|tv_sec
operator|>
name|asoc
operator|->
name|time_last_sent
operator|.
name|tv_sec
condition|)
block|{
name|tim_touse
operator|=
operator|&
name|asoc
operator|->
name|time_last_rcvd
expr_stmt|;
block|}
else|else
block|{
name|tim_touse
operator|=
operator|&
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
block|}
comment|/* Now has long enough transpired to autoclose? */
name|ticks_gone_by
operator|=
name|SEC_TO_TICKS
argument_list|(
name|tn
operator|.
name|tv_sec
operator|-
name|tim_touse
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ticks_gone_by
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ticks_gone_by
operator|>=
operator|(
name|int
operator|)
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|)
condition|)
block|{
comment|/* 			 * autoclose time has hit, call the output routine, 			 * which should do nothing just to be SURE we don't 			 * have hanging data. We can then safely check the 			 * queues and know that we are clear to send 			 * shutdown 			 */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_AUTOCLOSE_TMR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* Are we clean? */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* 				 * there is nothing queued to send, so I'm 				 * done... 				 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* only send SHUTDOWN 1st time thru */
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * No auto close at this time, reset t-o to check 			 * later 			 */
name|int
name|tmp
decl_stmt|;
comment|/* fool the timer startup to use the time left */
name|tmp
operator|=
name|asoc
operator|->
name|sctp_autoclose_ticks
expr_stmt|;
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|-=
name|ticks_gone_by
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* restore the real tick value */
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

