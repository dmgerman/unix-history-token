begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_timer.c,v 1.29 2005/03/06 16:04:18 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_IP_VHL
end_define

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/sctp6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_function
name|void
name|sctp_early_fr_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|min_wait
decl_stmt|,
name|tv
decl_stmt|;
name|unsigned
name|int
name|cur_rtt
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|,
name|cnt_resend
init|=
literal|0
decl_stmt|;
comment|/* an early FR is occuring. */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* get cur rto in micro-seconds */
if|if
condition|(
name|net
operator|->
name|lastsa
operator|==
literal|0
condition|)
block|{
comment|/* Hmm no rtt estimate yet? */
name|cur_rtt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
operator|>>
literal|2
expr_stmt|;
block|}
else|else
block|{
name|cur_rtt
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cur_rtt
operator|<
name|sctp_early_fr_msec
condition|)
block|{
name|cur_rtt
operator|=
name|sctp_early_fr_msec
expr_stmt|;
block|}
name|cur_rtt
operator|*=
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|cur_rtt
operator|/
literal|1000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|cur_rtt
operator|%
literal|1000000
expr_stmt|;
name|min_wait
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|min_wait
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_wait
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|min_wait
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
comment|/* 		 * if we hit here, we don't have enough seconds on the clock 		 * to account for the RTO. We just let the lower seconds be 		 * the bounds and don't worry about it. This may mean we 		 * will mark a lot more than we should. 		 */
name|min_wait
operator|.
name|tv_sec
operator|=
name|min_wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
name|chk
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|chk
operator|!=
name|NULL
condition|;
name|chk
operator|=
name|tp2
control|)
block|{
name|tp2
operator|=
name|TAILQ_PREV
argument_list|(
name|chk
argument_list|,
name|sctpchunk_listhead
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
name|cnt_resend
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|chk
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_UNSENT
operator|)
operator|&&
operator|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
condition|)
block|{
comment|/* pending, may need retran */
if|if
condition|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|>
name|min_wait
operator|.
name|tv_sec
condition|)
block|{
comment|/* 				 * we have reached a chunk that was sent 				 * some seconds past our min.. forget it we 				 * will find no more to send. 				 */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|==
name|min_wait
operator|.
name|tv_sec
condition|)
block|{
comment|/* 				 * we must look at the micro seconds to 				 * know. 				 */
if|if
condition|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
operator|>=
name|min_wait
operator|.
name|tv_usec
condition|)
block|{
comment|/* 					 * ok it was sent after our boundary 					 * time. 					 */
continue|continue;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_EARLYFR_LOGGING
name|sctp_log_fr
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|,
literal|4
argument_list|,
name|SCTP_FR_MARKED_EARLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrmrkretrans
argument_list|)
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
comment|/* double book size since we are doing an early FR */
name|chk
operator|->
name|book_size_scale
operator|++
expr_stmt|;
name|cnt
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|+
name|net
operator|->
name|flight_size
operator|)
operator|>
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* Mark all we could possibly resend */
break|break;
block|}
block|}
block|}
if|if
condition|(
name|cnt
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|int
name|old_cwnd
decl_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_EARLY_FR_TMR
argument_list|)
expr_stmt|;
comment|/* 		 * make a small adjustment to cwnd and force to CA. 		 */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|net
operator|->
name|mtu
condition|)
comment|/* drop down one MTU after sending */
name|net
operator|->
name|cwnd
operator|-=
name|net
operator|->
name|mtu
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|ssthresh
condition|)
comment|/* still in SS move to CA */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|old_cwnd
operator|-
name|net
operator|->
name|cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|cnt_resend
condition|)
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_EARLY_FR_TMR
argument_list|)
expr_stmt|;
block|}
comment|/* Restart it? */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|<
name|net
operator|->
name|cwnd
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstrtmr
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_audit_retranmission_queue
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Audit invoked on send queue cnt:%d onqueue:%d\n"
argument_list|,
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|,
name|asoc
operator|->
name|sent_queue_cnt
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sent_queue_cnt
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Audit completes retran:%d onqueue:%d\n"
argument_list|,
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|,
name|asoc
operator|->
name|sent_queue_cnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_threshold_management
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint16_t
name|threshold
parameter_list|)
block|{
if|if
condition|(
name|net
condition|)
block|{
name|net
operator|->
name|error_count
operator|++
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Error count for %p now %d thresh:%d\n"
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|error_count
argument_list|,
name|net
operator|->
name|failure_threshold
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|error_count
operator|>
name|net
operator|->
name|failure_threshold
condition|)
block|{
comment|/* We had a threshold failure */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REQ_PRIMARY
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_WAS_PRIMARY
expr_stmt|;
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_FAILED_THRESHOLD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*********HOLD THIS COMMENT FOR PATCH OF ALTERNATE 		 *********ROUTING CODE 		 */
comment|/*********HOLD THIS COMMENT FOR END OF PATCH OF ALTERNATE 		 *********ROUTING CODE 		 */
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|++
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Overall error count for %p now %d thresh:%u state:%x\n"
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
operator|(
name|uint32_t
operator|)
name|threshold
argument_list|,
operator|(
operator|(
name|net
operator|==
name|NULL
operator|)
condition|?
operator|(
name|uint32_t
operator|)
literal|0
else|:
operator|(
name|uint32_t
operator|)
name|net
operator|->
name|dest_state
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We specifically do not do>= to give the assoc one more change 	 * before we fail it. 	 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|>
name|threshold
condition|)
block|{
comment|/* Abort notification sends a ULP notify */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
name|inp
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_1
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_FAILED_THRESHOLD
argument_list|,
name|oper
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|sctp_nets
modifier|*
name|sctp_find_alternate_net
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|highest_ssthresh
parameter_list|)
block|{
comment|/* Find and return an alternate network if possible */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|,
modifier|*
name|mnet
decl_stmt|,
modifier|*
name|hthresh
init|=
name|NULL
decl_stmt|;
name|int
name|once
decl_stmt|;
name|uint32_t
name|val
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|==
literal|1
condition|)
block|{
comment|/* No others but net */
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|highest_ssthresh
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|mnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|!=
name|SCTP_ADDR_REACHABLE
operator|)
operator|||
operator|(
name|mnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
condition|)
block|{
comment|/* 				 * will skip ones that are not-reachable or 				 * unconfirmed 				 */
continue|continue;
block|}
if|if
condition|(
name|val
operator|>
name|mnet
operator|->
name|ssthresh
condition|)
block|{
name|hthresh
operator|=
name|mnet
expr_stmt|;
name|val
operator|=
name|mnet
operator|->
name|ssthresh
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|==
name|mnet
operator|->
name|ssthresh
condition|)
block|{
name|uint32_t
name|rndval
decl_stmt|;
name|uint8_t
name|this_random
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|>
literal|3
condition|)
block|{
name|rndval
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|,
operator|&
name|rndval
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|)
argument_list|)
expr_stmt|;
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|this_random
operator|%
literal|2
condition|)
block|{
name|hthresh
operator|=
name|mnet
expr_stmt|;
name|val
operator|=
name|mnet
operator|->
name|ssthresh
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hthresh
condition|)
block|{
return|return
operator|(
name|hthresh
operator|)
return|;
block|}
block|}
name|mnet
operator|=
name|net
expr_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mnet
operator|==
name|NULL
condition|)
block|{
name|mnet
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|alt
operator|=
name|TAILQ_NEXT
argument_list|(
name|mnet
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
name|once
operator|++
expr_stmt|;
if|if
condition|(
name|once
operator|>
literal|1
condition|)
block|{
break|break;
block|}
name|alt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|alt
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|alt
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|alt
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|alt
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|alt
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_REACHABLE
operator|)
operator|&&
operator|(
name|alt
operator|->
name|ro
operator|.
name|ro_rt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|!
operator|(
name|alt
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
condition|)
block|{
comment|/* Found a reachable address */
break|break;
block|}
name|mnet
operator|=
name|alt
expr_stmt|;
block|}
do|while
condition|(
name|alt
operator|!=
name|NULL
condition|)
do|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
comment|/* Case where NO insv network exists (dormant state) */
comment|/* we rotate destinations */
name|once
operator|=
literal|0
expr_stmt|;
name|mnet
operator|=
name|net
expr_stmt|;
do|do
block|{
name|alt
operator|=
name|TAILQ_NEXT
argument_list|(
name|mnet
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
name|once
operator|++
expr_stmt|;
if|if
condition|(
name|once
operator|>
literal|1
condition|)
block|{
break|break;
block|}
name|alt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
operator|(
name|alt
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
operator|&&
operator|(
name|alt
operator|!=
name|net
operator|)
condition|)
block|{
comment|/* Found an alternate address */
break|break;
block|}
name|mnet
operator|=
name|alt
expr_stmt|;
block|}
do|while
condition|(
name|alt
operator|!=
name|NULL
condition|)
do|;
block|}
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|net
operator|)
return|;
block|}
return|return
operator|(
name|alt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_backoff_on_timeout
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|win_probe
parameter_list|,
name|int
name|num_marked
parameter_list|)
block|{
name|net
operator|->
name|RTO
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|win_probe
operator|==
literal|0
operator|)
operator|&&
name|num_marked
condition|)
block|{
comment|/* We don't apply penalty to window probe scenarios */
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
endif|#
directive|endif
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
operator|(
name|net
operator|->
name|mtu
operator|<<
literal|1
operator|)
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
operator|(
name|net
operator|->
name|mtu
operator|<<
literal|1
operator|)
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* floor of 1 mtu */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|mtu
condition|)
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
argument_list|,
name|SCTP_CWND_LOG_FROM_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_mark_all_for_resend
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|alt
parameter_list|,
name|int
name|window_probe
parameter_list|,
name|int
modifier|*
name|num_marked
parameter_list|)
block|{
comment|/* 	 * Mark all chunks (well not all) that were sent to *net for 	 * retransmission. Move them to alt for there destination as well... 	 * We only mark chunks that have been outstanding long enough to 	 * have received feed-back. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|tp2
decl_stmt|,
modifier|*
name|could_be_sent
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnets
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|,
name|min_wait
decl_stmt|,
name|tv
decl_stmt|;
name|int
name|cur_rtt
decl_stmt|;
name|int
name|audit_tf
decl_stmt|,
name|num_mk
decl_stmt|,
name|fir
decl_stmt|;
name|unsigned
name|int
name|cnt_mk
decl_stmt|;
name|uint32_t
name|orig_flight
decl_stmt|,
name|orig_tf
decl_stmt|;
name|uint32_t
name|tsnlast
decl_stmt|,
name|tsnfirst
decl_stmt|;
comment|/* 	 * CMT: Using RTX_SSTHRESH policy for CMT. If CMT is being used, 	 * then pick dest with largest ssthresh for any retransmission. 	 * (iyengar@cis.udel.edu, 2005/08/12) 	 */
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * CUCv2: If a different dest is picked for the 		 * retransmission, then new (rtx-)pseudo_cumack needs to be 		 * tracked for orig dest. Let CUCv2 track new (rtx-) 		 * pseudo-cumack always. 		 */
name|net
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
comment|/* none in flight now */
name|audit_tf
operator|=
literal|0
expr_stmt|;
name|fir
operator|=
literal|0
expr_stmt|;
comment|/* 	 * figure out how long a data chunk must be pending before we can 	 * mark it .. 	 */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* get cur rto in micro-seconds */
name|cur_rtt
operator|=
operator|(
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|cur_rtt
operator|*=
literal|1000
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
name|cur_rtt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|window_probe
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
name|sctp_log_fr
argument_list|(
name|net
operator|->
name|flight_size
argument_list|,
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
argument_list|,
name|SCTP_OS_TIMER_ACTIVE
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
argument_list|,
name|SCTP_FR_CWND_REPORT
argument_list|)
expr_stmt|;
name|sctp_log_fr
argument_list|(
name|net
operator|->
name|flight_size
argument_list|,
name|net
operator|->
name|cwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|SCTP_FR_CWND_REPORT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tv
operator|.
name|tv_sec
operator|=
name|cur_rtt
operator|/
literal|1000000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|cur_rtt
operator|%
literal|1000000
expr_stmt|;
name|min_wait
operator|=
name|now
expr_stmt|;
name|timevalsub
argument_list|(
operator|&
name|min_wait
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
if|if
condition|(
name|min_wait
operator|.
name|tv_sec
operator|<
literal|0
operator|||
name|min_wait
operator|.
name|tv_usec
operator|<
literal|0
condition|)
block|{
comment|/* 		 * if we hit here, we don't have enough seconds on the clock 		 * to account for the RTO. We just let the lower seconds be 		 * the bounds and don't worry about it. This may mean we 		 * will mark a lot more than we should. 		 */
name|min_wait
operator|.
name|tv_sec
operator|=
name|min_wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
name|cur_rtt
argument_list|,
name|now
operator|.
name|tv_sec
argument_list|,
name|now
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
name|min_wait
operator|.
name|tv_sec
argument_list|,
name|min_wait
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Our rwnd will be incorrect here since we are not adding back the 	 * cnt * mbuf but we will fix that down below. 	 */
name|orig_flight
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
name|orig_tf
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
name|net
operator|->
name|fast_retran_ip
operator|=
literal|0
expr_stmt|;
comment|/* Now on to each chunk */
name|num_mk
operator|=
name|cnt_mk
operator|=
literal|0
expr_stmt|;
name|tsnfirst
operator|=
name|tsnlast
operator|=
literal|0
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|chk
operator|!=
name|NULL
condition|;
name|chk
operator|=
name|tp2
control|)
block|{
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|)
condition|)
block|{
comment|/* Strange case our list got out of order? */
name|SCTP_PRINTF
argument_list|(
literal|"Our list is out of order?\n"
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"Out of order list"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
operator|)
condition|)
block|{
comment|/* 			 * found one to mark: If it is less than 			 * DATAGRAM_ACKED it MUST not be a skipped or marked 			 * TSN but instead one that is either already set 			 * for retransmission OR one that needs 			 * retransmission. 			 */
comment|/* validate its been outstanding long enough */
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_MARK_TIME
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|>
name|min_wait
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|window_probe
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * we have reached a chunk that was sent 				 * some seconds past our min.. forget it we 				 * will find no more to send. 				 */
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_STOPPED
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|==
name|min_wait
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|window_probe
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * we must look at the micro seconds to 				 * know. 				 */
if|if
condition|(
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
operator|>=
name|min_wait
operator|.
name|tv_usec
condition|)
block|{
comment|/* 					 * ok it was sent after our boundary 					 * time. 					 */
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
argument_list|,
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
argument_list|,
name|SCTP_FR_T3_STOPPED
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
block|}
if|if
condition|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* Is it expired? */
if|if
condition|(
operator|(
name|now
operator|.
name|tv_sec
operator|>
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
operator|==
name|now
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|now
operator|.
name|tv_usec
operator|>
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_usec
operator|)
operator|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|PR_SCTP_RTX_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* Has it been retransmitted tv_sec times? */
if|if
condition|(
name|chk
operator|->
name|snd_count
operator|>
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|num_mk
operator|++
expr_stmt|;
if|if
condition|(
name|fir
operator|==
literal|0
condition|)
block|{
name|fir
operator|=
literal|1
expr_stmt|;
name|tsnfirst
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
name|tsnlast
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_T3_MARKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|chk
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|chk
operator|->
name|book_size
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|net
operator|->
name|marked_retrans
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|marked_retrans
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_RSND_TO
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|chk
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|chk
operator|->
name|whoTo
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_flight_size_decrease
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+=
name|sctp_peer_chunk_oh
expr_stmt|;
block|}
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_markedretrans
argument_list|)
expr_stmt|;
comment|/* reset the TSN for striking and other FR stuff */
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
comment|/* Clear any time so NO RTT is being done */
name|chk
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
condition|)
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sctp_cmt_on_off
operator|==
literal|1
condition|)
block|{
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* remember highest acked one */
name|could_be_sent
operator|=
name|chk
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|cnt_mk
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|orig_flight
operator|-
name|net
operator|->
name|flight_size
operator|)
operator|!=
operator|(
name|orig_tf
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
condition|)
block|{
comment|/* we did not subtract the same things? */
name|audit_tf
operator|=
literal|1
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
name|sctp_log_fr
argument_list|(
name|tsnfirst
argument_list|,
name|tsnlast
argument_list|,
name|num_mk
argument_list|,
name|SCTP_FR_T3_TIMEOUT
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|num_mk
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"LAST TSN marked was %x\n"
argument_list|,
name|tsnlast
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Num marked for retransmission was %d peer-rwd:%ld\n"
argument_list|,
name|num_mk
argument_list|,
operator|(
name|u_long
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"LAST TSN marked was %x\n"
argument_list|,
name|tsnlast
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"Num marked for retransmission was %d peer-rwd:%d\n"
argument_list|,
name|num_mk
argument_list|,
operator|(
name|int
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|num_marked
operator|=
name|num_mk
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|could_be_sent
operator|)
condition|)
block|{
comment|/* fix it so we retransmit the highest acked anyway */
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|cnt_mk
operator|++
expr_stmt|;
name|could_be_sent
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|!=
name|cnt_mk
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|SCTP_PRINTF
argument_list|(
literal|"Local Audit says there are %d for retran asoc cnt:%d\n"
argument_list|,
name|cnt_mk
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|SCTP_AUDITING_ENABLED
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
name|cnt_mk
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Now check for a ECN Echo that may be stranded */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|audit_tf
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Audit total flight due to negative value net:%p\n"
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|=
literal|0
expr_stmt|;
comment|/* Clear all networks flight size */
name|TAILQ_FOREACH
argument_list|(
argument|lnets
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|lnets
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER4
argument_list|,
literal|"Net:%p c-f cwnd:%d ssthresh:%d\n"
argument_list|,
name|lnets
argument_list|,
name|lnets
operator|->
name|cwnd
argument_list|,
name|lnets
operator|->
name|ssthresh
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|chk
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|chk
operator|->
name|whoTo
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_flight_size_increase
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Setup the ecn nonce re-sync point. We do this since 	 * retranmissions are NOT setup for ECN. This means that do to 	 * Karn's rule, we don't know the total of the peers ecn bits. 	 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|nonce_resync_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|nonce_resync_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
comment|/* We return 1 if we only have a window probe outstanding */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_move_all_chunks_to_alt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|alt
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|net
operator|==
name|alt
condition|)
comment|/* nothing to do */
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* 	 * now through all the streams checking for chunks sent to our bad 	 * network. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|outs
argument_list|,
argument|&asoc->out_wheel
argument_list|,
argument|next_spoke
argument_list|)
block|{
comment|/* now clean up any chunks here */
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&outs->outqueue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|net
operator|==
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now check the pending queue */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_t3rxt_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|int
name|win_probe
decl_stmt|,
name|num_mk
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_T3_TIMEOUT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
block|{
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|==
name|lnet
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|1
argument_list|,
name|SCTP_CWND_LOG_FROM_T3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FROM_T3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* Find an alternate and mark those for retransmission */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|<
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_timowindowprobe
argument_list|)
expr_stmt|;
name|win_probe
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|win_probe
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
comment|/* 		 * CMT: Using RTX_SSTHRESH policy for CMT. If CMT is being 		 * used, then pick dest with largest ssthresh for any 		 * retransmission. 		 */
name|alt
operator|=
name|net
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * CUCv2: If a different dest is picked for the 		 * retransmission, then new (rtx-)pseudo_cumack needs to be 		 * tracked for orig dest. Let CUCv2 track new (rtx-) 		 * pseudo-cumack always. 		 */
name|net
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* CMT is OFF */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sctp_mark_all_for_resend
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|alt
argument_list|,
name|win_probe
argument_list|,
operator|&
name|num_mk
argument_list|)
expr_stmt|;
comment|/* FR Loss recovery just ended with the T3. */
name|stcb
operator|->
name|asoc
operator|.
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
comment|/* CMT FR loss recovery ended with the T3 */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
comment|/* 	 * setup the sat loss recovery that prevents satellite cwnd advance. 	 */
name|stcb
operator|->
name|asoc
operator|.
name|sat_t3_loss_recovery
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sat_t3_recovery_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
comment|/* Backoff the timer and cwnd */
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|win_probe
argument_list|,
name|num_mk
argument_list|)
expr_stmt|;
if|if
condition|(
name|win_probe
operator|==
literal|0
condition|)
block|{
comment|/* We don't do normal threshold management on window probes */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Association was destroyed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* send a immediate HB if our RTO is stale */
name|struct
name|timeval
name|now
decl_stmt|;
name|unsigned
name|int
name|ms_goneby
decl_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
condition|)
block|{
name|ms_goneby
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
else|else
block|{
name|ms_goneby
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ms_goneby
operator|>
name|net
operator|->
name|RTO
operator|)
operator|||
operator|(
name|net
operator|->
name|RTO
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 					 * no recent feed back in an RTO or 					 * more, request a RTT update 					 */
operator|(
name|void
operator|)
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * For a window probe we don't penalize the net's but only 		 * the association. This may fail it if SACKs are not coming 		 * back. If sack's are coming with rwnd locked at 0, we will 		 * continue to hold things waiting for rwnd to raise 		 */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Association was destroyed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* Move all pending over too */
name|sctp_move_all_chunks_to_alt
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|alt
argument_list|)
expr_stmt|;
comment|/* 		 * Get the address that failed, to force a new src address 		 * selecton and a route allocation. 		 */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
comment|/* Force a route allocation too */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Was it our primary? */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|==
name|net
operator|)
operator|&&
operator|(
name|alt
operator|!=
name|net
operator|)
condition|)
block|{
comment|/* 			 * Yes, note it as such and find an alternate note: 			 * this means HB code must use this to resent the 			 * primary if it goes active AND if someone does a 			 * change-primary then this flag must be cleared 			 * from any net structures. 			 */
if|if
condition|(
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|alt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_WAS_PRIMARY
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Special case for cookie-echo'ed case, we don't do output but must 	 * await the COOKIE-ACK before retransmission 	 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* 		 * Here we just reset the timer and start again since we 		 * have not established the asoc 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|advanced_peer_ack_point
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing for notes 			 * on issues that will occur when the ECN NONCE 			 * stuff is put into SCTP for cross checking. 			 */
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|cwnd
argument_list|,
name|SCTP_CWND_LOG_FROM_RTX
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_t1init_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* bump the thresholds */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
condition|)
block|{
comment|/* 		 * special hook for delayed connection. The library did NOT 		 * complete the rest of its sends. 		 */
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|=
literal|0
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|(
operator|&
name|stcb
operator|->
name|asoc
operator|)
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_init_times
argument_list|)
condition|)
block|{
comment|/* Association was destroyed */
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|=
literal|0
expr_stmt|;
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_init_rto_max
operator|<
name|net
operator|->
name|RTO
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_init_rto_max
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|numnets
operator|>
literal|1
condition|)
block|{
comment|/* If we have more than one addr use it */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|alt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|alt
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
condition|)
block|{
name|sctp_move_all_chunks_to_alt
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|alt
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|alt
expr_stmt|;
block|}
block|}
comment|/* Send out a new init */
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For cookie and asconf we actually need to find and mark for resend, then  * increment the resend counter (after all the threshold management stuff of  * course).  */
end_comment

begin_function
name|int
name|sctp_cookie_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|cookie
decl_stmt|;
comment|/* first before all else we must find the cookie */
name|TAILQ_FOREACH
argument_list|(
argument|cookie
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|cookie
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cookie
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* FOOBAR! */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
block|}
name|inp
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_3
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_INTERNAL_ERROR
argument_list|,
name|oper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Cookie timer expires in wrong state?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Strange in state %d not cookie-echoed yet c-e timer expires?\n"
argument_list|,
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Ok we found the cookie, threshold management next */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|cookie
operator|->
name|whoTo
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_init_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * cleared theshold management now lets backoff the address& select 	 * an alternate 	 */
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|=
literal|0
expr_stmt|;
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|cookie
operator|->
name|whoTo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|cookie
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|cookie
operator|->
name|whoTo
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|cookie
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|cookie
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now mark the retran info */
if|if
condition|(
name|cookie
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|cookie
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
comment|/* 	 * Now call the output routine to kick out the cookie again, Note we 	 * don't mark any chunks for retran so that FR will need to kick in 	 * to move these (or a send timer). 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_strreset_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|strrst
init|=
name|NULL
decl_stmt|,
modifier|*
name|chk
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* find the existing STRRESET, we use the seq number we sent out on */
operator|(
name|void
operator|)
name|sctp_find_stream_reset
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
argument_list|,
operator|&
name|strrst
argument_list|)
expr_stmt|;
if|if
condition|(
name|strrst
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* do threshold management */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * cleared theshold management now lets backoff the address& select 	 * an alternate 	 */
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|strrst
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|strrst
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* See if a ECN Echo is also stranded */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* 		 * If the address went un-reachable, we need to move to 		 * alternates for ALL chk's in queue 		 */
name|sctp_move_all_chunks_to_alt
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|alt
argument_list|)
expr_stmt|;
block|}
comment|/* mark the retran info */
if|if
condition|(
name|strrst
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|strrst
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
comment|/* restart the timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|strrst
operator|->
name|whoTo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_asconf_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|asconf
decl_stmt|,
modifier|*
name|chk
decl_stmt|;
comment|/* is this the first send, or a retransmission? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_sent
operator|==
literal|0
condition|)
block|{
comment|/* compose a new ASCONF chunk and send it */
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Retransmission of the existing ASCONF needed... */
comment|/* find the existing ASCONF */
name|TAILQ_FOREACH
argument_list|(
argument|asconf
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|asconf
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|asconf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* do threshold management */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asconf
operator|->
name|whoTo
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * PETER? FIX? How will the following code ever run? If the 		 * max_send_times is hit, threshold managment will blow away 		 * the association? 		 */
if|if
condition|(
name|asconf
operator|->
name|snd_count
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
condition|)
block|{
comment|/* 			 * Something is rotten, peer is not responding to 			 * ASCONFs but maybe is to data etc.  e.g. it is not 			 * properly handling the chunk type upper bits Mark 			 * this peer as ASCONF incapable and cleanup 			 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_TIMER1
argument_list|,
literal|"asconf_timer: Peer has not responded to our repeated ASCONFs\n"
argument_list|)
expr_stmt|;
name|sctp_asconf_cleanup
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * cleared theshold management now lets backoff the address 		 *& select an alternate 		 */
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|asconf
operator|->
name|whoTo
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|asconf
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|asconf
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|asconf
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* See if a ECN Echo is also stranded */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* 			 * If the address went un-reachable, we need to move 			 * to alternates for ALL chk's in queue 			 */
name|sctp_move_all_chunks_to_alt
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|alt
argument_list|)
expr_stmt|;
block|}
comment|/* mark the retran info */
if|if
condition|(
name|asconf
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|asconf
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For the shutdown and shutdown-ack, we do not keep one around on the  * control queue. This means we must generate a new one and call the general  * chunk output routine, AFTER having done threshold management.  */
end_comment

begin_function
name|int
name|sctp_shutdown_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* first threshold managment */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* second select an alternative */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* third generate a shutdown into the queue for out net */
if|if
condition|(
name|alt
condition|)
block|{
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * if alt is NULL, there is no dest to send to?? 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* fourth restart timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_shutdownack_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* first threshold managment */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/* Assoc is over */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* second select an alternative */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* third generate a shutdown into the queue for out net */
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
comment|/* fourth restart timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|alt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_audit_stream_queues_for_size
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|int
name|chks_in_queue
init|=
literal|0
decl_stmt|;
name|int
name|being_filled
init|=
literal|0
decl_stmt|;
comment|/* 	 * This function is ONLY called when the send/sent queues are empty. 	 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|inp
operator|==
name|NULL
operator|)
condition|)
return|return;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Hmm, sent_queue_retran_cnt is non-zero %d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|out_wheel
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Check to see if a spoke fell off the wheel */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|sctp_insert_on_wheel
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
condition|)
block|{
comment|/* yep, we lost a spoke or two */
name|SCTP_PRINTF
argument_list|(
literal|"Found an additional %d streams NOT on outwheel, corrected\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* no spokes lost, */
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* Check to see if some data queued, if so report it */
name|TAILQ_FOREACH
argument_list|(
argument|outs
argument_list|,
argument|&stcb->asoc.out_wheel
argument_list|,
argument|next_spoke
argument_list|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&outs->outqueue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
name|being_filled
operator|++
expr_stmt|;
name|chks_in_queue
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|chks_in_queue
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Hmm, stream queue cnt at %d I counted %d in stream out wheel\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
name|chks_in_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chks_in_queue
condition|)
block|{
comment|/* call the output queue function */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Probably should go in and make it go back through 			 * and add fragments allowed 			 */
if|if
condition|(
name|being_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Still nothing moved %d chunks are stuck\n"
argument_list|,
name|chks_in_queue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Found no chunks on any queue tot:%lu\n"
argument_list|,
operator|(
name|u_long
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_heartbeat_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|cnt_of_unconf
parameter_list|)
block|{
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|hb_responded
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
comment|/* 				 * Invalidate the src address if we did not 				 * get a response last time. 				 */
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_backoff_on_timeout
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Zero PBA, if it needs it */
if|if
condition|(
name|net
operator|->
name|partial_bytes_acked
condition|)
block|{
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|>
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
name|sctp_audit_stream_queues_for_size
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* Send a new HB, this will do threshold managment, pick a new dest */
if|if
condition|(
name|cnt_of_unconf
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * this will send out extra hb's up to maxburst if there are 		 * any unconfirmed addresses. 		 */
name|int
name|cnt_sent
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
name|cnt_sent
operator|++
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|hb_responded
operator|==
literal|0
condition|)
block|{
comment|/* Did we respond last time? */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|net
argument_list|)
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|cnt_sent
operator|>=
name|sctp_hb_maxburst
condition|)
break|break;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_is_hb_timer_running
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|hb_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* its running */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* nope */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_is_sack_timer_running
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* its running */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* nope */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|SCTP_NUMBER_OF_MTU_SIZES
value|18
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|mtu_sizes
index|[]
init|=
block|{
literal|68
block|,
literal|296
block|,
literal|508
block|,
literal|512
block|,
literal|544
block|,
literal|576
block|,
literal|1006
block|,
literal|1492
block|,
literal|1500
block|,
literal|1536
block|,
literal|2002
block|,
literal|2048
block|,
literal|4352
block|,
literal|4464
block|,
literal|8166
block|,
literal|17914
block|,
literal|32000
block|,
literal|65535
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint32_t
name|sctp_getnext_mtu
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|cur_mtu
parameter_list|)
block|{
comment|/* select another MTU that is just bigger than this one */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SCTP_NUMBER_OF_MTU_SIZES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_mtu
operator|<
name|mtu_sizes
index|[
name|i
index|]
condition|)
block|{
comment|/* no max_mtu is bigger than this one */
return|return
operator|(
name|mtu_sizes
index|[
name|i
index|]
operator|)
return|;
block|}
block|}
comment|/* here return the highest allowable */
return|return
operator|(
name|cur_mtu
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_pathmtu_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|next_mtu
decl_stmt|;
comment|/* restart the timer in any case */
name|next_mtu
operator|=
name|sctp_getnext_mtu
argument_list|(
name|inp
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_mtu
operator|<=
name|net
operator|->
name|mtu
condition|)
block|{
comment|/* nothing to do */
return|return;
block|}
block|{
name|uint32_t
name|mtu
decl_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
operator|)
operator|||
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
operator|)
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
block|{
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|mtu
operator|=
name|SCTP_GATHER_MTU_FROM_ROUTE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|.
name|sa
argument_list|,
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|next_mtu
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|next_mtu
expr_stmt|;
block|}
block|}
block|}
comment|/* restart the timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_autoclose_timer
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|timeval
name|tn
decl_stmt|,
modifier|*
name|tim_touse
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|ticks_gone_by
decl_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|tn
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
comment|/* Auto close is on */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* pick the time to use */
if|if
condition|(
name|asoc
operator|->
name|time_last_rcvd
operator|.
name|tv_sec
operator|>
name|asoc
operator|->
name|time_last_sent
operator|.
name|tv_sec
condition|)
block|{
name|tim_touse
operator|=
operator|&
name|asoc
operator|->
name|time_last_rcvd
expr_stmt|;
block|}
else|else
block|{
name|tim_touse
operator|=
operator|&
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
block|}
comment|/* Now has long enough transpired to autoclose? */
name|ticks_gone_by
operator|=
name|SEC_TO_TICKS
argument_list|(
name|tn
operator|.
name|tv_sec
operator|-
name|tim_touse
operator|->
name|tv_sec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ticks_gone_by
operator|>
literal|0
operator|)
operator|&&
operator|(
name|ticks_gone_by
operator|>=
operator|(
name|int
operator|)
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|)
condition|)
block|{
comment|/* 			 * autoclose time has hit, call the output routine, 			 * which should do nothing just to be SURE we don't 			 * have hanging data. We can then safely check the 			 * queues and know that we are clear to send 			 * shutdown 			 */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_AUTOCLOSE_TMR
argument_list|)
expr_stmt|;
comment|/* Are we clean? */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* 				 * there is nothing queued to send, so I'm 				 * done... 				 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* only send SHUTDOWN 1st time thru */
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * No auto close at this time, reset t-o to check 			 * later 			 */
name|int
name|tmp
decl_stmt|;
comment|/* fool the timer startup to use the time left */
name|tmp
operator|=
name|asoc
operator|->
name|sctp_autoclose_ticks
expr_stmt|;
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|-=
name|ticks_gone_by
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* restore the real tick value */
name|asoc
operator|->
name|sctp_autoclose_ticks
operator|=
name|tmp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_iterator_timer
parameter_list|(
name|struct
name|sctp_iterator
modifier|*
name|it
parameter_list|)
block|{
name|int
name|iteration_count
init|=
literal|0
decl_stmt|;
name|int
name|inp_skip
init|=
literal|0
decl_stmt|;
comment|/* 	 * only one iterator can run at a time. This is the only way we can 	 * cleanly pull ep's from underneath all the running interators when 	 * a ep is freed. 	 */
name|SCTP_ITERATOR_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
comment|/* iterator is complete */
name|done_with_iterator
label|:
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|iteratorhead
argument_list|,
name|it
argument_list|,
name|sctp_nxt_itr
argument_list|)
expr_stmt|;
comment|/* stopping the callout is not needed, in theory */
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|it
operator|->
name|tmr
operator|.
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|function_atend
operator|!=
name|NULL
condition|)
block|{
call|(
modifier|*
name|it
operator|->
name|function_atend
call|)
argument_list|(
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|it
argument_list|)
expr_stmt|;
return|return;
block|}
name|select_a_new_ep
label|:
name|SCTP_INP_WLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|it
operator|->
name|pcb_flags
operator|)
operator|&&
operator|(
operator|(
name|it
operator|->
name|inp
operator|->
name|sctp_flags
operator|&
name|it
operator|->
name|pcb_flags
operator|)
operator|!=
name|it
operator|->
name|pcb_flags
operator|)
operator|)
operator|||
operator|(
operator|(
name|it
operator|->
name|pcb_features
operator|)
operator|&&
operator|(
operator|(
name|it
operator|->
name|inp
operator|->
name|sctp_features
operator|&
name|it
operator|->
name|pcb_features
operator|)
operator|!=
name|it
operator|->
name|pcb_features
operator|)
operator|)
condition|)
block|{
comment|/* endpoint flags or features don't match, so keep looking */
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|done_with_iterator
goto|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|it
operator|->
name|inp
operator|->
name|inp_starting_point_for_iterator
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|it
operator|->
name|inp
operator|->
name|inp_starting_point_for_iterator
operator|!=
name|it
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Iterator collision, waiting for one at %p\n"
argument_list|,
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|start_timer_return
goto|;
block|}
comment|/* mark the current iterator on the endpoint */
name|it
operator|->
name|inp
operator|->
name|inp_starting_point_for_iterator
operator|=
name|it
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
comment|/* now go through each assoc which is in the desired state */
if|if
condition|(
name|it
operator|->
name|done_current_ep
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp
operator|!=
name|NULL
condition|)
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
name|it
operator|->
name|done_current_ep
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* run the per instance function */
name|it
operator|->
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|it
operator|->
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp_skip
operator|)
operator|||
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp_end
operator|!=
name|NULL
condition|)
block|{
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp_end
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
goto|goto
name|no_stcb
goto|;
block|}
if|if
condition|(
operator|(
name|it
operator|->
name|stcb
operator|)
operator|&&
operator|(
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|stcb_starting_point_for_iterator
operator|==
name|it
operator|)
condition|)
block|{
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|stcb_starting_point_for_iterator
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|it
operator|->
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|asoc_state
operator|&&
operator|(
operator|(
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|it
operator|->
name|asoc_state
operator|)
operator|!=
name|it
operator|->
name|asoc_state
operator|)
condition|)
block|{
comment|/* not in the right state... keep looking */
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|next_assoc
goto|;
block|}
comment|/* mark the current iterator on the assoc */
name|it
operator|->
name|stcb
operator|->
name|asoc
operator|.
name|stcb_starting_point_for_iterator
operator|=
name|it
expr_stmt|;
comment|/* see if we have limited out the iterator loop */
name|iteration_count
operator|++
expr_stmt|;
if|if
condition|(
name|iteration_count
operator|>
name|SCTP_ITERATOR_MAX_AT_ONCE
condition|)
block|{
name|start_timer_return
label|:
comment|/* set a timer to continue this later */
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ITERATOR
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|it
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_ITERATOR_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* run function on this one */
call|(
modifier|*
name|it
operator|->
name|function_assoc
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|stcb
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* 		 * we lie here, it really needs to have its own type but 		 * first I must verify that this won't effect things :-0 		 */
if|if
condition|(
name|it
operator|->
name|no_chunk_output
operator|==
literal|0
condition|)
name|sctp_chunk_output
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|it
operator|->
name|stcb
argument_list|)
expr_stmt|;
name|next_assoc
label|:
name|it
operator|->
name|stcb
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|it
operator|->
name|function_inp_end
operator|!=
name|NULL
condition|)
block|{
name|inp_skip
operator|=
call|(
modifier|*
name|it
operator|->
name|function_inp_end
call|)
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|it
operator|->
name|pointer
argument_list|,
name|it
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|no_stcb
label|:
comment|/* done with all assocs on this endpoint, move on to next endpoint */
name|it
operator|->
name|done_current_ep
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
name|it
operator|->
name|inp
operator|->
name|inp_starting_point_for_iterator
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|it
operator|->
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|it
operator|->
name|iterator_flags
operator|&
name|SCTP_ITERATOR_DO_SINGLE_INP
condition|)
block|{
name|it
operator|->
name|inp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|it
operator|->
name|inp
operator|=
name|LIST_NEXT
argument_list|(
name|it
operator|->
name|inp
argument_list|,
name|sctp_list
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|it
operator|->
name|inp
operator|==
name|NULL
condition|)
block|{
goto|goto
name|done_with_iterator
goto|;
block|}
goto|goto
name|select_a_new_ep
goto|;
block|}
end_function

end_unit

