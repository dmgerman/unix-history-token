begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Michael Shalayeff.  * Copyright (c) 2003 Ryan McBride.  * Copyright (c) 2011 Gleb Smirnoff<glebius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,  * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING  * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bpf.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/counter.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/fddi.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llatbl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/iso88025.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_carp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<crypto/sha1.h>
end_include

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_CARP
argument_list|,
literal|"CARP"
argument_list|,
literal|"CARP addresses"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|carp_softc
block|{
name|struct
name|ifnet
modifier|*
name|sc_carpdev
decl_stmt|;
comment|/* Pointer to parent ifnet. */
name|struct
name|ifaddr
modifier|*
modifier|*
name|sc_ifas
decl_stmt|;
comment|/* Our ifaddrs. */
name|struct
name|sockaddr_dl
name|sc_addr
decl_stmt|;
comment|/* Our link level address. */
name|struct
name|callout
name|sc_ad_tmo
decl_stmt|;
comment|/* Advertising timeout. */
ifdef|#
directive|ifdef
name|INET
name|struct
name|callout
name|sc_md_tmo
decl_stmt|;
comment|/* Master down timeout. */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|callout
name|sc_md6_tmo
decl_stmt|;
comment|/* XXX: Master down timeout. */
endif|#
directive|endif
name|struct
name|mtx
name|sc_mtx
decl_stmt|;
name|int
name|sc_vhid
decl_stmt|;
name|int
name|sc_advskew
decl_stmt|;
name|int
name|sc_advbase
decl_stmt|;
name|int
name|sc_naddrs
decl_stmt|;
name|int
name|sc_naddrs6
decl_stmt|;
name|int
name|sc_ifasiz
decl_stmt|;
enum|enum
block|{
name|INIT
init|=
literal|0
block|,
name|BACKUP
block|,
name|MASTER
block|}
name|sc_state
enum|;
name|int
name|sc_suppress
decl_stmt|;
name|int
name|sc_sendad_errors
decl_stmt|;
define|#
directive|define
name|CARP_SENDAD_MAX_ERRORS
value|3
name|int
name|sc_sendad_success
decl_stmt|;
define|#
directive|define
name|CARP_SENDAD_MIN_SUCCESS
value|3
name|int
name|sc_init_counter
decl_stmt|;
name|uint64_t
name|sc_counter
decl_stmt|;
comment|/* authentication */
define|#
directive|define
name|CARP_HMAC_PAD
value|64
name|unsigned
name|char
name|sc_key
index|[
name|CARP_KEY_LEN
index|]
decl_stmt|;
name|unsigned
name|char
name|sc_pad
index|[
name|CARP_HMAC_PAD
index|]
decl_stmt|;
name|SHA1_CTX
name|sc_sha1
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|carp_softc
argument_list|)
name|sc_list
expr_stmt|;
comment|/* On the carp_if list. */
name|LIST_ENTRY
argument_list|(
argument|carp_softc
argument_list|)
name|sc_next
expr_stmt|;
comment|/* On the global list. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|carp_if
block|{
ifdef|#
directive|ifdef
name|INET
name|int
name|cif_naddrs
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|int
name|cif_naddrs6
decl_stmt|;
endif|#
directive|endif
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|carp_softc
argument_list|)
name|cif_vrs
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip_moptions
name|cif_imo
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_moptions
name|cif_im6o
decl_stmt|;
endif|#
directive|endif
name|struct
name|ifnet
modifier|*
name|cif_ifp
decl_stmt|;
name|struct
name|mtx
name|cif_mtx
decl_stmt|;
name|uint32_t
name|cif_flags
decl_stmt|;
define|#
directive|define
name|CIF_PROMISC
value|0x00000001
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|CARP_INET
value|0
end_define

begin_define
define|#
directive|define
name|CARP_INET6
value|1
end_define

begin_decl_stmt
specifier|static
name|int
name|proto_reg
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Brief design of carp(4).  *  * Any carp-capable ifnet may have a list of carp softcs hanging off  * its ifp->if_carp pointer. Each softc represents one unique virtual  * host id, or vhid. The softc has a back pointer to the ifnet. All  * softcs are joined in a global list, which has quite limited use.  *  * Any interface address that takes part in CARP negotiation has a  * pointer to the softc of its vhid, ifa->ifa_carp. That could be either  * AF_INET or AF_INET6 address.  *  * Although, one can get the softc's backpointer to ifnet and traverse  * through its ifp->if_addrhead queue to find all interface addresses  * involved in CARP, we keep a growable array of ifaddr pointers. This  * allows us to avoid grabbing the IF_ADDR_LOCK() in many traversals that  * do calls into the network stack, thus avoiding LORs.  *  * Locking:  *  * Each softc has a lock sc_mtx. It is used to synchronise carp_input_c(),  * callout-driven events and ioctl()s.  *  * To traverse the list of softcs on an ifnet we use CIF_LOCK(), to  * traverse the global list we use the mutex carp_mtx.  *  * Known issues with locking:  *  * - Sending ad, we put the pointer to the softc in an mtag, and no reference  *   counting is done on the softc.  * - On module unload we may race (?) with packet processing thread  *   dereferencing our function pointers.  */
end_comment

begin_comment
comment|/* Accept incoming CARP packets. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|carp_allow
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_carp_allow
value|VNET(carp_allow)
end_define

begin_comment
comment|/* Preempt slower nodes. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|carp_preempt
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_carp_preempt
value|VNET(carp_preempt)
end_define

begin_comment
comment|/* Log level. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|carp_log
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_carp_log
value|VNET(carp_log)
end_define

begin_comment
comment|/* Global advskew demotion. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|carp_demotion
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_carp_demotion
value|VNET(carp_demotion)
end_define

begin_comment
comment|/* Send error demotion factor. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|carp_senderr_adj
argument_list|)
operator|=
name|CARP_MAXSKEW
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_carp_senderr_adj
value|VNET(carp_senderr_adj)
end_define

begin_comment
comment|/* Iface down demotion factor. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|carp_ifdown_adj
argument_list|)
operator|=
name|CARP_MAXSKEW
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_carp_ifdown_adj
value|VNET(carp_ifdown_adj)
end_define

begin_function_decl
specifier|static
name|int
name|carp_demote_adj_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet
argument_list|,
name|IPPROTO_CARP
argument_list|,
name|carp
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"CARP"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|allow
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|carp_allow
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Accept incoming CARP packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|preempt
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|carp_preempt
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"High-priority backup preemption mode"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|log
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|carp_log
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"CARP log level"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|demotion
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|carp_demote_adj_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|"Adjust demotion factor (skew of advskew)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|senderr_demotion_factor
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|carp_senderr_adj
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Send error demotion factor adjustment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|ifdown_demotion_factor
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|carp_ifdown_adj
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Interface down demotion factor adjustment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|carpstats
argument_list|,
name|carpstats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|carpstats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|carpstats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CARPSTATS_ADD
parameter_list|(
name|name
parameter_list|,
name|val
parameter_list|)
define|\
value|counter_u64_add(VNET(carpstats)[offsetof(struct carpstats, name) / \ 	sizeof(uint64_t)], (val))
end_define

begin_define
define|#
directive|define
name|CARPSTATS_INC
parameter_list|(
name|name
parameter_list|)
value|CARPSTATS_ADD(name, 1)
end_define

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_carp
argument_list|,
name|OID_AUTO
argument_list|,
name|stats
argument_list|,
expr|struct
name|carpstats
argument_list|,
name|carpstats
argument_list|,
literal|"CARP statistics (struct carpstats, netinet/ip_carp.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CARP_LOCK_INIT
parameter_list|(
name|sc
parameter_list|)
value|mtx_init(&(sc)->sc_mtx, "carp_softc",   \ 	NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|CARP_LOCK_DESTROY
parameter_list|(
name|sc
parameter_list|)
value|mtx_destroy(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CARP_LOCK_ASSERT
parameter_list|(
name|sc
parameter_list|)
value|mtx_assert(&(sc)->sc_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|CARP_LOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_lock(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CARP_UNLOCK
parameter_list|(
name|sc
parameter_list|)
value|mtx_unlock(&(sc)->sc_mtx)
end_define

begin_define
define|#
directive|define
name|CIF_LOCK_INIT
parameter_list|(
name|cif
parameter_list|)
value|mtx_init(&(cif)->cif_mtx, "carp_if",   \ 	NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|CIF_LOCK_DESTROY
parameter_list|(
name|cif
parameter_list|)
value|mtx_destroy(&(cif)->cif_mtx)
end_define

begin_define
define|#
directive|define
name|CIF_LOCK_ASSERT
parameter_list|(
name|cif
parameter_list|)
value|mtx_assert(&(cif)->cif_mtx, MA_OWNED)
end_define

begin_define
define|#
directive|define
name|CIF_LOCK
parameter_list|(
name|cif
parameter_list|)
value|mtx_lock(&(cif)->cif_mtx)
end_define

begin_define
define|#
directive|define
name|CIF_UNLOCK
parameter_list|(
name|cif
parameter_list|)
value|mtx_unlock(&(cif)->cif_mtx)
end_define

begin_define
define|#
directive|define
name|CIF_FREE
parameter_list|(
name|cif
parameter_list|)
value|do {				\ 		CIF_LOCK(cif);				\ 		if (TAILQ_EMPTY(&(cif)->cif_vrs))	\ 			carp_free_if(cif);		\ 		else					\ 			CIF_UNLOCK(cif);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|CARP_LOG
parameter_list|(
modifier|...
parameter_list|)
value|do {				\ 	if (V_carp_log> 0)				\ 		log(LOG_INFO, "carp: " __VA_ARGS__);	\ } while (0)
end_define

begin_define
define|#
directive|define
name|CARP_DEBUG
parameter_list|(
modifier|...
parameter_list|)
value|do {				\ 	if (V_carp_log> 1)				\ 		log(LOG_DEBUG, __VA_ARGS__);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|IFNET_FOREACH_IFA
parameter_list|(
name|ifp
parameter_list|,
name|ifa
parameter_list|)
define|\
value|IF_ADDR_LOCK_ASSERT(ifp);					\ 	TAILQ_FOREACH((ifa),&(ifp)->if_addrhead, ifa_link)		\ 		if ((ifa)->ifa_carp != NULL)
end_define

begin_define
define|#
directive|define
name|CARP_FOREACH_IFA
parameter_list|(
name|sc
parameter_list|,
name|ifa
parameter_list|)
define|\
value|CARP_LOCK_ASSERT(sc);						\ 	for (int _i = 0;						\ 		_i< (sc)->sc_naddrs + (sc)->sc_naddrs6&&		\ 		((ifa) = sc->sc_ifas[_i]) != NULL;			\ 		++_i)
end_define

begin_define
define|#
directive|define
name|IFNET_FOREACH_CARP
parameter_list|(
name|ifp
parameter_list|,
name|sc
parameter_list|)
define|\
value|CIF_LOCK_ASSERT(ifp->if_carp);					\ 	TAILQ_FOREACH((sc),&(ifp)->if_carp->cif_vrs, sc_list)
end_define

begin_define
define|#
directive|define
name|DEMOTE_ADVSKEW
parameter_list|(
name|sc
parameter_list|)
define|\
value|(((sc)->sc_advskew + V_carp_demotion> CARP_MAXSKEW) ?	\     CARP_MAXSKEW : ((sc)->sc_advskew + V_carp_demotion))
end_define

begin_function_decl
specifier|static
name|void
name|carp_input_c
parameter_list|(
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|carp_header
modifier|*
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|carp_softc
modifier|*
name|carp_alloc
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_destroy
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|carp_if
modifier|*
name|carp_alloc_if
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_free_if
parameter_list|(
name|struct
name|carp_if
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_set_state
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_sc_state
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_setrun
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|,
name|sa_family_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_master_down
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_master_down_locked
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_send_ad
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_send_ad_locked
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_addroute
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_ifa_addroute
parameter_list|(
name|struct
name|ifaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_delroute
parameter_list|(
name|struct
name|carp_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_ifa_delroute
parameter_list|(
name|struct
name|ifaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_send_ad_all
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|carp_demote_adj
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|carp_softc
argument_list|)
name|carp_list
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|carp_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|carp_sx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|task
name|carp_sendall_task
init|=
name|TASK_INITIALIZER
argument_list|(
literal|0
argument_list|,
name|carp_send_ad_all
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|carp_hmac_prepare
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint8_t
name|version
init|=
name|CARP_VERSION
decl_stmt|,
name|type
init|=
name|CARP_ADVERTISEMENT
decl_stmt|;
name|uint8_t
name|vhid
init|=
name|sc
operator|->
name|sc_vhid
operator|&
literal|0xff
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|in_addr
name|last
decl_stmt|,
name|cur
decl_stmt|,
name|in
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|last6
decl_stmt|,
name|cur6
decl_stmt|,
name|in6
decl_stmt|;
endif|#
directive|endif
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Compute ipad from key. */
name|bzero
argument_list|(
name|sc
operator|->
name|sc_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_pad
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_key
argument_list|,
name|sc
operator|->
name|sc_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_key
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_pad
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_pad
index|[
name|i
index|]
operator|^=
literal|0x36
expr_stmt|;
comment|/* Precompute first part of inner hash. */
name|SHA1Init
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
name|sc
operator|->
name|sc_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_pad
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|version
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|type
argument_list|,
sizeof|sizeof
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|vhid
argument_list|,
sizeof|sizeof
argument_list|(
name|vhid
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|cur
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|last
operator|=
name|cur
expr_stmt|;
name|cur
operator|.
name|s_addr
operator|=
literal|0xffffffff
expr_stmt|;
name|CARP_FOREACH_IFA
argument_list|(
argument|sc
argument_list|,
argument|ifa
argument_list|)
block|{
name|in
operator|.
name|s_addr
operator|=
name|ifatoia
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
operator|>
name|ntohl
argument_list|(
name|last
operator|.
name|s_addr
argument_list|)
operator|&&
name|ntohl
argument_list|(
name|in
operator|.
name|s_addr
argument_list|)
operator|<
name|ntohl
argument_list|(
name|cur
operator|.
name|s_addr
argument_list|)
condition|)
block|{
name|cur
operator|.
name|s_addr
operator|=
name|in
operator|.
name|s_addr
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|SHA1Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cur
argument_list|,
sizeof|sizeof
argument_list|(
name|cur
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|found
condition|)
do|;
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
name|memset
argument_list|(
operator|&
name|cur6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cur6
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|found
operator|=
literal|0
expr_stmt|;
name|last6
operator|=
name|cur6
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cur6
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|cur6
argument_list|)
argument_list|)
expr_stmt|;
name|CARP_FOREACH_IFA
argument_list|(
argument|sc
argument_list|,
argument|ifa
argument_list|)
block|{
name|in6
operator|=
name|ifatoia6
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
operator|.
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_EMBED
argument_list|(
operator|&
name|in6
argument_list|)
condition|)
name|in6
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|memcmp
argument_list|(
operator|&
name|in6
argument_list|,
operator|&
name|last6
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|memcmp
argument_list|(
operator|&
name|in6
argument_list|,
operator|&
name|cur6
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cur6
operator|=
name|in6
expr_stmt|;
name|found
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found
condition|)
name|SHA1Update
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cur6
argument_list|,
sizeof|sizeof
argument_list|(
name|cur6
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|found
condition|)
do|;
endif|#
directive|endif
comment|/* INET6 */
comment|/* convert ipad to opad */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_pad
argument_list|)
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_pad
index|[
name|i
index|]
operator|^=
literal|0x36
operator|^
literal|0x5c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_hmac_generate
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|counter
index|[
literal|2
index|]
parameter_list|,
name|unsigned
name|char
name|md
index|[
literal|20
index|]
parameter_list|)
block|{
name|SHA1_CTX
name|sha1ctx
decl_stmt|;
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* fetch first half of inner hash */
name|bcopy
argument_list|(
operator|&
name|sc
operator|->
name|sc_sha1
argument_list|,
operator|&
name|sha1ctx
argument_list|,
sizeof|sizeof
argument_list|(
name|sha1ctx
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
operator|(
name|void
operator|*
operator|)
name|counter
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_counter
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Final
argument_list|(
name|md
argument_list|,
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
comment|/* outer hash */
name|SHA1Init
argument_list|(
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|sc
operator|->
name|sc_pad
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_pad
argument_list|)
argument_list|)
expr_stmt|;
name|SHA1Update
argument_list|(
operator|&
name|sha1ctx
argument_list|,
name|md
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|SHA1Final
argument_list|(
name|md
argument_list|,
operator|&
name|sha1ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|carp_hmac_verify
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|uint32_t
name|counter
index|[
literal|2
index|]
parameter_list|,
name|unsigned
name|char
name|md
index|[
literal|20
index|]
parameter_list|)
block|{
name|unsigned
name|char
name|md2
index|[
literal|20
index|]
decl_stmt|;
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|carp_hmac_generate
argument_list|(
name|sc
argument_list|,
name|counter
argument_list|,
name|md2
argument_list|)
expr_stmt|;
return|return
operator|(
name|bcmp
argument_list|(
name|md
argument_list|,
name|md2
argument_list|,
sizeof|sizeof
argument_list|(
name|md2
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process input packet.  * we have rearranged checks order compared to the rfc,  * but it seems more efficient this way or not possible otherwise.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
name|int
name|carp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|struct
name|carp_header
modifier|*
name|ch
decl_stmt|;
name|int
name|iplen
decl_stmt|,
name|len
decl_stmt|;
name|iplen
operator|=
operator|*
name|offp
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
name|CARPSTATS_INC
argument_list|(
name|carps_ipackets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|V_carp_allow
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* verify that the IP TTL is 255.  */
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|!=
name|CARP_DFLTTL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badttl
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: received ttl %d != 255 on %s\n"
argument_list|,
name|__func__
argument_list|,
name|ip
operator|->
name|ip_ttl
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|iplen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|iplen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badlen
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: received len %zd< sizeof(struct carp_header) "
literal|"on %s\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
if|if
condition|(
name|iplen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
operator|<
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|iplen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_hdrops
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: pullup failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|carp_header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|iplen
operator|)
expr_stmt|;
comment|/* 	 * verify that the received packet length is 	 * equal to the CARP header 	 */
name|len
operator|=
name|iplen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badlen
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: packet too short %d on %s\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_hdrops
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|carp_header
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|+
name|iplen
operator|)
expr_stmt|;
comment|/* verify the CARP checksum */
name|m
operator|->
name|m_data
operator|+=
name|iplen
expr_stmt|;
if|if
condition|(
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
operator|-
name|iplen
argument_list|)
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badsum
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: checksum failed on %s\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|m
operator|->
name|m_data
operator|-=
name|iplen
expr_stmt|;
name|carp_input_c
argument_list|(
name|m
argument_list|,
name|ch
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|carp6_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
decl_stmt|;
name|struct
name|carp_header
modifier|*
name|ch
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|CARPSTATS_INC
argument_list|(
name|carps_ipackets6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|V_carp_allow
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* check if received on a valid carp interface */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_carp
operator|==
name|NULL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badif
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: packet received on non-carp interface: %s\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* verify that the IP TTL is 255 */
if|if
condition|(
name|ip6
operator|->
name|ip6_hlim
operator|!=
name|CARP_DFLTTL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badttl
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: received ttl %d != 255 on %s\n"
argument_list|,
name|__func__
argument_list|,
name|ip6
operator|->
name|ip6_hlim
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* verify that we have a complete carp packet */
name|len
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
name|IP6_EXTHDR_GET
argument_list|(
name|ch
argument_list|,
expr|struct
name|carp_header
operator|*
argument_list|,
name|m
argument_list|,
operator|*
name|offp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badlen
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: packet size %u too small\n"
argument_list|,
name|__func__
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* verify the CARP checksum */
name|m
operator|->
name|m_data
operator|+=
operator|*
name|offp
expr_stmt|;
if|if
condition|(
name|in_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|)
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badsum
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: checksum failed, on %s\n"
argument_list|,
name|__func__
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|m
operator|->
name|m_data
operator|-=
operator|*
name|offp
expr_stmt|;
name|carp_input_c
argument_list|(
name|m
argument_list|,
name|ch
argument_list|,
name|AF_INET6
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_comment
comment|/*  * This routine should not be necessary at all, but some switches  * (VMWare ESX vswitches) can echo our own packets back at us,  * and we must ignore them or they will cause us to drop out of  * MASTER mode.  *  * We cannot catch all cases of network loops.  Instead, what we  * do here is catch any packet that arrives with a carp header  * with a VHID of 0, that comes from an address that is our own.  * These packets are by definition "from us" (even if they are from  * a misconfigured host that is pretending to be us).  *  * The VHID test is outside this mini-function.  */
end_comment

begin_function
specifier|static
name|int
name|carp_source_is_self
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|ip
modifier|*
name|ip4
decl_stmt|;
name|struct
name|in_addr
name|in4
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|in6_addr
name|in6
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ip4
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|in4
operator|=
name|ifatoia
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
operator|.
name|sin_addr
expr_stmt|;
return|return
operator|(
name|in4
operator|.
name|s_addr
operator|==
name|ip4
operator|->
name|ip_src
operator|.
name|s_addr
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|in6
operator|=
name|ifatoia6
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
operator|.
name|sin6_addr
expr_stmt|;
return|return
operator|(
name|memcmp
argument_list|(
operator|&
name|in6
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
return|;
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_input_c
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|carp_header
modifier|*
name|ch
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|match
decl_stmt|;
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|tmp_counter
decl_stmt|;
name|struct
name|timeval
name|sc_tv
decl_stmt|,
name|ch_tv
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Verify that the VHID is valid on the receiving interface. 	 * 	 * There should be just one match.  If there are none 	 * the VHID is not valid and we drop the packet.  If 	 * there are multiple VHID matches, take just the first 	 * one, for compatibility with previous code.  While we're 	 * scanning, check for obvious loops in the network topology 	 * (these should never happen, and as noted above, we may 	 * miss real loops; this is just a double-check). 	 */
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|match
operator|=
name|NULL
expr_stmt|;
name|IFNET_FOREACH_IFA
argument_list|(
argument|ifp
argument_list|,
argument|ifa
argument_list|)
block|{
if|if
condition|(
name|match
operator|==
name|NULL
operator|&&
name|ifa
operator|->
name|ifa_carp
operator|!=
name|NULL
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|af
operator|&&
name|ifa
operator|->
name|ifa_carp
operator|->
name|sc_vhid
operator|==
name|ch
operator|->
name|carp_vhid
condition|)
name|match
operator|=
name|ifa
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|carp_vhid
operator|==
literal|0
operator|&&
name|carp_source_is_self
argument_list|(
name|m
argument_list|,
name|ifa
argument_list|,
name|af
argument_list|)
condition|)
name|error
operator|=
name|ELOOP
expr_stmt|;
block|}
name|ifa
operator|=
name|error
condition|?
name|NULL
else|:
name|match
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
name|ifa_ref
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ELOOP
condition|)
block|{
name|CARP_DEBUG
argument_list|(
literal|"dropping looped packet on interface %s\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|CARPSTATS_INC
argument_list|(
name|carps_badif
argument_list|)
expr_stmt|;
comment|/* ??? */
block|}
else|else
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badvhid
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* verify the CARP version. */
if|if
condition|(
name|ch
operator|->
name|carp_version
operator|!=
name|CARP_VERSION
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badver
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: invalid version %d\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ch
operator|->
name|carp_version
argument_list|)
expr_stmt|;
name|ifa_free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|sc
operator|=
name|ifa
operator|->
name|ifa_carp
expr_stmt|;
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|ifa_free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|carp_hmac_verify
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|carp_counter
argument_list|,
name|ch
operator|->
name|carp_md
argument_list|)
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_badauth
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: incorrect hash for VHID %u@%s\n"
argument_list|,
name|__func__
argument_list|,
name|sc
operator|->
name|sc_vhid
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tmp_counter
operator|=
name|ntohl
argument_list|(
name|ch
operator|->
name|carp_counter
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tmp_counter
operator|=
name|tmp_counter
operator|<<
literal|32
expr_stmt|;
name|tmp_counter
operator|+=
name|ntohl
argument_list|(
name|ch
operator|->
name|carp_counter
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* XXX Replay protection goes here */
name|sc
operator|->
name|sc_init_counter
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_counter
operator|=
name|tmp_counter
expr_stmt|;
name|sc_tv
operator|.
name|tv_sec
operator|=
name|sc
operator|->
name|sc_advbase
expr_stmt|;
name|sc_tv
operator|.
name|tv_usec
operator|=
name|DEMOTE_ADVSKEW
argument_list|(
name|sc
argument_list|)
operator|*
literal|1000000
operator|/
literal|256
expr_stmt|;
name|ch_tv
operator|.
name|tv_sec
operator|=
name|ch
operator|->
name|carp_advbase
expr_stmt|;
name|ch_tv
operator|.
name|tv_usec
operator|=
name|ch
operator|->
name|carp_advskew
operator|*
literal|1000000
operator|/
literal|256
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|INIT
case|:
break|break;
case|case
name|MASTER
case|:
comment|/* 		 * If we receive an advertisement from a master who's going to 		 * be more frequent than us, go into BACKUP state. 		 */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sc_tv
argument_list|,
operator|&
name|ch_tv
argument_list|,
operator|>
argument_list|)
operator|||
name|timevalcmp
argument_list|(
operator|&
name|sc_tv
argument_list|,
operator|&
name|ch_tv
argument_list|,
operator|==
argument_list|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|)
expr_stmt|;
name|carp_set_state
argument_list|(
name|sc
argument_list|,
name|BACKUP
argument_list|,
literal|"more frequent advertisement received"
argument_list|)
expr_stmt|;
name|carp_setrun
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|carp_delroute
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BACKUP
case|:
comment|/* 		 * If we're pre-empting masters who advertise slower than us, 		 * and this one claims to be slower, treat him as down. 		 */
if|if
condition|(
name|V_carp_preempt
operator|&&
name|timevalcmp
argument_list|(
operator|&
name|sc_tv
argument_list|,
operator|&
name|ch_tv
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|carp_master_down_locked
argument_list|(
name|sc
argument_list|,
literal|"preempting a slower master"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 *  If the master is going to advertise at such a low frequency 		 *  that he's guaranteed to time out, we'd might as well just 		 *  treat him as timed out now. 		 */
name|sc_tv
operator|.
name|tv_sec
operator|=
name|sc
operator|->
name|sc_advbase
operator|*
literal|3
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|sc_tv
argument_list|,
operator|&
name|ch_tv
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|carp_master_down_locked
argument_list|(
name|sc
argument_list|,
literal|"master will time out"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Otherwise, we reset the counter and wait for the next 		 * advertisement. 		 */
name|carp_setrun
argument_list|(
name|sc
argument_list|,
name|af
argument_list|)
expr_stmt|;
break|break;
block|}
name|out
label|:
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|carp_prepare_ad
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|struct
name|carp_header
modifier|*
name|ch
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_init_counter
condition|)
block|{
comment|/* this could also be seconds since unix epoch */
name|sc
operator|->
name|sc_counter
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|sc
operator|->
name|sc_counter
operator|=
name|sc
operator|->
name|sc_counter
operator|<<
literal|32
expr_stmt|;
name|sc
operator|->
name|sc_counter
operator|+=
name|arc4random
argument_list|()
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_counter
operator|++
expr_stmt|;
name|ch
operator|->
name|carp_counter
index|[
literal|0
index|]
operator|=
name|htonl
argument_list|(
operator|(
name|sc
operator|->
name|sc_counter
operator|>>
literal|32
operator|)
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|ch
operator|->
name|carp_counter
index|[
literal|1
index|]
operator|=
name|htonl
argument_list|(
name|sc
operator|->
name|sc_counter
operator|&
literal|0xffffffff
argument_list|)
expr_stmt|;
name|carp_hmac_generate
argument_list|(
name|sc
argument_list|,
name|ch
operator|->
name|carp_counter
argument_list|,
name|ch
operator|->
name|carp_md
argument_list|)
expr_stmt|;
comment|/* Tag packet for carp_output */
if|if
condition|(
operator|(
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_CARP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|carp_softc
operator|*
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CARPSTATS_INC
argument_list|(
name|carps_onomem
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|sc
argument_list|,
name|mtag
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * To avoid LORs and possible recursions this function shouldn't  * be called directly, but scheduled via taskqueue.  */
end_comment

begin_function
specifier|static
name|void
name|carp_send_ad_all
parameter_list|(
name|void
modifier|*
name|ctx
name|__unused
parameter_list|,
name|int
name|pending
name|__unused
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sc
argument_list|,
argument|&carp_list
argument_list|,
argument|sc_next
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|MASTER
condition|)
block|{
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|carp_send_ad_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Send a periodic advertisement, executed in callout context. */
end_comment

begin_function
specifier|static
name|void
name|carp_send_ad
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|carp_send_ad_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_send_ad_error
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_sendad_errors
operator|<
name|INT_MAX
condition|)
name|sc
operator|->
name|sc_sendad_errors
operator|++
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_sendad_errors
operator|==
name|CARP_SENDAD_MAX_ERRORS
condition|)
block|{
specifier|static
specifier|const
name|char
name|fmt
index|[]
init|=
literal|"send error %d on %s"
decl_stmt|;
name|char
name|msg
index|[
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|+
name|IFNAMSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
name|fmt
argument_list|,
name|error
argument_list|,
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|carp_demote_adj
argument_list|(
name|V_carp_senderr_adj
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_sendad_success
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sc
operator|->
name|sc_sendad_errors
operator|>=
name|CARP_SENDAD_MAX_ERRORS
operator|&&
operator|++
name|sc
operator|->
name|sc_sendad_success
operator|>=
name|CARP_SENDAD_MIN_SUCCESS
condition|)
block|{
specifier|static
specifier|const
name|char
name|fmt
index|[]
init|=
literal|"send ok on %s"
decl_stmt|;
name|char
name|msg
index|[
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
operator|+
name|IFNAMSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|msg
argument_list|,
name|fmt
argument_list|,
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|carp_demote_adj
argument_list|(
operator|-
name|V_carp_senderr_adj
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_sendad_errors
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sc
operator|->
name|sc_sendad_errors
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pick the best ifaddr on the given ifp for sending CARP  * advertisements.  *  * "Best" here is defined by ifa_preferred().  This function is much  * much like ifaof_ifpforaddr() except that we just use ifa_preferred().  *  * (This could be simplified to return the actual address, except that  * it has a different format in AF_INET and AF_INET6.)  */
end_comment

begin_function
specifier|static
name|struct
name|ifaddr
modifier|*
name|carp_best_ifa
parameter_list|(
name|int
name|af
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|best
decl_stmt|;
if|if
condition|(
name|af
operator|>=
name|AF_MAX
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|best
operator|=
name|NULL
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|af
operator|&&
operator|(
name|best
operator|==
name|NULL
operator|||
name|ifa_preferred
argument_list|(
name|best
argument_list|,
name|ifa
argument_list|)
operator|)
condition|)
name|best
operator|=
name|ifa
expr_stmt|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|best
operator|!=
name|NULL
condition|)
name|ifa_ref
argument_list|(
name|best
argument_list|)
expr_stmt|;
return|return
operator|(
name|best
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_send_ad_locked
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|carp_header
name|ch
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|carp_header
modifier|*
name|ch_ptr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|advskew
decl_stmt|;
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|advskew
operator|=
name|DEMOTE_ADVSKEW
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|sc
operator|->
name|sc_advbase
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|advskew
operator|*
literal|1000000
operator|/
literal|256
expr_stmt|;
name|ch
operator|.
name|carp_version
operator|=
name|CARP_VERSION
expr_stmt|;
name|ch
operator|.
name|carp_type
operator|=
name|CARP_ADVERTISEMENT
expr_stmt|;
name|ch
operator|.
name|carp_vhid
operator|=
name|sc
operator|->
name|sc_vhid
expr_stmt|;
name|ch
operator|.
name|carp_advbase
operator|=
name|sc
operator|->
name|sc_advbase
expr_stmt|;
name|ch
operator|.
name|carp_advskew
operator|=
name|advskew
expr_stmt|;
name|ch
operator|.
name|carp_authlen
operator|=
literal|7
expr_stmt|;
comment|/* XXX DEFINE */
name|ch
operator|.
name|carp_pad1
operator|=
literal|0
expr_stmt|;
comment|/* must be zero */
name|ch
operator|.
name|carp_cksum
operator|=
literal|0
expr_stmt|;
comment|/* XXXGL: OpenBSD picks first ifaddr with needed family. */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sc
operator|->
name|sc_naddrs
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_onomem
argument_list|)
expr_stmt|;
goto|goto
name|resched
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
operator|>>
literal|2
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
name|IPTOS_LOWDELAY
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|CARP_DFLTTL
expr_stmt|;
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_CARP
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|ip_fillid
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|ifa
operator|=
name|carp_best_ifa
argument_list|(
name|AF_INET
argument_list|,
name|sc
operator|->
name|sc_carpdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|ifatoia
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ifa_free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_CARP_GROUP
argument_list|)
expr_stmt|;
name|ch_ptr
operator|=
operator|(
expr|struct
name|carp_header
operator|*
operator|)
operator|(
operator|&
name|ip
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ch
argument_list|,
name|ch_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|carp_prepare_ad
argument_list|(
name|m
argument_list|,
name|sc
argument_list|,
name|ch_ptr
argument_list|)
condition|)
goto|goto
name|resched
goto|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
name|ch_ptr
operator|->
name|carp_cksum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ip
argument_list|)
expr_stmt|;
name|CARPSTATS_INC
argument_list|(
name|carps_opackets
argument_list|)
expr_stmt|;
name|carp_send_ad_error
argument_list|(
name|sc
argument_list|,
name|ip_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|IP_RAWOUTPUT
argument_list|,
operator|&
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_carp
operator|->
name|cif_imo
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sc
operator|->
name|sc_naddrs6
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|CARPSTATS_INC
argument_list|(
name|carps_onomem
argument_list|)
expr_stmt|;
goto|goto
name|resched
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|len
expr_stmt|;
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ip6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_vfc
operator||=
name|IPV6_VERSION
expr_stmt|;
name|ip6
operator|->
name|ip6_hlim
operator|=
name|CARP_DFLTTL
expr_stmt|;
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_CARP
expr_stmt|;
comment|/* set the source address */
name|ifa
operator|=
name|carp_best_ifa
argument_list|(
name|AF_INET6
argument_list|,
name|sc
operator|->
name|sc_carpdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|IFA_IN6
argument_list|(
name|ifa
argument_list|)
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ifa_free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* This should never happen with IPv6. */
name|bzero
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the multicast destination. */
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr16
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
literal|0xff02
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|.
name|s6_addr8
index|[
literal|15
index|]
operator|=
literal|0x12
expr_stmt|;
if|if
condition|(
name|in6_setscope
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|,
name|sc
operator|->
name|sc_carpdev
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CARP_DEBUG
argument_list|(
literal|"%s: in6_setscope failed\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|resched
goto|;
block|}
name|ch_ptr
operator|=
operator|(
expr|struct
name|carp_header
operator|*
operator|)
operator|(
operator|&
name|ip6
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ch
argument_list|,
name|ch_ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|carp_prepare_ad
argument_list|(
name|m
argument_list|,
name|sc
argument_list|,
name|ch_ptr
argument_list|)
condition|)
goto|goto
name|resched
goto|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|ch_ptr
operator|->
name|carp_cksum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ip6
argument_list|)
expr_stmt|;
name|CARPSTATS_INC
argument_list|(
name|carps_opackets6
argument_list|)
expr_stmt|;
name|carp_send_ad_error
argument_list|(
name|sc
argument_list|,
name|ip6_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_carp
operator|->
name|cif_im6o
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|resched
label|:
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|carp_send_ad
argument_list|,
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_addroute
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|CARP_FOREACH_IFA
argument_list|(
argument|sc
argument_list|,
argument|ifa
argument_list|)
name|carp_ifa_addroute
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_ifa_addroute
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|in_addprefix
argument_list|(
name|ifatoia
argument_list|(
name|ifa
argument_list|)
argument_list|,
name|RTF_UP
argument_list|)
expr_stmt|;
name|ifa_add_loopback_route
argument_list|(
name|ifa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifatoia
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ifa_add_loopback_route
argument_list|(
name|ifa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifatoia6
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
argument_list|)
expr_stmt|;
name|nd6_add_ifa_lle
argument_list|(
name|ifatoia6
argument_list|(
name|ifa
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|carp_delroute
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|CARP_FOREACH_IFA
argument_list|(
argument|sc
argument_list|,
argument|ifa
argument_list|)
name|carp_ifa_delroute
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_ifa_delroute
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|ifa_del_loopback_route
argument_list|(
name|ifa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifatoia
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
argument_list|)
expr_stmt|;
name|in_scrubprefix
argument_list|(
name|ifatoia
argument_list|(
name|ifa
argument_list|)
argument_list|,
name|LLE_STATIC
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ifa_del_loopback_route
argument_list|(
name|ifa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ifatoia6
argument_list|(
name|ifa
argument_list|)
operator|->
name|ia_addr
argument_list|)
expr_stmt|;
name|nd6_rem_ifa_lle
argument_list|(
name|ifatoia6
argument_list|(
name|ifa
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|int
name|carp_master
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|ifa
operator|->
name|ifa_carp
decl_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_state
operator|==
name|MASTER
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_comment
comment|/*  * Broadcast a gratuitous ARP request containing  * the virtual router MAC address for each IP address  * associated with the virtual router.  */
end_comment

begin_function
specifier|static
name|void
name|carp_send_arp
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
name|CARP_FOREACH_IFA
argument_list|(
argument|sc
argument_list|,
argument|ifa
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|arp_announce_ifaddr
argument_list|(
name|sc
operator|->
name|sc_carpdev
argument_list|,
name|addr
argument_list|,
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|carp_iamatch
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|enaddr
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|ifa
operator|->
name|ifa_carp
decl_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|MASTER
condition|)
block|{
operator|*
name|enaddr
operator|=
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|void
name|carp_send_na
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
specifier|static
name|struct
name|in6_addr
name|mcast
init|=
name|IN6ADDR_LINKLOCAL_ALLNODES_INIT
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|in6
decl_stmt|;
name|CARP_FOREACH_IFA
argument_list|(
argument|sc
argument_list|,
argument|ifa
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|in6
operator|=
name|IFA_IN6
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|nd6_na_output
argument_list|(
name|sc
operator|->
name|sc_carpdev
argument_list|,
operator|&
name|mcast
argument_list|,
name|in6
argument_list|,
name|ND_NA_FLAG_OVERRIDE
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
block|}
end_function

begin_comment
comment|/*  * Returns ifa in case it's a carp address and it is MASTER, or if the address  * matches and is not a carp address.  Returns NULL otherwise.  */
end_comment

begin_function
name|struct
name|ifaddr
modifier|*
name|carp_iamatch6
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|in6_addr
modifier|*
name|taddr
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|ifa
operator|=
name|NULL
expr_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
name|taddr
argument_list|,
name|IFA_IN6
argument_list|(
name|ifa
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ifa
operator|->
name|ifa_carp
operator|&&
name|ifa
operator|->
name|ifa_carp
operator|->
name|sc_state
operator|!=
name|MASTER
condition|)
name|ifa
operator|=
name|NULL
expr_stmt|;
else|else
name|ifa_ref
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
break|break;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ifa
operator|)
return|;
block|}
end_function

begin_function
name|caddr_t
name|carp_macmatch6
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|in6_addr
modifier|*
name|taddr
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_IFA
argument_list|(
argument|ifp
argument_list|,
argument|ifa
argument_list|)
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
name|taddr
argument_list|,
name|IFA_IN6
argument_list|(
name|ifa
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|ifa
operator|->
name|ifa_carp
decl_stmt|;
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|mtag
operator|=
name|m_tag_get
argument_list|(
name|PACKET_TAG_CARP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|carp_softc
operator|*
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
comment|/* Better a bit than nothing. */
return|return
operator|(
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
operator|)
return|;
name|bcopy
argument_list|(
operator|&
name|sc
argument_list|,
name|mtag
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
operator|)
return|;
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_function
name|int
name|carp_forus
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|u_char
modifier|*
name|dhost
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
name|uint8_t
modifier|*
name|ena
init|=
name|dhost
decl_stmt|;
if|if
condition|(
name|ena
index|[
literal|0
index|]
operator|||
name|ena
index|[
literal|1
index|]
operator|||
name|ena
index|[
literal|2
index|]
operator|!=
literal|0x5e
operator|||
name|ena
index|[
literal|3
index|]
operator|||
name|ena
index|[
literal|4
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CIF_LOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
block|{
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|MASTER
operator|&&
operator|!
name|bcmp
argument_list|(
name|dhost
argument_list|,
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
argument_list|,
name|ETHER_ADDR_LEN
argument_list|)
condition|)
block|{
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Master down timeout event, executed in callout context. */
end_comment

begin_function
specifier|static
name|void
name|carp_master_down
parameter_list|(
name|void
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|v
decl_stmt|;
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|==
name|BACKUP
condition|)
block|{
name|carp_master_down_locked
argument_list|(
name|sc
argument_list|,
literal|"master timed out"
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_master_down_locked
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|BACKUP
case|:
name|carp_set_state
argument_list|(
name|sc
argument_list|,
name|MASTER
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|carp_send_ad_locked
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|carp_send_arp
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|carp_send_na
argument_list|(
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|carp_setrun
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|carp_addroute
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|INIT
case|:
case|case
name|MASTER
case|:
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"carp: VHID %u@%s: master_down event in %s state\n"
argument_list|,
name|sc
operator|->
name|sc_vhid
argument_list|,
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_xname
argument_list|,
name|sc
operator|->
name|sc_state
condition|?
literal|"MASTER"
else|:
literal|"INIT"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * When in backup state, af indicates whether to reset the master down timer  * for v4 or v6. If it's set to zero, reset the ones which are already pending.  */
end_comment

begin_function
specifier|static
name|void
name|carp_setrun
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|sa_family_t
name|af
parameter_list|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
operator|||
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_link_state
operator|!=
name|LINK_STATE_UP
operator|||
operator|(
name|sc
operator|->
name|sc_naddrs
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_naddrs6
operator|==
literal|0
operator|)
condition|)
return|return;
switch|switch
condition|(
name|sc
operator|->
name|sc_state
condition|)
block|{
case|case
name|INIT
case|:
name|carp_set_state
argument_list|(
name|sc
argument_list|,
name|BACKUP
argument_list|,
literal|"initialization complete"
argument_list|)
expr_stmt|;
name|carp_setrun
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKUP
case|:
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
literal|3
operator|*
name|sc
operator|->
name|sc_advbase
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|sc
operator|->
name|sc_advskew
operator|*
literal|1000000
operator|/
literal|256
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_md_tmo
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|carp_master_down
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_md6_tmo
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|carp_master_down
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sc
operator|->
name|sc_naddrs
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_md_tmo
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|carp_master_down
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sc
operator|->
name|sc_naddrs6
condition|)
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_md6_tmo
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|carp_master_down
argument_list|,
name|sc
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
break|break;
case|case
name|MASTER
case|:
name|tv
operator|.
name|tv_sec
operator|=
name|sc
operator|->
name|sc_advbase
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|sc
operator|->
name|sc_advskew
operator|*
literal|1000000
operator|/
literal|256
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|,
name|tvtohz
argument_list|(
operator|&
name|tv
argument_list|)
argument_list|,
name|carp_send_ad
argument_list|,
name|sc
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup multicast structures.  */
end_comment

begin_function
specifier|static
name|int
name|carp_multicast_setup
parameter_list|(
name|struct
name|carp_if
modifier|*
name|cif
parameter_list|,
name|sa_family_t
name|sa
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|cif
operator|->
name|cif_ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|sa
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
init|=
operator|&
name|cif
operator|->
name|cif_imo
decl_stmt|;
name|struct
name|in_addr
name|addr
decl_stmt|;
if|if
condition|(
name|imo
operator|->
name|imo_membership
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|imo
operator|->
name|imo_membership
operator|=
operator|(
expr|struct
name|in_multi
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_multi
operator|*
argument_list|)
operator|*
name|IP_MIN_MEMBERSHIPS
operator|)
argument_list|,
name|M_CARP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_mfilters
operator|=
name|NULL
expr_stmt|;
name|imo
operator|->
name|imo_max_memberships
operator|=
name|IP_MIN_MEMBERSHIPS
expr_stmt|;
name|imo
operator|->
name|imo_multicast_vif
operator|=
operator|-
literal|1
expr_stmt|;
name|addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_CARP_GROUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in_joingroup
argument_list|(
name|ifp
argument_list|,
operator|&
name|addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|imo
operator|->
name|imo_membership
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|imo
operator|->
name|imo_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
break|break;
block|}
name|imo
operator|->
name|imo_num_memberships
operator|++
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ifp
operator|=
name|ifp
expr_stmt|;
name|imo
operator|->
name|imo_multicast_ttl
operator|=
name|CARP_DFLTTL
expr_stmt|;
name|imo
operator|->
name|imo_multicast_loop
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|ip6_moptions
modifier|*
name|im6o
init|=
operator|&
name|cif
operator|->
name|cif_im6o
decl_stmt|;
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|struct
name|in6_multi
modifier|*
name|in6m
decl_stmt|;
if|if
condition|(
name|im6o
operator|->
name|im6o_membership
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|im6o
operator|->
name|im6o_membership
operator|=
operator|(
expr|struct
name|in6_multi
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_multi
operator|*
argument_list|)
operator|*
name|IPV6_MIN_MEMBERSHIPS
operator|)
argument_list|,
name|M_CARP
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|im6o
operator|->
name|im6o_mfilters
operator|=
name|NULL
expr_stmt|;
name|im6o
operator|->
name|im6o_max_memberships
operator|=
name|IPV6_MIN_MEMBERSHIPS
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_hlim
operator|=
name|CARP_DFLTTL
expr_stmt|;
name|im6o
operator|->
name|im6o_multicast_ifp
operator|=
name|ifp
expr_stmt|;
comment|/* Join IPv6 CARP multicast group. */
name|bzero
argument_list|(
operator|&
name|in6
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
name|in6
operator|.
name|s6_addr16
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
literal|0xff02
argument_list|)
expr_stmt|;
name|in6
operator|.
name|s6_addr8
index|[
literal|15
index|]
operator|=
literal|0x12
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|in6
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|im6o
operator|->
name|im6o_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
break|break;
block|}
name|in6m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in6_mc_join
argument_list|(
name|ifp
argument_list|,
operator|&
name|in6
argument_list|,
name|NULL
argument_list|,
operator|&
name|in6m
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|im6o
operator|->
name|im6o_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
break|break;
block|}
name|im6o
operator|->
name|im6o_membership
index|[
literal|0
index|]
operator|=
name|in6m
expr_stmt|;
name|im6o
operator|->
name|im6o_num_memberships
operator|++
expr_stmt|;
comment|/* Join solicited multicast address. */
name|bzero
argument_list|(
operator|&
name|in6
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
name|in6
operator|.
name|s6_addr16
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
literal|0xff02
argument_list|)
expr_stmt|;
name|in6
operator|.
name|s6_addr32
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|in6
operator|.
name|s6_addr32
index|[
literal|2
index|]
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|in6
operator|.
name|s6_addr32
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|in6
operator|.
name|s6_addr8
index|[
literal|12
index|]
operator|=
literal|0xff
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in6_setscope
argument_list|(
operator|&
name|in6
argument_list|,
name|ifp
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|in6_mc_leave
argument_list|(
name|im6o
operator|->
name|im6o_membership
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|im6o
operator|->
name|im6o_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
break|break;
block|}
name|in6m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|in6_mc_join
argument_list|(
name|ifp
argument_list|,
operator|&
name|in6
argument_list|,
name|NULL
argument_list|,
operator|&
name|in6m
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|in6_mc_leave
argument_list|(
name|im6o
operator|->
name|im6o_membership
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|im6o
operator|->
name|im6o_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
break|break;
block|}
name|im6o
operator|->
name|im6o_membership
index|[
literal|1
index|]
operator|=
name|in6m
expr_stmt|;
name|im6o
operator|->
name|im6o_num_memberships
operator|++
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free multicast structures.  */
end_comment

begin_function
specifier|static
name|void
name|carp_multicast_cleanup
parameter_list|(
name|struct
name|carp_if
modifier|*
name|cif
parameter_list|,
name|sa_family_t
name|sa
parameter_list|)
block|{
name|sx_assert
argument_list|(
operator|&
name|carp_sx
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sa
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|cif
operator|->
name|cif_naddrs
operator|==
literal|0
condition|)
block|{
name|struct
name|ip_moptions
modifier|*
name|imo
init|=
operator|&
name|cif
operator|->
name|cif_imo
decl_stmt|;
name|in_leavegroup
argument_list|(
name|imo
operator|->
name|imo_membership
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|imo
operator|->
name|imo_mfilters
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: imo_mfilters != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|imo
operator|->
name|imo_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
name|imo
operator|->
name|imo_membership
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|cif
operator|->
name|cif_naddrs6
operator|==
literal|0
condition|)
block|{
name|struct
name|ip6_moptions
modifier|*
name|im6o
init|=
operator|&
name|cif
operator|->
name|cif_im6o
decl_stmt|;
name|in6_mc_leave
argument_list|(
name|im6o
operator|->
name|im6o_membership
index|[
literal|0
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|in6_mc_leave
argument_list|(
name|im6o
operator|->
name|im6o_membership
index|[
literal|1
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|im6o
operator|->
name|im6o_mfilters
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: im6o_mfilters != NULL"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|im6o
operator|->
name|im6o_membership
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
name|im6o
operator|->
name|im6o_membership
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|int
name|carp_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
if|if
condition|(
operator|!
name|sa
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mtag
operator|=
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_CARP
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bcopy
argument_list|(
name|mtag
operator|+
literal|1
argument_list|,
operator|&
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the source MAC address to the Virtual Router MAC Address. */
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_L2VLAN
case|:
block|{
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_shost
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|ether_shost
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|ether_shost
index|[
literal|2
index|]
operator|=
literal|0x5e
expr_stmt|;
name|eh
operator|->
name|ether_shost
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|eh
operator|->
name|ether_shost
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|eh
operator|->
name|ether_shost
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|sc_vhid
expr_stmt|;
block|}
break|break;
case|case
name|IFT_FDDI
case|:
block|{
name|struct
name|fddi_header
modifier|*
name|fh
decl_stmt|;
name|fh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|fddi_header
operator|*
argument_list|)
expr_stmt|;
name|fh
operator|->
name|fddi_shost
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fh
operator|->
name|fddi_shost
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|fh
operator|->
name|fddi_shost
index|[
literal|2
index|]
operator|=
literal|0x5e
expr_stmt|;
name|fh
operator|->
name|fddi_shost
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|fh
operator|->
name|fddi_shost
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|fh
operator|->
name|fddi_shost
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|sc_vhid
expr_stmt|;
block|}
break|break;
case|case
name|IFT_ISO88025
case|:
block|{
name|struct
name|iso88025_header
modifier|*
name|th
decl_stmt|;
name|th
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|iso88025_header
operator|*
argument_list|)
expr_stmt|;
name|th
operator|->
name|iso88025_shost
index|[
literal|0
index|]
operator|=
literal|3
expr_stmt|;
name|th
operator|->
name|iso88025_shost
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|iso88025_shost
index|[
literal|2
index|]
operator|=
literal|0x40
operator|>>
operator|(
name|sc
operator|->
name|sc_vhid
operator|-
literal|1
operator|)
expr_stmt|;
name|th
operator|->
name|iso88025_shost
index|[
literal|3
index|]
operator|=
literal|0x40000
operator|>>
operator|(
name|sc
operator|->
name|sc_vhid
operator|-
literal|1
operator|)
expr_stmt|;
name|th
operator|->
name|iso88025_shost
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|th
operator|->
name|iso88025_shost
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|printf
argument_list|(
literal|"%s: carp is not supported for the %d interface type\n"
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|ifp
operator|->
name|if_type
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|carp_softc
modifier|*
name|carp_alloc
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|carp_if
modifier|*
name|cif
decl_stmt|;
if|if
condition|(
operator|(
name|cif
operator|=
name|ifp
operator|->
name|if_carp
operator|)
operator|==
name|NULL
condition|)
name|cif
operator|=
name|carp_alloc_if
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|sc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc
argument_list|)
argument_list|,
name|M_CARP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_advbase
operator|=
name|CARP_DFLTINTV
expr_stmt|;
name|sc
operator|->
name|sc_vhid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* required setting */
name|sc
operator|->
name|sc_init_counter
operator|=
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|INIT
expr_stmt|;
name|sc
operator|->
name|sc_ifasiz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ifaddr
operator|*
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifas
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_ifasiz
argument_list|,
name|M_CARP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_carpdev
operator|=
name|ifp
expr_stmt|;
name|CARP_LOCK_INIT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_md_tmo
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_md6_tmo
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|callout_init_mtx
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|,
operator|&
name|sc
operator|->
name|sc_mtx
argument_list|,
name|CALLOUT_RETURNUNLOCKED
argument_list|)
expr_stmt|;
name|CIF_LOCK
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cif
operator|->
name|cif_vrs
argument_list|,
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|CIF_UNLOCK
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|carp_list
argument_list|,
name|sc
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_grow_ifas
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_ifasiz
operator|*
literal|2
argument_list|,
name|M_CARP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_ifas
argument_list|,
name|new
argument_list|,
name|sc
operator|->
name|sc_ifasiz
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_ifas
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifas
operator|=
name|new
expr_stmt|;
name|sc
operator|->
name|sc_ifasiz
operator|*=
literal|2
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_destroy
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|sc
operator|->
name|sc_carpdev
decl_stmt|;
name|struct
name|carp_if
modifier|*
name|cif
init|=
name|ifp
operator|->
name|if_carp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|carp_sx
argument_list|,
name|SA_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_suppress
condition|)
name|carp_demote_adj
argument_list|(
operator|-
name|V_carp_ifdown_adj
argument_list|,
literal|"vhid removed"
argument_list|)
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CIF_LOCK
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cif
operator|->
name|cif_vrs
argument_list|,
name|sc
argument_list|,
name|sc_list
argument_list|)
expr_stmt|;
name|CIF_UNLOCK
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|sc
argument_list|,
name|sc_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_md_tmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|callout_drain
argument_list|(
operator|&
name|sc
operator|->
name|sc_md6_tmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CARP_LOCK_DESTROY
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
operator|->
name|sc_ifas
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sc
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|carp_if
modifier|*
name|carp_alloc_if
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|carp_if
modifier|*
name|cif
decl_stmt|;
name|int
name|error
decl_stmt|;
name|cif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cif
argument_list|)
argument_list|,
name|M_CARP
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|ifpromisc
argument_list|(
name|ifp
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: ifpromisc(%s) failed: %d\n"
argument_list|,
name|__func__
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
name|error
argument_list|)
expr_stmt|;
else|else
name|cif
operator|->
name|cif_flags
operator||=
name|CIF_PROMISC
expr_stmt|;
name|CIF_LOCK_INIT
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|cif
operator|->
name|cif_ifp
operator|=
name|ifp
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cif
operator|->
name|cif_vrs
argument_list|)
expr_stmt|;
name|IF_ADDR_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_carp
operator|=
name|cif
expr_stmt|;
name|if_ref
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|cif
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_free_if
parameter_list|(
name|struct
name|carp_if
modifier|*
name|cif
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|cif
operator|->
name|cif_ifp
decl_stmt|;
name|CIF_LOCK_ASSERT
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cif
operator|->
name|cif_vrs
argument_list|)
argument_list|,
operator|(
literal|"%s: softc list not empty"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|IF_ADDR_WLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_carp
operator|=
name|NULL
expr_stmt|;
name|IF_ADDR_WUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CIF_LOCK_DESTROY
argument_list|(
name|cif
argument_list|)
expr_stmt|;
if|if
condition|(
name|cif
operator|->
name|cif_flags
operator|&
name|CIF_PROMISC
condition|)
name|ifpromisc
argument_list|(
name|ifp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cif
argument_list|,
name|M_CARP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_carprcp
parameter_list|(
name|struct
name|carpreq
modifier|*
name|carpr
parameter_list|,
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|priv
parameter_list|)
block|{
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|carpr
operator|->
name|carpr_state
operator|=
name|sc
operator|->
name|sc_state
expr_stmt|;
name|carpr
operator|->
name|carpr_vhid
operator|=
name|sc
operator|->
name|sc_vhid
expr_stmt|;
name|carpr
operator|->
name|carpr_advbase
operator|=
name|sc
operator|->
name|sc_advbase
expr_stmt|;
name|carpr
operator|->
name|carpr_advskew
operator|=
name|sc
operator|->
name|sc_advskew
expr_stmt|;
if|if
condition|(
name|priv
condition|)
name|bcopy
argument_list|(
name|sc
operator|->
name|sc_key
argument_list|,
name|carpr
operator|->
name|carpr_key
argument_list|,
sizeof|sizeof
argument_list|(
name|carpr
operator|->
name|carpr_key
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bzero
argument_list|(
name|carpr
operator|->
name|carpr_key
argument_list|,
sizeof|sizeof
argument_list|(
name|carpr
operator|->
name|carpr_key
argument_list|)
argument_list|)
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|carp_ioctl
parameter_list|(
name|struct
name|ifreq
modifier|*
name|ifr
parameter_list|,
name|u_long
name|cmd
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|carpreq
name|carpr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|locked
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|ifr
operator|->
name|ifr_data
argument_list|,
operator|&
name|carpr
argument_list|,
sizeof|sizeof
name|carpr
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ifp
operator|=
name|ifunit_ref
argument_list|(
name|ifr
operator|->
name|ifr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_L2VLAN
case|:
case|case
name|IFT_BRIDGE
case|:
case|case
name|IFT_FDDI
case|:
case|case
name|IFT_ISO88025
case|:
break|break;
default|default:
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MULTICAST
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCSVH
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETINET_CARP
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|carpr
operator|.
name|carpr_vhid
operator|<=
literal|0
operator|||
name|carpr
operator|.
name|carpr_vhid
operator|>
name|CARP_MAXVHID
operator|||
name|carpr
operator|.
name|carpr_advbase
operator|<
literal|0
operator|||
name|carpr
operator|.
name|carpr_advskew
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_carp
condition|)
block|{
name|CIF_LOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_vhid
operator|==
name|carpr
operator|.
name|carpr_vhid
condition|)
break|break;
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|sc
operator|=
name|carp_alloc
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_vhid
operator|=
name|carpr
operator|.
name|carpr_vhid
expr_stmt|;
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
index|[
literal|2
index|]
operator|=
literal|0x5e
expr_stmt|;
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
index|[
literal|4
index|]
operator|=
literal|1
expr_stmt|;
name|LLADDR
argument_list|(
operator|&
name|sc
operator|->
name|sc_addr
argument_list|)
index|[
literal|5
index|]
operator|=
name|sc
operator|->
name|sc_vhid
expr_stmt|;
block|}
else|else
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|carpr
operator|.
name|carpr_advbase
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|carpr
operator|.
name|carpr_advbase
operator|>
literal|255
operator|||
name|carpr
operator|.
name|carpr_advbase
operator|<
name|CARP_DFLTINTV
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_advbase
operator|=
name|carpr
operator|.
name|carpr_advbase
expr_stmt|;
block|}
if|if
condition|(
name|carpr
operator|.
name|carpr_advskew
operator|>=
literal|255
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|sc
operator|->
name|sc_advskew
operator|=
name|carpr
operator|.
name|carpr_advskew
expr_stmt|;
if|if
condition|(
name|carpr
operator|.
name|carpr_key
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|bcopy
argument_list|(
name|carpr
operator|.
name|carpr_key
argument_list|,
name|sc
operator|->
name|sc_key
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_key
argument_list|)
argument_list|)
expr_stmt|;
name|carp_hmac_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|INIT
operator|&&
name|carpr
operator|.
name|carpr_state
operator|!=
name|sc
operator|->
name|sc_state
condition|)
block|{
switch|switch
condition|(
name|carpr
operator|.
name|carpr_state
condition|)
block|{
case|case
name|BACKUP
case|:
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|)
expr_stmt|;
name|carp_set_state
argument_list|(
name|sc
argument_list|,
name|BACKUP
argument_list|,
literal|"user requested via ifconfig"
argument_list|)
expr_stmt|;
name|carp_setrun
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|carp_delroute
argument_list|(
name|sc
argument_list|)
expr_stmt|;
break|break;
case|case
name|MASTER
case|:
name|carp_master_down_locked
argument_list|(
name|sc
argument_list|,
literal|"user requested via ifconfig"
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
break|break;
case|case
name|SIOCGVH
case|:
block|{
name|int
name|priveleged
decl_stmt|;
if|if
condition|(
name|carpr
operator|.
name|carpr_vhid
operator|<
literal|0
operator|||
name|carpr
operator|.
name|carpr_vhid
operator|>
name|CARP_MAXVHID
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|carpr
operator|.
name|carpr_count
operator|<
literal|1
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ifp
operator|->
name|if_carp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|priveleged
operator|=
operator|(
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NETINET_CARP
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|carpr
operator|.
name|carpr_vhid
operator|!=
literal|0
condition|)
block|{
name|CIF_LOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_vhid
operator|==
name|carpr
operator|.
name|carpr_vhid
condition|)
break|break;
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
name|carp_carprcp
argument_list|(
operator|&
name|carpr
argument_list|,
name|sc
argument_list|,
name|priveleged
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|carpr
argument_list|,
name|ifr
operator|->
name|ifr_data
argument_list|,
sizeof|sizeof
argument_list|(
name|carpr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|,
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|CIF_LOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|>
name|carpr
operator|.
name|carpr_count
condition|)
block|{
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
name|i
operator|=
literal|0
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
block|{
name|carp_carprcp
argument_list|(
operator|&
name|carpr
argument_list|,
name|sc
argument_list|,
name|priveleged
argument_list|)
expr_stmt|;
name|carpr
operator|.
name|carpr_count
operator|=
name|count
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|carpr
argument_list|,
name|ifr
operator|->
name|ifr_data
operator|+
operator|(
name|i
operator|*
sizeof|sizeof
argument_list|(
name|carpr
argument_list|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|carpr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|locked
condition|)
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|if_rele
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|carp_get_vhid
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
if|if
condition|(
name|ifa
operator|==
name|NULL
operator|||
name|ifa
operator|->
name|ifa_carp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ifa
operator|->
name|ifa_carp
operator|->
name|sc_vhid
operator|)
return|;
block|}
end_function

begin_function
name|int
name|carp_attach
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|int
name|vhid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ifa
operator|->
name|ifa_ifp
decl_stmt|;
name|struct
name|carp_if
modifier|*
name|cif
init|=
name|ifp
operator|->
name|if_carp
decl_stmt|;
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
name|int
name|index
decl_stmt|,
name|error
decl_stmt|;
name|KASSERT
argument_list|(
name|ifa
operator|->
name|ifa_carp
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: ifa %p attached"
operator|,
name|__func__
operator|,
name|ifa
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
operator|(
name|EPROTOTYPE
operator|)
return|;
block|}
name|sx_xlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_carp
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOPROTOOPT
operator|)
return|;
block|}
name|CIF_LOCK
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
if|if
condition|(
name|sc
operator|->
name|sc_vhid
operator|==
name|vhid
condition|)
break|break;
name|CIF_UNLOCK
argument_list|(
name|cif
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|error
operator|=
name|carp_multicast_setup
argument_list|(
name|cif
argument_list|,
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|CIF_FREE
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|index
operator|=
name|sc
operator|->
name|sc_naddrs
operator|+
name|sc
operator|->
name|sc_naddrs6
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|index
operator|>
name|sc
operator|->
name|sc_ifasiz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifaddr
operator|*
argument_list|)
condition|)
name|carp_grow_ifas
argument_list|(
name|sc
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|cif
operator|->
name|cif_naddrs
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_naddrs
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|cif
operator|->
name|cif_naddrs6
operator|++
expr_stmt|;
name|sc
operator|->
name|sc_naddrs6
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|ifa_ref
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_ifas
index|[
name|index
operator|-
literal|1
index|]
operator|=
name|ifa
expr_stmt|;
name|ifa
operator|->
name|ifa_carp
operator|=
name|sc
expr_stmt|;
name|carp_hmac_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|carp_sc_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|carp_detach
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ifa
operator|->
name|ifa_ifp
decl_stmt|;
name|struct
name|carp_if
modifier|*
name|cif
init|=
name|ifp
operator|->
name|if_carp
decl_stmt|;
name|struct
name|carp_softc
modifier|*
name|sc
init|=
name|ifa
operator|->
name|ifa_carp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|index
decl_stmt|;
name|KASSERT
argument_list|(
name|sc
operator|!=
name|NULL
argument_list|,
operator|(
literal|"%s: %p not attached"
operator|,
name|__func__
operator|,
name|ifa
operator|)
argument_list|)
expr_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* Shift array. */
name|index
operator|=
name|sc
operator|->
name|sc_naddrs
operator|+
name|sc
operator|->
name|sc_naddrs6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sc
operator|->
name|sc_ifas
index|[
name|i
index|]
operator|==
name|ifa
condition|)
break|break;
name|KASSERT
argument_list|(
name|i
operator|<
name|index
argument_list|,
operator|(
literal|"%s: %p no backref"
operator|,
name|__func__
operator|,
name|ifa
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|index
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|sc
operator|->
name|sc_ifas
index|[
name|i
index|]
operator|=
name|sc
operator|->
name|sc_ifas
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|sc
operator|->
name|sc_ifas
index|[
name|index
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|cif
operator|->
name|cif_naddrs
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_naddrs
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|cif
operator|->
name|cif_naddrs6
operator|--
expr_stmt|;
name|sc
operator|->
name|sc_naddrs6
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|carp_ifa_delroute
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|carp_multicast_cleanup
argument_list|(
name|cif
argument_list|,
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|ifa
operator|->
name|ifa_carp
operator|=
name|NULL
expr_stmt|;
name|ifa_free
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|carp_hmac_prepare
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|carp_sc_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_naddrs
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_naddrs6
operator|==
literal|0
condition|)
name|carp_destroy
argument_list|(
name|sc
argument_list|)
expr_stmt|;
else|else
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CIF_FREE
argument_list|(
name|cif
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_set_state
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|,
name|int
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_state
operator|!=
name|state
condition|)
block|{
specifier|const
name|char
modifier|*
name|carp_states
index|[]
init|=
block|{
name|CARP_STATES
block|}
decl_stmt|;
name|char
name|subsys
index|[
name|IFNAMSIZ
operator|+
literal|5
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|subsys
argument_list|,
name|IFNAMSIZ
operator|+
literal|5
argument_list|,
literal|"%u@%s"
argument_list|,
name|sc
operator|->
name|sc_vhid
argument_list|,
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|CARP_LOG
argument_list|(
literal|"%s: %s -> %s (%s)\n"
argument_list|,
name|subsys
argument_list|,
name|carp_states
index|[
name|sc
operator|->
name|sc_state
index|]
argument_list|,
name|carp_states
index|[
name|state
index|]
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_state
operator|=
name|state
expr_stmt|;
name|devctl_notify
argument_list|(
literal|"CARP"
argument_list|,
name|subsys
argument_list|,
name|carp_states
index|[
name|state
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|carp_linkstate
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|carp_softc
modifier|*
name|sc
decl_stmt|;
name|CIF_LOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
name|IFNET_FOREACH_CARP
argument_list|(
argument|ifp
argument_list|,
argument|sc
argument_list|)
block|{
name|CARP_LOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|carp_sc_state
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|CARP_UNLOCK
argument_list|(
name|sc
argument_list|)
expr_stmt|;
block|}
name|CIF_UNLOCK
argument_list|(
name|ifp
operator|->
name|if_carp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|carp_sc_state
parameter_list|(
name|struct
name|carp_softc
modifier|*
name|sc
parameter_list|)
block|{
name|CARP_LOCK_ASSERT
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_link_state
operator|!=
name|LINK_STATE_UP
operator|||
operator|!
operator|(
name|sc
operator|->
name|sc_carpdev
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_ad_tmo
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_md_tmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|callout_stop
argument_list|(
operator|&
name|sc
operator|->
name|sc_md6_tmo
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|carp_set_state
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
literal|"hardware interface down"
argument_list|)
expr_stmt|;
name|carp_setrun
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc
operator|->
name|sc_suppress
condition|)
name|carp_demote_adj
argument_list|(
name|V_carp_ifdown_adj
argument_list|,
literal|"interface down"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_suppress
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|carp_set_state
argument_list|(
name|sc
argument_list|,
name|INIT
argument_list|,
literal|"hardware interface up"
argument_list|)
expr_stmt|;
name|carp_setrun
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_suppress
condition|)
name|carp_demote_adj
argument_list|(
operator|-
name|V_carp_ifdown_adj
argument_list|,
literal|"interface up"
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_suppress
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|carp_demote_adj
parameter_list|(
name|int
name|adj
parameter_list|,
name|char
modifier|*
name|reason
parameter_list|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|V_carp_demotion
argument_list|,
name|adj
argument_list|)
expr_stmt|;
name|CARP_LOG
argument_list|(
literal|"demoted by %d to %d (%s)\n"
argument_list|,
name|adj
argument_list|,
name|V_carp_demotion
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|carp_sendall_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|carp_demote_adj_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|new
decl_stmt|,
name|error
decl_stmt|;
name|new
operator|=
name|V_carp_demotion
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|carp_demote_adj
argument_list|(
name|new
argument_list|,
literal|"sysctl"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inetdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|in_carp_protosw
init|=
block|{
operator|.
name|pr_type
operator|=
name|SOCK_RAW
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|inetdomain
block|,
operator|.
name|pr_protocol
operator|=
name|IPPROTO_CARP
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
block|,
operator|.
name|pr_input
operator|=
name|carp_input
block|,
operator|.
name|pr_output
operator|=
name|rip_output
block|,
operator|.
name|pr_ctloutput
operator|=
name|rip_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|rip_usrreqs
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inet6domain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|protosw
name|in6_carp_protosw
init|=
block|{
operator|.
name|pr_type
operator|=
name|SOCK_RAW
block|,
operator|.
name|pr_domain
operator|=
operator|&
name|inet6domain
block|,
operator|.
name|pr_protocol
operator|=
name|IPPROTO_CARP
block|,
operator|.
name|pr_flags
operator|=
name|PR_ATOMIC
operator||
name|PR_ADDR
block|,
operator|.
name|pr_input
operator|=
name|carp6_input
block|,
operator|.
name|pr_output
operator|=
name|rip6_output
block|,
operator|.
name|pr_ctloutput
operator|=
name|rip6_ctloutput
block|,
operator|.
name|pr_usrreqs
operator|=
operator|&
name|rip6_usrreqs
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|carp_mod_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|proto_reg
index|[
name|CARP_INET
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ipproto_unregister
argument_list|(
name|IPPROTO_CARP
argument_list|)
expr_stmt|;
name|pf_proto_unregister
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_CARP
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
name|proto_reg
index|[
name|CARP_INET
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|carp_iamatch_p
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|proto_reg
index|[
name|CARP_INET6
index|]
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ip6proto_unregister
argument_list|(
name|IPPROTO_CARP
argument_list|)
expr_stmt|;
name|pf_proto_unregister
argument_list|(
name|PF_INET6
argument_list|,
name|IPPROTO_CARP
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
name|proto_reg
index|[
name|CARP_INET6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|carp_iamatch6_p
operator|=
name|NULL
expr_stmt|;
name|carp_macmatch6_p
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|carp_ioctl_p
operator|=
name|NULL
expr_stmt|;
name|carp_attach_p
operator|=
name|NULL
expr_stmt|;
name|carp_detach_p
operator|=
name|NULL
expr_stmt|;
name|carp_get_vhid_p
operator|=
name|NULL
expr_stmt|;
name|carp_linkstate_p
operator|=
name|NULL
expr_stmt|;
name|carp_forus_p
operator|=
name|NULL
expr_stmt|;
name|carp_output_p
operator|=
name|NULL
expr_stmt|;
name|carp_demote_adj_p
operator|=
name|NULL
expr_stmt|;
name|carp_master_p
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|carp_sendall_task
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|carp_sx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|carp_mod_load
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|carp_mtx
argument_list|,
literal|"carp_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|carp_sx
argument_list|,
literal|"carp_sx"
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|carp_list
argument_list|)
expr_stmt|;
name|carp_get_vhid_p
operator|=
name|carp_get_vhid
expr_stmt|;
name|carp_forus_p
operator|=
name|carp_forus
expr_stmt|;
name|carp_output_p
operator|=
name|carp_output
expr_stmt|;
name|carp_linkstate_p
operator|=
name|carp_linkstate
expr_stmt|;
name|carp_ioctl_p
operator|=
name|carp_ioctl
expr_stmt|;
name|carp_attach_p
operator|=
name|carp_attach
expr_stmt|;
name|carp_detach_p
operator|=
name|carp_detach
expr_stmt|;
name|carp_demote_adj_p
operator|=
name|carp_demote_adj
expr_stmt|;
name|carp_master_p
operator|=
name|carp_master
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|carp_iamatch6_p
operator|=
name|carp_iamatch6
expr_stmt|;
name|carp_macmatch6_p
operator|=
name|carp_macmatch6
expr_stmt|;
name|proto_reg
index|[
name|CARP_INET6
index|]
operator|=
name|pf_proto_register
argument_list|(
name|PF_INET6
argument_list|,
operator|(
expr|struct
name|protosw
operator|*
operator|)
operator|&
name|in6_carp_protosw
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto_reg
index|[
name|CARP_INET6
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"carp: error %d attaching to PF_INET6\n"
argument_list|,
name|proto_reg
index|[
name|CARP_INET6
index|]
argument_list|)
expr_stmt|;
name|carp_mod_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|proto_reg
index|[
name|CARP_INET6
index|]
operator|)
return|;
block|}
name|err
operator|=
name|ip6proto_register
argument_list|(
name|IPPROTO_CARP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"carp: error %d registering with INET6\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|carp_mod_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|carp_iamatch_p
operator|=
name|carp_iamatch
expr_stmt|;
name|proto_reg
index|[
name|CARP_INET
index|]
operator|=
name|pf_proto_register
argument_list|(
name|PF_INET
argument_list|,
operator|&
name|in_carp_protosw
argument_list|)
expr_stmt|;
if|if
condition|(
name|proto_reg
index|[
name|CARP_INET
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"carp: error %d attaching to PF_INET\n"
argument_list|,
name|proto_reg
index|[
name|CARP_INET
index|]
argument_list|)
expr_stmt|;
name|carp_mod_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|proto_reg
index|[
name|CARP_INET
index|]
operator|)
return|;
block|}
name|err
operator|=
name|ipproto_register
argument_list|(
name|IPPROTO_CARP
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|printf
argument_list|(
literal|"carp: error %d registering with INET\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|carp_mod_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|carp_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
return|return
name|carp_mod_load
argument_list|()
return|;
comment|/* NOTREACHED */
case|case
name|MOD_UNLOAD
case|:
name|mtx_lock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|carp_list
argument_list|)
condition|)
name|carp_mod_cleanup
argument_list|()
expr_stmt|;
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|carp_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|carp_mod
init|=
block|{
literal|"carp"
block|,
name|carp_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|carp
argument_list|,
name|carp_mod
argument_list|,
name|SI_SUB_PROTO_DOMAIN
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

