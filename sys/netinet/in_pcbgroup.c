begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2010-2011 Juniper Networks, Inc.  * All rights reserved.  *  * This software was developed by Robert N. M. Watson under contract  * to Juniper Networks, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_comment
comment|/*  * pcbgroups, or "connection groups" are based on Willman, Rixner, and Cox's  * 2006 USENIX paper, "An Evaluation of Network Stack Parallelization  * Strategies in Modern Operating Systems".  This implementation differs  * significantly from that described in the paper, in that it attempts to  * introduce not just notions of affinity for connections and distribute work  * so as to reduce lock contention, but also align those notions with  * hardware work distribution strategies such as RSS.  In this construction,  * connection groups supplement, rather than replace, existing reservation  * tables for protocol 4-tuples, offering CPU-affine lookup tables with  * minimal cache line migration and lock contention during steady state  * operation.  *  * Hardware-offloaded checksums are often inefficient in software -- for  * example, Toeplitz, specified by RSS, introduced a significant overhead if  * performed during per-packge processing.  It is therefore desirable to fall  * back on traditional reservation table lookups without affinity where  * hardware-offloaded checksums aren't available, such as for traffic over  * non-RSS interfaces.  *  * Internet protocols, such as UDP and TCP, register to use connection groups  * by providing an ipi_hashfields value other than IPI_HASHFIELDS_NONE; this  * indicates to the connection group code whether a 2-tuple or 4-tuple is  * used as an argument to hashes that assign a connection to a particular  * group.  This must be aligned with any hardware offloaded distribution  * model, such as RSS or similar approaches taken in embedded network boards.  * Wildcard sockets require special handling, as in Willman 2006, and are  * shared between connection groups -- while being protected by group-local  * locks.  This means that connection establishment and teardown can be  * signficantly more expensive than without connection groups, but that  * steady-state processing can be significantly faster.  *  * When RSS is used, certain connection group parameters, such as the number  * of groups, are provided by the RSS implementation, found in in_rss.c.  * Otherwise, in_pcbgroup.c selects possible sensible parameters  * corresponding to the degree of parallelism exposed by netisr.  *  * Most of the implementation of connection groups is in this file; however,  * connection group lookup is implemented in in_pcb.c alongside reservation  * table lookups -- see in_pcblookup_group().  *  * TODO:  *  * Implement dynamic rebalancing of buckets with connection groups; when  * load is unevenly distributed, search for more optimal balancing on  * demand.  This might require scaling up the number of connection groups  * by<<1.  *  * Provide an IP 2-tuple or 4-tuple netisr m2cpu handler based on connection  * groups for ip_input and ip6_input, allowing non-offloaded work  * distribution.  *  * Expose effective CPU affinity of connections to userspace using socket  * options.  *  * Investigate per-connection affinity overrides based on socket options; an  * option could be set, certainly resulting in work being distributed  * differently in software, and possibly propagated to supporting hardware  * with TCAMs or hardware hash tables.  This might require connections to  * exist in more than one connection group at a time.  *  * Hook netisr thread reconfiguration events, and propagate those to RSS so  * that rebalancing can occur when the thread pool grows or shrinks.  *  * Expose per-pcbgroup statistics to userspace monitoring tools such as  * netstat, in order to allow better debugging and profiling.  */
end_comment

begin_function
name|void
name|in_pcbgroup_init
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|,
name|u_int
name|hashfields
parameter_list|,
name|int
name|hash_nelements
parameter_list|)
block|{
name|struct
name|inpcbgroup
modifier|*
name|pcbgroup
decl_stmt|;
name|u_int
name|numpcbgroups
decl_stmt|,
name|pgn
decl_stmt|;
comment|/* 	 * Only enable connection groups for a protocol if it has been 	 * specifically requested. 	 */
if|if
condition|(
name|hashfields
operator|==
name|IPI_HASHFIELDS_NONE
condition|)
return|return;
comment|/* 	 * Connection groups are about multi-processor load distribution, 	 * lock contention, and connection CPU affinity.  As such, no point 	 * in turning them on for a uniprocessor machine, it only wastes 	 * memory. 	 */
if|if
condition|(
name|mp_ncpus
operator|==
literal|1
condition|)
return|return;
ifdef|#
directive|ifdef
name|RSS
comment|/* 	 * If we're using RSS, then RSS determines the number of connection 	 * groups to use: one connection group per RSS bucket.  If for some 	 * reason RSS isn't able to provide a number of buckets, disable 	 * connection groups entirely. 	 * 	 * XXXRW: Can this ever happen? 	 */
name|numpcbgroups
operator|=
name|rss_getnumbuckets
argument_list|()
expr_stmt|;
if|if
condition|(
name|numpcbgroups
operator|==
literal|0
condition|)
return|return;
else|#
directive|else
comment|/* 	 * Otherwise, we'll just use one per CPU for now.  If we decide to 	 * do dynamic rebalancing a la RSS, we'll need similar logic here. 	 */
name|numpcbgroups
operator|=
name|mp_ncpus
expr_stmt|;
endif|#
directive|endif
name|pcbinfo
operator|->
name|ipi_hashfields
operator|=
name|hashfields
expr_stmt|;
name|pcbinfo
operator|->
name|ipi_pcbgroups
operator|=
name|malloc
argument_list|(
name|numpcbgroups
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pcbinfo
operator|->
name|ipi_pcbgroups
argument_list|)
argument_list|,
name|M_PCB
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|pcbinfo
operator|->
name|ipi_npcbgroups
operator|=
name|numpcbgroups
expr_stmt|;
name|pcbinfo
operator|->
name|ipi_wildbase
operator|=
name|hashinit
argument_list|(
name|hash_nelements
argument_list|,
name|M_PCB
argument_list|,
operator|&
name|pcbinfo
operator|->
name|ipi_wildmask
argument_list|)
expr_stmt|;
for|for
control|(
name|pgn
operator|=
literal|0
init|;
name|pgn
operator|<
name|pcbinfo
operator|->
name|ipi_npcbgroups
condition|;
name|pgn
operator|++
control|)
block|{
name|pcbgroup
operator|=
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|pgn
index|]
expr_stmt|;
name|pcbgroup
operator|->
name|ipg_hashbase
operator|=
name|hashinit
argument_list|(
name|hash_nelements
argument_list|,
name|M_PCB
argument_list|,
operator|&
name|pcbgroup
operator|->
name|ipg_hashmask
argument_list|)
expr_stmt|;
name|INP_GROUP_LOCK_INIT
argument_list|(
name|pcbgroup
argument_list|,
literal|"pcbgroup"
argument_list|)
expr_stmt|;
comment|/* 		 * Initialise notional affinity of the pcbgroup -- for RSS, 		 * we want the same notion of affinity as NICs to be used.  In 		 * the non-RSS case, just round robin for the time being. 		 * 		 * XXXRW: The notion of a bucket to CPU mapping is common at 		 * both pcbgroup and RSS layers -- does that mean that we 		 * should migrate it all from RSS to here, and just leave RSS 		 * responsible only for providing hashing and mapping funtions? 		 */
ifdef|#
directive|ifdef
name|RSS
name|pcbgroup
operator|->
name|ipg_cpu
operator|=
name|rss_getcpu
argument_list|(
name|pgn
argument_list|)
expr_stmt|;
else|#
directive|else
name|pcbgroup
operator|->
name|ipg_cpu
operator|=
operator|(
name|pgn
operator|%
name|mp_ncpus
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|in_pcbgroup_destroy
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|)
block|{
name|struct
name|inpcbgroup
modifier|*
name|pcbgroup
decl_stmt|;
name|u_int
name|pgn
decl_stmt|;
if|if
condition|(
name|pcbinfo
operator|->
name|ipi_npcbgroups
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|pgn
operator|=
literal|0
init|;
name|pgn
operator|<
name|pcbinfo
operator|->
name|ipi_npcbgroups
condition|;
name|pgn
operator|++
control|)
block|{
name|pcbgroup
operator|=
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|pgn
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
name|pcbinfo
operator|->
name|ipi_listhead
argument_list|)
argument_list|,
operator|(
literal|"in_pcbinfo_destroy: listhead not empty"
operator|)
argument_list|)
expr_stmt|;
name|INP_GROUP_LOCK_DESTROY
argument_list|(
name|pcbgroup
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|pcbgroup
operator|->
name|ipg_hashbase
argument_list|,
name|M_PCB
argument_list|,
name|pcbgroup
operator|->
name|ipg_hashmask
argument_list|)
expr_stmt|;
block|}
name|hashdestroy
argument_list|(
name|pcbinfo
operator|->
name|ipi_wildbase
argument_list|,
name|M_PCB
argument_list|,
name|pcbinfo
operator|->
name|ipi_wildmask
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pcbinfo
operator|->
name|ipi_pcbgroups
argument_list|,
name|M_PCB
argument_list|)
expr_stmt|;
name|pcbinfo
operator|->
name|ipi_pcbgroups
operator|=
name|NULL
expr_stmt|;
name|pcbinfo
operator|->
name|ipi_npcbgroups
operator|=
literal|0
expr_stmt|;
name|pcbinfo
operator|->
name|ipi_hashfields
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a hash of whatever the covered tuple might be, return a pcbgroup  * index.  Where RSS is supported, try to align bucket selection with RSS CPU  * affinity strategy.  */
end_comment

begin_function
specifier|static
name|__inline
name|u_int
name|in_pcbgroup_getbucket
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RSS
return|return
operator|(
name|rss_getbucket
argument_list|(
name|hash
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|hash
operator|%
name|pcbinfo
operator|->
name|ipi_npcbgroups
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Map a (hashtype, hash) tuple into a connection group, or NULL if the hash  * information is insufficient to identify the pcbgroup.  This might occur if  * a TCP packet turns up with a 2-tuple hash, or if an RSS hash is present but  * RSS is not compiled into the kernel.  */
end_comment

begin_function
name|struct
name|inpcbgroup
modifier|*
name|in_pcbgroup_byhash
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|,
name|u_int
name|hashtype
parameter_list|,
name|uint32_t
name|hash
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
operator|(
name|pcbinfo
operator|->
name|ipi_hashfields
operator|==
name|IPI_HASHFIELDS_4TUPLE
operator|&&
name|hashtype
operator|==
name|M_HASHTYPE_RSS_TCP_IPV4
operator|)
operator|||
operator|(
name|pcbinfo
operator|->
name|ipi_hashfields
operator|==
name|IPI_HASHFIELDS_4TUPLE
operator|&&
name|hashtype
operator|==
name|M_HASHTYPE_RSS_UDP_IPV4
operator|)
operator|||
operator|(
name|pcbinfo
operator|->
name|ipi_hashfields
operator|==
name|IPI_HASHFIELDS_2TUPLE
operator|&&
name|hashtype
operator|==
name|M_HASHTYPE_RSS_IPV4
operator|)
condition|)
return|return
operator|(
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|in_pcbgroup_getbucket
argument_list|(
name|pcbinfo
argument_list|,
name|hash
argument_list|)
index|]
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|inpcbgroup
modifier|*
name|in_pcbgroup_bymbuf
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
return|return
operator|(
name|in_pcbgroup_byhash
argument_list|(
name|pcbinfo
argument_list|,
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|inpcbgroup
modifier|*
name|in_pcbgroup_bytuple
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|,
name|struct
name|in_addr
name|laddr
parameter_list|,
name|u_short
name|lport
parameter_list|,
name|struct
name|in_addr
name|faddr
parameter_list|,
name|u_short
name|fport
parameter_list|)
block|{
name|uint32_t
name|hash
decl_stmt|;
comment|/* 	 * RSS note: we pass foreign addr/port as source, and local addr/port 	 * as destination, as we want to align with what the hardware is 	 * doing. 	 */
switch|switch
condition|(
name|pcbinfo
operator|->
name|ipi_hashfields
condition|)
block|{
case|case
name|IPI_HASHFIELDS_4TUPLE
case|:
ifdef|#
directive|ifdef
name|RSS
name|hash
operator|=
name|rss_hash_ip4_4tuple
argument_list|(
name|faddr
argument_list|,
name|fport
argument_list|,
name|laddr
argument_list|,
name|lport
argument_list|)
expr_stmt|;
else|#
directive|else
name|hash
operator|=
name|faddr
operator|.
name|s_addr
operator|^
name|fport
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IPI_HASHFIELDS_2TUPLE
case|:
ifdef|#
directive|ifdef
name|RSS
name|hash
operator|=
name|rss_hash_ip4_2tuple
argument_list|(
name|faddr
argument_list|,
name|laddr
argument_list|)
expr_stmt|;
else|#
directive|else
name|hash
operator|=
name|faddr
operator|.
name|s_addr
operator|^
name|laddr
operator|.
name|s_addr
expr_stmt|;
endif|#
directive|endif
break|break;
default|default:
name|hash
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|in_pcbgroup_getbucket
argument_list|(
name|pcbinfo
argument_list|,
name|hash
argument_list|)
index|]
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|inpcbgroup
modifier|*
name|in_pcbgroup_byinpcb
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RSS
comment|/* 	 * Listen sockets with INP_RSS_BUCKET_SET set have a pre-determined 	 * RSS bucket and thus we should use this pcbgroup, rather than 	 * using a tuple or hash. 	 * 	 * XXX should verify that there's actually pcbgroups and inp_rss_listen_bucket 	 * fits in that! 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_RSS_BUCKET_SET
condition|)
return|return
operator|(
operator|&
name|inp
operator|->
name|inp_pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|inp
operator|->
name|inp_rss_listen_bucket
index|]
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
name|in_pcbgroup_bytuple
argument_list|(
name|inp
operator|->
name|inp_pcbinfo
argument_list|,
name|inp
operator|->
name|inp_laddr
argument_list|,
name|inp
operator|->
name|inp_lport
argument_list|,
name|inp
operator|->
name|inp_faddr
argument_list|,
name|inp
operator|->
name|inp_fport
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_pcbwild_add
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|inpcbhead
modifier|*
name|head
decl_stmt|;
name|u_int
name|pgn
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
operator|)
argument_list|,
operator|(
literal|"%s: is wild"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|pcbinfo
operator|=
name|inp
operator|->
name|inp_pcbinfo
expr_stmt|;
for|for
control|(
name|pgn
operator|=
literal|0
init|;
name|pgn
operator|<
name|pcbinfo
operator|->
name|ipi_npcbgroups
condition|;
name|pgn
operator|++
control|)
name|INP_GROUP_LOCK
argument_list|(
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|pgn
index|]
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|pcbinfo
operator|->
name|ipi_wildbase
index|[
name|INP_PCBHASH
argument_list|(
name|INADDR_ANY
argument_list|,
name|inp
operator|->
name|inp_lport
argument_list|,
literal|0
argument_list|,
name|pcbinfo
operator|->
name|ipi_wildmask
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|inp
argument_list|,
name|inp_pcbgroup_wild
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_flags2
operator||=
name|INP_PCBGROUPWILD
expr_stmt|;
for|for
control|(
name|pgn
operator|=
literal|0
init|;
name|pgn
operator|<
name|pcbinfo
operator|->
name|ipi_npcbgroups
condition|;
name|pgn
operator|++
control|)
name|INP_GROUP_UNLOCK
argument_list|(
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|pgn
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_pcbwild_remove
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|u_int
name|pgn
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
operator|)
argument_list|,
operator|(
literal|"%s: not wild"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|pcbinfo
operator|=
name|inp
operator|->
name|inp_pcbinfo
expr_stmt|;
for|for
control|(
name|pgn
operator|=
literal|0
init|;
name|pgn
operator|<
name|pcbinfo
operator|->
name|ipi_npcbgroups
condition|;
name|pgn
operator|++
control|)
name|INP_GROUP_LOCK
argument_list|(
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|pgn
index|]
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|inp_pcbgroup_wild
argument_list|)
expr_stmt|;
for|for
control|(
name|pgn
operator|=
literal|0
init|;
name|pgn
operator|<
name|pcbinfo
operator|->
name|ipi_npcbgroups
condition|;
name|pgn
operator|++
control|)
name|INP_GROUP_UNLOCK
argument_list|(
operator|&
name|pcbinfo
operator|->
name|ipi_pcbgroups
index|[
name|pgn
index|]
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_flags2
operator|&=
operator|~
name|INP_PCBGROUPWILD
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|in_pcbwild_needed
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|RSS
comment|/* 	 * If it's a listen socket and INP_RSS_BUCKET_SET is set, 	 * it's a wildcard socket _but_ it's in a specific pcbgroup. 	 * Thus we don't treat it as a pcbwild inp. 	 */
if|if
condition|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_RSS_BUCKET_SET
condition|)
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
return|return
operator|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
operator|)
return|;
else|else
endif|#
directive|endif
return|return
operator|(
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
operator|==
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|in_pcbwild_update_internal
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|int
name|wildcard_needed
decl_stmt|;
name|wildcard_needed
operator|=
name|in_pcbwild_needed
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|wildcard_needed
operator|&&
operator|!
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
operator|)
condition|)
name|in_pcbwild_add
argument_list|(
name|inp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|wildcard_needed
operator|&&
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
operator|)
condition|)
name|in_pcbwild_remove
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the pcbgroup of an inpcb, which might include removing an old  * pcbgroup reference and/or adding a new one.  Wildcard processing is not  * performed here, although ideally we'll never install a pcbgroup for a  * wildcard inpcb (asserted below).  */
end_comment

begin_function
specifier|static
name|void
name|in_pcbgroup_update_internal
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|,
name|struct
name|inpcbgroup
modifier|*
name|newpcbgroup
parameter_list|,
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|inpcbgroup
modifier|*
name|oldpcbgroup
decl_stmt|;
name|struct
name|inpcbhead
modifier|*
name|pcbhash
decl_stmt|;
name|uint32_t
name|hashkey_faddr
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|oldpcbgroup
operator|=
name|inp
operator|->
name|inp_pcbgroup
expr_stmt|;
if|if
condition|(
name|oldpcbgroup
operator|!=
name|NULL
operator|&&
name|oldpcbgroup
operator|!=
name|newpcbgroup
condition|)
block|{
name|INP_GROUP_LOCK
argument_list|(
name|oldpcbgroup
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|inp_pcbgrouphash
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_pcbgroup
operator|=
name|NULL
expr_stmt|;
name|INP_GROUP_UNLOCK
argument_list|(
name|oldpcbgroup
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newpcbgroup
operator|!=
name|NULL
operator|&&
name|oldpcbgroup
operator|!=
name|newpcbgroup
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
name|hashkey_faddr
operator|=
name|INP6_PCBHASHKEY
argument_list|(
operator|&
name|inp
operator|->
name|in6p_faddr
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|hashkey_faddr
operator|=
name|inp
operator|->
name|inp_faddr
operator|.
name|s_addr
expr_stmt|;
name|INP_GROUP_LOCK
argument_list|(
name|newpcbgroup
argument_list|)
expr_stmt|;
comment|/* 		 * If the inp is an RSS bucket wildcard entry, ensure 		 * that the PCB hash is calculated correctly. 		 * 		 * The wildcard hash calculation differs from the 		 * non-wildcard definition.  The source address is 		 * INADDR_ANY and the far port is 0. 		 */
if|if
condition|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_RSS_BUCKET_SET
condition|)
block|{
name|pcbhash
operator|=
operator|&
name|newpcbgroup
operator|->
name|ipg_hashbase
index|[
name|INP_PCBHASH
argument_list|(
name|INADDR_ANY
argument_list|,
name|inp
operator|->
name|inp_lport
argument_list|,
literal|0
argument_list|,
name|newpcbgroup
operator|->
name|ipg_hashmask
argument_list|)
index|]
expr_stmt|;
block|}
else|else
block|{
name|pcbhash
operator|=
operator|&
name|newpcbgroup
operator|->
name|ipg_hashbase
index|[
name|INP_PCBHASH
argument_list|(
name|hashkey_faddr
argument_list|,
name|inp
operator|->
name|inp_lport
argument_list|,
name|inp
operator|->
name|inp_fport
argument_list|,
name|newpcbgroup
operator|->
name|ipg_hashmask
argument_list|)
index|]
expr_stmt|;
block|}
name|LIST_INSERT_HEAD
argument_list|(
name|pcbhash
argument_list|,
name|inp
argument_list|,
name|inp_pcbgrouphash
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_pcbgroup
operator|=
name|newpcbgroup
expr_stmt|;
name|INP_GROUP_UNLOCK
argument_list|(
name|newpcbgroup
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|!
operator|(
name|newpcbgroup
operator|!=
name|NULL
operator|&&
name|in_pcbwild_needed
argument_list|(
name|inp
argument_list|)
operator|)
argument_list|,
operator|(
literal|"%s: pcbgroup and wildcard!"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Two update paths: one in which the 4-tuple on an inpcb has been updated  * and therefore connection groups may need to change (or a wildcard entry  * may needed to be installed), and another in which the 4-tuple has been  * set as a result of a packet received, in which case we may be able to use  * the hash on the mbuf to avoid doing a software hash calculation for RSS.  *  * In each case: first, let the wildcard code have a go at placing it as a  * wildcard socket.  If it was a wildcard, or if the connection has been  * dropped, then no pcbgroup is required (so potentially clear it);  * otherwise, calculate and update the pcbgroup for the inpcb.  */
end_comment

begin_function
name|void
name|in_pcbgroup_update
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|inpcbgroup
modifier|*
name|newpcbgroup
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|pcbinfo
operator|=
name|inp
operator|->
name|inp_pcbinfo
expr_stmt|;
if|if
condition|(
operator|!
name|in_pcbgroup_enabled
argument_list|(
name|pcbinfo
argument_list|)
condition|)
return|return;
name|in_pcbwild_update_internal
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
operator|)
operator|&&
operator|!
operator|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
name|newpcbgroup
operator|=
name|in6_pcbgroup_byinpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|newpcbgroup
operator|=
name|in_pcbgroup_byinpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
name|newpcbgroup
operator|=
name|NULL
expr_stmt|;
name|in_pcbgroup_update_internal
argument_list|(
name|pcbinfo
argument_list|,
name|newpcbgroup
argument_list|,
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|in_pcbgroup_update_mbuf
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
decl_stmt|;
name|struct
name|inpcbgroup
modifier|*
name|newpcbgroup
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|pcbinfo
operator|=
name|inp
operator|->
name|inp_pcbinfo
expr_stmt|;
if|if
condition|(
operator|!
name|in_pcbgroup_enabled
argument_list|(
name|pcbinfo
argument_list|)
condition|)
return|return;
comment|/* 	 * Possibly should assert !INP_PCBGROUPWILD rather than testing for 	 * it; presumably this function should never be called for anything 	 * other than non-wildcard socket? 	 */
name|in_pcbwild_update_internal
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
operator|)
operator|&&
operator|!
operator|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DROPPED
operator|)
condition|)
block|{
name|newpcbgroup
operator|=
name|in_pcbgroup_bymbuf
argument_list|(
name|pcbinfo
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|inp_vflag
operator|&
name|INP_IPV6
condition|)
block|{
if|if
condition|(
name|newpcbgroup
operator|==
name|NULL
condition|)
name|newpcbgroup
operator|=
name|in6_pcbgroup_byinpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
name|newpcbgroup
operator|==
name|NULL
condition|)
name|newpcbgroup
operator|=
name|in_pcbgroup_byinpcb
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
block|}
else|else
name|newpcbgroup
operator|=
name|NULL
expr_stmt|;
name|in_pcbgroup_update_internal
argument_list|(
name|pcbinfo
argument_list|,
name|newpcbgroup
argument_list|,
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove pcbgroup entry and optional pcbgroup wildcard entry for this inpcb.  */
end_comment

begin_function
name|void
name|in_pcbgroup_remove
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|inpcbgroup
modifier|*
name|pcbgroup
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_pcbgroup_enabled
argument_list|(
name|inp
operator|->
name|inp_pcbinfo
argument_list|)
condition|)
return|return;
if|if
condition|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_PCBGROUPWILD
condition|)
name|in_pcbwild_remove
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|pcbgroup
operator|=
name|inp
operator|->
name|inp_pcbgroup
expr_stmt|;
if|if
condition|(
name|pcbgroup
operator|!=
name|NULL
condition|)
block|{
name|INP_GROUP_LOCK
argument_list|(
name|pcbgroup
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|inp
argument_list|,
name|inp_pcbgrouphash
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_pcbgroup
operator|=
name|NULL
expr_stmt|;
name|INP_GROUP_UNLOCK
argument_list|(
name|pcbgroup
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Query whether or not it is appropriate to use pcbgroups to look up inpcbs  * for a protocol.  */
end_comment

begin_function
name|int
name|in_pcbgroup_enabled
parameter_list|(
name|struct
name|inpcbinfo
modifier|*
name|pcbinfo
parameter_list|)
block|{
return|return
operator|(
name|pcbinfo
operator|->
name|ipi_npcbgroups
operator|>
literal|0
operator|)
return|;
block|}
end_function

end_unit

