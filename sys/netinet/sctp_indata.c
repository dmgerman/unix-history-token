begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_indata.c,v 1.36 2005/03/06 16:04:17 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_define
define|#
directive|define
name|SCTP_CALC_TSN_TO_GAP
parameter_list|(
name|gap
parameter_list|,
name|tsn
parameter_list|,
name|mapping_tsn
parameter_list|)
value|do { \ 					if ((compare_with_wrap(tsn, mapping_tsn, MAX_TSN)) || \                         (tsn == mapping_tsn)) { \ 						gap = tsn - mapping_tsn; \ 					} else { \ 						gap = (MAX_TSN - mapping_tsn) + tsn + 1; \ 					} \                   } while(0)
end_define

begin_define
define|#
directive|define
name|SCTP_REVERSE_OUT_TSN_PRES
parameter_list|(
name|nr_gap
parameter_list|,
name|tsn
parameter_list|,
name|asoc
parameter_list|)
value|do { \                     if (asoc->mapping_array_base_tsn == asoc->nr_mapping_array_base_tsn) { \                        SCTP_UNSET_TSN_PRESENT(asoc->mapping_array, nr_gap); \                     } else {\                        int lgap; \                        SCTP_CALC_TSN_TO_GAP(lgap, tsn, asoc->mapping_array_base_tsn); \                        SCTP_UNSET_TSN_PRESENT(asoc->mapping_array, lgap); \                     } \                   } while(0)
end_define

begin_comment
comment|/*  * NOTES: On the outbound side of things I need to check the sack timer to  * see if I should generate a sack into the chunk queue (if I have data to  * send that is and will be sending it .. for bundling.  *  * The callback in sctp_usrreq.c will get called when the socket is read from.  * This will cause sctp_service_queues() to get called on the top entry in  * the list.  */
end_comment

begin_function
name|void
name|sctp_set_rwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|asoc
operator|->
name|my_rwnd
operator|=
name|sctp_calc_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate what the rwnd would be */
end_comment

begin_function
name|uint32_t
name|sctp_calc_rwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|uint32_t
name|calc
init|=
literal|0
decl_stmt|;
comment|/* 	 * This is really set wrong with respect to a 1-2-m socket. Since 	 * the sb_cc is the count that everyone as put up. When we re-write 	 * sctp_soreceive then we will fix this so that ONLY this 	 * associations data is taken into account. 	 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
return|return
operator|(
name|calc
operator|)
return|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_reasm_queue
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_all_streams
operator|==
literal|0
condition|)
block|{
comment|/* Full rwnd granted */
name|calc
operator|=
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
expr_stmt|;
return|return
operator|(
name|calc
operator|)
return|;
block|}
comment|/* get actual space */
name|calc
operator|=
operator|(
name|uint32_t
operator|)
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * take out what has NOT been put on socket queue and we yet hold 	 * for putting up. 	 */
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|)
expr_stmt|;
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|size_on_all_streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc
operator|==
literal|0
condition|)
block|{
comment|/* out of space */
return|return
operator|(
name|calc
operator|)
return|;
block|}
comment|/* what is the overhead of all these rwnd's */
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd_control_len
argument_list|)
expr_stmt|;
comment|/* 	 * If the window gets too small due to ctrl-stuff, reduce it to 1, 	 * even it is 0. SWS engaged 	 */
if|if
condition|(
name|calc
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd_control_len
condition|)
block|{
name|calc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|calc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build out our readq entry based on the incoming packet.  */
end_comment

begin_function
name|struct
name|sctp_queued_to_read
modifier|*
name|sctp_build_readq_entry
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint32_t
name|ppid
parameter_list|,
name|uint32_t
name|context
parameter_list|,
name|uint16_t
name|stream_no
parameter_list|,
name|uint16_t
name|stream_seq
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|dm
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|read_queue_e
init|=
name|NULL
decl_stmt|;
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|read_queue_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_queue_e
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_build
goto|;
block|}
name|read_queue_e
operator|->
name|sinfo_stream
operator|=
name|stream_no
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ssn
operator|=
name|stream_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_flags
operator|=
operator|(
name|flags
operator|<<
literal|8
operator|)
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ppid
operator|=
name|ppid
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_timetolive
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_tsn
operator|=
name|tsn
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_cumtsn
operator|=
name|tsn
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|whoFrom
operator|=
name|net
expr_stmt|;
name|read_queue_e
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|data
operator|=
name|dm
expr_stmt|;
name|read_queue_e
operator|->
name|spec_flags
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|read_queue_e
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
name|read_queue_e
operator|->
name|stcb
operator|=
name|stcb
expr_stmt|;
name|read_queue_e
operator|->
name|port_from
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|read_queue_e
operator|->
name|do_not_ref_stcb
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|end_added
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|some_taken
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|pdapi_aborted
operator|=
literal|0
expr_stmt|;
name|failed_build
label|:
return|return
operator|(
name|read_queue_e
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build out our readq entry based on the incoming packet.  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_queued_to_read
modifier|*
name|sctp_build_readq_entry_chk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|read_queue_e
init|=
name|NULL
decl_stmt|;
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|read_queue_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_queue_e
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_build
goto|;
block|}
name|read_queue_e
operator|->
name|sinfo_stream
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ssn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_flags
operator|=
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|<<
literal|8
operator|)
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_timetolive
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_cumtsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|whoFrom
operator|=
name|chk
operator|->
name|whoTo
expr_stmt|;
name|read_queue_e
operator|->
name|aux_data
operator|=
name|NULL
expr_stmt|;
name|read_queue_e
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|read_queue_e
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|read_queue_e
operator|->
name|stcb
operator|=
name|stcb
expr_stmt|;
name|read_queue_e
operator|->
name|port_from
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|read_queue_e
operator|->
name|spec_flags
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|do_not_ref_stcb
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|end_added
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|some_taken
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|pdapi_aborted
operator|=
literal|0
expr_stmt|;
name|failed_build
label|:
return|return
operator|(
name|read_queue_e
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_build_ctl_nchunk
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sinfo
parameter_list|)
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|outinfo
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ret
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|use_extended
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
block|{
comment|/* user does not want the sndrcv ctl */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
condition|)
block|{
name|use_extended
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* No space */
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* We need a CMSG header followed by the struct  */
name|cmh
operator|=
name|mtod
argument_list|(
name|ret
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|outinfo
operator|=
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmh
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_level
operator|=
name|IPPROTO_SCTP
expr_stmt|;
if|if
condition|(
name|use_extended
condition|)
block|{
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_EXTRCV
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|outinfo
argument_list|,
name|sinfo
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_SNDRCV
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|len
expr_stmt|;
operator|*
name|outinfo
operator|=
operator|*
name|sinfo
expr_stmt|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|=
name|cmh
operator|->
name|cmsg_len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|sctp_build_ctl_cchunk
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|int
modifier|*
name|control_len
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sinfo
parameter_list|)
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|outinfo
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmh
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|use_extended
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
block|{
comment|/* user does not want the sndrcv ctl */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
condition|)
block|{
name|use_extended
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SCTP_MALLOC
argument_list|(
name|buf
argument_list|,
name|char
operator|*
argument_list|,
name|len
argument_list|,
name|SCTP_M_CMSG
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
comment|/* No space */
return|return
operator|(
name|buf
operator|)
return|;
block|}
comment|/* We need a CMSG header followed by the struct  */
name|cmh
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|buf
expr_stmt|;
name|outinfo
operator|=
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmh
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_level
operator|=
name|IPPROTO_SCTP
expr_stmt|;
if|if
condition|(
name|use_extended
condition|)
block|{
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_EXTRCV
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|outinfo
argument_list|,
name|sinfo
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_SNDRCV
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|len
expr_stmt|;
operator|*
name|outinfo
operator|=
operator|*
name|sinfo
expr_stmt|;
block|}
operator|*
name|control_len
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We are delivering currently from the reassembly queue. We must continue to  * deliver until we either: 1) run out of space. 2) run out of sequential  * TSN's 3) hit the SCTP_DATA_LAST_FRAG flag.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_service_reassembly
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
name|uint16_t
name|stream_no
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|cntDel
decl_stmt|;
comment|/* EY if any out-of-order delivered, then tag it nr on nr_map */
name|uint32_t
name|nr_tsn
decl_stmt|,
name|nr_gap
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|ctlat
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|cntDel
operator|=
name|stream_no
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
comment|/* socket above is long gone or going.. */
name|abandon
label|:
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
comment|/* 			 * Lose the data pointer, since its in the socket 			 * buffer 			 */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now free the address and data */
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
do|do
block|{
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|!=
operator|(
name|asoc
operator|->
name|tsn_last_delivered
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Can't deliver more :< */
return|return;
block|}
name|stream_no
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|nxt_todel
operator|=
name|asoc
operator|->
name|strmin
index|[
name|stream_no
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nxt_todel
operator|!=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Not the next sequence to deliver in its stream OR 			 * unordered 			 */
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|control
operator|=
name|sctp_build_readq_entry_chk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory? */
return|return;
block|}
comment|/* save it off for our future deliveries */
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|control
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
name|end
operator|=
literal|1
expr_stmt|;
else|else
name|end
operator|=
literal|0
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|end
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|cntDel
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
name|end
operator|=
literal|1
expr_stmt|;
else|else
name|end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_append_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
argument_list|,
name|chk
operator|->
name|data
argument_list|,
name|end
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
comment|/* 				 * something is very wrong, either 				 * control_pdapi is NULL, or the tail_mbuf 				 * is corrupt, or there is a EOM already on 				 * the mbuf chain. 				 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|abandon
goto|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|->
name|tail_mbuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|panic
argument_list|(
literal|"This should not happen control_pdapi NULL?"
argument_list|)
expr_stmt|;
block|}
comment|/* if we did not panic, it was a EOM */
name|panic
argument_list|(
literal|"Bad chunking ??"
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|->
name|tail_mbuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"This should not happen control_pdapi NULL?\n"
argument_list|)
expr_stmt|;
block|}
name|SCTP_PRINTF
argument_list|(
literal|"Bad chunking ??\n"
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"Dumping re-assembly queue this will probably hose the association\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|abandon
goto|;
block|}
block|}
name|cntDel
operator|++
expr_stmt|;
block|}
comment|/* pull it we did it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 		 * EY this is the chunk that should be tagged nr gapped 		 * calculate the gap and such then tag this TSN nr 		 * chk->rec.data.TSN_seq 		 */
comment|/* 		 * EY!-TODO- this tsn should be tagged nr only if it is 		 * out-of-order, the if statement should be modified 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|nr_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|nr_mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
operator|||
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * EY The 1st should never happen, as in 				 * process_a_data_chunk method this check 				 * should be done 				 */
comment|/* 				 * EY The 2nd should never happen, because 				 * nr_mapping_array is always expanded when 				 * mapping_array is expanded 				 */
name|printf
argument_list|(
literal|"Impossible nr_gap ack range failed\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|nr_tsn
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmin
index|[
name|stream_no
index|]
operator|.
name|last_sequence_delivered
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_reasmusrmsgs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* 			 * turn the flag back on since we just  delivered 			 * yet another one. 			 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|tsn_of_pdapi_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|last_flags_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|asoc
operator|->
name|last_strm_seq_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|last_strm_no_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
comment|/* free up the chk */
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Now lets see if we can deliver the next one on 			 * the stream 			 */
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|stream_no
index|]
expr_stmt|;
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
operator|(
name|nxt_todel
operator|==
name|ctl
operator|->
name|sinfo_ssn
operator|)
condition|)
block|{
while|while
condition|(
name|ctl
operator|!=
name|NULL
condition|)
block|{
comment|/* Deliver more if we can. */
if|if
condition|(
name|nxt_todel
operator|==
name|ctl
operator|->
name|sinfo_ssn
condition|)
block|{
name|ctlat
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|ctl
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_sequence_delivered
operator|++
expr_stmt|;
comment|/* 						 * EY will be used to 						 * calculate nr-gap 						 */
name|nr_tsn
operator|=
name|ctl
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ctl
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 						 * EY -now something is 						 * delivered, calculate 						 * nr_gap and tag this tsn 						 * NR 						 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|nr_mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nr_gap
operator|>=
operator|(
name|SCTP_NR_MAPPING_ARRAY
operator|<<
literal|3
operator|)
operator|)
operator|||
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Impossible NR gap calculation?\n"
argument_list|)
expr_stmt|;
comment|/* 								 * EY The 								 * 1st 								 * should 								 * never 								 * happen, 								 * as in 								 * process_a_ 								 * data_chunk 								 *  method 								 * this 								 * check 								 * should be 								 * done 								 */
comment|/* 								 * EY The 								 * 2nd 								 * should 								 * never 								 * happen, 								 * because 								 * nr_mapping 								 * _array is 								 * always 								 * expanded 								 * when 								 * mapping_ar 								 * ray is 								 * expanded 								 */
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|nr_tsn
expr_stmt|;
block|}
block|}
name|ctl
operator|=
name|ctlat
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* sa_ignore FREED_MEMORY */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chk
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Queue the chunk either right into the socket buffer if it is the next one  * to go OR put it in the correct place in the delivery queue.  If we do  * append to the so_buf, keep doing so until we are out of order. One big  * question still remains, what to do when the socket buffer is FULL??  */
end_comment

begin_function
specifier|static
name|void
name|sctp_queue_data_to_stream
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* 	 * FIX-ME maybe? What happens when the ssn wraps? If we are getting 	 * all the data in one stream this could happen quite rapidly. One 	 * could use the TSN to keep track of things, but this scheme breaks 	 * down in the other type of stream useage that could occur. Send a 	 * single msg to stream 0, send 4Billion messages to stream 1, now 	 * send a message to stream 0. You have a situation where the TSN 	 * has wrapped but not in the stream. Is this worth worrying about 	 * or should we just change our queue sort at the bottom to be by 	 * TSN. 	 *  	 * Could it also be legal for a peer to send ssn 1 with TSN 2 and ssn 2 	 * with TSN 1? If the peer is doing some sort of funky TSN/SSN 	 * assignment this could happen... and I don't see how this would be 	 * a violation. So for now I am undecided an will leave the sort by 	 * SSN alone. Maybe a hybred approach is the answer 	 *  	 */
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|at
decl_stmt|;
name|int
name|queue_needed
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
comment|/* EY- will be used to calculate nr-gap for a tsn */
name|uint32_t
name|nr_tsn
decl_stmt|,
name|nr_gap
decl_stmt|;
name|queue_needed
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|+=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
expr_stmt|;
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_INTO_STRD
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"queue to stream called for ssn:%u lastdel:%u nxt:%u\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|control
operator|->
name|sinfo_stream
argument_list|,
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|last_sequence_delivered
argument_list|,
operator|(
name|uint32_t
operator|)
name|nxt_todel
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|strm
operator|->
name|last_sequence_delivered
argument_list|,
name|control
operator|->
name|sinfo_ssn
argument_list|,
name|MAX_SEQ
argument_list|)
operator|||
operator|(
name|strm
operator|->
name|last_sequence_delivered
operator|==
name|control
operator|->
name|sinfo_ssn
operator|)
condition|)
block|{
comment|/* The incoming sseq is behind where we last delivered? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Duplicate S-SEQ:%d delivered:%d from peer, Abort  association\n"
argument_list|,
name|control
operator|->
name|sinfo_ssn
argument_list|,
name|strm
operator|->
name|last_sequence_delivered
argument_list|)
expr_stmt|;
name|protocol_error
label|:
comment|/* 		 * throw it in the stream so it gets cleaned up in 		 * association destruction 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|control
operator|->
name|sinfo_stream
operator|<<
literal|16
operator|)
operator||
name|control
operator|->
name|sinfo_ssn
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_1
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nxt_todel
operator|==
name|control
operator|->
name|sinfo_ssn
condition|)
block|{
comment|/* can be delivered right away? */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_IMMED_DEL
argument_list|)
expr_stmt|;
block|}
comment|/* EY it wont be queued if it could be delivered directly */
name|queue_needed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_sequence_delivered
operator|++
expr_stmt|;
comment|/* EY will be used to calculate nr-gap */
name|nr_tsn
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 		 * EY this is the chunk that should be tagged nr gapped 		 * calculate the gap and such then tag this TSN nr 		 * chk->rec.data.TSN_seq 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|nr_mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nr_gap
operator|>=
operator|(
name|SCTP_NR_MAPPING_ARRAY
operator|<<
literal|3
operator|)
operator|)
operator|||
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Impossible nr_tsn set 2?\n"
argument_list|)
expr_stmt|;
comment|/* 				 * EY The 1st should never happen, as in 				 * process_a_data_chunk method this check 				 * should be done 				 */
comment|/* 				 * EY The 2nd should never happen, because 				 * nr_mapping_array is always expanded when 				 * mapping_array is expanded 				 */
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|nr_tsn
expr_stmt|;
block|}
block|}
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
comment|/* all delivered */
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nxt_todel
operator|==
name|control
operator|->
name|sinfo_ssn
condition|)
block|{
name|at
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_sequence_delivered
operator|++
expr_stmt|;
comment|/* 				 * We ignore the return of deliver_data here 				 * since we always can hold the chunk on the 				 * d-queue. And we have a finite number that 				 * can be delivered from the strq. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_IMMED_DEL
argument_list|)
expr_stmt|;
block|}
comment|/* EY will be used to calculate nr-gap */
name|nr_tsn
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 				 * EY this is the chunk that should be 				 * tagged nr gapped calculate the gap and 				 * such then tag this TSN nr 				 * chk->rec.data.TSN_seq 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|nr_mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nr_gap
operator|>=
operator|(
name|SCTP_NR_MAPPING_ARRAY
operator|<<
literal|3
operator|)
operator|)
operator|||
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Impossible nr TSN set 3?\n"
argument_list|)
expr_stmt|;
comment|/* 						 * EY The 1st should never 						 * happen, as in 						 * process_a_data_chunk 						 * method this check should 						 * be done 						 */
comment|/* 						 * EY The 2nd should never 						 * happen, because 						 * nr_mapping_array is 						 * always expanded when 						 * mapping_array is expanded 						 */
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|nr_tsn
expr_stmt|;
block|}
block|}
name|control
operator|=
name|at
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|queue_needed
condition|)
block|{
comment|/* 		 * Ok, we did not deliver this guy, find the correct place 		 * to put it on the queue. 		 */
if|if
condition|(
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|control
operator|->
name|sinfo_tsn
operator|==
name|asoc
operator|->
name|cumulative_tsn
operator|)
condition|)
block|{
goto|goto
name|protocol_error
goto|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
condition|)
block|{
comment|/* Empty queue */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_HD
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&strm->inqueue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|at
operator|->
name|sinfo_ssn
argument_list|,
name|control
operator|->
name|sinfo_ssn
argument_list|,
name|MAX_SEQ
argument_list|)
condition|)
block|{
comment|/* 					 * one in queue is bigger than the 					 * new one, insert before this one 					 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_MD
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|sinfo_ssn
operator|==
name|control
operator|->
name|sinfo_ssn
condition|)
block|{
comment|/* 					 * Gak, He sent me a duplicate str 					 * seq number 					 */
comment|/* 					 * foo bar, I guess I will just free 					 * this new guy, should we abort 					 * too? FIX ME MAYBE? Or it COULD be 					 * that the SSN's have wrapped. 					 * Maybe I should compare to TSN 					 * somehow... sigh for now just blow 					 * away the chunk! 					 */
if|if
condition|(
name|control
operator|->
name|data
condition|)
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|whoFrom
condition|)
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|control
operator|->
name|whoFrom
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 						 * We are at the end, insert 						 * it after this one 						 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_TL
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|at
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns two things: You get the total size of the deliverable parts of the  * first fragmented message on the reassembly queue. And you get a 1 back if  * all of the message is ready or a 0 back if the message is still incomplete  */
end_comment

begin_function
specifier|static
name|int
name|sctp_is_all_msg_on_reasm
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
modifier|*
name|t_size
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|;
operator|*
name|t_size
operator|=
literal|0
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* nothing on the queue */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Not a first on the queue */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
if|if
condition|(
name|tsn
operator|!=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|t_size
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tsn
operator|++
expr_stmt|;
name|chk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_deliver_reasm_check
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
name|uint32_t
name|tsize
decl_stmt|,
name|pd_point
decl_stmt|;
name|doit_again
label|:
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* Huh? */
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
condition|)
block|{
name|nxt_todel
operator|=
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
name|nxt_todel
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Yep the first one is here and its ok to deliver 			 * but should we? 			 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|pd_point
operator|=
name|min
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pd_point
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_all_msg_on_reasm
argument_list|(
name|asoc
argument_list|,
operator|&
name|tsize
argument_list|)
operator|||
operator|(
name|tsize
operator|>=
name|pd_point
operator|)
condition|)
block|{
comment|/* 				 * Yes, we setup to start reception, by 				 * backing down the TSN just in case we 				 * can't deliver. If we 				 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|pdapi_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Service re-assembly will deliver stream data queued at 		 * the end of fragmented delivery.. but it wont know to go 		 * back and call itself again... we do that here with the 		 * got doit_again 		 */
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
condition|)
block|{
comment|/* 			 * finished our Fragmented delivery, could be more 			 * waiting? 			 */
goto|goto
name|doit_again
goto|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Dump onto the re-assembly queue, in its proper place. After dumping on the  * queue, see if anthing can be delivered. If so pull it off (or as much as  * we can. If we run out of space then we must dump what we can and set the  * appropriate flag to say we queued what we could.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_queue_data_for_reasm
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|uint32_t
name|cum_ackp1
decl_stmt|,
name|last_tsn
decl_stmt|,
name|prev_tsn
decl_stmt|,
name|post_tsn
decl_stmt|;
name|u_char
name|last_flags
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|prev
operator|=
name|next
operator|=
name|NULL
expr_stmt|;
name|cum_ackp1
operator|=
name|asoc
operator|->
name|tsn_last_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* This is the first one on the queue */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 		 * we do not check for delivery of anything when only one 		 * fragment is here 		 */
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|cum_ackp1
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|!=
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* 				 * An empty queue, no delivery inprogress, 				 * we hit the next one and it does NOT have 				 * a FIRST fragment mark. 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, its not first, no fragmented delivery in progress\n"
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_2
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* 				 * We are doing a partial delivery and the 				 * NEXT chunk MUST be either the LAST or 				 * MIDDLE fragment NOT a FIRST 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, it IS a first and fragmented delivery in progress\n"
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_3
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* 				 * Here we are ok with a MIDDLE or LAST 				 * piece 				 */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|asoc
operator|->
name|str_of_pdapi
condition|)
block|{
comment|/* Got to be the right STR No */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, it IS not same stream number %d vs %d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|,
name|asoc
operator|->
name|str_of_pdapi
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_4
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|fragment_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|!=
name|SCTP_DATA_UNORDERED
operator|&&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|asoc
operator|->
name|ssn_of_pdapi
condition|)
block|{
comment|/* Got to be the right STR Seq */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, it IS not same stream seq %d vs %d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|asoc
operator|->
name|ssn_of_pdapi
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_5
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
comment|/* Find its place */
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&asoc->reasmqueue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * one in queue is bigger than the new one, insert 			 * before this one 			 */
comment|/* A check */
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|next
operator|=
name|at
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* Gak, He sent me a duplicate str seq number */
comment|/* 			 * foo bar, I guess I will just free this new guy, 			 * should we abort too? FIX ME MAYBE? Or it COULD be 			 * that the SSN's have wrapped. Maybe I should 			 * compare to TSN somehow... sigh for now just blow 			 * away the chunk! 			 */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|last_flags
operator|=
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|last_tsn
operator|=
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|prev
operator|=
name|at
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|sctp_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * We are at the end, insert it after this 				 * one 				 */
comment|/* check it first */
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|at
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now the audits */
if|if
condition|(
name|prev
condition|)
block|{
name|prev_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prev_tsn
operator|==
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* 			 * Ok the one I am dropping onto the end is the 			 * NEXT. A bit of valdiation here. 			 */
if|if
condition|(
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
operator|||
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_MIDDLE_FRAG
condition|)
block|{
comment|/* 				 * Insert chk MUST be a MIDDLE or LAST 				 * fragment 				 */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Prev check - It can be a midlle or last but not a first\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, it's a FIRST!\n"
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_6
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
name|SCTP_PRINTF
argument_list|(
literal|"Prev check - Gak, Evil plot, ssn:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|,
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_7
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Prev check - Gak, Evil plot, sseq:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_8
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* Insert chk MUST be a FIRST */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Prev check - Gak, evil plot, its not FIRST and it must be!\n"
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_9
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
if|if
condition|(
name|next
condition|)
block|{
name|post_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|post_tsn
operator|==
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* 			 * Ok the one I am inserting ahead of is my NEXT 			 * one. A bit of valdiation here. 			 */
if|if
condition|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* Insert chk MUST be a last fragment */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Next chk - Next is FIRST, we must be LAST\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, its not a last!\n"
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_10
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_MIDDLE_FRAG
operator|||
operator|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* 				 * Insert chk CAN be MIDDLE or FIRST NOT 				 * LAST 				 */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Next chk - Next is a MIDDLE/LAST\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Gak, Evil plot, new prev chunk is a LAST\n"
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_11
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_11
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Next chk - Gak, Evil plot, ssn:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|,
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_12
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_12
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Next chk - Gak, Evil plot, sseq:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_13
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_13
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/* Do we need to do some delivery? check */
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is an unfortunate routine. It checks to make sure a evil guy is not  * stuffing us full of bad packet fragments. A broken peer could also do this  * but this is doubtful. It is to bad I must worry about evil crackers sigh  * :< more cycles.  */
end_comment

begin_function
specifier|static
name|int
name|sctp_does_tsn_belong_to_reasm
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|TSN_seq
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|;
name|uint32_t
name|tsn_est
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&asoc->reasmqueue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|TSN_seq
argument_list|,
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* is it one bigger? */
name|tsn_est
operator|=
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsn_est
operator|==
name|TSN_seq
condition|)
block|{
comment|/* yep. It better be a last then */
if|if
condition|(
operator|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* 					 * Ok this guy belongs next to a guy 					 * that is NOT last, it should be a 					 * middle/last, not a complete 					 * chunk. 					 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 					 * This guy is ok since its a LAST 					 * and the new chunk is a fully 					 * self- contained one. 					 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TSN_seq
operator|==
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* Software error since I have a dup? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Ok, 'at' is larger than new chunk but does it 			 * need to be right before it. 			 */
name|tsn_est
operator|=
name|TSN_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsn_est
operator|==
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* Yep, It better be a first */
if|if
condition|(
operator|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_process_a_data_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_data_chunk
modifier|*
name|ch
parameter_list|,
name|int
name|chk_length
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
modifier|*
name|high_tsn
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|int
modifier|*
name|break_flag
parameter_list|,
name|int
name|last_chunk
parameter_list|)
block|{
comment|/* Process a data chunk */
comment|/* struct sctp_tmit_chunk *chk; */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|,
name|gap
decl_stmt|;
comment|/* EY - for nr_sack */
name|uint32_t
name|nr_gap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dmbuf
decl_stmt|;
name|int
name|indx
decl_stmt|,
name|the_len
decl_stmt|;
name|int
name|need_reasm_check
init|=
literal|0
decl_stmt|;
name|uint16_t
name|strmno
decl_stmt|,
name|strmseq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|int
name|ordered
decl_stmt|;
name|uint32_t
name|protocol_id
decl_stmt|;
name|uint8_t
name|chunk_flags
decl_stmt|;
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
name|chk
operator|=
name|NULL
expr_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|ch
operator|->
name|dp
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|chunk_flags
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_SACK_IMMEDIATELY
operator|)
operator|==
name|SCTP_DATA_SACK_IMMEDIATELY
condition|)
block|{
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
name|protocol_id
operator|=
name|ch
operator|->
name|dp
operator|.
name|protocol_id
expr_stmt|;
name|ordered
operator|=
operator|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_TSN_ENTERS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_LTRACE_CHK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ch
operator|->
name|ch
operator|.
name|chunk_type
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|tsn
condition|)
block|{
comment|/* It is a duplicate */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdupdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|numduptsns
operator|<
name|SCTP_MAX_DUP_TSNS
condition|)
block|{
comment|/* Record a dup for the next outbound sack */
name|asoc
operator|->
name|dup_tsns
index|[
name|asoc
operator|->
name|numduptsns
index|]
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|numduptsns
operator|++
expr_stmt|;
block|}
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Calculate the number of TSN's between the base and this TSN */
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap
operator|>=
operator|(
name|SCTP_MAPPING_ARRAY
operator|<<
literal|3
operator|)
condition|)
block|{
comment|/* Can't hold the bit in the mapping at max array, toss it */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|mapping_array_size
operator|<<
literal|3
argument_list|)
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_expand_mapping_array
argument_list|(
name|asoc
argument_list|,
name|gap
argument_list|)
condition|)
block|{
comment|/* Can't expand, drop it */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* EY - for nr_sack */
name|nr_gap
operator|=
name|gap
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
operator|*
name|high_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
operator|*
name|high_tsn
operator|=
name|tsn
expr_stmt|;
block|}
comment|/* See if we have received this one already */
if|if
condition|(
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdupdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|numduptsns
operator|<
name|SCTP_MAX_DUP_TSNS
condition|)
block|{
comment|/* Record a dup for the next outbound sack */
name|asoc
operator|->
name|dup_tsns
index|[
name|asoc
operator|->
name|numduptsns
index|]
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|numduptsns
operator|++
expr_stmt|;
block|}
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to see about the GONE flag, duplicates would cause a sack 	 * to be sent up above 	 */
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
operator|)
condition|)
block|{
comment|/* 		 * wait a minute, this guy is gone, there is no longer a 		 * receiver. Send peer an ABORT! 		 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now before going further we see if there is room. If NOT then we 	 * MAY let one through only IF this TSN is the one we are waiting 	 * for on a partial delivery API. 	 */
comment|/* now do the tests */
if|if
condition|(
operator|(
operator|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_msg_on_sb
operator|)
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|int
operator|)
name|asoc
operator|->
name|my_rwnd
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * When we have NO room in the rwnd we check to make sure 		 * the reader is doing its job... 		 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
block|{
comment|/* some to read, wake-up */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* now is it in the mapping array of what we have accepted? */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* Nope not in the valid range dump it */
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_msg_on_sb
operator|)
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_datadropchklmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_datadroprwnd
argument_list|)
expr_stmt|;
block|}
name|indx
operator|=
operator|*
name|break_flag
expr_stmt|;
operator|*
name|break_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|strmno
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|dp
operator|.
name|stream_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|strmno
operator|>=
name|asoc
operator|->
name|streamincnt
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
comment|/* add some space up front so prepend will work well */
name|SCTP_BUF_RESV_UF
argument_list|(
name|mb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 			 * Error causes are just param's and this one has 			 * two back to back phdr, one with the error type 			 * and size, the other with the streamid and a rsvd 			 */
name|SCTP_BUF_LEN
argument_list|(
name|mb
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|*
literal|2
operator|)
expr_stmt|;
name|phdr
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_INVALID_STREAM
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* We insert the stream in the type field */
name|phdr
operator|->
name|param_type
operator|=
name|ch
operator|->
name|dp
operator|.
name|stream_id
expr_stmt|;
comment|/* And set the length to 0 for the rsvd field */
name|phdr
operator|->
name|param_length
operator|=
literal|0
expr_stmt|;
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|mb
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsid
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
comment|/* EY set this tsn present in  nr_sack's nr_mapping_array */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|gap
argument_list|,
name|tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* we have a new high score */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|tsn
expr_stmt|;
comment|/* EY nr_sack version of the above */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tsn
operator|==
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Update cum-ack */
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|tsn
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Before we continue lets validate that we are not being fooled by 	 * an evil attacker. We can only have 4k chunks based on our TSN 	 * spread allowed by the mapping array 512 * 8 bits, so there is no 	 * way our stream sequence numbers could have wrapped. We of course 	 * only validate the FIRST fragment so the bit must be set. 	 */
name|strmseq
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|dp
operator|.
name|stream_sequence
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|tsn_in_at
operator|>=
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|asoc
operator|->
name|tsn_in_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_in_wrapped
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|strm
operator|=
name|strmno
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|seq
operator|=
name|strmseq
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|sz
operator|=
name|chk_length
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|flgs
operator|=
name|chunk_flags
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|in_pos
operator|=
name|asoc
operator|->
name|tsn_in_at
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|in_out
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|tsn_in_at
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|&&
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
argument_list|,
name|strmseq
argument_list|,
name|MAX_SEQ
argument_list|)
operator|||
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|==
name|strmseq
operator|)
condition|)
block|{
comment|/* The incoming sseq is behind where we last delivered? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"EVIL/Broken-Dup S-SEQ:%d delivered:%d from peer, Abort!\n"
argument_list|,
name|strmseq
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_14
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_14
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/************************************ 	 * From here down we may find ch-> invalid 	 * so its a good idea NOT to use it. 	 *************************************/
name|the_len
operator|=
operator|(
name|chk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
name|dmbuf
operator|=
name|SCTP_M_COPYM
argument_list|(
operator|*
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
argument_list|,
name|the_len
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|mat
operator|=
name|dmbuf
expr_stmt|;
while|while
condition|(
name|mat
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We can steal the last chunk */
name|int
name|l_len
decl_stmt|;
name|dmbuf
operator|=
operator|*
name|m
expr_stmt|;
comment|/* lop off the top part */
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|dmbuf
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|l_len
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * need to count up the size hopefully does not hit 			 * this to often :-0 			 */
name|struct
name|mbuf
modifier|*
name|lat
decl_stmt|;
name|l_len
operator|=
literal|0
expr_stmt|;
name|lat
operator|=
name|dmbuf
expr_stmt|;
while|while
condition|(
name|lat
condition|)
block|{
name|l_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|lat
argument_list|)
expr_stmt|;
name|lat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|lat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_len
operator|>
name|the_len
condition|)
block|{
comment|/* Trim the end round bytes off  too */
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|-
operator|(
name|l_len
operator|-
name|the_len
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dmbuf
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
operator|&&
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|&&
operator|(
operator|(
name|ordered
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
operator|)
operator|==
name|strmseq
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|inqueue
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Candidate for express delivery */
comment|/* 		 * Its not fragmented, No PD-API is up, Nothing in the 		 * delivery queue, Its un-ordered OR ordered and the next to 		 * deliver AND nothing else is stuck on the stream queue, 		 * And there is room for it in the socket buffer. Lets just 		 * stuff it up the buffer.... 		 */
comment|/* It would be nice to avoid this copy if we could :< */
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|sctp_build_readq_entry_mac
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|context
argument_list|,
name|net
argument_list|,
name|tsn
argument_list|,
name|protocol_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
name|strmno
argument_list|,
name|strmseq
argument_list|,
name|chunk_flags
argument_list|,
name|dmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_express_del
goto|;
block|}
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 		 * EY here I should check if this delivered tsn is 		 * out_of_order, if yes then update the nr_map 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
comment|/* 			 * EY check if the mapping_array and nr_mapping 			 * array are consistent 			 */
if|if
condition|(
name|asoc
operator|->
name|mapping_array_base_tsn
operator|!=
name|asoc
operator|->
name|nr_mapping_array_base_tsn
condition|)
comment|/* 				 * printf("EY-IN 				 * sctp_process_a_data_chunk(5): Something 				 * is wrong the map base tsn" "\nEY-and 				 * nr_map base tsn should be equal."); 				 */
comment|/* EY debugging block */
block|{
comment|/* 				 * printf("\nEY-Calculating an 				 * nr_gap!!\nmapping_array_size = %d 				 * nr_mapping_array_size = %d" 				 * "\nEY-mapping_array_base = %d 				 * nr_mapping_array_base = 				 * %d\nEY-highest_tsn_inside_map = %d" 				 * "highest_tsn_inside_nr_map = %d\nEY-TSN = 				 * %d nr_gap = %d",asoc->mapping_array_size, 				 * asoc->nr_mapping_array_size, 				 * asoc->mapping_array_base_tsn, 				 * asoc->nr_mapping_array_base_tsn, 				 * asoc->highest_tsn_inside_map, 				 * asoc->highest_tsn_inside_nr_map,tsn,nr_gap 				 * ); 				 */
block|}
comment|/* EY - not %100 sure about the lock thing */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* for ordered, bump what we delivered */
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|++
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvexpress
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del_alt
argument_list|(
name|stcb
argument_list|,
name|tsn
argument_list|,
name|strmseq
argument_list|,
name|strmno
argument_list|,
name|SCTP_STR_LOG_FROM_EXPRS_DEL
argument_list|)
expr_stmt|;
block|}
name|control
operator|=
name|NULL
expr_stmt|;
goto|goto
name|finish_express_del
goto|;
block|}
name|failed_express_del
label|:
comment|/* If we reach here this is a new chunk */
name|chk
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
comment|/* Express for fragmented delivery? */
if|if
condition|(
operator|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|str_of_pdapi
operator|==
name|strmno
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|ssn_of_pdapi
operator|==
name|strmseq
operator|)
condition|)
block|{
name|control
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* Can't be another first? */
goto|goto
name|failed_pdapi_express_del
goto|;
block|}
if|if
condition|(
name|tsn
operator|==
operator|(
name|control
operator|->
name|sinfo_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Yep, we can add it on */
name|int
name|end
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cumack
decl_stmt|;
if|if
condition|(
name|chunk_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|end
operator|=
literal|1
expr_stmt|;
block|}
name|cumack
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
if|if
condition|(
operator|(
name|cumack
operator|+
literal|1
operator|)
operator|==
name|tsn
condition|)
name|cumack
operator|=
name|tsn
expr_stmt|;
if|if
condition|(
name|sctp_append_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
name|dmbuf
argument_list|,
name|end
argument_list|,
name|tsn
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Append fails end:%d\n"
argument_list|,
name|end
argument_list|)
expr_stmt|;
goto|goto
name|failed_pdapi_express_del
goto|;
block|}
comment|/* 			 * EY It is appended to the read queue in prev if 			 * block here I should check if this delivered tsn 			 * is out_of_order, if yes then update the nr_map 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
comment|/* EY debugging block */
block|{
comment|/* 					 * printf("\nEY-Calculating an 					 * nr_gap!!\nEY-mapping_array_size = 					 * %d nr_mapping_array_size = %d" 					 * "\nEY-mapping_array_base = %d 					 * nr_mapping_array_base = 					 * %d\nEY-highest_tsn_inside_map = 					 * %d" "highest_tsn_inside_nr_map = 					 * %d\nEY-TSN = %d nr_gap = 					 * %d",asoc->mapping_array_size, 					 * asoc->nr_mapping_array_size, 					 * asoc->mapping_array_base_tsn, 					 * asoc->nr_mapping_array_base_tsn, 					 * asoc->highest_tsn_inside_map, 					 * asoc->highest_tsn_inside_nr_map,ts 					 * n,nr_gap); 					 */
block|}
comment|/* EY - not %100 sure about the lock thing */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvexpressm
argument_list|)
expr_stmt|;
name|control
operator|->
name|sinfo_tsn
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chunk_flags
expr_stmt|;
name|asoc
operator|->
name|tsn_of_pdapi_last_delivered
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|last_flags_delivered
operator|=
name|chunk_flags
expr_stmt|;
name|asoc
operator|->
name|last_strm_seq_delivered
operator|=
name|strmseq
expr_stmt|;
name|asoc
operator|->
name|last_strm_no_delivered
operator|=
name|strmno
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
comment|/* clean up the flags and such */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|++
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * There could be another message 					 * ready 					 */
name|need_reasm_check
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|control
operator|=
name|NULL
expr_stmt|;
goto|goto
name|finish_express_del
goto|;
block|}
block|}
name|failed_pdapi_express_del
label|:
name|control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|chunk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|!=
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the chunk */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
comment|/* we copied it, free the copy */
name|sctp_m_freem
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|=
name|tsn
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|=
name|strmseq
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|=
name|strmno
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
operator|=
name|protocol_id
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
name|chunk_flags
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|the_len
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|dmbuf
expr_stmt|;
block|}
else|else
block|{
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|sctp_build_readq_entry_mac
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|context
argument_list|,
name|net
argument_list|,
name|tsn
argument_list|,
name|protocol_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
name|strmno
argument_list|,
name|strmseq
argument_list|,
name|chunk_flags
argument_list|,
name|dmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the chunk */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
comment|/* we copied it, free the copy */
name|sctp_m_freem
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|control
operator|->
name|length
operator|=
name|the_len
expr_stmt|;
block|}
comment|/* Mark it as received */
comment|/* Now queue it where it belongs */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
comment|/* First a sanity check */
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* 			 * Ok, we have a fragmented delivery in progress if 			 * this chunk is next to deliver OR belongs in our 			 * view to the reassembly, the peer is evil or 			 * broken. 			 */
name|uint32_t
name|estimate_tsn
decl_stmt|;
name|estimate_tsn
operator|=
name|asoc
operator|->
name|tsn_last_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
operator|&&
operator|(
name|estimate_tsn
operator|==
name|control
operator|->
name|sinfo_tsn
operator|)
condition|)
block|{
comment|/* Evil/Broke peer */
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|whoFrom
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|control
operator|->
name|whoFrom
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_15
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_15
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sctp_does_tsn_belong_to_reasm
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|whoFrom
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|control
operator|->
name|whoFrom
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_16
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_16
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* No PDAPI running */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* 				 * Reassembly queue is NOT empty validate 				 * that this tsn does not need to be in 				 * reasembly queue. If it does then our peer 				 * is broken or evil. 				 */
if|if
condition|(
name|sctp_does_tsn_belong_to_reasm
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|whoFrom
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|control
operator|->
name|whoFrom
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_17
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_17
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* ok, if we reach here we have passed the sanity checks */
if|if
condition|(
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* queue directly into socket buffer */
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 			 * EY It is added to the read queue in prev if block 			 * here I should check if this delivered tsn is 			 * out_of_order, if yes then update the nr_map 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
comment|/* 				 * EY check if the mapping_array and 				 * nr_mapping array are consistent 				 */
if|if
condition|(
name|asoc
operator|->
name|mapping_array_base_tsn
operator|!=
name|asoc
operator|->
name|nr_mapping_array_base_tsn
condition|)
comment|/* 					 * printf("EY-IN 					 * sctp_process_a_data_chunk(6): 					 * Something is wrong the map base 					 * tsn" "\nEY-and nr_map base tsn 					 * should be equal."); 					 */
comment|/* 					 * EY - not %100 sure about the lock 					 * thing, i think we don't need the 					 * below, 					 */
comment|/* SCTP_TCB_LOCK_ASSERT(stcb); */
block|{
comment|/* 					 * printf("\nEY-Calculating an 					 * nr_gap!!\nEY-mapping_array_size = 					 * %d nr_mapping_array_size = %d" 					 * "\nEY-mapping_array_base = %d 					 * nr_mapping_array_base = 					 * %d\nEY-highest_tsn_inside_map = 					 * %d" "highest_tsn_inside_nr_map = 					 * %d\nEY-TSN = %d nr_gap = 					 * %d",asoc->mapping_array_size, 					 * asoc->nr_mapping_array_size, 					 * asoc->mapping_array_base_tsn, 					 * asoc->nr_mapping_array_base_tsn, 					 * asoc->highest_tsn_inside_map, 					 * asoc->highest_tsn_inside_nr_map,ts 					 * n,nr_gap); 					 */
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Special check for when streams are resetting. We 			 * could be more smart about this and check the 			 * actual stream to see if it is not being reset.. 			 * that way we would not create a HOLB when amongst 			 * streams being reset and those not being reset. 			 *  			 * We take complete messages that have a stream reset 			 * intervening (aka the TSN is after where our 			 * cum-ack needs to be) off and put them on a 			 * pending_reply_queue. The reassembly ones we do 			 * not have to worry about since they are all sorted 			 * and proceessed by TSN order. It is only the 			 * singletons I must worry about. 			 */
if|if
condition|(
operator|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 				 * yep its past where we need to reset... go 				 * ahead and queue it. 				 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
condition|)
block|{
comment|/* first one on */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|ctlOn
decl_stmt|;
name|unsigned
name|char
name|inserted
init|=
literal|0
decl_stmt|;
name|ctlOn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctlOn
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|ctlOn
operator|->
name|sinfo_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|ctlOn
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctlOn
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* found it */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|ctlOn
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inserted
operator|==
literal|0
condition|)
block|{
comment|/* 						 * must be put at end, use 						 * prevP (all setup from 						 * loop) to setup nextP. 						 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Into the re-assembly queue */
name|sctp_queue_data_for_reasm
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
comment|/* 			 * the assoc is now gone and chk was put onto the 			 * reasm queue, which has all been freed. 			 */
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|finish_express_del
label|:
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* we have a new high score */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|tsn
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tsn
operator|==
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Update cum-ack */
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|last_chunk
condition|)
block|{
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ordered
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inorderchunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inunorderchunks
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdata
argument_list|)
expr_stmt|;
comment|/* Set it present please */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del_alt
argument_list|(
name|stcb
argument_list|,
name|tsn
argument_list|,
name|strmseq
argument_list|,
name|strmno
argument_list|,
name|SCTP_STR_LOG_FROM_MARK_TSN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_do_drain
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
block|}
comment|/* check the special flag for stream resets */
if|if
condition|(
operator|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|liste
operator|->
name|tsn
operator|)
operator|)
condition|)
block|{
comment|/* 		 * we have finished working through the backlogged TSN's now 		 * time to reset streams. 1: call reset function. 2: free 		 * pending_reply space 3: distribute any chunks in 		 * pending_reply_queue. 		 */
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|;
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
name|liste
operator|->
name|number_entries
argument_list|,
name|liste
operator|->
name|req
operator|.
name|list_of_streams
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|liste
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|liste
argument_list|,
name|SCTP_M_STRESET
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
operator|(
name|liste
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* All can be removed */
while|while
condition|(
name|ctl
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ctl
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctl
condition|)
block|{
comment|/* more than one in queue */
while|while
condition|(
operator|!
name|compare_with_wrap
argument_list|(
name|ctl
operator|->
name|sinfo_tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 				 * if ctl->sinfo_tsn is<= liste->tsn we can 				 * process it which is the NOT of 				 * ctl->sinfo_tsn> liste->tsn 				 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ctl
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Now service re-assembly to pick up anything that has been 		 * held on reassembly queue? 		 */
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|need_reasm_check
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|need_reasm_check
condition|)
block|{
comment|/* Another one waits ? */
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int8_t
name|sctp_map_lookup_tab
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|5
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|6
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|5
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|7
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_sack_check
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|ok_to_sack
parameter_list|,
name|int
name|was_a_gap
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* 	 * Now we also need to check the mapping array in a couple of ways. 	 * 1) Did we move the cum-ack point? 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|at
decl_stmt|;
name|uint8_t
name|comb_byte
decl_stmt|;
name|int
name|last_all_ones
init|=
literal|0
decl_stmt|;
name|int
name|slide_from
decl_stmt|,
name|slide_end
decl_stmt|,
name|lgap
decl_stmt|,
name|distance
decl_stmt|;
comment|/* EY nr_mapping array variables */
comment|/* int nr_at; */
comment|/* int nr_last_all_ones = 0; */
comment|/* int nr_slide_from, nr_slide_end, nr_lgap, nr_distance; */
name|uint32_t
name|old_cumack
decl_stmt|,
name|old_base
decl_stmt|,
name|old_highest
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
name|old_cumack
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|old_base
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
name|old_highest
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
comment|/* 	 * We could probably improve this a small bit by calculating the 	 * offset of the current cum-ack as the starting point. 	 */
name|at
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slide_from
operator|=
literal|0
init|;
name|slide_from
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
condition|;
name|slide_from
operator|++
control|)
block|{
comment|/* 		 * We must combine the renegable and non-renegable arrays 		 * here to form a unified view of what is acked right now 		 * (since they are kept separate 		 */
name|comb_byte
operator|=
name|asoc
operator|->
name|mapping_array
index|[
name|slide_from
index|]
operator||
name|asoc
operator|->
name|nr_mapping_array
index|[
name|slide_from
index|]
expr_stmt|;
if|if
condition|(
name|comb_byte
operator|==
literal|0xff
condition|)
block|{
name|at
operator|+=
literal|8
expr_stmt|;
name|last_all_ones
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* there is a 0 bit */
name|at
operator|+=
name|sctp_map_lookup_tab
index|[
name|comb_byte
index|]
expr_stmt|;
name|last_all_ones
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
operator|(
name|at
operator|-
name|last_all_ones
operator|)
expr_stmt|;
comment|/* at is one off, since in the table a embedded -1 is present */
name|at
operator|++
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"huh, cumack 0x%x greater than high-tsn 0x%x in map"
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"huh, cumack 0x%x greater than high-tsn 0x%x in map - should panic?\n"
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
expr_stmt|;
name|sctp_print_mapping_array
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|asoc
operator|->
name|highest_tsn_inside_map
operator|)
operator|&&
operator|(
name|at
operator|>=
literal|8
operator|)
condition|)
block|{
comment|/* The complete array was completed by a single FR */
comment|/* higest becomes the cum-ack */
name|int
name|clr
decl_stmt|;
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
comment|/* clear the array */
name|clr
operator|=
operator|(
name|at
operator|>>
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|clr
operator|>
name|asoc
operator|->
name|mapping_array_size
condition|)
block|{
name|clr
operator|=
name|asoc
operator|->
name|mapping_array_size
expr_stmt|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|clr
argument_list|)
expr_stmt|;
comment|/* base becomes one ahead of the cum-ack */
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
if|if
condition|(
name|clr
operator|>
name|asoc
operator|->
name|nr_mapping_array_size
condition|)
name|clr
operator|=
name|asoc
operator|->
name|nr_mapping_array_size
expr_stmt|;
name|memset
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|clr
argument_list|)
expr_stmt|;
comment|/* base becomes one ahead of the cum-ack */
name|asoc
operator|->
name|nr_mapping_array_base_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|old_base
argument_list|,
name|old_cumack
argument_list|,
name|old_highest
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_CLEARED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|at
operator|>=
literal|8
condition|)
block|{
comment|/* we can slide the mapping array down */
comment|/* slide_from holds where we hit the first NON 0xff byte */
comment|/* 		 * now calculate the ceiling of the move using our highest 		 * TSN value 		 */
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|>=
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|lgap
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|lgap
operator|=
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
literal|1
expr_stmt|;
block|}
name|slide_end
operator|=
name|lgap
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|slide_end
operator|<
name|slide_from
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"impossible slide"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"impossible slide?\n"
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
if|if
condition|(
name|slide_end
operator|>
name|asoc
operator|->
name|mapping_array_size
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"would overrun buffer"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Gak, would have overrun map end:%d slide_end:%d\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|slide_end
argument_list|)
expr_stmt|;
name|slide_end
operator|=
name|asoc
operator|->
name|mapping_array_size
expr_stmt|;
endif|#
directive|endif
block|}
name|distance
operator|=
operator|(
name|slide_end
operator|-
name|slide_from
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|old_base
argument_list|,
name|old_cumack
argument_list|,
name|old_highest
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
name|sctp_log_map
argument_list|(
operator|(
name|uint32_t
operator|)
name|slide_from
argument_list|,
operator|(
name|uint32_t
operator|)
name|slide_end
argument_list|,
operator|(
name|uint32_t
operator|)
name|lgap
argument_list|,
name|SCTP_MAP_SLIDE_FROM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|distance
operator|+
name|slide_from
operator|>
name|asoc
operator|->
name|mapping_array_size
operator|||
name|distance
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Here we do NOT slide forward the array so that 			 * hopefully when more data comes in to fill it up 			 * we will be able to slide it forward. Really I 			 * don't think this should happen :-0 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
operator|(
name|uint32_t
operator|)
name|distance
argument_list|,
operator|(
name|uint32_t
operator|)
name|slide_from
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_MAP_SLIDE_NONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|ii
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|distance
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|mapping_array
index|[
name|ii
index|]
operator|=
name|asoc
operator|->
name|mapping_array
index|[
name|slide_from
operator|+
name|ii
index|]
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|distance
init|;
name|ii
operator|<=
name|slide_end
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|mapping_array
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+=
operator|(
name|slide_from
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * EY if doing nr_sacks then slide the 			 * nr_mapping_array accordingly please 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|distance
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|nr_mapping_array
index|[
name|ii
index|]
operator|=
name|asoc
operator|->
name|nr_mapping_array
index|[
name|slide_from
operator|+
name|ii
index|]
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|distance
init|;
name|ii
operator|<=
name|slide_end
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|nr_mapping_array
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|nr_mapping_array_base_tsn
operator|+=
operator|(
name|slide_from
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Now we need to see if we need to queue a sack or just start the 	 * timer (if allowed). 	 */
if|if
condition|(
name|ok_to_sack
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* 			 * Ok special case, in SHUTDOWN-SENT case. here we 			 * maker sure SACK timer is off and instead send a 			 * SHUTDOWN and a SACK 			 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_18
argument_list|)
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
comment|/* 			 * EY if nr_sacks used then send an nr-sack , a sack 			 * otherwise 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nr_sack
condition|)
name|sctp_send_nr_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
else|else
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|is_a_gap
decl_stmt|;
comment|/* is there a gap now ? */
name|is_a_gap
operator|=
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
expr_stmt|;
comment|/* 			 * CMT DAC algorithm: increase number of packets 			 * received since last ack 			 */
name|stcb
operator|->
name|asoc
operator|.
name|cmt_dac_pkts_rcvd
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|==
literal|1
operator|)
operator|||
comment|/* We need to send a 								 * SACK */
operator|(
operator|(
name|was_a_gap
operator|)
operator|&&
operator|(
name|is_a_gap
operator|==
literal|0
operator|)
operator|)
operator|||
comment|/* was a gap, but no 								 * longer is one */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|)
operator|||
comment|/* we have dup's */
operator|(
name|is_a_gap
operator|)
operator|||
comment|/* is still a gap */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|==
literal|0
operator|)
operator|||
comment|/* Delayed sack disabled */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|data_pkts_seen
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
operator|)
comment|/* hit limit of pkts */
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|)
operator|&&
operator|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * CMT DAC algorithm: With CMT, 					 * delay acks even in the face of 					 *  					 * reordering. Therefore, if acks that 					 * do not have to be sent because of 					 * the above reasons, will be 					 * delayed. That is, acks that would 					 * have been sent due to gap reports 					 * will be delayed with DAC. Start 					 * the delayed ack timer. 					 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Ok we must build a SACK since the 					 * timer is pending, we got our 					 * first packet OR there are gaps or 					 * duplicates. 					 */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
comment|/* 					 * EY if nr_sacks used then send an 					 * nr-sack , a sack otherwise 					 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nr_sack
condition|)
name|sctp_send_nr_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
else|else
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_service_queues
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsize
decl_stmt|,
name|pd_point
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
comment|/* Can we proceed further, i.e. the PD-API is complete */
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* no */
return|return;
block|}
comment|/* 	 * Now is there some other chunk I can deliver from the reassembly 	 * queue. 	 */
name|doit_again
label|:
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|nxt_todel
operator|=
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
operator|(
name|nxt_todel
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Yep the first one is here. We setup to start reception, 		 * by backing down the TSN just in case we can't deliver. 		 */
comment|/* 		 * Before we start though either all of the message should 		 * be here or the socket buffer max or nothing on the 		 * delivery queue and something can be delivered. 		 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|pd_point
operator|=
name|min
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pd_point
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_all_msg_on_reasm
argument_list|(
name|asoc
argument_list|,
operator|&
name|tsize
argument_list|)
operator|||
operator|(
name|tsize
operator|>=
name|pd_point
operator|)
condition|)
block|{
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|pdapi_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
condition|)
block|{
goto|goto
name|doit_again
goto|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_process_data
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
modifier|*
name|high_tsn
parameter_list|)
block|{
name|struct
name|sctp_data_chunk
modifier|*
name|ch
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|num_chunks
init|=
literal|0
decl_stmt|;
comment|/* number of control chunks processed */
name|int
name|stop_proc
init|=
literal|0
decl_stmt|;
name|int
name|chk_length
decl_stmt|,
name|break_flag
decl_stmt|,
name|last_chunk
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|,
name|was_a_gap
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* set the rwnd */
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mm
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* there was a gap before this data was processed */
name|was_a_gap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * setup where we got the last DATA packet from for any SACK that 	 * may need to go out. Don't bump the net. This is done ONLY when a 	 * chunk is assigned. 	 */
name|asoc
operator|->
name|last_data_chunk_from
operator|=
name|net
expr_stmt|;
comment|/*- 	 * Now before we proceed we must figure out if this is a wasted 	 * cluster... i.e. it is a small packet sent in and yet the driver 	 * underneath allocated a full cluster for it. If so we must copy it 	 * to a smaller mbuf and free up the cluster mbuf. This will help 	 * with cluster starvation. Note for __Panda__ we don't do this 	 * since it has clusters all the way down to 64 bytes. 	 */
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|<
operator|(
name|long
operator|)
name|MLEN
operator|&&
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* we only handle mbufs that are singletons.. not chains */
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* ok lets see if we can copy the data up */
name|caddr_t
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
comment|/* get the pointers and copy */
name|to
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
operator|*
argument_list|)
expr_stmt|;
name|from
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|,
name|caddr_t
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy the length and free up the old */
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
operator|*
name|mm
argument_list|)
expr_stmt|;
comment|/* sucess, back copy */
operator|*
name|mm
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* We are in trouble in the mbuf world .. yikes */
name|m
operator|=
operator|*
name|mm
expr_stmt|;
block|}
block|}
comment|/* get pointer to the first chunk header */
name|ch
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * process all DATA chunks... 	 */
operator|*
name|high_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|break_flag
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|data_pkts_seen
operator|++
expr_stmt|;
while|while
condition|(
name|stop_proc
operator|==
literal|0
condition|)
block|{
comment|/* validate chunk length */
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|*
name|offset
operator|<
name|chk_length
condition|)
block|{
comment|/* all done, mutulated chunk */
name|stop_proc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* 				 * Need to send an abort since we had a 				 * invalid data chunk. 				 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_19
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_19
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
literal|0
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|==
operator|(
name|length
operator|-
operator|*
name|offset
operator|)
condition|)
block|{
name|last_chunk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_chunk
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sctp_process_a_data_chunk
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|mm
argument_list|,
operator|*
name|offset
argument_list|,
name|ch
argument_list|,
name|chk_length
argument_list|,
name|net
argument_list|,
name|high_tsn
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|&
name|break_flag
argument_list|,
name|last_chunk
argument_list|)
condition|)
block|{
name|num_chunks
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|abort_flag
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|break_flag
condition|)
block|{
comment|/* 				 * Set because of out of rwnd space and no 				 * drop rep space left. 				 */
name|stop_proc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not a data chunk in the data region */
switch|switch
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INITIATION
case|:
case|case
name|SCTP_INITIATION_ACK
case|:
case|case
name|SCTP_SELECTIVE_ACK
case|:
case|case
name|SCTP_NR_SELECTIVE_ACK
case|:
comment|/* EY */
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
case|case
name|SCTP_HEARTBEAT_ACK
case|:
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
case|case
name|SCTP_SHUTDOWN
case|:
case|case
name|SCTP_SHUTDOWN_ACK
case|:
case|case
name|SCTP_OPERATION_ERROR
case|:
case|case
name|SCTP_COOKIE_ECHO
case|:
case|case
name|SCTP_COOKIE_ACK
case|:
case|case
name|SCTP_ECN_ECHO
case|:
case|case
name|SCTP_ECN_CWR
case|:
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
case|case
name|SCTP_AUTHENTICATION
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
case|case
name|SCTP_PACKET_DROPPED
case|:
case|case
name|SCTP_STREAM_RESET
case|:
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
case|case
name|SCTP_ASCONF
case|:
comment|/* 				 * Now, what do we do with KNOWN chunks that 				 * are NOT in the right place? 				 *  				 * For now, I do nothing but ignore them. We 				 * may later want to add sysctl stuff to 				 * switch out and do either an ABORT() or 				 * possibly process them. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_data_order
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
literal|0
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
break|break;
default|default:
comment|/* unknown chunk type, use bit rules */
if|if
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|&
literal|0x40
condition|)
block|{
comment|/* Add a error report to the queue */
name|struct
name|mbuf
modifier|*
name|merr
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phd
decl_stmt|;
name|merr
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|merr
condition|)
block|{
name|phd
operator|=
name|mtod
argument_list|(
name|merr
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 						 * We cheat and use param 						 * type since we did not 						 * bother to define a error 						 * cause struct. They are 						 * the same basic format 						 * with different names. 						 */
name|phd
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRECOG_CHUNK
argument_list|)
expr_stmt|;
name|phd
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|chk_length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|merr
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|merr
argument_list|)
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|merr
argument_list|)
condition|)
block|{
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|merr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|merr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* discard the rest of this packet */
name|stop_proc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* else skip this bad chunk and 					 * continue... */
break|break;
block|}
empty_stmt|;
comment|/* switch of chunk type */
block|}
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|offset
operator|>=
name|length
operator|)
operator|||
name|stop_proc
condition|)
block|{
comment|/* no more data left in the mbuf chain */
name|stop_proc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
name|stop_proc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* while */
if|if
condition|(
name|break_flag
condition|)
block|{
comment|/* 		 * we need to report rwnd overrun drops. 		 */
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|*
name|mm
argument_list|,
name|iphlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_chunks
condition|)
block|{
comment|/* 		 * Did we get data, if so update the time for auto-close and 		 * give peer credit for being alive. 		 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpktwithdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_last_rcvd
argument_list|)
expr_stmt|;
block|}
comment|/* now service all of the reassm queue if needed */
if|if
condition|(
operator|!
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
operator|)
condition|)
name|sctp_service_queues
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* Assure that we ack right away */
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Start a sack timer or QUEUE a SACK for sending */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|data_pkts_seen
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|==
literal|0
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * EY if nr_sacks used then send an nr-sack , a sack 			 * otherwise 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nr_sack
condition|)
name|sctp_send_nr_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
else|else
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|was_a_gap
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abort_flag
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_process_segment_range
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
modifier|*
name|p_tp1
parameter_list|,
name|uint32_t
name|last_tsn
parameter_list|,
name|uint16_t
name|frag_strt
parameter_list|,
name|uint16_t
name|frag_end
parameter_list|,
name|int
name|nr_sacking
parameter_list|,
name|int
modifier|*
name|num_frs
parameter_list|,
name|uint32_t
modifier|*
name|biggest_newly_acked_tsn
parameter_list|,
name|uint32_t
modifier|*
name|this_sack_lowest_newack
parameter_list|,
name|int
modifier|*
name|ecn_seg_sums
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|unsigned
name|int
name|theTSN
decl_stmt|;
name|int
name|j
decl_stmt|,
name|wake_him
init|=
literal|0
decl_stmt|;
comment|/* Recover the tp1 we last saw */
name|tp1
operator|=
operator|*
name|p_tp1
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|frag_strt
init|;
name|j
operator|<=
name|frag_end
condition|;
name|j
operator|++
control|)
block|{
name|theTSN
operator|=
name|j
operator|+
name|last_tsn
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
condition|)
operator|(
operator|*
name|num_frs
operator|)
operator|+=
literal|1
expr_stmt|;
comment|/*- 			 * CMT: CUCv2 algorithm. For each TSN being 			 * processed from the sent queue, track the 			 * next expected pseudo-cumack, or 			 * rtx_pseudo_cumack, if required. Separate 			 * cumack trackers for first transmissions, 			 * and retransmissions. 			 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|==
literal|1
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|pseudo_cumack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|>
literal|1
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rtx_pseudo_cumack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|theTSN
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/*- 					 * must be held until 					 * cum-ack passes 					 */
comment|/*- 					 * ECN Nonce: Add the nonce 					 * value to the sender's 					 * nonce sum 					 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/*- 						 * If it is less than RESEND, it is 						 * now no-longer in flight. 						 * Higher values may already be set 						 * via previous Gap Ack Blocks... 						 * i.e. ACKED or RESEND. 						 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
operator|*
name|biggest_newly_acked_tsn
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/*- 						 * CMT: SFR algo (and HTNA) - set 						 * saw_newack to 1 for dest being 						 * newly acked. update 						 * this_sack_highest_newack if 						 * appropriate. 						 */
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/*- 						 * CMT DAC algo: also update 						 * this_sack_lowest_newack 						 */
if|if
condition|(
operator|*
name|this_sack_lowest_newack
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
operator|*
name|this_sack_lowest_newack
argument_list|,
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
operator|*
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/*- 						 * CMT: CUCv2 algorithm. If (rtx-)pseudo-cumack for corresp 						 * dest is being acked, then we have a new (rtx-)pseudo-cumack. Set 						 * new_(rtx_)pseudo_cumack to TRUE so that the cwnd for this dest can be 						 * updated. Also trigger search for the next expected (rtx-)pseudo-cumack. 						 * Separate pseudo_cumack trackers for first transmissions and 						 * retransmissions. 						 */
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tp1
operator|->
name|whoTo
operator|->
name|pseudo_cumack
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tp1
operator|->
name|whoTo
operator|->
name|rtx_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|frag_strt
argument_list|,
name|frag_end
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_GAP
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/*- 							 * True non-retransmited chunk 							 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/*- 							 * update RTO too ? 							 */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
operator|(
operator|*
name|ecn_seg_sums
operator|)
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
operator|(
operator|*
name|ecn_seg_sums
operator|)
operator|&=
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|this_sack_highest_gap
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|this_sack_highest_gap
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB2
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*- 					 * All chunks NOT UNSENT fall through here and are marked 					 * (leave PR-SCTP ones that are to skip alone though) 					 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
condition|)
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_MARKED
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
comment|/* NR Sack code here */
if|if
condition|(
name|nr_sacking
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
condition|)
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_NR_MARKED
expr_stmt|;
comment|/* 						 * TAILQ_REMOVE(&asoc->sent_q 						 * ueue, tp1, sctp_next); 						 */
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* 							 * sa_ignore 							 * NO_NULL_CHK 							 */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* asoc->sent_queue_cnt--; */
comment|/* 						 * sctp_free_a_chunk(stcb, 						 * tp1); 						 */
name|wake_him
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* if (tp1->TSN_seq == theTSN) */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|theTSN
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
break|break;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
comment|/* end while (tp1) */
comment|/* In case the fragments were not in order we must reset */
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end for (j = fragStart */
operator|*
name|p_tp1
operator|=
name|tp1
expr_stmt|;
return|return
operator|(
name|wake_him
operator|)
return|;
comment|/* Return value only used for nr-sack */
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_segments
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_sack_chunk
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|last_tsn
parameter_list|,
name|uint32_t
modifier|*
name|biggest_tsn_acked
parameter_list|,
name|uint32_t
modifier|*
name|biggest_newly_acked_tsn
parameter_list|,
name|uint32_t
modifier|*
name|this_sack_lowest_newack
parameter_list|,
name|int
name|num_seg
parameter_list|,
name|int
modifier|*
name|ecn_seg_sums
parameter_list|)
block|{
comment|/************************************************/
comment|/* process fragments and update sendqueue        */
comment|/************************************************/
name|struct
name|sctp_sack
modifier|*
name|sack
decl_stmt|;
name|struct
name|sctp_gap_ack_block
modifier|*
name|frag
decl_stmt|,
name|block
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_frs
init|=
literal|0
decl_stmt|;
name|uint16_t
name|frag_strt
decl_stmt|,
name|frag_end
decl_stmt|,
name|primary_flag_set
decl_stmt|;
name|u_long
name|last_frag_high
decl_stmt|;
comment|/* 	 * @@@ JRI : TODO: This flag is not used anywhere .. remove? 	 */
if|if
condition|(
name|asoc
operator|->
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_SWITCH_PRIMARY
condition|)
block|{
name|primary_flag_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|primary_flag_set
operator|=
literal|0
expr_stmt|;
block|}
name|sack
operator|=
operator|&
name|ch
operator|->
name|sack
expr_stmt|;
name|frag
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tp1
operator|=
name|NULL
expr_stmt|;
name|last_frag_high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_seg
condition|;
name|i
operator|++
control|)
block|{
name|frag_strt
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|start
argument_list|)
expr_stmt|;
name|frag_end
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* some sanity checks on the fragment offsets */
if|if
condition|(
name|frag_strt
operator|>
name|frag_end
condition|)
block|{
comment|/* this one is malformed, skip */
name|frag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
operator|(
name|frag_end
operator|+
name|last_tsn
operator|)
argument_list|,
operator|*
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
operator|*
name|biggest_tsn_acked
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
comment|/* mark acked dgs and find out the highestTSN being acked */
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
comment|/* save the locations of the last frags */
name|last_frag_high
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * now lets see if we need to reset the queue due to 			 * a out-of-order SACK fragment 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|frag_strt
operator|+
name|last_tsn
argument_list|,
name|last_frag_high
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 				 * if the new frag starts after the last TSN 				 * frag covered, we are ok and this one is 				 * beyond the last one 				 */
empty_stmt|;
block|}
else|else
block|{
comment|/* 				 * ok, they have reset us, so we need to 				 * reset the queue this will cause extra 				 * hunting but hey, they chose the 				 * performance hit when they failed to order 				 * their gaps 				 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|last_frag_high
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
name|sctp_process_segment_range
argument_list|(
name|stcb
argument_list|,
operator|&
name|tp1
argument_list|,
name|last_tsn
argument_list|,
name|frag_strt
argument_list|,
name|frag_end
argument_list|,
literal|0
argument_list|,
operator|&
name|num_frs
argument_list|,
name|biggest_newly_acked_tsn
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|ecn_seg_sums
argument_list|)
expr_stmt|;
name|frag
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|num_frs
condition|)
name|sctp_log_fr
argument_list|(
operator|*
name|biggest_tsn_acked
argument_list|,
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|last_tsn
argument_list|,
name|SCTP_FR_LOG_BIGGEST_TSNS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_check_for_revoked
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|u_long
name|biggest_tsn_acked
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|tot_revoked
init|=
literal|0
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cumack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ok this guy is either ACK or MARKED. If it is 			 * ACKED it has been previously acked but not this 			 * time i.e. revoked.  If it is MARKED it was ACK'ed 			 * again. 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* it has been revoked */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
comment|/* 				 * We must add this stuff back in to assure 				 * timers and such get started. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_REVOKE
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
comment|/* 				 * We inflate the cwnd to compensate for our 				 * artificial inflation of the flight_size. 				 */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tot_revoked
operator|++
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_REVOKED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_MARKED
condition|)
block|{
comment|/* it has been re-acked in this SACK */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
break|break;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tot_revoked
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Setup the ecn nonce re-sync point. We do this since once 		 * data is revoked we begin to retransmit things, which do 		 * NOT have the ECN bits set. This means we are now out of 		 * sync and must wait until we get back in sync with the 		 * peer to check ECN bits. 		 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_strike_gap_ack_chunks
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|u_long
name|biggest_tsn_acked
parameter_list|,
name|u_long
name|biggest_tsn_newly_acked
parameter_list|,
name|u_long
name|this_sack_lowest_newack
parameter_list|,
name|int
name|accum_moved
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|strike_flag
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|tot_retrans
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sending_seq
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|num_dests_sacked
init|=
literal|0
decl_stmt|;
comment|/* 	 * select the sending_seq, this is either the next thing ready to be 	 * sent but not transmitted, OR, the next seq we assign. 	 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|sending_seq
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|sending_seq
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/* CMT DAC algo: finding out if SACK is a mixed SACK */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|saw_newack
condition|)
name|num_dests_sacked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
name|strike_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|no_fr_allowed
condition|)
block|{
comment|/* this one had a timeout or something */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_CHECK_STRIKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* done */
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
condition|)
block|{
if|if
condition|(
operator|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
operator|&&
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* Is it expired? */
if|if
condition|(
comment|/* 				 * TODO sctp_constants.h needs alternative 				 * time macros when _KERNEL is undefined. 				 */
operator|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
operator|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|this_sack_highest_gap
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* we are beyond the tsn in the sack  */
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|>=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* either a RESEND, ACKED, or MARKED */
comment|/* skip */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * CMT : SFR algo (covers part of DAC and HTNA as well) 		 */
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|&&
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No new acks were receieved for data sent to this 			 * dest. Therefore, according to the SFR algo for 			 * CMT, no data sent to this dest can be marked for 			 * FR using this SACK. 			 */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|&&
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * CMT: New acks were receieved for data sent to 			 * this dest. But no new acks were seen for data 			 * sent after tp1. Therefore, according to the SFR 			 * algo for CMT, tp1 cannot be marked for FR using 			 * this SACK. This step covers part of the DAC algo 			 * and the HTNA algo as well. 			 */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Here we check to see if we were have already done a FR 		 * and if so we see if the biggest TSN we saw in the sack is 		 * smaller than the recovery point. If so we don't strike 		 * the tsn... otherwise we CAN strike the TSN. 		 */
comment|/* 		 * @@@ JRI: Check for CMT if (accum_moved&& 		 * asoc->fast_retran_loss_recovery&& (sctp_cmt_on_off == 		 * 0)) { 		 */
if|if
condition|(
name|accum_moved
operator|&&
name|asoc
operator|->
name|fast_retran_loss_recovery
condition|)
block|{
comment|/* 			 * Strike the TSN if in fast-recovery and cum-ack 			 * moved. 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: If SACK flag is set to 				 * 0, then lowest_newack test will not pass 				 * because it would have been set to the 				 * cumack earlier. If not already to be 				 * rtx'd, If not a mixed sack and if tp1 is 				 * not between two sacked TSNs, then mark by 				 * one more. NOTE that we are marking by one 				 * additional time since the SACK DAC flag 				 * indicates that two packets have been 				 * received after this missing TSN. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|compare_with_wrap
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|16
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * For those that have done a FR we must take 			 * special consideration if we strike. I.e the 			 * biggest_newly_acked must be higher than the 			 * sending_seq at the time we did the FR. 			 */
if|if
condition|(
ifdef|#
directive|ifdef
name|SCTP_FR_TO_ALTERNATE
comment|/* 			 * If FR's go to new networks, then we must only do 			 * this for singly homed asoc's. However if the FR's 			 * go to the same network (Armando's work) then its 			 * ok to FR multiple times. 			 */
operator|(
name|asoc
operator|->
name|numnets
operator|<
literal|2
operator|)
else|#
directive|else
operator|(
literal|1
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|(
name|compare_with_wrap
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|biggest_tsn_newly_acked
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|)
condition|)
block|{
comment|/* 					 * Strike the TSN, since this ack is 					 * beyond where things were when we 					 * did a FR. 					 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
name|strike_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/* 						 * CMT DAC algorithm: If 						 * SACK flag is set to 0, 						 * then lowest_newack test 						 * will not pass because it 						 * would have been set to 						 * the cumack earlier. If 						 * not already to be rtx'd, 						 * If not a mixed sack and 						 * if tp1 is not between two 						 * sacked TSNs, then mark by 						 * one more. NOTE that we 						 * are marking by one 						 * additional time since the 						 * SACK DAC flag indicates 						 * that two packets have 						 * been received after this 						 * missing TSN. 						 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|compare_with_wrap
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|32
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* 			 * JRI: TODO: remove code for HTNA algo. CMT's SFR 			 * algo covers HTNA. 			 */
block|}
elseif|else
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|biggest_tsn_newly_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * We don't strike these: This is the  HTNA 			 * algorithm i.e. we don't strike If our TSN is 			 * larger than the Highest TSN Newly Acked. 			 */
empty_stmt|;
block|}
else|else
block|{
comment|/* Strike the TSN */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: If SACK flag is set to 				 * 0, then lowest_newack test will not pass 				 * because it would have been set to the 				 * cumack earlier. If not already to be 				 * rtx'd, If not a mixed sack and if tp1 is 				 * not between two sacked TSNs, then mark by 				 * one more. NOTE that we are marking by one 				 * additional time since the SACK DAC flag 				 * indicates that two packets have been 				 * received after this missing TSN. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|compare_with_wrap
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|48
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* fix counts and things */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_RSND
argument_list|,
operator|(
name|tp1
operator|->
name|whoTo
condition|?
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|)
else|:
literal|0
operator|)
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|whoTo
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|++
expr_stmt|;
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd
argument_list|(
name|SCTP_INCREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|tp1
operator|->
name|send_size
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* add back to the rwnd */
name|asoc
operator|->
name|peers_rwnd
operator|+=
operator|(
name|tp1
operator|->
name|send_size
operator|+
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
expr_stmt|;
comment|/* remove from the total flight */
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|PR_SCTP_RTX_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * Has it been retransmitted tv_sec times? - 				 * we store the retran count there. 				 */
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|>
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
condition|)
block|{
comment|/* Yes, so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure to flag we had a FR */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|++
expr_stmt|;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* printf("OK, we are now ready to FR this guy\n"); */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|snd_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_MARKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strike_flag
condition|)
block|{
comment|/* This is a subsequent FR */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendmultfastretrans
argument_list|)
expr_stmt|;
block|}
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
condition|)
block|{
comment|/* 				 * CMT: Using RTX_SSTHRESH policy for CMT. 				 * If CMT is being used, then pick dest with 				 * largest ssthresh for any retransmission. 				 */
name|tp1
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_pf
argument_list|)
condition|)
block|{
comment|/* 					 * JRS 5/18/07 - If CMT PF is on, 					 * use the PF version of 					 * find_alt_net() 					 */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * JRS 5/18/07 - If only CMT is on, 					 * use the CMT version of 					 * find_alt_net() 					 */
comment|/* sa_ignore NO_NULL_CHK */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
block|}
comment|/* 				 * CUCv2: If a different dest is picked for 				 * the retransmission, then new 				 * (rtx-)pseudo_cumack needs to be tracked 				 * for orig dest. Let CUCv2 track new (rtx-) 				 * pseudo-cumack always. 				 */
if|if
condition|(
name|tp1
operator|->
name|whoTo
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* CMT is OFF */
ifdef|#
directive|ifdef
name|SCTP_FR_TO_ALTERNATE
comment|/* Can we find an alternate? */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 				 * default behavior is to NOT retransmit 				 * FR's to an alternate. Armando Caro's 				 * paper details why. 				 */
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
endif|#
directive|endif
block|}
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|1
expr_stmt|;
name|tot_retrans
operator|++
expr_stmt|;
comment|/* mark the sending seq for possible subsequent FR's */
comment|/* 			 * printf("Marking TSN for FR new value %x\n", 			 * (uint32_t)tpi->rec.data.TSN_seq); 			 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
condition|)
block|{
comment|/* 				 * If the queue of send is empty then its 				 * the next sequence number that will be 				 * assigned so we subtract one from this to 				 * get the one we last sent. 				 */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If there are chunks on the send queue 				 * (unsent data that has made it from the 				 * stream queues but not out the door, we 				 * take the first one (which will have the 				 * lowest TSN) and subtract one to get the 				 * one we last sent. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|ttt
decl_stmt|;
name|ttt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|ttt
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
comment|/* 				 * this guy had a RTO calculation pending on 				 * it, cancel it 				 */
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|!=
name|tp1
operator|->
name|whoTo
condition|)
block|{
comment|/* yes, there is an alternate. */
name|sctp_free_remote_addr
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
name|tp1
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
comment|/* while (tp1) */
if|if
condition|(
name|tot_retrans
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Setup the ecn nonce re-sync point. We do this since once 		 * we go to FR something we introduce a Karn's rule scenario 		 * and won't know the totals for the ECN bits. 		 */
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|sending_seq
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|sctp_tmit_chunk
modifier|*
name|sctp_try_advance_peer_ack_point
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|,
modifier|*
name|a_adv
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
operator|&&
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* no chance to advance, out of here */
break|break;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_FORWARD_TSN_SKIP
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|PR_SCTP_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* 			 * We can't fwd-tsn past any that are reliable aka 			 * retransmitted until the asoc fails. 			 */
break|break;
block|}
if|if
condition|(
operator|!
name|now_filled
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|now_filled
operator|=
literal|1
expr_stmt|;
block|}
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 		 * now we got a chunk which is marked for another 		 * retransmission to a PR-stream but has run out its chances 		 * already maybe OR has been marked to skip now. Can we skip 		 * it if its a resend? 		 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
operator|&&
operator|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Now is this one marked for resend and its time is 			 * now up? 			 */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * No, we are done when hit one for resend 				 * whos time as not expired. 				 */
break|break;
block|}
block|}
comment|/* 		 * Ok now if this chunk is marked to drop it we can clean up 		 * the chunk, advance our peer ack point and we can check 		 * the next chunk. 		 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_FORWARD_TSN_SKIP
condition|)
block|{
comment|/* advance PeerAckPoint goes forward */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|a_adv
operator|=
name|tp1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|asoc
operator|->
name|advanced_peer_ack_point
condition|)
block|{
comment|/* No update but we do save the chk */
name|a_adv
operator|=
name|tp1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * If it is still in RESEND we can advance no 			 * further 			 */
break|break;
block|}
comment|/* 		 * If we hit here we just dumped tp1, move to next tsn on 		 * sent queue. 		 */
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
return|return
operator|(
name|a_adv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_fs_audit
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|int
name|inflight
init|=
literal|0
decl_stmt|,
name|resend
init|=
literal|0
decl_stmt|,
name|inbetween
init|=
literal|0
decl_stmt|,
name|acked
init|=
literal|0
decl_stmt|,
name|above
init|=
literal|0
decl_stmt|;
name|int
name|entry_flight
decl_stmt|,
name|entry_cnt
decl_stmt|,
name|ret
decl_stmt|;
name|entry_flight
operator|=
name|asoc
operator|->
name|total_flight
expr_stmt|;
name|entry_cnt
operator|=
name|asoc
operator|->
name|total_flight_count
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>=
name|asoc
operator|->
name|sent_queue_cnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|printf
argument_list|(
literal|"Chk TSN:%u size:%d inflight cnt:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|)
expr_stmt|;
name|inflight
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|resend
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
name|inbetween
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
name|above
operator|++
expr_stmt|;
block|}
else|else
block|{
name|acked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|inflight
operator|>
literal|0
operator|)
operator|||
operator|(
name|inbetween
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Flight size-express incorrect? \n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"asoc->total_flight:%d cnt:%d\n"
argument_list|,
name|entry_flight
argument_list|,
name|entry_cnt
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"Flight size-express incorrect F:%d I:%d R:%d Ab:%d ACK:%d\n"
argument_list|,
name|inflight
argument_list|,
name|inbetween
argument_list|,
name|resend
argument_list|,
name|above
argument_list|,
name|acked
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_window_probe_recovery
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
parameter_list|)
block|{
name|tp1
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|>=
name|SCTP_DATAGRAM_ACKED
operator|)
operator|||
operator|(
name|tp1
operator|->
name|data
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* TSN's skipped we do NOT move back. */
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DWN_WP_FWD
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First setup this by shrinking flight */
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
comment|/* Now mark for resend */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_WP
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_express_handle_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|,
name|int
name|nonce_sum_flag
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|old_rwnd
decl_stmt|;
name|int
name|win_probe_recovery
init|=
literal|0
decl_stmt|;
name|int
name|win_probe_recovered
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|done_once
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_SACK_ARRIVALS_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_LOG_EXPRESS
argument_list|,
name|cumack
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
index|]
operator|=
name|cumack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|>
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|old_rwnd
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* old ack */
return|return;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|cumack
condition|)
block|{
comment|/* Window update sack */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
goto|goto
name|again
goto|;
block|}
return|return;
block|}
comment|/* First setup for CC stuff */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC and Fast recovery algo variables before 		 * SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_sacks
argument_list|)
condition|)
block|{
name|uint32_t
name|send_s
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cumack
operator|==
name|send_s
operator|)
operator|||
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|INVARIANTS
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Impossible sack 1"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
block|}
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* process the new consecutive TSN first */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|cumack
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
name|printf
argument_list|(
literal|"Warning, an unsent is now acked?\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * ECN Nonce: Add the nonce to the sender's 				 * nonce sum 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_CA
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
comment|/* 							 * sa_ignore 							 * NO_NULL_CHK 							 */
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cumack
argument_list|,
literal|1
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cumack
argument_list|,
literal|1
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* JRS - Use the congestion control given in the CC module */
if|if
condition|(
name|asoc
operator|->
name|last_acked_seq
operator|!=
name|cumack
condition|)
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_sack
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ECN Nonce updates */
if|if
condition|(
name|asoc
operator|->
name|ecn_nonce_allowed
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_sum_check
condition|)
block|{
if|if
condition|(
name|nonce_sum_flag
operator|!=
operator|(
operator|(
name|asoc
operator|->
name|nonce_sum_expect_base
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_wait_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|nonce_wait_tsn
operator|)
condition|)
block|{
comment|/* 						 * Misbehaving peer. We need 						 * to react to this guy 						 */
name|asoc
operator|->
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* See if Resynchronization Possible */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_resync_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
comment|/* 				 * now we must calculate what the base is. 				 * We do this based on two things, we know 				 * the total's for all the segments 				 * gap-acked in the SACK (none), We also 				 * know the SACK's nonce sum, its in 				 * nonce_sum_flag. So we can build a truth 				 * table to back-calculate the new value of 				 * asoc->nonce_sum_expect_base: 				 *  				 * SACK-flag-Value         Seg-Sums Base 0 0 0 				 * 1                    0 1 0 1 1 1 				 * 1 0 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
operator|(
literal|0
operator|^
name|nonce_sum_flag
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
block|}
block|}
block|}
comment|/* RWND update */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
name|win_probe_recovery
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now assure a timer where data is queued at */
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|int
name|to_ticks
decl_stmt|;
if|if
condition|(
name|win_probe_recovery
operator|&&
operator|(
name|net
operator|->
name|window_probe
operator|)
condition|)
block|{
name|win_probe_recovered
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Find first chunk that was used with window probe 			 * and clear the sent 			 */
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|window_probe
condition|)
block|{
name|sctp_window_probe_recovery
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
comment|/* 				 * In window probes we must assure a timer 				 * is still running there 				 */
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|win_probe_recovered
operator|==
literal|0
operator|)
operator|&&
operator|(
name|done_once
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * huh, this should not happen unless all packets are 		 * PR-SCTP and marked to skip of course. 		 */
if|if
condition|(
name|sctp_fs_audit
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|done_once
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* 			 * I may be in a state where we got all across.. but 			 * cannot write more due to a shutdown... we abort 			 * since the user did not indicate EOR in this case. 			 * The sp will be cleaned during free of the asoc. 			 */
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Let cleanup code purge it */
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*********************************************/
comment|/* Here we perform PR-SCTP procedures        */
comment|/* (section 4.2)                             */
comment|/*********************************************/
comment|/* C1. update advancedPeerAckPoint */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cumack
expr_stmt|;
block|}
comment|/* PR-Sctp issues need to be addressed too */
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|uint32_t
name|old_adv_peer_ack_point
decl_stmt|;
name|old_adv_peer_ack_point
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|cumack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing for notes 			 * on issues that will occur when the ECN NONCE 			 * stuff is put into SCTP for cross checking. 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* 				 * ECN Nonce: Disable Nonce Sum check when 				 * FWD TSN is sent and store resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* try to FR fwd-tsn's that get lost too */
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|>
literal|3
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_handle_sack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_sack_chunk
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net_from
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|,
name|int
name|sack_len
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_sack
modifier|*
name|sack
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|cum_ack
decl_stmt|,
name|last_tsn
decl_stmt|,
name|biggest_tsn_acked
decl_stmt|,
name|biggest_tsn_newly_acked
decl_stmt|,
name|this_sack_lowest_newack
decl_stmt|;
name|uint32_t
name|sav_cum_ack
decl_stmt|;
name|uint16_t
name|num_seg
decl_stmt|,
name|num_dup
decl_stmt|;
name|uint16_t
name|wake_him
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|sack_length
decl_stmt|;
name|uint32_t
name|send_s
init|=
literal|0
decl_stmt|;
name|long
name|j
decl_stmt|;
name|int
name|accum_moved
init|=
literal|0
decl_stmt|;
name|int
name|will_exit_fast_recovery
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|,
name|old_rwnd
decl_stmt|;
name|int
name|win_probe_recovery
init|=
literal|0
decl_stmt|;
name|int
name|win_probe_recovered
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|int
name|nonce_sum_flag
decl_stmt|,
name|ecn_seg_sums
init|=
literal|0
decl_stmt|;
name|int
name|done_once
decl_stmt|;
name|uint8_t
name|reneged_all
init|=
literal|0
decl_stmt|;
name|uint8_t
name|cmt_dac_flag
decl_stmt|;
comment|/* 	 * we take any chance we can to service our queues since we cannot 	 * get awoken when the socket is read from :< 	 */
comment|/* 	 * Now perform the actual SACK handling: 1) Verify that it is not an 	 * old sack, if so discard. 2) If there is nothing left in the send 	 * queue (cum-ack is equal to last acked) then you have a duplicate 	 * too, update any rwnd change and verify no timers are running. 	 * then return. 3) Process any new consequtive data i.e. cum-ack 	 * moved process these first and note that it moved. 4) Process any 	 * sack blocks. 5) Drop any acked from the queue. 6) Check for any 	 * revoked blocks and mark. 7) Update the cwnd. 8) Nothing left, 	 * sync up flightsizes and things, stop all timers and also check 	 * for shutdown_pending state. If so then go ahead and send off the 	 * shutdown. If in shutdown recv, send off the shutdown-ack and 	 * start that timer, Ret. 9) Strike any non-acked things and do FR 	 * procedure if needed being sure to set the FR flag. 10) Do pr-sctp 	 * procedures. 11) Apply any FR penalties. 12) Assure we will SACK 	 * if in shutdown_recv state. 	 */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sack
operator|=
operator|&
name|ch
operator|->
name|sack
expr_stmt|;
comment|/* CMT DAC algo */
name|this_sack_lowest_newack
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|sack_length
operator|=
operator|(
name|unsigned
name|int
operator|)
name|sack_len
expr_stmt|;
comment|/* ECN Nonce */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_slowpath_sack
argument_list|)
expr_stmt|;
name|nonce_sum_flag
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
name|cum_ack
operator|=
name|last_tsn
operator|=
name|ntohl
argument_list|(
name|sack
operator|->
name|cum_tsn_ack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
index|]
operator|=
name|cum_ack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|>
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|num_seg
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|num_gap_ack_blks
argument_list|)
expr_stmt|;
name|a_rwnd
operator|=
name|rwnd
expr_stmt|;
comment|/* CMT DAC algo */
name|cmt_dac_flag
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_SACK_CMT_DAC
expr_stmt|;
name|num_dup
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|num_dup_tsns
argument_list|)
expr_stmt|;
name|old_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
literal|0
argument_list|,
name|num_seg
argument_list|,
name|num_dup
argument_list|,
name|SCTP_LOG_NEW_SACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num_dup
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
operator|(
name|SCTP_FR_LOGGING_ENABLE
operator||
name|SCTP_EARLYFR_LOGGING_ENABLE
operator|)
operator|)
condition|)
block|{
name|int
name|off_to_dup
decl_stmt|,
name|iii
decl_stmt|;
name|uint32_t
modifier|*
name|dupdata
decl_stmt|,
name|dblock
decl_stmt|;
name|off_to_dup
operator|=
operator|(
name|num_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_to_dup
operator|+
operator|(
name|num_dup
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
operator|<=
name|sack_length
condition|)
block|{
name|dupdata
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|off_to_dup
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
name|off_to_dup
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|dupdata
condition|)
block|{
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
name|num_dup
condition|;
name|iii
operator|++
control|)
block|{
name|sctp_log_fr
argument_list|(
operator|*
name|dupdata
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_DUPED
argument_list|)
expr_stmt|;
name|dupdata
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|off_to_dup
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dupdata
operator|==
name|NULL
condition|)
break|break;
name|off_to_dup
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Size invalid offset to dups:%d number dups:%d sack_len:%d num gaps:%d\n"
argument_list|,
name|off_to_dup
argument_list|,
name|num_dup
argument_list|,
name|sack_length
argument_list|,
name|num_seg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_sacks
argument_list|)
condition|)
block|{
comment|/* reality check */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
if|if
condition|(
name|cum_ack
operator|==
name|send_s
operator|||
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|INVARIANTS
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
name|hopeless_peer
label|:
name|panic
argument_list|(
literal|"Impossible sack 1"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 			 * no way, we have not even sent this TSN out yet. 			 * Peer is hopelessly messed up with us. 			 */
name|hopeless_peer
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
block|}
comment|/**********************/
comment|/* 1) check the range */
comment|/**********************/
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|last_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* acking something behind */
return|return;
block|}
name|sav_cum_ack
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* update the Rwnd of the peer */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing left on send/sent and strmq */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* stop any timers */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck1
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * We init netAckSz and netAckSz2 to 0. These are used to track 2 	 * things. The total byte count acked is tracked in netAckSz AND 	 * netAck2 is used to track the total bytes acked that are un- 	 * amibguious and were never retransmitted. We track these on a per 	 * destination address basis. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC and Fast recovery algo variables before 		 * SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
block|}
comment|/* process the new consecutive TSN first */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|last_tsn
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 				 * ECN Nonce: Add the nonce to the sender's 				 * nonce sum 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
name|accum_moved
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* 						 * If there was no retran 						 * and the address is 						 * un-confirmed and we sent 						 * there and are now 						 * sacked.. its confirmed, 						 * mark it so. 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_CA
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* CMT SFR and DAC algos */
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB3
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
name|biggest_tsn_newly_acked
operator|=
name|biggest_tsn_acked
operator|=
name|last_tsn
expr_stmt|;
comment|/* always set this up to cum-ack */
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|last_tsn
expr_stmt|;
comment|/* Move offset up to point to gaps/dups */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|num_seg
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|)
operator|>
name|sack_length
condition|)
block|{
comment|/* skip corrupt segments */
goto|goto
name|skip_segments
goto|;
block|}
if|if
condition|(
name|num_seg
operator|>
literal|0
condition|)
block|{
comment|/* 		 * CMT: SFR algo (and HTNA) - this_sack_highest_newack has 		 * to be greater than the cumack. Also reset saw_newack to 0 		 * for all dests. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|saw_newack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|this_sack_highest_newack
operator|=
name|last_tsn
expr_stmt|;
block|}
comment|/* 		 * thisSackHighestGap will increase while handling NEW 		 * segments this_sack_highest_newack will increase while 		 * handling NEWLY ACKED chunks. this_sack_lowest_newack is 		 * used for CMT DAC algo. saw_newack will also change. 		 */
name|sctp_handle_segments
argument_list|(
name|m
argument_list|,
operator|&
name|offset
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ch
argument_list|,
name|last_tsn
argument_list|,
operator|&
name|biggest_tsn_acked
argument_list|,
operator|&
name|biggest_tsn_newly_acked
argument_list|,
operator|&
name|this_sack_lowest_newack
argument_list|,
name|num_seg
argument_list|,
operator|&
name|ecn_seg_sums
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_sacks
argument_list|)
condition|)
block|{
comment|/* 			 * validate the biggest_tsn_acked in the gap acks if 			 * strict adherence is wanted. 			 */
if|if
condition|(
operator|(
name|biggest_tsn_acked
operator|==
name|send_s
operator|)
operator|||
operator|(
name|compare_with_wrap
argument_list|(
name|biggest_tsn_acked
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * peer is either confused or we are under 				 * attack. We must abort. 				 */
goto|goto
name|hopeless_peer
goto|;
block|}
block|}
block|}
name|skip_segments
label|:
comment|/*******************************************/
comment|/* cancel ALL T3-send timer if accum moved */
comment|/*******************************************/
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|new_pseudo_cumack
condition|)
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_27
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|accum_moved
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_28
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/********************************************/
comment|/* drop the acked chunks from the sendqueue */
comment|/********************************************/
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cum_ack
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
goto|goto
name|done_with_it
goto|;
do|do
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cum_ack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* no more sent on list */
name|printf
argument_list|(
literal|"Warning, tp1->sent == %d and its now acked?\n"
argument_list|,
name|tp1
operator|->
name|sent
argument_list|)
expr_stmt|;
block|}
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|pr_sctp_on
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|!=
literal|0
condition|)
name|asoc
operator|->
name|pr_sctp_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Warning flight size is postive and should be 0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Warning flight size incorrect should be 0 is %d\n"
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|&&
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|wake_him
operator|++
expr_stmt|;
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
do|while
condition|(
name|tp1
operator|!=
name|NULL
condition|)
do|;
name|done_with_it
label|:
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
operator|(
name|wake_him
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_socket
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|wake_him
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|wake_him
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|accum_moved
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|fast_recovery_tsn
condition|)
block|{
comment|/* Setup so we will exit RFC2582 fast recovery */
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for revoked fragments: 	 *  	 * if Previous sack - Had no frags then we can't have any revoked if 	 * Previous sack - Had frag's then - If we now have frags aka 	 * num_seg> 0 call sctp_check_for_revoked() to tell if peer revoked 	 * some of them. else - The peer revoked all ACKED fragments, since 	 * we had some before and now we have NONE. 	 */
if|if
condition|(
name|num_seg
condition|)
name|sctp_check_for_revoked
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|cum_ack
argument_list|,
name|biggest_tsn_acked
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|asoc
operator|->
name|saw_sack_with_frags
condition|)
block|{
name|int
name|cnt_revoked
init|=
literal|0
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|!=
name|NULL
condition|)
block|{
comment|/* Peer revoked all dg's marked or acked */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_FORWARD_TSN_SKIP
operator|)
condition|)
block|{
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_REVOKE
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
comment|/* 					 * To ensure that this increase in 					 * flightsize, which is artificial, 					 * does not throttle the sender, we 					 * also increase the cwnd 					 * artificially. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|cnt_revoked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_revoked
condition|)
block|{
name|reneged_all
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_seg
condition|)
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|1
expr_stmt|;
else|else
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
comment|/* JRS - Use the congestion control given in the CC module */
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_sack
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|accum_moved
argument_list|,
name|reneged_all
argument_list|,
name|will_exit_fast_recovery
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* stop all timers */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_29
argument_list|)
expr_stmt|;
block|}
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_30
argument_list|)
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* 			 * I may be in a state where we got all across.. but 			 * cannot write more due to a shutdown... we abort 			 * since the user did not indicate EOR in this case. 			 */
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now here we are going to recycle net_ack for a different use... 	 * HEADS UP. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT DAC algorithm: If SACK DAC flag was 0, then no extra marking 	 * to be done. Setting this_sack_lowest_newack to the cum_ack will 	 * automatically ensure that. 	 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
operator|&&
operator|(
name|cmt_dac_flag
operator|==
literal|0
operator|)
condition|)
block|{
name|this_sack_lowest_newack
operator|=
name|cum_ack
expr_stmt|;
block|}
if|if
condition|(
name|num_seg
operator|>
literal|0
condition|)
block|{
name|sctp_strike_gap_ack_chunks
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|biggest_tsn_newly_acked
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|accum_moved
argument_list|)
expr_stmt|;
block|}
comment|/* JRS - Use the congestion control given in the CC module */
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_fr
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/****************************************************************** 	 *  Here we do the stuff with ECN Nonce checking. 	 *  We basically check to see if the nonce sum flag was incorrect 	 *  or if resynchronization needs to be done. Also if we catch a 	 *  misbehaving receiver we give him the kick. 	 ******************************************************************/
if|if
condition|(
name|asoc
operator|->
name|ecn_nonce_allowed
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_sum_check
condition|)
block|{
if|if
condition|(
name|nonce_sum_flag
operator|!=
operator|(
operator|(
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+
name|ecn_seg_sums
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_wait_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|nonce_wait_tsn
operator|)
condition|)
block|{
comment|/* 						 * Misbehaving peer. We need 						 * to react to this guy 						 */
name|asoc
operator|->
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* See if Resynchronization Possible */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_resync_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
comment|/* 				 * now we must calculate what the base is. 				 * We do this based on two things, we know 				 * the total's for all the segments 				 * gap-acked in the SACK, its stored in 				 * ecn_seg_sums. We also know the SACK's 				 * nonce sum, its in nonce_sum_flag. So we 				 * can build a truth table to back-calculate 				 * the new value of 				 * asoc->nonce_sum_expect_base: 				 *  				 * SACK-flag-Value         Seg-Sums Base 0 0 0 				 * 1                    0 1 0 1 1 1 				 * 1 0 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
operator|(
name|ecn_seg_sums
operator|^
name|nonce_sum_flag
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
block|}
block|}
block|}
comment|/* Now are we exiting loss recovery ? */
if|if
condition|(
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|sat_t3_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|sat_t3_recovery_tsn
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* end satellite t3 loss recovery */
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT Fast recovery 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Adjust and set the new rwnd value */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|a_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
name|win_probe_recovery
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now we must setup so we have a timer up for anyone with 	 * outstanding data. 	 */
name|done_once
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|win_probe_recovery
operator|&&
operator|(
name|net
operator|->
name|window_probe
operator|)
condition|)
block|{
name|win_probe_recovered
operator|=
literal|1
expr_stmt|;
comment|/*- 			 * Find first chunk that was used with 			 * window probe and clear the event. Put 			 * it back into the send queue as if has 			 * not been sent. 			 */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|window_probe
condition|)
block|{
name|sctp_window_probe_recovery
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{ 			}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
comment|/* 				 * In window probes we must assure a timer 				 * is still running there 				 */
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|win_probe_recovered
operator|==
literal|0
operator|)
operator|&&
operator|(
name|done_once
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * huh, this should not happen unless all packets are 		 * PR-SCTP and marked to skip of course. 		 */
if|if
condition|(
name|sctp_fs_audit
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|done_once
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/* Fix up the a-p-a-p for future PR-SCTP sends */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cum_ack
expr_stmt|;
block|}
comment|/* C2. try to further move advancedPeerAckPoint ahead */
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|uint32_t
name|old_adv_peer_ack_point
decl_stmt|;
name|old_adv_peer_ack_point
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|cum_ack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing for notes 			 * on issues that will occur when the ECN NONCE 			 * stuff is put into SCTP for cross checking. 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
literal|0xee
argument_list|,
name|cum_ack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* 				 * ECN Nonce: Disable Nonce Sum check when 				 * FWD TSN is sent and store resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* try to FR fwd-tsn's that get lost too */
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|>
literal|3
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|a_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_update_acked
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_shutdown_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|netp
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* Copy cum-ack */
name|uint32_t
name|cum_ack
decl_stmt|,
name|a_rwnd
decl_stmt|;
name|cum_ack
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|cumulative_tsn_ack
argument_list|)
expr_stmt|;
comment|/* Arrange so a_rwnd does NOT change */
name|a_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
comment|/* Now call the express sack handling */
name|sctp_express_handle_sack
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
literal|0
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_kick_prsctp_reorder_queue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strmin
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|tt
decl_stmt|;
comment|/* EY -used to calculate nr_gap information */
name|uint32_t
name|nr_tsn
decl_stmt|,
name|nr_gap
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|tt
operator|=
name|strmin
operator|->
name|last_sequence_delivered
expr_stmt|;
comment|/* 	 * First deliver anything prior to and including the stream no that 	 * came in 	 */
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tt
argument_list|,
name|ctl
operator|->
name|sinfo_ssn
argument_list|,
name|MAX_SEQ
argument_list|)
operator|||
operator|(
name|tt
operator|==
name|ctl
operator|->
name|sinfo_ssn
operator|)
condition|)
block|{
comment|/* this is deliverable now */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* subtract pending on streams */
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|ctl
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
comment|/* deliver it to at least the delivery-q */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
comment|/* EY need the tsn info for calculating nr */
name|nr_tsn
operator|=
name|ctl
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ctl
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 				 * EY this is the chunk that should be 				 * tagged nr gapped calculate the gap and 				 * such then tag this TSN nr 				 * chk->rec.data.TSN_seq 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|nr_mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nr_gap
operator|>=
operator|(
name|SCTP_NR_MAPPING_ARRAY
operator|<<
literal|3
operator|)
operator|)
operator|||
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
condition|)
block|{
comment|/* 						 * EY These should never 						 * happen- explained before 						 */
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|nr_tsn
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|nr_gap
argument_list|)
condition|)
comment|/* 						 * printf("In 						 * sctp_kick_prsctp_reorder_q 						 * ueue(7): Something wrong, 						 * the TSN to be tagged" 						 * "\nas NR is not even in 						 * the mapping_array, or map 						 * and nr_map are 						 * inconsistent"); 						 */
comment|/* 						 * EY - not %100 sure about 						 * the lock thing, don't 						 * think its required 						 */
comment|/* 						 * SCTP_TCB_LOCK_ASSERT(stcb) 						 * ; 						 */
block|{
comment|/* 						 * printf("\nCalculating an 						 * nr_gap!!\nmapping_array_si 						 * ze = %d 						 * nr_mapping_array_size = 						 * %d" "\nmapping_array_base 						 * = %d 						 * nr_mapping_array_base = 						 * %d\nhighest_tsn_inside_map 						 *  = %d" 						 * "highest_tsn_inside_nr_map 						 *  = %d\nTSN = %d nr_gap = 						 * %d",asoc->mapping_array_si 						 * ze, 						 * asoc->nr_mapping_array_siz 						 * e, 						 * asoc->mapping_array_base_t 						 * sn, 						 * asoc->nr_mapping_array_bas 						 * e_tsn, 						 * asoc->highest_tsn_inside_m 						 * ap, 						 * asoc->highest_tsn_inside_n 						 * r_map,tsn,nr_gap); 						 */
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* no more delivery now. */
break|break;
block|}
name|ctl
operator|=
name|nctl
expr_stmt|;
block|}
comment|/* 	 * now we must deliver things in queue the normal way  if any are 	 * now ready. 	 */
name|tt
operator|=
name|strmin
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|==
name|ctl
operator|->
name|sinfo_ssn
condition|)
block|{
comment|/* this is deliverable now */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* subtract pending on streams */
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|ctl
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
comment|/* deliver it to at least the delivery-q */
name|strmin
operator|->
name|last_sequence_delivered
operator|=
name|ctl
operator|->
name|sinfo_ssn
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
comment|/* EY */
name|nr_tsn
operator|=
name|ctl
operator|->
name|sinfo_tsn
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ctl
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 				 * EY this is the chunk that should be 				 * tagged nr gapped calculate the gap and 				 * such then tag this TSN nr 				 * chk->rec.data.TSN_seq 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|nr_mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nr_gap
operator|>=
operator|(
name|SCTP_NR_MAPPING_ARRAY
operator|<<
literal|3
operator|)
operator|)
operator|||
operator|(
name|nr_gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|<<
literal|3
argument_list|)
operator|)
condition|)
block|{
comment|/* 						 * EY These should never 						 * happen, explained before 						 */
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|nr_gap
argument_list|)
expr_stmt|;
name|SCTP_REVERSE_OUT_TSN_PRES
argument_list|(
name|nr_gap
argument_list|,
name|nr_tsn
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|nr_tsn
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|nr_gap
argument_list|)
condition|)
comment|/* 						 * printf("In 						 * sctp_kick_prsctp_reorder_q 						 * ueue(8): Something wrong, 						 * the TSN to be tagged" 						 * "\nas NR is not even in 						 * the mapping_array, or map 						 * and nr_map are 						 * inconsistent"); 						 */
comment|/* 						 * EY - not %100 sure about 						 * the lock thing, don't 						 * think its required 						 */
comment|/* 						 * SCTP_TCB_LOCK_ASSERT(stcb) 						 * ; 						 */
block|{
comment|/* 						 * printf("\nCalculating an 						 * nr_gap!!\nmapping_array_si 						 * ze = %d 						 * nr_mapping_array_size = 						 * %d" "\nmapping_array_base 						 * = %d 						 * nr_mapping_array_base = 						 * %d\nhighest_tsn_inside_map 						 *  = %d" 						 * "highest_tsn_inside_nr_map 						 *  = %d\nTSN = %d nr_gap = 						 * %d",asoc->mapping_array_si 						 * ze, 						 * asoc->nr_mapping_array_siz 						 * e, 						 * asoc->mapping_array_base_t 						 * sn, 						 * asoc->nr_mapping_array_bas 						 * e_tsn, 						 * asoc->highest_tsn_inside_m 						 * ap, 						 * asoc->highest_tsn_inside_n 						 * r_map,tsn,nr_gap); 						 */
block|}
block|}
block|}
name|tt
operator|=
name|strmin
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|ctl
operator|=
name|nctl
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_flush_reassm_for_str_seq
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint16_t
name|stream
parameter_list|,
name|uint16_t
name|seq
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|at
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* For each one on here see if we need to toss it */
comment|/* 		 * For now large messages held on the reasmqueue that are 		 * complete will be tossed too. We could in theory do more 		 * work to spin through and stop after dumping one msg aka 		 * seeing the start of a new msg at the head, and call the 		 * delivery function... to see if it can be delivered... But 		 * for now we just dump everything on the queue. 		 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|at
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 			 * Do not toss it if on a different stream or marked 			 * for unordered delivery in which case the stream 			 * sequence number has no meaning. 			 */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|stream
operator|)
operator|||
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
name|SCTP_DATA_UNORDERED
operator|)
condition|)
block|{
name|chk
operator|=
name|at
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|==
name|seq
condition|)
block|{
comment|/* It needs to be tossed */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|tsn_last_delivered
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
block|}
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
comment|/* Clear up any stream problem */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|!=
name|SCTP_DATA_UNORDERED
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
argument_list|,
name|MAX_SEQ
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We must dump forward this streams 					 * sequence number if the chunk is 					 * not unordered that is being 					 * skipped. There is a chance that 					 * if the peer does not include the 					 * last fragment in its FWD-TSN we 					 * WILL have a problem here since 					 * you would have a partial chunk in 					 * queue that may not be 					 * deliverable. Also if a Partial 					 * delivery API as started the user 					 * may get a partial chunk. The next 					 * read returning a new chunk... 					 * really ugly but I see no way 					 * around it! Maybe a notify?? 					 */
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|seq
argument_list|,
name|MAX_SEQ
argument_list|)
condition|)
block|{
comment|/* 				 * If the stream_seq is> than the purging 				 * one, we are done 				 */
break|break;
block|}
name|chk
operator|=
name|at
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_handle_forward_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_forward_tsn_chunk
modifier|*
name|fwd
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|/* 	 * ISSUES that MUST be fixed for ECN! When we are the sender of the 	 * forward TSN, when the SACK comes back that acknowledges the 	 * FWD-TSN we must reset the NONCE sum to match correctly. This will 	 * get quite tricky since we may have sent more data interveneing 	 * and must carefully account for what the SACK says on the nonce 	 * and any gaps that are reported. This work will NOT be done here, 	 * but I note it here since it is really related to PR-SCTP and 	 * FWD-TSN's 	 */
comment|/* The pr-sctp fwd tsn */
comment|/* 	 * here we will perform all the data receiver side steps for 	 * processing FwdTSN, as required in by pr-sctp draft: 	 *  	 * Assume we get FwdTSN(x): 	 *  	 * 1) update local cumTSN to x 2) try to further advance cumTSN to x + 	 * others we have 3) examine and update re-ordering queue on 	 * pr-in-streams 4) clean up re-assembly queue 5) Send a sack to 	 * report where we are. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|new_cum_tsn
decl_stmt|,
name|gap
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|fwd_sz
decl_stmt|,
name|cumack_set_flag
decl_stmt|,
name|m_size
decl_stmt|;
name|uint32_t
name|str_seq
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|at
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|sv
decl_stmt|;
name|cumack_set_flag
operator|=
literal|0
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|fwd_sz
operator|=
name|ntohs
argument_list|(
name|fwd
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Bad size too small/big fwd-tsn\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_size
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/*************************************************************/
comment|/* 1. Here we update local cumTSN and shift the bitmap array */
comment|/*************************************************************/
name|new_cum_tsn
operator|=
name|ntohl
argument_list|(
name|fwd
operator|->
name|new_cumulative_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|new_cum_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|new_cum_tsn
condition|)
block|{
comment|/* Already got there ... */
return|return;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|new_cum_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|new_cum_tsn
expr_stmt|;
comment|/* EY nr_mapping_array version of the above */
comment|/* 		 * if(SCTP_BASE_SYSCTL(sctp_nr_sack_on_off)&& 		 * asoc->peer_supports_nr_sack) 		 */
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|new_cum_tsn
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * now we know the new TSN is more advanced, let's find the actual 	 * gap 	 */
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|new_cum_tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap
operator|>=
name|m_size
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|gap
operator|>
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
comment|/* 			 * out of range (of single byte chunks in the rwnd I 			 * give out). This must be an attacker. 			 */
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_33
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|new_cum_tsn
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_33
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_fwdtsn_map_over
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|cumack_set_flag
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|new_cum_tsn
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|new_cum_tsn
expr_stmt|;
comment|/* EY - nr_sack: nr_mapping_array version of the above */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
condition|)
block|{
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|nr_mapping_array_size
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array_base_tsn
operator|=
name|new_cum_tsn
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|new_cum_tsn
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array_size
operator|!=
name|asoc
operator|->
name|mapping_array_size
condition|)
block|{
comment|/* 				 * printf("IN sctp_handle_forward_tsn: 				 * Something is wrong the size of" "map and 				 * nr_map should be equal!") 				 */
empty_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|last_echo_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|gap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nr_sack_on_off
argument_list|)
operator|&&
name|asoc
operator|->
name|peer_supports_nr_sack
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_do_drain
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Now after marking all, slide thing forward but no sack 		 * please. 		 */
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
return|return;
block|}
comment|/*************************************************************/
comment|/* 2. Clear up re-assembly queue                             */
comment|/*************************************************************/
comment|/* 	 * First service it if pd-api is up, just in case we can progress it 	 * forward 	 */
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* For each one on here see if we need to toss it */
comment|/* 		 * For now large messages held on the reasmqueue that are 		 * complete will be tossed too. We could in theory do more 		 * work to spin through and stop after dumping one msg aka 		 * seeing the start of a new msg at the head, and call the 		 * delivery function... to see if it can be delivered... But 		 * for now we just dump everything on the queue. 		 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|at
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|compare_with_wrap
argument_list|(
name|new_cum_tsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|new_cum_tsn
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|)
condition|)
block|{
comment|/* It needs to be tossed */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|tsn_last_delivered
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
block|}
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
comment|/* Clear up any stream problem */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|!=
name|SCTP_DATA_UNORDERED
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
argument_list|,
name|MAX_SEQ
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We must dump forward this streams 					 * sequence number if the chunk is 					 * not unordered that is being 					 * skipped. There is a chance that 					 * if the peer does not include the 					 * last fragment in its FWD-TSN we 					 * WILL have a problem here since 					 * you would have a partial chunk in 					 * queue that may not be 					 * deliverable. Also if a Partial 					 * delivery API as started the user 					 * may get a partial chunk. The next 					 * read returning a new chunk... 					 * really ugly but I see no way 					 * around it! Maybe a notify?? 					 */
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Ok we have gone beyond the end of the 				 * fwd-tsn's mark. 				 */
break|break;
block|}
name|chk
operator|=
name|at
expr_stmt|;
block|}
block|}
comment|/*******************************************************/
comment|/* 3. Update the PR-stream re-ordering queues and fix  */
comment|/* delivery issues as needed.                       */
comment|/*******************************************************/
name|fwd_sz
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|fwd_sz
condition|)
block|{
comment|/* New method. */
name|unsigned
name|int
name|num_str
decl_stmt|;
name|struct
name|sctp_strseq
modifier|*
name|stseq
decl_stmt|,
name|strseqbuf
decl_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|num_str
operator|=
name|fwd_sz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_str
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|st
decl_stmt|;
name|stseq
operator|=
operator|(
expr|struct
name|sctp_strseq
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|strseqbuf
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|stseq
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
comment|/* Convert */
name|st
operator|=
name|ntohs
argument_list|(
name|stseq
operator|->
name|stream
argument_list|)
expr_stmt|;
name|stseq
operator|->
name|stream
operator|=
name|st
expr_stmt|;
name|st
operator|=
name|ntohs
argument_list|(
name|stseq
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|stseq
operator|->
name|sequence
operator|=
name|st
expr_stmt|;
comment|/* now process */
comment|/* 			 * Ok we now look for the stream/seq on the read 			 * queue where its not all delivered. If we find it 			 * we transmute the read entry into a PDI_ABORTED. 			 */
if|if
condition|(
name|stseq
operator|->
name|stream
operator|>=
name|asoc
operator|->
name|streamincnt
condition|)
block|{
comment|/* screwed up streams, stop!  */
break|break;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_of_pdapi
operator|==
name|stseq
operator|->
name|stream
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|ssn_of_pdapi
operator|==
name|stseq
operator|->
name|sequence
operator|)
condition|)
block|{
comment|/* 				 * If this is the one we were partially 				 * delivering now then we no longer are. 				 * Note this will change with the reassembly 				 * re-write. 				 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_flush_reassm_for_str_seq
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|stseq
operator|->
name|stream
argument_list|,
name|stseq
operator|->
name|sequence
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ctl
argument_list|,
argument|&stcb->sctp_ep->read_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|ctl
operator|->
name|sinfo_stream
operator|==
name|stseq
operator|->
name|stream
operator|)
operator|&&
operator|(
name|ctl
operator|->
name|sinfo_ssn
operator|==
name|stseq
operator|->
name|sequence
operator|)
condition|)
block|{
name|str_seq
operator|=
operator|(
name|stseq
operator|->
name|stream
operator|<<
literal|16
operator|)
operator||
name|stseq
operator|->
name|sequence
expr_stmt|;
name|ctl
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|ctl
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|sv
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|ctl
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
argument_list|,
name|stcb
argument_list|,
name|SCTP_PARTIAL_DELIVERY_ABORTED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|str_seq
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|sv
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|ctl
operator|->
name|sinfo_stream
operator|==
name|stseq
operator|->
name|stream
operator|)
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|ctl
operator|->
name|sinfo_ssn
argument_list|,
name|stseq
operator|->
name|sequence
argument_list|,
name|MAX_SEQ
argument_list|)
operator|)
condition|)
block|{
comment|/* We are past our victim SSN */
break|break;
block|}
block|}
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|stseq
operator|->
name|stream
index|]
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stseq
operator|->
name|sequence
argument_list|,
name|strm
operator|->
name|last_sequence_delivered
argument_list|,
name|MAX_SEQ
argument_list|)
condition|)
block|{
comment|/* Update the sequence number */
name|strm
operator|->
name|last_sequence_delivered
operator|=
name|stseq
operator|->
name|sequence
expr_stmt|;
block|}
comment|/* now kick the stream the new way */
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_kick_prsctp_reorder_queue
argument_list|(
name|stcb
argument_list|,
name|strm
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* now lets kick out and check for more fragmented delivery */
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EY fully identical to sctp_express_handle_sack, duplicated for only naming convention */
end_comment

begin_function
name|void
name|sctp_express_handle_nr_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|,
name|int
name|nonce_sum_flag
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|old_rwnd
decl_stmt|;
name|int
name|win_probe_recovery
init|=
literal|0
decl_stmt|;
name|int
name|win_probe_recovered
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|done_once
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_SACK_ARRIVALS_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_LOG_EXPRESS
argument_list|,
name|cumack
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
index|]
operator|=
name|cumack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|>
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|old_rwnd
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* old ack */
return|return;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|cumack
condition|)
block|{
comment|/* Window update sack */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
goto|goto
name|again
goto|;
block|}
return|return;
block|}
comment|/* First setup for CC stuff */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC and Fast recovery algo variables before 		 * SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_sacks
argument_list|)
condition|)
block|{
name|uint32_t
name|send_s
decl_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cumack
operator|==
name|send_s
operator|)
operator|||
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|INVARIANTS
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Impossible sack 1"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
block|}
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* process the new consecutive TSN first */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|cumack
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
name|printf
argument_list|(
literal|"Warning, an unsent is now acked?\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 				 * ECN Nonce: Add the nonce to the sender's 				 * nonce sum 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_CA
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
comment|/* 							 * sa_ignore 							 * NO_NULL_CHK 							 */
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cumack
argument_list|,
literal|1
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cumack
argument_list|,
literal|1
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* JRS - Use the congestion control given in the CC module */
if|if
condition|(
name|asoc
operator|->
name|last_acked_seq
operator|!=
name|cumack
condition|)
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_sack
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Fix up the a-p-a-p for future PR-SCTP sends */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cumack
expr_stmt|;
block|}
comment|/* ECN Nonce updates */
if|if
condition|(
name|asoc
operator|->
name|ecn_nonce_allowed
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_sum_check
condition|)
block|{
if|if
condition|(
name|nonce_sum_flag
operator|!=
operator|(
operator|(
name|asoc
operator|->
name|nonce_sum_expect_base
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_wait_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|nonce_wait_tsn
operator|)
condition|)
block|{
comment|/* 						 * Misbehaving peer. We need 						 * to react to this guy 						 */
name|asoc
operator|->
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* See if Resynchronization Possible */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_resync_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
comment|/* 				 * now we must calculate what the base is. 				 * We do this based on two things, we know 				 * the total's for all the segments 				 * gap-acked in the SACK (none), We also 				 * know the SACK's nonce sum, its in 				 * nonce_sum_flag. So we can build a truth 				 * table to back-calculate the new value of 				 * asoc->nonce_sum_expect_base: 				 *  				 * SACK-flag-Value         Seg-Sums Base 0 0 0 				 * 1                    0 1 0 1 1 1 1 0 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
operator|(
literal|0
operator|^
name|nonce_sum_flag
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
block|}
block|}
block|}
comment|/* RWND update */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
name|win_probe_recovery
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now assure a timer where data is queued at */
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|int
name|to_ticks
decl_stmt|;
if|if
condition|(
name|win_probe_recovery
operator|&&
operator|(
name|net
operator|->
name|window_probe
operator|)
condition|)
block|{
name|win_probe_recovered
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Find first chunk that was used with window probe 			 * and clear the sent 			 */
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|window_probe
condition|)
block|{
comment|/* move back to data send queue */
name|sctp_window_probe_recovery
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
comment|/* 				 * In window probes we must assure a timer 				 * is still running there 				 */
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|win_probe_recovered
operator|==
literal|0
operator|)
operator|&&
operator|(
name|done_once
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * huh, this should not happen unless all packets are 		 * PR-SCTP and marked to skip of course. 		 */
if|if
condition|(
name|sctp_fs_audit
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|done_once
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* 			 * I may be in a state where we got all across.. but 			 * cannot write more due to a shutdown... we abort 			 * since the user did not indicate EOR in this case. 			 * The sp will be cleaned during free of the asoc. 			 */
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Let cleanup code purge it */
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EY! nr_sack version of sctp_handle_segments, nr-gapped TSNs get removed from RtxQ in this method*/
end_comment

begin_function
specifier|static
name|void
name|sctp_handle_nr_sack_segments
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_nr_sack_chunk
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|last_tsn
parameter_list|,
name|uint32_t
modifier|*
name|biggest_tsn_acked
parameter_list|,
name|uint32_t
modifier|*
name|biggest_newly_acked_tsn
parameter_list|,
name|uint32_t
modifier|*
name|this_sack_lowest_newack
parameter_list|,
name|uint32_t
name|num_seg
parameter_list|,
name|uint32_t
name|num_nr_seg
parameter_list|,
name|int
modifier|*
name|ecn_seg_sums
parameter_list|)
block|{
comment|/************************************************/
comment|/* process fragments and update sendqueue        */
comment|/************************************************/
name|struct
name|sctp_nr_sack
modifier|*
name|nr_sack
decl_stmt|;
name|struct
name|sctp_gap_ack_block
modifier|*
name|frag
decl_stmt|,
name|block
decl_stmt|;
name|struct
name|sctp_nr_gap_ack_block
modifier|*
name|nr_frag
decl_stmt|,
name|nr_block
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|int
name|wake_him
init|=
literal|0
decl_stmt|;
name|int
name|num_frs
init|=
literal|0
decl_stmt|;
name|uint16_t
name|frag_strt
decl_stmt|,
name|frag_end
decl_stmt|,
name|primary_flag_set
decl_stmt|;
name|uint16_t
name|nr_frag_strt
decl_stmt|,
name|nr_frag_end
decl_stmt|;
name|uint32_t
name|last_frag_high
decl_stmt|;
name|uint32_t
name|last_nr_frag_high
decl_stmt|;
comment|/* 	 * @@@ JRI : TODO: This flag is not used anywhere .. remove? 	 */
if|if
condition|(
name|asoc
operator|->
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_SWITCH_PRIMARY
condition|)
block|{
name|primary_flag_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|primary_flag_set
operator|=
literal|0
expr_stmt|;
block|}
name|nr_sack
operator|=
operator|&
name|ch
operator|->
name|nr_sack
expr_stmt|;
comment|/* 	 * EY! - I will process nr_gaps similarly,by going to this position 	 * again if All bit is set 	 */
name|frag
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tp1
operator|=
name|NULL
expr_stmt|;
name|last_frag_high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_seg
condition|;
name|i
operator|++
control|)
block|{
name|frag_strt
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|start
argument_list|)
expr_stmt|;
name|frag_end
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* some sanity checks on the fargment offsets */
if|if
condition|(
name|frag_strt
operator|>
name|frag_end
condition|)
block|{
comment|/* this one is malformed, skip */
name|frag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
operator|(
name|frag_end
operator|+
name|last_tsn
operator|)
argument_list|,
operator|*
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
operator|*
name|biggest_tsn_acked
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
comment|/* mark acked dgs and find out the highestTSN being acked */
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
comment|/* save the locations of the last frags */
name|last_frag_high
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * now lets see if we need to reset the queue due to 			 * a out-of-order SACK fragment 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|frag_strt
operator|+
name|last_tsn
argument_list|,
name|last_frag_high
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 				 * if the new frag starts after the last TSN 				 * frag covered, we are ok and this one is 				 * beyond the last one 				 */
empty_stmt|;
block|}
else|else
block|{
comment|/* 				 * ok, they have reset us, so we need to 				 * reset the queue this will cause extra 				 * hunting but hey, they chose the 				 * performance hit when they failed to order 				 * there gaps.. 				 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|last_frag_high
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
name|sctp_process_segment_range
argument_list|(
name|stcb
argument_list|,
operator|&
name|tp1
argument_list|,
name|last_tsn
argument_list|,
name|frag_strt
argument_list|,
name|frag_end
argument_list|,
literal|0
argument_list|,
operator|&
name|num_frs
argument_list|,
name|biggest_newly_acked_tsn
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|ecn_seg_sums
argument_list|)
expr_stmt|;
name|frag
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|num_frs
condition|)
name|sctp_log_fr
argument_list|(
operator|*
name|biggest_tsn_acked
argument_list|,
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|last_tsn
argument_list|,
name|SCTP_FR_LOG_BIGGEST_TSNS
argument_list|)
expr_stmt|;
block|}
name|nr_frag
operator|=
operator|(
expr|struct
name|sctp_nr_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|nr_block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|nr_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_frag
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|tp1
operator|=
name|NULL
expr_stmt|;
name|last_nr_frag_high
operator|=
literal|0
expr_stmt|;
comment|/* Reset to beginning for the nr_sack section */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_nr_seg
condition|;
name|i
operator|++
control|)
block|{
name|nr_frag_strt
operator|=
name|ntohs
argument_list|(
name|nr_frag
operator|->
name|start
argument_list|)
expr_stmt|;
name|nr_frag_end
operator|=
name|ntohs
argument_list|(
name|nr_frag
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* some sanity checks on the nr fargment offsets */
if|if
condition|(
name|nr_frag_strt
operator|>
name|nr_frag_end
condition|)
block|{
comment|/* this one is malformed, skip */
name|nr_frag
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* mark acked dgs and find out the highestTSN being acked */
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
comment|/* save the locations of the last frags */
name|last_nr_frag_high
operator|=
name|nr_frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * now lets see if we need to reset the queue due to 			 * a out-of-order SACK fragment 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|nr_frag_strt
operator|+
name|last_tsn
argument_list|,
name|last_nr_frag_high
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 				 * if the new frag starts after the last TSN 				 * frag covered, we are ok and this one is 				 * beyond the last one 				 */
empty_stmt|;
block|}
else|else
block|{
comment|/* 				 * ok, they have reset us, so we need to 				 * reset the queue this will cause extra 				 * hunting but hey, they chose the 				 * performance hit when they failed to order 				 * there gaps.. 				 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|last_nr_frag_high
operator|=
name|nr_frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
name|num_frs
operator|=
literal|0
expr_stmt|;
name|wake_him
operator|=
name|sctp_process_segment_range
argument_list|(
name|stcb
argument_list|,
operator|&
name|tp1
argument_list|,
name|last_tsn
argument_list|,
name|nr_frag_strt
argument_list|,
name|nr_frag_end
argument_list|,
literal|1
argument_list|,
operator|&
name|num_frs
argument_list|,
name|biggest_newly_acked_tsn
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|ecn_seg_sums
argument_list|)
expr_stmt|;
name|nr_frag
operator|=
operator|(
expr|struct
name|sctp_nr_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|nr_block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|nr_block
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr_frag
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
comment|/* 	 * EY- wake up the socket if things have been removed from the sent 	 * queue 	 */
if|if
condition|(
operator|(
name|wake_him
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_socket
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * if (SCTP_BASE_SYSCTL(sctp_logging_level)& 		 * SCTP_WAKE_LOGGING_ENABLE) { sctp_wakeup_log(stcb, 		 * cum_ack, wake_him, SCTP_WAKESND_FROM_SACK);} 		 */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* else { if 				 * (SCTP_BASE_SYSCTL(sctp_logging_level)& 				 * SCTP_WAKE_LOGGING_ENABLE) { 				 * sctp_wakeup_log(stcb, cum_ack, wake_him, 				 * SCTP_NOWAKE_FROM_SACK); } } */
block|}
end_function

begin_comment
comment|/* EY- nr_sack */
end_comment

begin_comment
comment|/* Identifies the non-renegable tsns that are revoked*/
end_comment

begin_function
specifier|static
name|void
name|sctp_check_for_nr_revoked
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|u_long
name|biggest_tsn_acked
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cumack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ok this guy is either ACK or MARKED. If it is 			 * ACKED it has been previously acked but not this 			 * time i.e. revoked.  If it is MARKED it was ACK'ed 			 * again. 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
break|break;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
comment|/* 				 * EY! a non-renegable TSN is revoked, need 				 * to abort the association 				 */
comment|/* 				 * EY TODO: put in the code to abort the 				 * assoc. 				 */
return|return;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_NR_MARKED
condition|)
block|{
comment|/* it has been re-acked in this SACK */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_NR_ACKED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
break|break;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* EY! nr_sack version of sctp_handle_sack, nr_gap_ack processing should be added to this method*/
end_comment

begin_function
name|void
name|sctp_handle_nr_sack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_nr_sack_chunk
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net_from
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|,
name|int
name|nr_sack_len
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
comment|/* EY sack */
name|struct
name|sctp_nr_sack
modifier|*
name|nr_sack
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|cum_ack
decl_stmt|,
name|last_tsn
decl_stmt|,
name|biggest_tsn_acked
decl_stmt|,
name|biggest_tsn_newly_acked
decl_stmt|,
name|this_sack_lowest_newack
decl_stmt|;
name|uint32_t
name|sav_cum_ack
decl_stmt|;
comment|/* EY num_seg */
name|uint16_t
name|num_seg
decl_stmt|,
name|num_nr_seg
decl_stmt|,
name|num_dup
decl_stmt|;
name|uint16_t
name|wake_him
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|nr_sack_length
decl_stmt|;
name|uint32_t
name|send_s
init|=
literal|0
decl_stmt|;
name|long
name|j
decl_stmt|;
name|int
name|accum_moved
init|=
literal|0
decl_stmt|;
name|int
name|will_exit_fast_recovery
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|,
name|old_rwnd
decl_stmt|;
name|int
name|win_probe_recovery
init|=
literal|0
decl_stmt|;
name|int
name|win_probe_recovered
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|int
name|nonce_sum_flag
decl_stmt|,
name|ecn_seg_sums
init|=
literal|0
decl_stmt|;
name|int
name|done_once
decl_stmt|;
name|uint8_t
name|reneged_all
init|=
literal|0
decl_stmt|;
name|uint8_t
name|cmt_dac_flag
decl_stmt|;
comment|/* 	 * we take any chance we can to service our queues since we cannot 	 * get awoken when the socket is read from :< 	 */
comment|/* 	 * Now perform the actual SACK handling: 1) Verify that it is not an 	 * old sack, if so discard. 2) If there is nothing left in the send 	 * queue (cum-ack is equal to last acked) then you have a duplicate 	 * too, update any rwnd change and verify no timers are running. 	 * then return. 3) Process any new consequtive data i.e. cum-ack 	 * moved process these first and note that it moved. 4) Process any 	 * sack blocks. 5) Drop any acked from the queue. 6) Check for any 	 * revoked blocks and mark. 7) Update the cwnd. 8) Nothing left, 	 * sync up flightsizes and things, stop all timers and also check 	 * for shutdown_pending state. If so then go ahead and send off the 	 * shutdown. If in shutdown recv, send off the shutdown-ack and 	 * start that timer, Ret. 9) Strike any non-acked things and do FR 	 * procedure if needed being sure to set the FR flag. 10) Do pr-sctp 	 * procedures. 11) Apply any FR penalties. 12) Assure we will SACK 	 * if in shutdown_recv state. 	 */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|nr_sack
operator|=
operator|&
name|ch
operator|->
name|nr_sack
expr_stmt|;
comment|/* CMT DAC algo */
name|this_sack_lowest_newack
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|nr_sack_length
operator|=
operator|(
name|unsigned
name|int
operator|)
name|nr_sack_len
expr_stmt|;
comment|/* ECN Nonce */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_slowpath_sack
argument_list|)
expr_stmt|;
name|nonce_sum_flag
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
name|cum_ack
operator|=
name|last_tsn
operator|=
name|ntohl
argument_list|(
name|nr_sack
operator|->
name|cum_tsn_ack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
index|]
operator|=
name|cum_ack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|>
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|num_seg
operator|=
name|ntohs
argument_list|(
name|nr_sack
operator|->
name|num_gap_ack_blks
argument_list|)
expr_stmt|;
name|num_nr_seg
operator|=
name|ntohs
argument_list|(
name|nr_sack
operator|->
name|num_nr_gap_ack_blks
argument_list|)
expr_stmt|;
name|a_rwnd
operator|=
name|rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_SACK_ARRIVALS_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_LOG_NORMAL
argument_list|,
name|cum_ack
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
comment|/* CMT DAC algo */
name|cmt_dac_flag
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_SACK_CMT_DAC
expr_stmt|;
name|num_dup
operator|=
name|ntohs
argument_list|(
name|nr_sack
operator|->
name|num_dup_tsns
argument_list|)
expr_stmt|;
name|old_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
literal|0
argument_list|,
name|num_seg
argument_list|,
name|num_dup
argument_list|,
name|SCTP_LOG_NEW_SACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num_dup
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
operator|(
name|SCTP_FR_LOGGING_ENABLE
operator||
name|SCTP_EARLYFR_LOGGING_ENABLE
operator|)
operator|)
condition|)
block|{
name|int
name|off_to_dup
decl_stmt|,
name|iii
decl_stmt|;
name|uint32_t
modifier|*
name|dupdata
decl_stmt|,
name|dblock
decl_stmt|;
name|off_to_dup
operator|=
operator|(
name|num_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|+
operator|(
name|num_nr_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_gap_ack_block
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_to_dup
operator|+
operator|(
name|num_dup
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
operator|<=
name|nr_sack_length
condition|)
block|{
name|dupdata
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|off_to_dup
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
name|off_to_dup
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|dupdata
condition|)
block|{
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
name|num_dup
condition|;
name|iii
operator|++
control|)
block|{
name|sctp_log_fr
argument_list|(
operator|*
name|dupdata
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_DUPED
argument_list|)
expr_stmt|;
name|dupdata
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|off_to_dup
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dupdata
operator|==
name|NULL
condition|)
break|break;
name|off_to_dup
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Size invalid offset to dups:%d number dups:%d nr_sack_len:%d num gaps:%d num nr_gaps:%d\n"
argument_list|,
name|off_to_dup
argument_list|,
name|num_dup
argument_list|,
name|nr_sack_length
argument_list|,
name|num_seg
argument_list|,
name|num_nr_seg
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_sacks
argument_list|)
condition|)
block|{
comment|/* reality check */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
if|if
condition|(
name|cum_ack
operator|==
name|send_s
operator|||
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifndef|#
directive|ifndef
name|INVARIANTS
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
name|hopeless_peer
label|:
name|panic
argument_list|(
literal|"Impossible sack 1"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 			 * no way, we have not even sent this TSN out yet. 			 * Peer is hopelessly messed up with us. 			 */
name|hopeless_peer
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
block|}
comment|/**********************/
comment|/* 1) check the range */
comment|/**********************/
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|last_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* acking something behind */
return|return;
block|}
name|sav_cum_ack
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* update the Rwnd of the peer */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing left on send/sent and strmq */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* stop any timers */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck1
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * We init netAckSz and netAckSz2 to 0. These are used to track 2 	 * things. The total byte count acked is tracked in netAckSz AND 	 * netAck2 is used to track the total bytes acked that are un- 	 * amibguious and were never retransmitted. We track these on a per 	 * destination address basis. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC and Fast recovery algo variables before 		 * SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
block|}
comment|/* process the new consecutive TSN first */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|last_tsn
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 				 * ECN Nonce: Add the nonce to the sender's 				 * nonce sum 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
name|accum_moved
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* 						 * If there was no retran 						 * and the address is 						 * un-confirmed and we sent 						 * there and are now 						 * sacked.. its confirmed, 						 * mark it so. 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_CA
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* CMT SFR and DAC algos */
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB3
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
name|biggest_tsn_newly_acked
operator|=
name|biggest_tsn_acked
operator|=
name|last_tsn
expr_stmt|;
comment|/* always set this up to cum-ack */
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|last_tsn
expr_stmt|;
comment|/* Move offset up to point to gaps/dups */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|num_seg
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
operator|)
operator|>
name|nr_sack_length
condition|)
block|{
comment|/* skip corrupt segments */
goto|goto
name|skip_segments
goto|;
block|}
if|if
condition|(
name|num_seg
operator|>
literal|0
condition|)
block|{
comment|/* 		 * CMT: SFR algo (and HTNA) - this_sack_highest_newack has 		 * to be greater than the cumack. Also reset saw_newack to 0 		 * for all dests. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|saw_newack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|this_sack_highest_newack
operator|=
name|last_tsn
expr_stmt|;
block|}
comment|/* 		 * thisSackHighestGap will increase while handling NEW 		 * segments this_sack_highest_newack will increase while 		 * handling NEWLY ACKED chunks. this_sack_lowest_newack is 		 * used for CMT DAC algo. saw_newack will also change. 		 */
name|sctp_handle_nr_sack_segments
argument_list|(
name|m
argument_list|,
operator|&
name|offset
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ch
argument_list|,
name|last_tsn
argument_list|,
operator|&
name|biggest_tsn_acked
argument_list|,
operator|&
name|biggest_tsn_newly_acked
argument_list|,
operator|&
name|this_sack_lowest_newack
argument_list|,
name|num_seg
argument_list|,
name|num_nr_seg
argument_list|,
operator|&
name|ecn_seg_sums
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_strict_sacks
argument_list|)
condition|)
block|{
comment|/* 			 * validate the biggest_tsn_acked in the gap acks if 			 * strict adherence is wanted. 			 */
if|if
condition|(
operator|(
name|biggest_tsn_acked
operator|==
name|send_s
operator|)
operator|||
operator|(
name|compare_with_wrap
argument_list|(
name|biggest_tsn_acked
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * peer is either confused or we are under 				 * attack. We must abort. 				 */
goto|goto
name|hopeless_peer
goto|;
block|}
block|}
block|}
name|skip_segments
label|:
comment|/*******************************************/
comment|/* cancel ALL T3-send timer if accum moved */
comment|/*******************************************/
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|new_pseudo_cumack
condition|)
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_27
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|accum_moved
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_28
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/********************************************/
comment|/* drop the acked chunks from the sendqueue */
comment|/********************************************/
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cum_ack
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
goto|goto
name|done_with_it
goto|;
do|do
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cum_ack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* no more sent on list */
name|printf
argument_list|(
literal|"Warning, tp1->sent == %d and its now acked?\n"
argument_list|,
name|tp1
operator|->
name|sent
argument_list|)
expr_stmt|;
block|}
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|pr_sctp_on
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|!=
literal|0
condition|)
name|asoc
operator|->
name|pr_sctp_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Warning flight size is postive and should be 0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Warning flight size incorrect should be 0 is %d\n"
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|&&
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|wake_him
operator|++
expr_stmt|;
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
do|while
condition|(
name|tp1
operator|!=
name|NULL
condition|)
do|;
name|done_with_it
label|:
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
operator|(
name|wake_him
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_socket
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|wake_him
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|wake_him
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|accum_moved
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|fast_recovery_tsn
condition|)
block|{
comment|/* Setup so we will exit RFC2582 fast recovery */
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for revoked fragments: 	 *  	 * if Previous sack - Had no frags then we can't have any revoked if 	 * Previous sack - Had frag's then - If we now have frags aka 	 * num_seg> 0 call sctp_check_for_revoked() to tell if peer revoked 	 * some of them. else - The peer revoked all ACKED fragments, since 	 * we had some before and now we have NONE. 	 */
if|if
condition|(
name|num_seg
condition|)
name|sctp_check_for_revoked
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|cum_ack
argument_list|,
name|biggest_tsn_acked
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|asoc
operator|->
name|saw_sack_with_frags
condition|)
block|{
name|int
name|cnt_revoked
init|=
literal|0
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|!=
name|NULL
condition|)
block|{
comment|/* Peer revoked all dg's marked or acked */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 				 * EY- maybe check only if it is nr_acked 				 * nr_marked may not be possible 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_NR_ACKED
operator|)
operator|||
operator|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_NR_MARKED
operator|)
condition|)
block|{
comment|/* 					 * EY! - TODO: Something previously 					 * nr_gapped is reneged, abort the 					 * association 					 */
return|return;
block|}
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_FORWARD_TSN_SKIP
operator|)
condition|)
block|{
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_REVOKE
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
comment|/* 					 * To ensure that this increase in 					 * flightsize, which is artificial, 					 * does not throttle the sender, we 					 * also increase the cwnd 					 * artificially. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|cnt_revoked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_revoked
condition|)
block|{
name|reneged_all
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_seg
condition|)
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|1
expr_stmt|;
else|else
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
comment|/* EY! - not sure about if there should be an IF */
if|if
condition|(
name|num_nr_seg
condition|)
name|sctp_check_for_nr_revoked
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|cum_ack
argument_list|,
name|biggest_tsn_acked
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|asoc
operator|->
name|saw_sack_with_nr_frags
condition|)
block|{
comment|/* 		 * EY!- TODO: all previously nr_gapped chunks have been 		 * reneged abort the association 		 */
name|asoc
operator|->
name|saw_sack_with_nr_frags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_nr_seg
condition|)
name|asoc
operator|->
name|saw_sack_with_nr_frags
operator|=
literal|1
expr_stmt|;
else|else
name|asoc
operator|->
name|saw_sack_with_nr_frags
operator|=
literal|0
expr_stmt|;
comment|/* JRS - Use the congestion control given in the CC module */
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_sack
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|accum_moved
argument_list|,
name|reneged_all
argument_list|,
name|will_exit_fast_recovery
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* stop all timers */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_29
argument_list|)
expr_stmt|;
block|}
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_30
argument_list|)
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* 			 * I may be in a state where we got all across.. but 			 * cannot write more due to a shutdown... we abort 			 * since the user did not indicate EOR in this case. 			 */
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now here we are going to recycle net_ack for a different use... 	 * HEADS UP. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT DAC algorithm: If SACK DAC flag was 0, then no extra marking 	 * to be done. Setting this_sack_lowest_newack to the cum_ack will 	 * automatically ensure that. 	 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
operator|&&
operator|(
name|cmt_dac_flag
operator|==
literal|0
operator|)
condition|)
block|{
name|this_sack_lowest_newack
operator|=
name|cum_ack
expr_stmt|;
block|}
if|if
condition|(
name|num_seg
operator|>
literal|0
condition|)
block|{
name|sctp_strike_gap_ack_chunks
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|biggest_tsn_newly_acked
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|accum_moved
argument_list|)
expr_stmt|;
block|}
comment|/* JRS - Use the congestion control given in the CC module */
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_fr
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/****************************************************************** 	 *  Here we do the stuff with ECN Nonce checking. 	 *  We basically check to see if the nonce sum flag was incorrect 	 *  or if resynchronization needs to be done. Also if we catch a 	 *  misbehaving receiver we give him the kick. 	 ******************************************************************/
if|if
condition|(
name|asoc
operator|->
name|ecn_nonce_allowed
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_sum_check
condition|)
block|{
if|if
condition|(
name|nonce_sum_flag
operator|!=
operator|(
operator|(
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+
name|ecn_seg_sums
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_wait_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|nonce_wait_tsn
operator|)
condition|)
block|{
comment|/* 						 * Misbehaving peer. We need 						 * to react to this guy 						 */
name|asoc
operator|->
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* See if Resynchronization Possible */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_resync_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
comment|/* 				 * now we must calculate what the base is. 				 * We do this based on two things, we know 				 * the total's for all the segments 				 * gap-acked in the SACK, its stored in 				 * ecn_seg_sums. We also know the SACK's 				 * nonce sum, its in nonce_sum_flag. So we 				 * can build a truth table to back-calculate 				 * the new value of 				 * asoc->nonce_sum_expect_base: 				 *  				 * SACK-flag-Value         Seg-Sums Base 0 0 0 				 * 1                    0 1 0 1 1 1 1 0 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
operator|(
name|ecn_seg_sums
operator|^
name|nonce_sum_flag
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
block|}
block|}
block|}
comment|/* Now are we exiting loss recovery ? */
if|if
condition|(
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|sat_t3_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|sat_t3_recovery_tsn
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* end satellite t3 loss recovery */
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT Fast recovery 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Adjust and set the new rwnd value */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|a_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
name|win_probe_recovery
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now we must setup so we have a timer up for anyone with 	 * outstanding data. 	 */
name|done_once
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|win_probe_recovery
operator|&&
operator|(
name|net
operator|->
name|window_probe
operator|)
condition|)
block|{
name|win_probe_recovered
operator|=
literal|1
expr_stmt|;
comment|/*- 			 * Find first chunk that was used with 			 * window probe and clear the event. Put 			 * it back into the send queue as if has 			 * not been sent. 			 */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|window_probe
condition|)
block|{
name|sctp_window_probe_recovery
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_early_fr
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|win_probe_recovered
operator|==
literal|0
operator|)
operator|&&
operator|(
name|done_once
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * huh, this should not happen unless all packets are 		 * PR-SCTP and marked to skip of course. 		 */
if|if
condition|(
name|sctp_fs_audit
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
block|}
block|}
block|}
name|done_once
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/*********************************************/
comment|/* Here we perform PR-SCTP procedures        */
comment|/* (section 4.2)                             */
comment|/*********************************************/
comment|/* C1. update advancedPeerAckPoint */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cum_ack
expr_stmt|;
block|}
comment|/* C2. try to further move advancedPeerAckPoint ahead */
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|uint32_t
name|old_adv_peer_ack_point
decl_stmt|;
name|old_adv_peer_ack_point
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|cum_ack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing for notes 			 * on issues that will occur when the ECN NONCE 			 * stuff is put into SCTP for cross checking. 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* 				 * ECN Nonce: Disable Nonce Sum check when 				 * FWD TSN is sent and store resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* try to FR fwd-tsn's that get lost too */
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|>
literal|3
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|a_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

