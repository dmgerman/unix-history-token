begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2006, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_indata.c,v 1.36 2005/03/06 16:04:17 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_sctp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|uint32_t
name|sctp_debug_on
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * NOTES: On the outbound side of things I need to check the sack timer to  * see if I should generate a sack into the chunk queue (if I have data to  * send that is and will be sending it .. for bundling.  *  * The callback in sctp_usrreq.c will get called when the socket is read from.  * This will cause sctp_service_queues() to get called on the top entry in  * the list.  */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|sctp_strict_sacks
decl_stmt|;
end_decl_stmt

begin_function
name|__inline
name|void
name|sctp_set_rwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|uint32_t
name|calc
decl_stmt|,
name|calc_w_oh
decl_stmt|;
comment|/* 	 * This is really set wrong with respect to a 1-2-m socket. Since 	 * the sb_cc is the count that everyone as put up. When we re-write 	 * sctp_soreceive then we will fix this so that ONLY this 	 * associations data is taken into account. 	 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_reasm_queue
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_all_streams
operator|==
literal|0
condition|)
block|{
comment|/* Full rwnd granted */
name|asoc
operator|->
name|my_rwnd
operator|=
name|max
argument_list|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get actual space */
name|calc
operator|=
operator|(
name|uint32_t
operator|)
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * take out what has NOT been put on socket queue and we yet hold 	 * for putting up. 	 */
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|)
expr_stmt|;
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|size_on_all_streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc
operator|==
literal|0
condition|)
block|{
comment|/* out of space */
name|asoc
operator|->
name|my_rwnd
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* what is the overhead of all these rwnd's */
name|calc_w_oh
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd_control_len
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_rwnd
operator|=
name|calc
expr_stmt|;
if|if
condition|(
name|calc_w_oh
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If our overhead is greater than the advertised rwnd, we 		 * clamp the rwnd to 1. This lets us still accept inbound 		 * segments, but hopefully will shut the sender down when he 		 * finally gets the message. 		 */
name|asoc
operator|->
name|my_rwnd
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* SWS threshold */
if|if
condition|(
name|asoc
operator|->
name|my_rwnd
operator|&&
operator|(
name|asoc
operator|->
name|my_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_receiver
operator|)
condition|)
block|{
comment|/* SWS engaged, tell peer none left */
name|asoc
operator|->
name|my_rwnd
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Calculate what the rwnd would be */
end_comment

begin_function
name|__inline
name|uint32_t
name|sctp_calc_rwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|uint32_t
name|calc
init|=
literal|0
decl_stmt|,
name|calc_w_oh
decl_stmt|;
comment|/* 	 * This is really set wrong with respect to a 1-2-m socket. Since 	 * the sb_cc is the count that everyone as put up. When we re-write 	 * sctp_soreceive then we will fix this so that ONLY this 	 * associations data is taken into account. 	 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
return|return
operator|(
name|calc
operator|)
return|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_reasm_queue
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_all_streams
operator|==
literal|0
condition|)
block|{
comment|/* Full rwnd granted */
name|calc
operator|=
name|max
argument_list|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_hiwat
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
expr_stmt|;
return|return
operator|(
name|calc
operator|)
return|;
block|}
comment|/* get actual space */
name|calc
operator|=
operator|(
name|uint32_t
operator|)
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * take out what has NOT been put on socket queue and we yet hold 	 * for putting up. 	 */
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|)
expr_stmt|;
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|size_on_all_streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc
operator|==
literal|0
condition|)
block|{
comment|/* out of space */
return|return
operator|(
name|calc
operator|)
return|;
block|}
comment|/* what is the overhead of all these rwnd's */
name|calc_w_oh
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd_control_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_w_oh
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If our overhead is greater than the advertised rwnd, we 		 * clamp the rwnd to 1. This lets us still accept inbound 		 * segments, but hopefully will shut the sender down when he 		 * finally gets the message. 		 */
name|calc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* SWS threshold */
if|if
condition|(
name|calc
operator|&&
operator|(
name|calc
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_receiver
operator|)
condition|)
block|{
comment|/* SWS engaged, tell peer none left */
name|calc
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|calc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build out our readq entry based on the incoming packet.  */
end_comment

begin_function
name|struct
name|sctp_queued_to_read
modifier|*
name|sctp_build_readq_entry
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint32_t
name|ppid
parameter_list|,
name|uint32_t
name|context
parameter_list|,
name|uint16_t
name|stream_no
parameter_list|,
name|uint16_t
name|stream_seq
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|dm
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|read_queue_e
init|=
name|NULL
decl_stmt|;
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|read_queue_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_queue_e
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_build
goto|;
block|}
name|read_queue_e
operator|->
name|sinfo_stream
operator|=
name|stream_no
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ssn
operator|=
name|stream_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_flags
operator|=
operator|(
name|flags
operator|<<
literal|8
operator|)
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ppid
operator|=
name|ppid
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_timetolive
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_tsn
operator|=
name|tsn
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_cumtsn
operator|=
name|tsn
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|whoFrom
operator|=
name|net
expr_stmt|;
name|read_queue_e
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|data
operator|=
name|dm
expr_stmt|;
name|read_queue_e
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|read_queue_e
operator|->
name|stcb
operator|=
name|stcb
expr_stmt|;
name|read_queue_e
operator|->
name|port_from
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|read_queue_e
operator|->
name|do_not_ref_stcb
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|end_added
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|pdapi_aborted
operator|=
literal|0
expr_stmt|;
name|failed_build
label|:
return|return
operator|(
name|read_queue_e
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build out our readq entry based on the incoming packet.  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_queued_to_read
modifier|*
name|sctp_build_readq_entry_chk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|read_queue_e
init|=
name|NULL
decl_stmt|;
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|read_queue_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_queue_e
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_build
goto|;
block|}
name|read_queue_e
operator|->
name|sinfo_stream
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ssn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_flags
operator|=
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|<<
literal|8
operator|)
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_timetolive
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_cumtsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|whoFrom
operator|=
name|chk
operator|->
name|whoTo
expr_stmt|;
name|read_queue_e
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|read_queue_e
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|read_queue_e
operator|->
name|stcb
operator|=
name|stcb
expr_stmt|;
name|read_queue_e
operator|->
name|port_from
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|read_queue_e
operator|->
name|do_not_ref_stcb
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|end_added
operator|=
literal|0
expr_stmt|;
name|read_queue_e
operator|->
name|pdapi_aborted
operator|=
literal|0
expr_stmt|;
name|failed_build
label|:
return|return
operator|(
name|read_queue_e
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_build_ctl_nchunk
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sinfo
parameter_list|)
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|outinfo
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ret
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|use_extended
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
block|{
comment|/* user does not want the sndrcv ctl */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
condition|)
block|{
name|use_extended
operator|=
literal|1
expr_stmt|;
name|len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|1
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* No space */
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* We need a CMSG header followed by the struct  */
name|cmh
operator|=
name|mtod
argument_list|(
name|ret
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
name|outinfo
operator|=
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmh
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_level
operator|=
name|IPPROTO_SCTP
expr_stmt|;
if|if
condition|(
name|use_extended
condition|)
block|{
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_EXTRCV
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|outinfo
argument_list|,
name|sinfo
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_SNDRCV
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|len
expr_stmt|;
operator|*
name|outinfo
operator|=
operator|*
name|sinfo
expr_stmt|;
block|}
name|ret
operator|->
name|m_len
operator|=
name|cmh
operator|->
name|cmsg_len
expr_stmt|;
name|ret
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ret
operator|->
name|m_len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We are delivering currently from the reassembly queue. We must continue to  * deliver until we either: 1) run out of space. 2) run out of sequential  * TSN's 3) hit the SCTP_DATA_LAST_FRAG flag.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_service_reassembly
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
name|uint16_t
name|stream_no
decl_stmt|;
name|int
name|end
init|=
literal|0
decl_stmt|;
name|int
name|cntDel
decl_stmt|;
name|cntDel
operator|=
name|stream_no
operator|=
literal|0
expr_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|ctlat
decl_stmt|;
if|if
condition|(
name|stcb
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
operator|)
condition|)
block|{
comment|/* socket above is long gone */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
comment|/* 			 * Lose the data pointer, since its in the socket 			 * buffer 			 */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Now free the address and data */
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
do|do
block|{
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|!=
operator|(
name|asoc
operator|->
name|tsn_last_delivered
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Can't deliver more :< */
return|return;
block|}
name|stream_no
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|nxt_todel
operator|=
name|asoc
operator|->
name|strmin
index|[
name|stream_no
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nxt_todel
operator|!=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Not the next sequence to deliver in its stream OR 			 * unordered 			 */
return|return;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|data
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* no room! */
return|return;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
comment|/* hopefully we hit here most of the time */
name|chk
operator|->
name|data
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Add the flag to the LAST mbuf in the 				 * chain 				 */
name|m
operator|=
name|chk
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|)
block|{
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
block|}
name|m
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|control
operator|=
name|sctp_build_readq_entry_chk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory? */
return|return;
block|}
comment|/* save it off for our future deliveries */
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|control
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
name|end
operator|=
literal|1
expr_stmt|;
else|else
name|end
operator|=
literal|0
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|cntDel
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
name|end
operator|=
literal|1
expr_stmt|;
else|else
name|end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_append_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
argument_list|,
name|chk
operator|->
name|data
argument_list|,
name|end
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
comment|/* 				 * something is very wrong, either 				 * control_pdapi is NULL, or the tail_mbuf 				 * is corrupt, or there is a EOM already on 				 * the mbuf chain. 				 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"This should not happen control_pdapi NULL?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|->
name|tail_mbuf
operator|==
name|NULL
condition|)
block|{
name|panic
argument_list|(
literal|"This should not happen, tail_mbuf not being maintained?"
argument_list|)
expr_stmt|;
block|}
comment|/* if we did not panic, it was a EOM */
name|panic
argument_list|(
literal|"Bad chunking ??"
argument_list|)
expr_stmt|;
block|}
name|cntDel
operator|++
expr_stmt|;
block|}
comment|/* pull it we did it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmin
index|[
name|stream_no
index|]
operator|.
name|last_sequence_delivered
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_reasmusrmsgs
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* 			 * turn the flag back on since we just  delivered 			 * yet another one. 			 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|tsn_of_pdapi_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|last_flags_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|asoc
operator|->
name|last_strm_seq_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|last_strm_no_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
comment|/* free up the chk */
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Now lets see if we can deliver the next one on 			 * the stream 			 */
name|uint16_t
name|nxt_todel
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|stream_no
index|]
expr_stmt|;
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
operator|(
name|nxt_todel
operator|==
name|ctl
operator|->
name|sinfo_ssn
operator|)
condition|)
block|{
while|while
condition|(
name|ctl
operator|!=
name|NULL
condition|)
block|{
comment|/* Deliver more if we can. */
if|if
condition|(
name|nxt_todel
operator|==
name|ctl
operator|->
name|sinfo_ssn
condition|)
block|{
name|ctlat
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|ctl
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_sequence_delivered
operator|++
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ctl
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|ctlat
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
block|}
block|}
return|return;
block|}
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|chk
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Queue the chunk either right into the socket buffer if it is the next one  * to go OR put it in the correct place in the delivery queue.  If we do  * append to the so_buf, keep doing so until we are out of order. One big  * question still remains, what to do when the socket buffer is FULL??  */
end_comment

begin_function
specifier|static
name|void
name|sctp_queue_data_to_stream
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* 	 * FIX-ME maybe? What happens when the ssn wraps? If we are getting 	 * all the data in one stream this could happen quite rapidly. One 	 * could use the TSN to keep track of things, but this scheme breaks 	 * down in the other type of stream useage that could occur. Send a 	 * single msg to stream 0, send 4Billion messages to stream 1, now 	 * send a message to stream 0. You have a situation where the TSN 	 * has wrapped but not in the stream. Is this worth worrying about 	 * or should we just change our queue sort at the bottom to be by 	 * TSN. 	 *  	 * Could it also be legal for a peer to send ssn 1 with TSN 2 and ssn 2 	 * with TSN 1? If the peer is doing some sort of funky TSN/SSN 	 * assignment this could happen... and I don't see how this would be 	 * a violation. So for now I am undecided an will leave the sort by 	 * SSN alone. Maybe a hybred approach is the answer 	 *  	 */
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|at
decl_stmt|;
name|int
name|queue_needed
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|queue_needed
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|+=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
expr_stmt|;
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_INTO_STRD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"queue to stream called for ssn:%u lastdel:%u nxt:%u\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|control
operator|->
name|sinfo_stream
argument_list|,
operator|(
name|uint32_t
operator|)
name|strm
operator|->
name|last_sequence_delivered
argument_list|,
operator|(
name|uint32_t
operator|)
name|nxt_todel
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|strm
operator|->
name|last_sequence_delivered
argument_list|,
name|control
operator|->
name|sinfo_ssn
argument_list|,
name|MAX_SEQ
argument_list|)
operator|||
operator|(
name|strm
operator|->
name|last_sequence_delivered
operator|==
name|control
operator|->
name|sinfo_ssn
operator|)
condition|)
block|{
comment|/* The incoming sseq is behind where we last delivered? */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Duplicate S-SEQ:%d delivered:%d from peer, Abort  association\n"
argument_list|,
name|control
operator|->
name|sinfo_ssn
argument_list|,
name|strm
operator|->
name|last_sequence_delivered
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * throw it in the stream so it gets cleaned up in 		 * association destruction 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|control
operator|->
name|sinfo_stream
operator|<<
literal|16
operator|)
operator||
name|control
operator|->
name|sinfo_ssn
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_1
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nxt_todel
operator|==
name|control
operator|->
name|sinfo_ssn
condition|)
block|{
comment|/* can be delivered right away? */
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_IMMED_DEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|queue_needed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_sequence_delivered
operator|++
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
comment|/* all delivered */
name|nxt_todel
operator|=
name|strm
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nxt_todel
operator|==
name|control
operator|->
name|sinfo_ssn
condition|)
block|{
name|at
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_sequence_delivered
operator|++
expr_stmt|;
comment|/* 				 * We ignore the return of deliver_data here 				 * since we always can hold the chunk on the 				 * d-queue. And we have a finite number that 				 * can be delivered from the strq. 				 */
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_IMMED_DEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|control
operator|=
name|at
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|queue_needed
condition|)
block|{
comment|/* 		 * Ok, we did not deliver this guy, find the correct place 		 * to put it on the queue. 		 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
condition|)
block|{
comment|/* Empty queue */
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_HD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&strm->inqueue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|at
operator|->
name|sinfo_ssn
argument_list|,
name|control
operator|->
name|sinfo_ssn
argument_list|,
name|MAX_SEQ
argument_list|)
condition|)
block|{
comment|/* 					 * one in queue is bigger than the 					 * new one, insert before this one 					 */
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_MD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|sinfo_ssn
operator|==
name|control
operator|->
name|sinfo_ssn
condition|)
block|{
comment|/* 					 * Gak, He sent me a duplicate str 					 * seq number 					 */
comment|/* 					 * foo bar, I guess I will just free 					 * this new guy, should we abort 					 * too? FIX ME MAYBE? Or it COULD be 					 * that the SSN's have wrapped. 					 * Maybe I should compare to TSN 					 * somehow... sigh for now just blow 					 * away the chunk! 					 */
if|if
condition|(
name|control
operator|->
name|data
condition|)
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 						 * We are at the end, insert 						 * it after this one 						 */
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_TL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|at
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns two things: You get the total size of the deliverable parts of the  * first fragmented message on the reassembly queue. And you get a 1 back if  * all of the message is ready or a 0 back if the message is still incomplete  */
end_comment

begin_function
specifier|static
name|int
name|sctp_is_all_msg_on_reasm
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
modifier|*
name|t_size
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|;
operator|*
name|t_size
operator|=
literal|0
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* nothing on the queue */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Not a first on the queue */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
if|if
condition|(
name|tsn
operator|!=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|t_size
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|tsn
operator|++
expr_stmt|;
name|chk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_deliver_reasm_check
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
name|uint32_t
name|tsize
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* Huh? */
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
condition|)
block|{
name|nxt_todel
operator|=
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
name|nxt_todel
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Yep the first one is here and its ok to deliver 			 * but should we? 			 */
if|if
condition|(
operator|(
name|sctp_is_all_msg_on_reasm
argument_list|(
name|asoc
argument_list|,
operator|&
name|tsize
argument_list|)
operator|||
operator|(
name|tsize
operator|>
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
operator|)
operator|)
condition|)
block|{
comment|/* 				 * Yes, we setup to start reception, by 				 * backing down the TSN just in case we 				 * can't deliver. If we 				 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|pdapi_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dump onto the re-assembly queue, in its proper place. After dumping on the  * queue, see if anthing can be delivered. If so pull it off (or as much as  * we can. If we run out of space then we must dump what we can and set the  * appropriate flag to say we queued what we could.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_queue_data_for_reasm
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|uint32_t
name|cum_ackp1
decl_stmt|,
name|last_tsn
decl_stmt|,
name|prev_tsn
decl_stmt|,
name|post_tsn
decl_stmt|;
name|u_char
name|last_flags
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|prev
operator|=
name|next
operator|=
name|NULL
expr_stmt|;
name|cum_ackp1
operator|=
name|asoc
operator|->
name|tsn_last_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* This is the first one on the queue */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 		 * we do not check for delivery of anything when only one 		 * fragment is here 		 */
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|cum_ackp1
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|!=
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* 				 * An empty queue, no delivery inprogress, 				 * we hit the next one and it does NOT have 				 * a FIRST fragment mark. 				 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, Evil plot, its not first, no fragmented delivery in progress\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_2
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* 				 * We are doing a partial delivery and the 				 * NEXT chunk MUST be either the LAST or 				 * MIDDLE fragment NOT a FIRST 				 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, Evil plot, it IS a first and fragmented delivery in progress\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_3
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* 				 * Here we are ok with a MIDDLE or LAST 				 * piece 				 */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|asoc
operator|->
name|str_of_pdapi
condition|)
block|{
comment|/* Got to be the right STR No */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, Evil plot, it IS not same stream number %d vs %d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|,
name|asoc
operator|->
name|str_of_pdapi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|*
literal|3
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_4
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|fragment_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|!=
name|SCTP_DATA_UNORDERED
operator|&&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|asoc
operator|->
name|ssn_of_pdapi
condition|)
block|{
comment|/* Got to be the right STR Seq */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, Evil plot, it IS not same stream seq %d vs %d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|asoc
operator|->
name|ssn_of_pdapi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_5
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
comment|/* Find its place */
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&asoc->reasmqueue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * one in queue is bigger than the new one, insert 			 * before this one 			 */
comment|/* A check */
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|next
operator|=
name|at
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* Gak, He sent me a duplicate str seq number */
comment|/* 			 * foo bar, I guess I will just free this new guy, 			 * should we abort too? FIX ME MAYBE? Or it COULD be 			 * that the SSN's have wrapped. Maybe I should 			 * compare to TSN somehow... sigh for now just blow 			 * away the chunk! 			 */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|last_flags
operator|=
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|last_tsn
operator|=
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|prev
operator|=
name|at
expr_stmt|;
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|sctp_next
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * We are at the end, insert it after this 				 * one 				 */
comment|/* check it first */
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|at
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Now the audits */
if|if
condition|(
name|prev
condition|)
block|{
name|prev_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|prev_tsn
operator|==
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* 			 * Ok the one I am dropping onto the end is the 			 * NEXT. A bit of valdiation here. 			 */
if|if
condition|(
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
operator|||
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_MIDDLE_FRAG
condition|)
block|{
comment|/* 				 * Insert chk MUST be a MIDDLE or LAST 				 * fragment 				 */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Prev check - It can be a midlle or last but not a first\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Gak, Evil plot, it's a FIRST!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_6
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Prev check - Gak, Evil plot, ssn:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|,
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_7
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Prev check - Gak, Evil plot, sseq:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_8
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|prev
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* Insert chk MUST be a FIRST */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Prev check - Gak, evil plot, its not FIRST and it must be!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_9
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
if|if
condition|(
name|next
condition|)
block|{
name|post_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|post_tsn
operator|==
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* 			 * Ok the one I am inserting ahead of is my NEXT 			 * one. A bit of valdiation here. 			 */
if|if
condition|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* Insert chk MUST be a last fragment */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Next chk - Next is FIRST, we must be LAST\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Gak, Evil plot, its not a last!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_10
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_MIDDLE_FRAG
operator|||
operator|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* 				 * Insert chk CAN be MIDDLE or FIRST NOT 				 * LAST 				 */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Next chk - Next is a MIDDLE/LAST\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Gak, Evil plot, new prev chunk is a LAST\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_11
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_11
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|!=
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Next chk - Gak, Evil plot, ssn:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|,
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_12
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_12
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|!=
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
condition|)
block|{
comment|/* 					 * Huh, need the correct STR here, 					 * they must be the same. 					 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Next chk - Gak, Evil plot, sseq:%d not the same as at:%d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|next
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_13
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_13
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
block|}
block|}
block|}
comment|/* Do we need to do some delivery? check */
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is an unfortunate routine. It checks to make sure a evil guy is not  * stuffing us full of bad packet fragments. A broken peer could also do this  * but this is doubtful. It is to bad I must worry about evil crackers sigh  * :< more cycles.  */
end_comment

begin_function
specifier|static
name|int
name|sctp_does_tsn_belong_to_reasm
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|TSN_seq
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|;
name|uint32_t
name|tsn_est
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&asoc->reasmqueue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|TSN_seq
argument_list|,
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* is it one bigger? */
name|tsn_est
operator|=
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsn_est
operator|==
name|TSN_seq
condition|)
block|{
comment|/* yep. It better be a last then */
if|if
condition|(
operator|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* 					 * Ok this guy belongs next to a guy 					 * that is NOT last, it should be a 					 * middle/last, not a complete 					 * chunk. 					 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 					 * This guy is ok since its a LAST 					 * and the new chunk is a fully 					 * self- contained one. 					 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|TSN_seq
operator|==
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* Software error since I have a dup? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Ok, 'at' is larger than new chunk but does it 			 * need to be right before it. 			 */
name|tsn_est
operator|=
name|TSN_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsn_est
operator|==
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* Yep, It better be a first */
if|if
condition|(
operator|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FRAG_MASK
operator|)
operator|!=
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|sctp_max_chunks_on_queue
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sctp_process_a_data_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_data_chunk
modifier|*
name|ch
parameter_list|,
name|int
name|chk_length
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
modifier|*
name|high_tsn
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|int
modifier|*
name|break_flag
parameter_list|,
name|int
name|last_chunk
parameter_list|)
block|{
comment|/* Process a data chunk */
comment|/* struct sctp_tmit_chunk *chk; */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|,
name|gap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dmbuf
decl_stmt|;
name|int
name|indx
decl_stmt|,
name|the_len
decl_stmt|;
name|uint16_t
name|strmno
decl_stmt|,
name|strmseq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|chk
operator|=
name|NULL
expr_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|ch
operator|->
name|dp
operator|.
name|tsn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
name|tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|tsn
condition|)
block|{
comment|/* It is a duplicate */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdupdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|numduptsns
operator|<
name|SCTP_MAX_DUP_TSNS
condition|)
block|{
comment|/* Record a dup for the next outbound sack */
name|asoc
operator|->
name|dup_tsns
index|[
name|asoc
operator|->
name|numduptsns
index|]
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|numduptsns
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Calculate the number of TSN's between the base and this TSN */
if|if
condition|(
name|tsn
operator|>=
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|gap
operator|=
name|tsn
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|gap
operator|=
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
name|tsn
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|>=
operator|(
name|SCTP_MAPPING_ARRAY
operator|<<
literal|3
operator|)
condition|)
block|{
comment|/* Can't hold the bit in the mapping at max array, toss it */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|mapping_array_size
operator|<<
literal|3
argument_list|)
condition|)
block|{
if|if
condition|(
name|sctp_expand_mapping_array
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
comment|/* Can't expand, drop it */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
operator|*
name|high_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
operator|*
name|high_tsn
operator|=
name|tsn
expr_stmt|;
block|}
comment|/* See if we have received this one already */
if|if
condition|(
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdupdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|numduptsns
operator|<
name|SCTP_MAX_DUP_TSNS
condition|)
block|{
comment|/* Record a dup for the next outbound sack */
name|asoc
operator|->
name|dup_tsns
index|[
name|asoc
operator|->
name|numduptsns
index|]
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|numduptsns
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|asoc
operator|->
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* 			 * By starting the timer we assure that we WILL sack 			 * at the end of the packet when sctp_sack_check 			 * gets called. 			 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to see about the GONE flag, duplicates would cause a sack 	 * to be sent up above 	 */
if|if
condition|(
name|stcb
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
operator|)
condition|)
block|{
comment|/* 		 * wait a minute, this guy is gone, there is no longer a 		 * receiver. Send peer an ABORT! 		 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now before going further we see if there is room. If NOT then we 	 * MAY let one through only IF this TSN is the one we are waiting 	 * for on a partial delivery API. 	 */
comment|/* now do the tests */
if|if
condition|(
operator|(
operator|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_msg_on_sb
operator|)
operator|>
name|sctp_max_chunks_on_queue
operator|)
operator|||
operator|(
operator|(
operator|(
name|int
operator|)
name|asoc
operator|->
name|my_rwnd
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * When we have NO room in the rwnd we check to make sure 		 * the reader is doing its job... 		 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
block|{
comment|/* some to read, wake-up */
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
comment|/* now is it in the mapping array of what we have accepted? */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* Nope not in the valid range dump it */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"My rwnd overrun1:tsn:%lx rwnd %lu sbspace:%ld\n"
argument_list|,
operator|(
name|u_long
operator|)
name|tsn
argument_list|,
operator|(
name|u_long
operator|)
name|asoc
operator|->
name|my_rwnd
argument_list|,
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_msg_on_sb
operator|)
operator|>
name|sctp_max_chunks_on_queue
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_datadropchklmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_datadroprwnd
argument_list|)
expr_stmt|;
block|}
name|indx
operator|=
operator|*
name|break_flag
expr_stmt|;
operator|*
name|break_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|strmno
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|dp
operator|.
name|stream_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|strmno
operator|>=
name|asoc
operator|->
name|streamincnt
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mb
decl_stmt|;
name|mb
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|*
literal|2
operator|)
argument_list|,
literal|1
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mb
operator|!=
name|NULL
condition|)
block|{
comment|/* add some space up front so prepend will work well */
name|mb
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|mtod
argument_list|(
name|mb
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 			 * Error causes are just param's and this one has 			 * two back to back phdr, one with the error type 			 * and size, the other with the streamid and a rsvd 			 */
name|mb
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mb
operator|->
name|m_len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|*
literal|2
operator|)
expr_stmt|;
name|phdr
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_INVALID_STREAM
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|phdr
operator|++
expr_stmt|;
comment|/* We insert the stream in the type field */
name|phdr
operator|->
name|param_type
operator|=
name|ch
operator|->
name|dp
operator|.
name|stream_id
expr_stmt|;
comment|/* And set the length to 0 for the rsvd field */
name|phdr
operator|->
name|param_length
operator|=
literal|0
expr_stmt|;
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|mb
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Before we continue lets validate that we are not being fooled by 	 * an evil attacker. We can only have 4k chunks based on our TSN 	 * spread allowed by the mapping array 512 * 8 bits, so there is no 	 * way our stream sequence numbers could have wrapped. We of course 	 * only validate the FIRST fragment so the bit must be set. 	 */
name|strmseq
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|dp
operator|.
name|stream_sequence
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
argument_list|,
name|strmseq
argument_list|,
name|MAX_SEQ
argument_list|)
operator|||
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|==
name|strmseq
operator|)
condition|)
block|{
comment|/* The incoming sseq is behind where we last delivered? */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"EVIL/Broken-Dup S-SEQ:%d delivered:%d from peer, Abort!\n"
argument_list|,
name|strmseq
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * throw it in the stream so it gets cleaned up in 		 * association destruction 		 */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_14
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_14
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|the_len
operator|=
operator|(
name|chk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
name|dmbuf
operator|=
name|sctp_m_copym
argument_list|(
operator|*
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
argument_list|,
name|the_len
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|mat
operator|=
name|dmbuf
expr_stmt|;
while|while
condition|(
name|mat
condition|)
block|{
if|if
condition|(
name|mat
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
name|mat
operator|=
name|mat
operator|->
name|m_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We can steal the last chunk */
name|dmbuf
operator|=
operator|*
name|m
expr_stmt|;
comment|/* lop off the top part */
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|the_len
condition|)
block|{
comment|/* Trim the end round bytes off  too */
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|-
operator|(
name|dmbuf
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|the_len
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dmbuf
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
operator|&&
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|==
literal|0
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|&&
operator|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
operator|)
operator|==
name|strmseq
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|inqueue
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Candidate for express delivery */
comment|/* 		 * Its not fragmented, No PD-API is up, Nothing in the 		 * delivery queue, Its un-ordered OR ordered and the next to 		 * deliver AND nothing else is stuck on the stream queue, 		 * And there is room for it in the socket buffer. Lets just 		 * stuff it up the buffer.... 		 */
comment|/* It would be nice to avoid this copy if we could :< */
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|sctp_build_readq_entry_mac
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|context
argument_list|,
name|net
argument_list|,
name|tsn
argument_list|,
name|ch
operator|->
name|dp
operator|.
name|protocol_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
name|strmno
argument_list|,
name|strmseq
argument_list|,
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
argument_list|,
name|dmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_express_del
goto|;
block|}
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* for ordered, bump what we delivered */
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|++
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvexpress
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del_alt
argument_list|(
name|stcb
argument_list|,
name|tsn
argument_list|,
name|strmseq
argument_list|,
name|strmno
argument_list|,
name|SCTP_STR_LOG_FROM_EXPRS_DEL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|control
operator|=
name|NULL
expr_stmt|;
goto|goto
name|finish_express_del
goto|;
block|}
name|failed_express_del
label|:
comment|/* If we reach here this is a new chunk */
name|chk
operator|=
name|NULL
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
comment|/* Express for fragmented delivery? */
if|if
condition|(
operator|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|str_of_pdapi
operator|==
name|strmno
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|ssn_of_pdapi
operator|==
name|strmseq
operator|)
condition|)
block|{
name|control
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* Can't be another first? */
goto|goto
name|failed_pdapi_express_del
goto|;
block|}
if|if
condition|(
name|tsn
operator|==
operator|(
name|control
operator|->
name|sinfo_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Yep, we can add it on */
name|int
name|end
init|=
literal|0
decl_stmt|;
name|uint32_t
name|cumack
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|end
operator|=
literal|1
expr_stmt|;
block|}
name|cumack
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
if|if
condition|(
operator|(
name|cumack
operator|+
literal|1
operator|)
operator|==
name|tsn
condition|)
name|cumack
operator|=
name|tsn
expr_stmt|;
if|if
condition|(
name|sctp_append_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
name|dmbuf
argument_list|,
name|end
argument_list|,
name|tsn
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Append fails end:%d\n"
argument_list|,
name|end
argument_list|)
expr_stmt|;
goto|goto
name|failed_pdapi_express_del
goto|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvexpressm
argument_list|)
expr_stmt|;
name|control
operator|->
name|sinfo_tsn
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
expr_stmt|;
name|asoc
operator|->
name|tsn_of_pdapi_last_delivered
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|last_flags_delivered
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
expr_stmt|;
name|asoc
operator|->
name|last_strm_seq_delivered
operator|=
name|strmseq
expr_stmt|;
name|asoc
operator|->
name|last_strm_no_delivered
operator|=
name|strmno
expr_stmt|;
if|if
condition|(
name|end
condition|)
block|{
comment|/* clean up the flags and such */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmin
index|[
name|strmno
index|]
operator|.
name|last_sequence_delivered
operator|++
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
block|}
name|control
operator|=
name|NULL
expr_stmt|;
goto|goto
name|finish_express_del
goto|;
block|}
block|}
name|failed_pdapi_express_del
label|:
name|control
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|!=
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the chunk */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
comment|/* we copied it, free the copy */
name|sctp_m_freem
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|=
name|tsn
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|=
name|strmseq
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|=
name|strmno
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
operator|=
name|ch
operator|->
name|dp
operator|.
name|protocol_id
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|the_len
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|dmbuf
expr_stmt|;
block|}
else|else
block|{
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|sctp_build_readq_entry_mac
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|context
argument_list|,
name|net
argument_list|,
name|tsn
argument_list|,
name|ch
operator|->
name|dp
operator|.
name|protocol_id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|context
argument_list|,
name|strmno
argument_list|,
name|strmseq
argument_list|,
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
argument_list|,
name|dmbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the chunk */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
comment|/* we copied it, free the copy */
name|sctp_m_freem
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|control
operator|->
name|length
operator|=
name|the_len
expr_stmt|;
block|}
comment|/* Mark it as received */
comment|/* Now queue it where it belongs */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
comment|/* First a sanity check */
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* 			 * Ok, we have a fragmented delivery in progress if 			 * this chunk is next to deliver OR belongs in our 			 * view to the reassembly, the peer is evil or 			 * broken. 			 */
name|uint32_t
name|estimate_tsn
decl_stmt|;
name|estimate_tsn
operator|=
name|asoc
operator|->
name|tsn_last_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
operator|&&
operator|(
name|estimate_tsn
operator|==
name|control
operator|->
name|sinfo_tsn
operator|)
condition|)
block|{
comment|/* Evil/Broke peer */
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_15
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_15
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|sctp_does_tsn_belong_to_reasm
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_16
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_16
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* No PDAPI running */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* 				 * Reassembly queue is NOT empty validate 				 * that this tsn does not need to be in 				 * reasembly queue. If it does then our peer 				 * is broken or evil. 				 */
if|if
condition|(
name|sctp_does_tsn_belong_to_reasm
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_17
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|tsn
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
operator|(
operator|(
name|strmno
operator|<<
literal|16
operator|)
operator||
name|strmseq
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_17
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
comment|/* ok, if we reach here we have passed the sanity checks */
if|if
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* queue directly into socket buffer */
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Special check for when streams are resetting. We 			 * could be more smart about this and check the 			 * actual stream to see if it is not being reset.. 			 * that way we would not create a HOLB when amongst 			 * streams being reset and those not being reset. 			 *  			 * We take complete messages that have a stream reset 			 * intervening (aka the TSN is after where our 			 * cum-ack needs to be) off and put them on a 			 * pending_reply_queue. The reassembly ones we do 			 * not have to worry about since they are all sorted 			 * and proceessed by TSN order. It is only the 			 * singletons I must worry about. 			 */
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|tsn
operator|==
name|ntohl
argument_list|(
name|liste
operator|->
name|tsn
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 				 * yep its past where we need to reset... go 				 * ahead and queue it. 				 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
condition|)
block|{
comment|/* first one on */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|ctlOn
decl_stmt|;
name|unsigned
name|char
name|inserted
init|=
literal|0
decl_stmt|;
name|ctlOn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctlOn
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|ctlOn
operator|->
name|sinfo_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|ctlOn
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctlOn
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* found it */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|ctlOn
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inserted
operator|==
literal|0
condition|)
block|{
comment|/* 						 * must be put at end, use 						 * prevP (all setup from 						 * loop) to setup nextP. 						 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* Into the re-assembly queue */
name|sctp_queue_data_for_reasm
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
comment|/* 			 * the assoc is now gone and chk was put onto the 			 * reasm queue, which has all been freed. 			 */
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|finish_express_del
label|:
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* we have a new high score */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|tsn
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|2
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tsn
operator|==
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Update cum-ack */
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|last_chunk
condition|)
block|{
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inorderchunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inunorderchunks
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdata
argument_list|)
expr_stmt|;
comment|/* Set it present please */
ifdef|#
directive|ifdef
name|SCTP_STR_LOGGING
name|sctp_log_strm_del_alt
argument_list|(
name|stcb
argument_list|,
name|tsn
argument_list|,
name|strmseq
argument_list|,
name|strmno
argument_list|,
name|SCTP_STR_LOG_FROM_MARK_TSN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|int8_t
name|sctp_map_lookup_tab
index|[
literal|256
index|]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|5
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|6
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|5
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|4
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|3
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|2
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
literal|0
block|,
operator|-
literal|1
block|,
literal|7
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_sack_check
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|ok_to_sack
parameter_list|,
name|int
name|was_a_gap
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* 	 * Now we also need to check the mapping array in a couple of ways. 	 * 1) Did we move the cum-ack point? 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|i
decl_stmt|,
name|at
decl_stmt|;
name|int
name|all_ones
decl_stmt|;
name|int
name|slide_from
decl_stmt|,
name|slide_end
decl_stmt|,
name|lgap
decl_stmt|,
name|distance
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|uint32_t
name|old_cumack
decl_stmt|,
name|old_base
decl_stmt|,
name|old_highest
decl_stmt|;
name|unsigned
name|char
name|aux_array
index|[
literal|64
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|old_cumack
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|old_base
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
name|old_highest
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|mapping_array_size
operator|<
literal|64
condition|)
name|memcpy
argument_list|(
name|aux_array
argument_list|,
name|asoc
operator|->
name|mapping_array
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|aux_array
argument_list|,
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|64
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * We could probably improve this a small bit by calculating the 	 * offset of the current cum-ack as the starting point. 	 */
name|all_ones
operator|=
literal|1
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
operator|==
literal|0xff
condition|)
block|{
name|at
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* there is a 0 bit */
name|all_ones
operator|=
literal|0
expr_stmt|;
name|at
operator|+=
name|sctp_map_lookup_tab
index|[
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
index|]
expr_stmt|;
break|break;
block|}
block|}
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
name|at
expr_stmt|;
comment|/* at is one off, since in the table a embedded -1 is present */
name|at
operator|++
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"huh, cumack greater than high-tsn in map"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"huh, cumack greater than high-tsn in map - should panic?\n"
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|all_ones
operator|||
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|asoc
operator|->
name|highest_tsn_inside_map
operator|&&
name|at
operator|>=
literal|8
operator|)
condition|)
block|{
comment|/* The complete array was completed by a single FR */
comment|/* higest becomes the cum-ack */
name|int
name|clr
decl_stmt|;
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
comment|/* clear the array */
if|if
condition|(
name|all_ones
condition|)
name|clr
operator|=
name|asoc
operator|->
name|mapping_array_size
expr_stmt|;
else|else
block|{
name|clr
operator|=
operator|(
name|at
operator|>>
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* 			 * this should be the allones case but just in case 			 * :> 			 */
if|if
condition|(
name|clr
operator|>
name|asoc
operator|->
name|mapping_array_size
condition|)
name|clr
operator|=
name|asoc
operator|->
name|mapping_array_size
expr_stmt|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|clr
argument_list|)
expr_stmt|;
comment|/* base becomes one ahead of the cum-ack */
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
name|old_base
argument_list|,
name|old_cumack
argument_list|,
name|old_highest
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_CLEARED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|at
operator|>=
literal|8
condition|)
block|{
comment|/* we can slide the mapping array down */
comment|/* Calculate the new byte postion we can move down */
name|slide_from
operator|=
name|at
operator|>>
literal|3
expr_stmt|;
comment|/* 		 * now calculate the ceiling of the move using our highest 		 * TSN value 		 */
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|>=
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|lgap
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|lgap
operator|=
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
literal|1
expr_stmt|;
block|}
name|slide_end
operator|=
name|lgap
operator|>>
literal|3
expr_stmt|;
if|if
condition|(
name|slide_end
operator|<
name|slide_from
condition|)
block|{
name|panic
argument_list|(
literal|"impossible slide"
argument_list|)
expr_stmt|;
block|}
name|distance
operator|=
operator|(
name|slide_end
operator|-
name|slide_from
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
name|old_base
argument_list|,
name|old_cumack
argument_list|,
name|old_highest
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
name|sctp_log_map
argument_list|(
operator|(
name|uint32_t
operator|)
name|slide_from
argument_list|,
operator|(
name|uint32_t
operator|)
name|slide_end
argument_list|,
operator|(
name|uint32_t
operator|)
name|lgap
argument_list|,
name|SCTP_MAP_SLIDE_FROM
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|distance
operator|+
name|slide_from
operator|>
name|asoc
operator|->
name|mapping_array_size
operator|||
name|distance
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Here we do NOT slide forward the array so that 			 * hopefully when more data comes in to fill it up 			 * we will be able to slide it forward. Really I 			 * don't think this should happen :-0 			 */
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
operator|(
name|uint32_t
operator|)
name|distance
argument_list|,
operator|(
name|uint32_t
operator|)
name|slide_from
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_MAP_SLIDE_NONE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|int
name|ii
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|distance
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|mapping_array
index|[
name|ii
index|]
operator|=
name|asoc
operator|->
name|mapping_array
index|[
name|slide_from
operator|+
name|ii
index|]
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|distance
init|;
name|ii
operator|<=
name|slide_end
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|mapping_array
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+=
operator|(
name|slide_from
operator|<<
literal|3
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* check the special flag for stream resets */
if|if
condition|(
operator|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|liste
operator|->
name|tsn
operator|)
operator|)
condition|)
block|{
comment|/* 		 * we have finished working through the backlogged TSN's now 		 * time to reset streams. 1: call reset function. 2: free 		 * pending_reply space 3: distribute any chunks in 		 * pending_reply_queue. 		 */
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|;
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
name|liste
operator|->
name|number_entries
argument_list|,
name|liste
operator|->
name|req
operator|.
name|list_of_streams
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|liste
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|liste
argument_list|)
expr_stmt|;
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|&&
operator|(
name|liste
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* All can be removed */
while|while
condition|(
name|ctl
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ctl
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return;
block|}
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ctl
condition|)
block|{
comment|/* more than one in queue */
while|while
condition|(
operator|!
name|compare_with_wrap
argument_list|(
name|ctl
operator|->
name|sinfo_tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 				 * if ctl->sinfo_tsn is<= liste->tsn we can 				 * process it which is the NOT of 				 * ctl->sinfo_tsn> liste->tsn 				 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ctl
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return;
block|}
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Now service re-assembly to pick up anything that has been 		 * held on reassembly queue? 		 */
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now we need to see if we need to queue a sack or just start the 	 * timer (if allowed). 	 */
if|if
condition|(
name|ok_to_sack
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* 			 * Ok special case, in SHUTDOWN-SENT case. here we 			 * maker sure SACK timer is off and instead send a 			 * SHUTDOWN and a SACK 			 */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_18
argument_list|)
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|is_a_gap
decl_stmt|;
comment|/* is there a gap now ? */
name|is_a_gap
operator|=
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
expr_stmt|;
comment|/* 			 * CMT DAC algorithm: increase number of packets 			 * received since last ack 			 */
name|stcb
operator|->
name|asoc
operator|.
name|cmt_dac_pkts_rcvd
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|first_ack_sent
operator|==
literal|0
operator|)
operator|||
comment|/* First time we send a 								 * sack */
operator|(
operator|(
name|was_a_gap
operator|)
operator|&&
operator|(
name|is_a_gap
operator|==
literal|0
operator|)
operator|)
operator|||
comment|/* was a gap, but no 								 * longer is one */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|)
operator|||
comment|/* we have dup's */
operator|(
name|is_a_gap
operator|)
operator|||
comment|/* is still a gap */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|==
literal|0
operator|)
operator|||
operator|(
name|callout_pending
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
operator|)
comment|/* timer was up . second 										 * packet */
condition|)
block|{
if|if
condition|(
operator|(
name|sctp_cmt_on_off
operator|)
operator|&&
operator|(
name|sctp_cmt_use_dac
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|first_ack_sent
operator|==
literal|1
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|)
operator|&&
operator|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * CMT DAC algorithm: With CMT, 					 * delay acks even in the face of 					 *  					 * reordering. Therefore, if acks that 					 * do not have to be sent because of 					 * the above reasons, will be 					 * delayed. That is, acks that would 					 * have been sent due to gap reports 					 * will be delayed with DAC. Start 					 * the delayed ack timer. 					 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Ok we must build a SACK since the 					 * timer is pending, we got our 					 * first packet OR there are gaps or 					 * duplicates. 					 */
name|stcb
operator|->
name|asoc
operator|.
name|first_ack_sent
operator|=
literal|1
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* The sending will stop the timer */
block|}
block|}
else|else
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_service_queues
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsize
decl_stmt|;
name|uint16_t
name|nxt_todel
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
comment|/* Can we proceed further, i.e. the PD-API is complete */
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* no */
return|return;
block|}
comment|/* 	 * Now is there some other chunk I can deliver from the reassembly 	 * queue. 	 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|nxt_todel
operator|=
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
operator|(
name|nxt_todel
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Yep the first one is here. We setup to start reception, 		 * by backing down the TSN just in case we can't deliver. 		 */
comment|/* 		 * Before we start though either all of the message should 		 * be here or 1/4 the socket buffer max or nothing on the 		 * delivery queue and something can be delivered. 		 */
if|if
condition|(
operator|(
name|sctp_is_all_msg_on_reasm
argument_list|(
name|asoc
argument_list|,
operator|&
name|tsize
argument_list|)
operator|||
operator|(
name|tsize
operator|>
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
operator|)
operator|)
condition|)
block|{
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|pdapi_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|sctp_strict_data_order
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp_process_data
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
modifier|*
name|high_tsn
parameter_list|)
block|{
name|struct
name|sctp_data_chunk
modifier|*
name|ch
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|num_chunks
init|=
literal|0
decl_stmt|;
comment|/* number of control chunks processed */
name|int
name|stop_proc
init|=
literal|0
decl_stmt|;
name|int
name|chk_length
decl_stmt|,
name|break_flag
decl_stmt|,
name|last_chunk
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|,
name|was_a_gap
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* set the rwnd */
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mm
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
condition|)
block|{
comment|/* 		 * wait a minute, this guy is gone, there is no longer a 		 * receiver. Send peer an ABORT! 		 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* there was a gap before this data was processed */
name|was_a_gap
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * setup where we got the last DATA packet from for any SACK that 	 * may need to go out. Don't bump the net. This is done ONLY when a 	 * chunk is assigned. 	 */
name|asoc
operator|->
name|last_data_chunk_from
operator|=
name|net
expr_stmt|;
comment|/* 	 * Now before we proceed we must figure out if this is a wasted 	 * cluster... i.e. it is a small packet sent in and yet the driver 	 * underneath allocated a full cluster for it. If so we must copy it 	 * to a smaller mbuf and free up the cluster mbuf. This will help 	 * with cluster starvation. 	 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
operator|(
name|long
operator|)
name|MHLEN
operator|&&
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
comment|/* we only handle mbufs that are singletons.. not chains */
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|m
operator|->
name|m_len
argument_list|,
literal|1
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* ok lets see if we can copy the data up */
name|caddr_t
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|mm
operator|)
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
comment|/* got to copy the header first */
name|M_MOVE_PKTHDR
argument_list|(
name|m
argument_list|,
operator|(
operator|*
name|mm
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* get the pointers and copy */
name|to
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
operator|*
argument_list|)
expr_stmt|;
name|from
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|,
name|caddr_t
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
operator|(
operator|*
name|mm
operator|)
operator|->
name|m_len
argument_list|)
expr_stmt|;
comment|/* copy the length and free up the old */
name|m
operator|->
name|m_len
operator|=
operator|(
operator|*
name|mm
operator|)
operator|->
name|m_len
expr_stmt|;
name|sctp_m_freem
argument_list|(
operator|*
name|mm
argument_list|)
expr_stmt|;
comment|/* sucess, back copy */
operator|*
name|mm
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* We are in trouble in the mbuf world .. yikes */
name|m
operator|=
operator|*
name|mm
expr_stmt|;
block|}
block|}
comment|/* get pointer to the first chunk header */
name|ch
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * process all DATA chunks... 	 */
operator|*
name|high_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|break_flag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|stop_proc
operator|==
literal|0
condition|)
block|{
comment|/* validate chunk length */
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|*
name|offset
operator|<
name|chk_length
condition|)
block|{
comment|/* all done, mutulated chunk */
name|stop_proc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
if|if
condition|(
operator|(
name|size_t
operator|)
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|+
literal|1
condition|)
block|{
comment|/* 				 * Need to send an abort since we had a 				 * invalid data chunk. 				 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|op_err
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|op_err
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_19
argument_list|)
expr_stmt|;
name|ippp
operator|++
expr_stmt|;
operator|*
name|ippp
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_19
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|==
operator|(
name|length
operator|-
operator|*
name|offset
operator|)
condition|)
block|{
name|last_chunk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_chunk
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sctp_process_a_data_chunk
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|mm
argument_list|,
operator|*
name|offset
argument_list|,
name|ch
argument_list|,
name|chk_length
argument_list|,
name|net
argument_list|,
name|high_tsn
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|&
name|break_flag
argument_list|,
name|last_chunk
argument_list|)
condition|)
block|{
name|num_chunks
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|abort_flag
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|break_flag
condition|)
block|{
comment|/* 				 * Set because of out of rwnd space and no 				 * drop rep space left. 				 */
name|stop_proc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* not a data chunk in the data region */
switch|switch
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INITIATION
case|:
case|case
name|SCTP_INITIATION_ACK
case|:
case|case
name|SCTP_SELECTIVE_ACK
case|:
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
case|case
name|SCTP_HEARTBEAT_ACK
case|:
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
case|case
name|SCTP_SHUTDOWN
case|:
case|case
name|SCTP_SHUTDOWN_ACK
case|:
case|case
name|SCTP_OPERATION_ERROR
case|:
case|case
name|SCTP_COOKIE_ECHO
case|:
case|case
name|SCTP_COOKIE_ACK
case|:
case|case
name|SCTP_ECN_ECHO
case|:
case|case
name|SCTP_ECN_CWR
case|:
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
case|case
name|SCTP_AUTHENTICATION
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
case|case
name|SCTP_PACKET_DROPPED
case|:
case|case
name|SCTP_STREAM_RESET
case|:
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
case|case
name|SCTP_ASCONF
case|:
comment|/* 				 * Now, what do we do with KNOWN chunks that 				 * are NOT in the right place? 				 *  				 * For now, I do nothing but ignore them. We 				 * may later want to add sysctl stuff to 				 * switch out and do either an ABORT() or 				 * possibly process them. 				 */
if|if
condition|(
name|sctp_strict_data_order
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
break|break;
default|default:
comment|/* unknown chunk type, use bit rules */
if|if
condition|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|&
literal|0x40
condition|)
block|{
comment|/* Add a error report to the queue */
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phd
decl_stmt|;
name|mm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
argument_list|,
literal|1
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
condition|)
block|{
name|phd
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 						 * We cheat and use param 						 * type since we did not 						 * bother to define a error 						 * cause struct. They are 						 * the same basic format 						 * with different names. 						 */
name|phd
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRECOG_CHUNK
argument_list|)
expr_stmt|;
name|phd
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|chk_length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
argument_list|)
expr_stmt|;
name|mm
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
expr_stmt|;
name|mm
operator|->
name|m_next
operator|=
name|sctp_m_copym
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
operator|->
name|m_next
condition|)
block|{
name|mm
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
expr_stmt|;
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|ch
operator|.
name|chunk_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* discard the rest of this packet */
name|stop_proc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* else skip this bad chunk and 					 * continue... */
break|break;
block|}
empty_stmt|;
comment|/* switch of chunk type */
block|}
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|offset
operator|>=
name|length
operator|)
operator|||
name|stop_proc
condition|)
block|{
comment|/* no more data left in the mbuf chain */
name|stop_proc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
name|stop_proc
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* while */
if|if
condition|(
name|break_flag
condition|)
block|{
comment|/* 		 * we need to report rwnd overrun drops. 		 */
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|*
name|mm
argument_list|,
name|iphlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_chunks
condition|)
block|{
comment|/* 		 * Did we get data, if so update the time for auto-close and 		 * give peer credit for being alive. 		 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpktwithdata
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_last_rcvd
argument_list|)
expr_stmt|;
block|}
comment|/* now service all of the reassm queue if needed */
if|if
condition|(
operator|!
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
operator|)
condition|)
name|sctp_service_queues
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* 		 * Assure that we ack right away by making sure that a d-ack 		 * timer is running. So the sack_check will send a sack. 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* Start a sack timer or QUEUE a SACK for sending */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|first_ack_sent
operator|)
condition|)
block|{
comment|/* Everything is in order */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
index|[
literal|0
index|]
operator|==
literal|0xff
condition|)
block|{
comment|/* need to do the slide */
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|was_a_gap
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|first_ack_sent
operator|=
literal|1
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|was_a_gap
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abort_flag
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_segments
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_sack_chunk
modifier|*
name|ch
parameter_list|,
name|uint32_t
name|last_tsn
parameter_list|,
name|uint32_t
modifier|*
name|biggest_tsn_acked
parameter_list|,
name|uint32_t
modifier|*
name|biggest_newly_acked_tsn
parameter_list|,
name|uint32_t
modifier|*
name|this_sack_lowest_newack
parameter_list|,
name|int
name|num_seg
parameter_list|,
name|int
modifier|*
name|ecn_seg_sums
parameter_list|)
block|{
comment|/************************************************/
comment|/* process fragments and update sendqueue        */
comment|/************************************************/
name|struct
name|sctp_sack
modifier|*
name|sack
decl_stmt|;
name|struct
name|sctp_gap_ack_block
modifier|*
name|frag
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|int
name|num_frs
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|frag_strt
decl_stmt|,
name|frag_end
decl_stmt|,
name|primary_flag_set
decl_stmt|;
name|u_long
name|last_frag_high
decl_stmt|;
comment|/* 	 * @@@ JRI : TODO: This flag is not used anywhere .. remove? 	 */
if|if
condition|(
name|asoc
operator|->
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_SWITCH_PRIMARY
condition|)
block|{
name|primary_flag_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|primary_flag_set
operator|=
literal|0
expr_stmt|;
block|}
name|sack
operator|=
operator|&
name|ch
operator|->
name|sack
expr_stmt|;
name|frag
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sack
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack
argument_list|)
operator|)
expr_stmt|;
name|tp1
operator|=
name|NULL
expr_stmt|;
name|last_frag_high
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_seg
condition|;
name|i
operator|++
control|)
block|{
name|frag_strt
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|start
argument_list|)
expr_stmt|;
name|frag_end
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|end
argument_list|)
expr_stmt|;
comment|/* some sanity checks on the fargment offsets */
if|if
condition|(
name|frag_strt
operator|>
name|frag_end
condition|)
block|{
comment|/* this one is malformed, skip */
name|frag
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
operator|(
name|frag_end
operator|+
name|last_tsn
operator|)
argument_list|,
operator|*
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
operator|*
name|biggest_tsn_acked
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
comment|/* mark acked dgs and find out the highestTSN being acked */
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
comment|/* save the locations of the last frags */
name|last_frag_high
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * now lets see if we need to reset the queue due to 			 * a out-of-order SACK fragment 			 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|frag_strt
operator|+
name|last_tsn
argument_list|,
name|last_frag_high
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 				 * if the new frag starts after the last TSN 				 * frag covered, we are ok and this one is 				 * beyond the last one 				 */
empty_stmt|;
block|}
else|else
block|{
comment|/* 				 * ok, they have reset us, so we need to 				 * reset the queue this will cause extra 				 * hunting but hey, they chose the 				 * performance hit when they failed to order 				 * there gaps.. 				 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|last_frag_high
operator|=
name|frag_end
operator|+
name|last_tsn
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|frag_strt
operator|+
name|last_tsn
init|;
name|j
operator|<=
name|frag_end
operator|+
name|last_tsn
condition|;
name|j
operator|++
control|)
block|{
while|while
condition|(
name|tp1
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
condition|)
name|num_frs
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * CMT: CUCv2 algorithm. For each TSN being 				 * processed from the sent queue, track the 				 * next expected pseudo-cumack, or 				 * rtx_pseudo_cumack, if required. Separate 				 * cumack trackers for first transmissions, 				 * and retransmissions. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|==
literal|1
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|pseudo_cumack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|>
literal|1
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rtx_pseudo_cumack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|j
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 						 * must be held until 						 * cum-ack passes 						 */
comment|/* 						 * ECN Nonce: Add the nonce 						 * value to the sender's 						 * nonce sum 						 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 							 * If it is less 							 * than ACKED, it is 							 * now no-longer in 							 * flight. Higher 							 * values may 							 * already be set 							 * via previous Gap 							 * Ack Blocks... 							 * i.e. ACKED or 							 * MARKED. 							 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
operator|*
name|biggest_newly_acked_tsn
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/* 							 * CMT: SFR algo 							 * (and HTNA) - set 							 * saw_newack to 1 							 * for dest being 							 * newly acked. 							 * update 							 * this_sack_highest_ 							 * n ewack if 							 * appropriate. 							 */
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/* 							 * CMT DAC algo: 							 * also update 							 * this_sack_lowest_n 							 * e wack 							 */
if|if
condition|(
operator|*
name|this_sack_lowest_newack
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
operator|*
name|this_sack_lowest_newack
argument_list|,
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/* 							 * CMT: CUCv2 							 * algorithm. If 							 * (rtx-)pseudo-cumac 							 * k for corresp 							 * dest is being 							 * acked, then we 							 * have a new 							 * (rtx-)pseudo-cumac 							 * k . Set 							 * new_(rtx_)pseudo_c 							 * u mack to TRUE so 							 * that the cwnd for 							 * this dest can be 							 * updated. Also 							 * trigger search 							 * for the next 							 * expected 							 * (rtx-)pseudo-cumac 							 * k . Separate 							 * pseudo_cumack 							 * trackers for 							 * first 							 * transmissions and 							 * retransmissions. 							 */
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tp1
operator|->
name|whoTo
operator|->
name|pseudo_cumack
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tp1
operator|->
name|whoTo
operator|->
name|rtx_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|frag_strt
argument_list|,
name|frag_end
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|>=
name|tp1
operator|->
name|book_size
condition|)
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
else|else
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|asoc
operator|->
name|total_flight
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight_count
operator|>
literal|0
condition|)
name|asoc
operator|->
name|total_flight_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 								 * True 								 * non-retran 								 * smited 								 * chunk */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* 								 * update RTO 								 * too ? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|rto_pending
operator|=
literal|0
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<=
name|SCTP_DATAGRAM_RESEND
operator|&&
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
operator|&&
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|this_sack_highest_gap
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB2
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
operator|(
operator|*
name|ecn_seg_sums
operator|)
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
operator|(
operator|*
name|ecn_seg_sums
operator|)
operator|&=
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_MARKED
expr_stmt|;
block|}
break|break;
block|}
comment|/* if (tp1->TSN_seq == j) */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|j
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
break|break;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
comment|/* end while (tp1) */
block|}
comment|/* end for (j = fragStart */
name|frag
operator|++
expr_stmt|;
comment|/* next one */
block|}
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
comment|/* 	 * if (num_frs) sctp_log_fr(*biggest_tsn_acked, 	 * *biggest_newly_acked_tsn, last_tsn, SCTP_FR_LOG_BIGGEST_TSNS); 	 */
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_check_for_revoked
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|u_long
name|biggest_tsn_acked
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|tot_revoked
init|=
literal|0
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cumack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ok this guy is either ACK or MARKED. If it is 			 * ACKED it has been previously acked but not this 			 * time i.e. revoked.  If it is MARKED it was ACK'ed 			 * again. 			 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* it has been revoked */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
comment|/* 				 * We must add this stuff back in to assure 				 * timers and such get started. 				 */
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|++
expr_stmt|;
name|asoc
operator|->
name|total_flight
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tot_revoked
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_REVOKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_MARKED
condition|)
block|{
comment|/* it has been re-acked in this SACK */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
break|break;
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tot_revoked
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Setup the ecn nonce re-sync point. We do this since once 		 * data is revoked we begin to retransmit things, which do 		 * NOT have the ECN bits set. This means we are now out of 		 * sync and must wait until we get back in sync with the 		 * peer to check ECN bits. 		 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|extern
name|int
name|sctp_peer_chunk_oh
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_strike_gap_ack_chunks
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|u_long
name|biggest_tsn_acked
parameter_list|,
name|u_long
name|biggest_tsn_newly_acked
parameter_list|,
name|u_long
name|this_sack_lowest_newack
parameter_list|,
name|int
name|accum_moved
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|strike_flag
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|tot_retrans
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sending_seq
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|num_dests_sacked
init|=
literal|0
decl_stmt|;
comment|/* 	 * select the sending_seq, this is either the next thing ready to be 	 * sent but not transmitted, OR, the next seq we assign. 	 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|sending_seq
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|sending_seq
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/* CMT DAC algo: finding out if SACK is a mixed SACK */
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_use_dac
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|saw_newack
condition|)
name|num_dests_sacked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
name|strike_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|no_fr_allowed
condition|)
block|{
comment|/* this one had a timeout or something */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_CHECK_STRIKE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* done */
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
condition|)
block|{
if|if
condition|(
operator|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
operator|&&
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* Is it expired? */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|PR_SCTP_RTX_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
operator|&&
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* Has it been retransmitted tv_sec times? */
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|>
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
condition|)
block|{
comment|/* Yes, so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|this_sack_highest_gap
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* we are beyond the tsn in the sack  */
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|>=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* either a RESEND, ACKED, or MARKED */
comment|/* skip */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * CMT : SFR algo (covers part of DAC and HTNA as well) 		 */
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No new acks were receieved for data sent to this 			 * dest. Therefore, according to the SFR algo for 			 * CMT, no data sent to this dest can be marked for 			 * FR using this SACK. (iyengar@cis.udel.edu, 			 * 2005/05/12) 			 */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * CMT: New acks were receieved for data sent to 			 * this dest. But no new acks were seen for data 			 * sent after tp1. Therefore, according to the SFR 			 * algo for CMT, tp1 cannot be marked for FR using 			 * this SACK. This step covers part of the DAC algo 			 * and the HTNA algo as well. 			 */
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Here we check to see if we were have already done a FR 		 * and if so we see if the biggest TSN we saw in the sack is 		 * smaller than the recovery point. If so we don't strike 		 * the tsn... otherwise we CAN strike the TSN. 		 */
comment|/* 		 * @@@ JRI: Check for CMT 		 */
if|if
condition|(
name|accum_moved
operator|&&
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Strike the TSN if in fast-recovery and cum-ack 			 * moved. 			 */
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_use_dac
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: If SACK flag is set to 				 * 0, then lowest_newack test will not pass 				 * because it would have been set to the 				 * cumack earlier. If not already to be 				 * rtx'd, If not a mixed sack and if tp1 is 				 * not between two sacked TSNs, then mark by 				 * one more. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|compare_with_wrap
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
literal|16
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
condition|)
block|{
comment|/* 			 * For those that have done a FR we must take 			 * special consideration if we strike. I.e the 			 * biggest_newly_acked must be higher than the 			 * sending_seq at the time we did the FR. 			 */
ifdef|#
directive|ifdef
name|SCTP_FR_TO_ALTERNATE
comment|/* 			 * If FR's go to new networks, then we must only do 			 * this for singly homed asoc's. However if the FR's 			 * go to the same network (Armando's work) then its 			 * ok to FR multiple times. 			 */
if|if
condition|(
name|asoc
operator|->
name|numnets
operator|<
literal|2
condition|)
else|#
directive|else
if|if
condition|(
literal|1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
operator|(
name|compare_with_wrap
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|biggest_tsn_newly_acked
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|)
condition|)
block|{
comment|/* 					 * Strike the TSN, since this ack is 					 * beyond where things were when we 					 * did a FR. 					 */
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
name|strike_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_use_dac
condition|)
block|{
comment|/* 						 * CMT DAC algorithm: If 						 * SACK flag is set to 0, 						 * then lowest_newack test 						 * will not pass because it 						 * would have been set to 						 * the cumack earlier. If 						 * not already to be rtx'd, 						 * If not a mixed sack and 						 * if tp1 is not between two 						 * sacked TSNs, then mark by 						 * one more. 						 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|compare_with_wrap
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
literal|32
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 			 * @@@ JRI: TODO: remove code for HTNA algo. CMT's 			 * SFR algo covers HTNA. 			 */
block|}
elseif|else
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|biggest_tsn_newly_acked
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * We don't strike these: This is the  HTNA 			 * algorithm i.e. we don't strike If our TSN is 			 * larger than the Highest TSN Newly Acked. 			 */
empty_stmt|;
block|}
else|else
block|{
comment|/* Strike the TSN */
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_use_dac
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: If SACK flag is set to 				 * 0, then lowest_newack test will not pass 				 * because it would have been set to the 				 * cumack earlier. If not already to be 				 * rtx'd, If not a mixed sack and if tp1 is 				 * not between two sacked TSNs, then mark by 				 * one more. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|compare_with_wrap
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
literal|48
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* Increment the count to resend */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* printf("OK, we are now ready to FR this guy\n"); */
ifdef|#
directive|ifdef
name|SCTP_FR_LOGGING
name|sctp_log_fr
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tp1
operator|->
name|snd_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_MARKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|strike_flag
condition|)
block|{
comment|/* This is a subsequent FR */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendmultfastretrans
argument_list|)
expr_stmt|;
block|}
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
comment|/* 				 * CMT: Using RTX_SSTHRESH policy for CMT. 				 * If CMT is being used, then pick dest with 				 * largest ssthresh for any retransmission. 				 * (iyengar@cis.udel.edu, 2005/08/12) 				 */
name|tp1
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 				 * CUCv2: If a different dest is picked for 				 * the retransmission, then new 				 * (rtx-)pseudo_cumack needs to be tracked 				 * for orig dest. Let CUCv2 track new (rtx-) 				 * pseudo-cumack always. 				 */
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* CMT is OFF */
ifdef|#
directive|ifdef
name|SCTP_FR_TO_ALTERNATE
comment|/* Can we find an alternate? */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 				 * default behavior is to NOT retransmit 				 * FR's to an alternate. Armando Caro's 				 * paper details why. 				 */
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
endif|#
directive|endif
block|}
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|1
expr_stmt|;
name|tot_retrans
operator|++
expr_stmt|;
comment|/* mark the sending seq for possible subsequent FR's */
comment|/* 			 * printf("Marking TSN for FR new value %x\n", 			 * (uint32_t)tpi->rec.data.TSN_seq); 			 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
condition|)
block|{
comment|/* 				 * If the queue of send is empty then its 				 * the next sequence number that will be 				 * assigned so we subtract one from this to 				 * get the one we last sent. 				 */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If there are chunks on the send queue 				 * (unsent data that has made it from the 				 * stream queues but not out the door, we 				 * take the first one (which will have the 				 * lowest TSN) and subtract one to get the 				 * one we last sent. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|ttt
decl_stmt|;
name|ttt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|ttt
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
comment|/* 				 * this guy had a RTO calculation pending on 				 * it, cancel it 				 */
name|tp1
operator|->
name|whoTo
operator|->
name|rto_pending
operator|=
literal|0
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* fix counts and things */
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|++
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|>=
name|tp1
operator|->
name|book_size
condition|)
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
else|else
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_RWND
name|sctp_log_rwnd
argument_list|(
name|SCTP_INCREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|tp1
operator|->
name|send_size
argument_list|,
name|sctp_peer_chunk_oh
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* add back to the rwnd */
name|asoc
operator|->
name|peers_rwnd
operator|+=
operator|(
name|tp1
operator|->
name|send_size
operator|+
name|sctp_peer_chunk_oh
operator|)
expr_stmt|;
comment|/* remove from the total flight */
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|asoc
operator|->
name|total_flight
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight_count
operator|>
literal|0
condition|)
name|asoc
operator|->
name|total_flight_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|!=
name|tp1
operator|->
name|whoTo
condition|)
block|{
comment|/* yes, there is an alternate. */
name|sctp_free_remote_addr
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
comment|/* while (tp1) */
if|if
condition|(
name|tot_retrans
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Setup the ecn nonce re-sync point. We do this since once 		 * we go to FR something we introduce a Karn's rule scenario 		 * and won't know the totals for the ECN bits. 		 */
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|sending_seq
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|struct
name|sctp_tmit_chunk
modifier|*
name|sctp_try_advance_peer_ack_point
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|,
modifier|*
name|a_adv
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
operator|&&
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* no chance to advance, out of here */
break|break;
block|}
if|if
condition|(
operator|!
name|PR_SCTP_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* 			 * We can't fwd-tsn past any that are reliable aka 			 * retransmitted until the asoc fails. 			 */
break|break;
block|}
if|if
condition|(
operator|!
name|now_filled
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|now_filled
operator|=
literal|1
expr_stmt|;
block|}
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 		 * now we got a chunk which is marked for another 		 * retransmission to a PR-stream but has run out its chances 		 * already maybe OR has been marked to skip now. Can we skip 		 * it if its a resend? 		 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
operator|&&
operator|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Now is this one marked for resend and its time is 			 * now up? 			 */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * No, we are done when hit one for resend 				 * whos time as not expired. 				 */
break|break;
block|}
block|}
comment|/* 		 * Ok now if this chunk is marked to drop it we can clean up 		 * the chunk, advance our peer ack point and we can check 		 * the next chunk. 		 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_FORWARD_TSN_SKIP
condition|)
block|{
comment|/* advance PeerAckPoint goes forward */
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|a_adv
operator|=
name|tp1
expr_stmt|;
comment|/* 			 * we don't want to de-queue it here. Just wait for 			 * the next peer SACK to come with a new cumTSN and 			 * then the chunk will be droped in the normal 			 * fashion. 			 */
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 				 * Maybe there should be another 				 * notification type 				 */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_DG_FAIL
argument_list|,
name|stcb
argument_list|,
operator|(
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
operator|)
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_sowwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_WAKE_LOGGING
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|1
argument_list|,
name|SCTP_WAKESND_FROM_FWDTSN
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * If it is still in RESEND we can advance no 			 * further 			 */
break|break;
block|}
comment|/* 		 * If we hit here we just dumped tp1, move to next tsn on 		 * sent queue. 		 */
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
return|return
operator|(
name|a_adv
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_HIGH_SPEED
end_ifdef

begin_struct
struct|struct
name|sctp_hs_raise_drop
block|{
name|int32_t
name|cwnd
decl_stmt|;
name|int32_t
name|increase
decl_stmt|;
name|int32_t
name|drop_percent
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SCTP_HS_TABLE_SIZE
value|73
end_define

begin_decl_stmt
name|struct
name|sctp_hs_raise_drop
name|sctp_cwnd_adjust
index|[
name|SCTP_HS_TABLE_SIZE
index|]
init|=
block|{
block|{
literal|38
block|,
literal|1
block|,
literal|50
block|}
block|,
comment|/* 0   */
block|{
literal|118
block|,
literal|2
block|,
literal|44
block|}
block|,
comment|/* 1   */
block|{
literal|221
block|,
literal|3
block|,
literal|41
block|}
block|,
comment|/* 2   */
block|{
literal|347
block|,
literal|4
block|,
literal|38
block|}
block|,
comment|/* 3   */
block|{
literal|495
block|,
literal|5
block|,
literal|37
block|}
block|,
comment|/* 4   */
block|{
literal|663
block|,
literal|6
block|,
literal|35
block|}
block|,
comment|/* 5   */
block|{
literal|851
block|,
literal|7
block|,
literal|34
block|}
block|,
comment|/* 6   */
block|{
literal|1058
block|,
literal|8
block|,
literal|33
block|}
block|,
comment|/* 7   */
block|{
literal|1284
block|,
literal|9
block|,
literal|32
block|}
block|,
comment|/* 8   */
block|{
literal|1529
block|,
literal|10
block|,
literal|31
block|}
block|,
comment|/* 9   */
block|{
literal|1793
block|,
literal|11
block|,
literal|30
block|}
block|,
comment|/* 10  */
block|{
literal|2076
block|,
literal|12
block|,
literal|29
block|}
block|,
comment|/* 11  */
block|{
literal|2378
block|,
literal|13
block|,
literal|28
block|}
block|,
comment|/* 12  */
block|{
literal|2699
block|,
literal|14
block|,
literal|28
block|}
block|,
comment|/* 13  */
block|{
literal|3039
block|,
literal|15
block|,
literal|27
block|}
block|,
comment|/* 14  */
block|{
literal|3399
block|,
literal|16
block|,
literal|27
block|}
block|,
comment|/* 15  */
block|{
literal|3778
block|,
literal|17
block|,
literal|26
block|}
block|,
comment|/* 16  */
block|{
literal|4177
block|,
literal|18
block|,
literal|26
block|}
block|,
comment|/* 17  */
block|{
literal|4596
block|,
literal|19
block|,
literal|25
block|}
block|,
comment|/* 18  */
block|{
literal|5036
block|,
literal|20
block|,
literal|25
block|}
block|,
comment|/* 19  */
block|{
literal|5497
block|,
literal|21
block|,
literal|24
block|}
block|,
comment|/* 20  */
block|{
literal|5979
block|,
literal|22
block|,
literal|24
block|}
block|,
comment|/* 21  */
block|{
literal|6483
block|,
literal|23
block|,
literal|23
block|}
block|,
comment|/* 22  */
block|{
literal|7009
block|,
literal|24
block|,
literal|23
block|}
block|,
comment|/* 23  */
block|{
literal|7558
block|,
literal|25
block|,
literal|22
block|}
block|,
comment|/* 24  */
block|{
literal|8130
block|,
literal|26
block|,
literal|22
block|}
block|,
comment|/* 25  */
block|{
literal|8726
block|,
literal|27
block|,
literal|22
block|}
block|,
comment|/* 26  */
block|{
literal|9346
block|,
literal|28
block|,
literal|21
block|}
block|,
comment|/* 27  */
block|{
literal|9991
block|,
literal|29
block|,
literal|21
block|}
block|,
comment|/* 28  */
block|{
literal|10661
block|,
literal|30
block|,
literal|21
block|}
block|,
comment|/* 29  */
block|{
literal|11358
block|,
literal|31
block|,
literal|20
block|}
block|,
comment|/* 30  */
block|{
literal|12082
block|,
literal|32
block|,
literal|20
block|}
block|,
comment|/* 31  */
block|{
literal|12834
block|,
literal|33
block|,
literal|20
block|}
block|,
comment|/* 32  */
block|{
literal|13614
block|,
literal|34
block|,
literal|19
block|}
block|,
comment|/* 33  */
block|{
literal|14424
block|,
literal|35
block|,
literal|19
block|}
block|,
comment|/* 34  */
block|{
literal|15265
block|,
literal|36
block|,
literal|19
block|}
block|,
comment|/* 35  */
block|{
literal|16137
block|,
literal|37
block|,
literal|19
block|}
block|,
comment|/* 36  */
block|{
literal|17042
block|,
literal|38
block|,
literal|18
block|}
block|,
comment|/* 37  */
block|{
literal|17981
block|,
literal|39
block|,
literal|18
block|}
block|,
comment|/* 38  */
block|{
literal|18955
block|,
literal|40
block|,
literal|18
block|}
block|,
comment|/* 39  */
block|{
literal|19965
block|,
literal|41
block|,
literal|17
block|}
block|,
comment|/* 40  */
block|{
literal|21013
block|,
literal|42
block|,
literal|17
block|}
block|,
comment|/* 41  */
block|{
literal|22101
block|,
literal|43
block|,
literal|17
block|}
block|,
comment|/* 42  */
block|{
literal|23230
block|,
literal|44
block|,
literal|17
block|}
block|,
comment|/* 43  */
block|{
literal|24402
block|,
literal|45
block|,
literal|16
block|}
block|,
comment|/* 44  */
block|{
literal|25618
block|,
literal|46
block|,
literal|16
block|}
block|,
comment|/* 45  */
block|{
literal|26881
block|,
literal|47
block|,
literal|16
block|}
block|,
comment|/* 46  */
block|{
literal|28193
block|,
literal|48
block|,
literal|16
block|}
block|,
comment|/* 47  */
block|{
literal|29557
block|,
literal|49
block|,
literal|15
block|}
block|,
comment|/* 48  */
block|{
literal|30975
block|,
literal|50
block|,
literal|15
block|}
block|,
comment|/* 49  */
block|{
literal|32450
block|,
literal|51
block|,
literal|15
block|}
block|,
comment|/* 50  */
block|{
literal|33986
block|,
literal|52
block|,
literal|15
block|}
block|,
comment|/* 51  */
block|{
literal|35586
block|,
literal|53
block|,
literal|14
block|}
block|,
comment|/* 52  */
block|{
literal|37253
block|,
literal|54
block|,
literal|14
block|}
block|,
comment|/* 53  */
block|{
literal|38992
block|,
literal|55
block|,
literal|14
block|}
block|,
comment|/* 54  */
block|{
literal|40808
block|,
literal|56
block|,
literal|14
block|}
block|,
comment|/* 55  */
block|{
literal|42707
block|,
literal|57
block|,
literal|13
block|}
block|,
comment|/* 56  */
block|{
literal|44694
block|,
literal|58
block|,
literal|13
block|}
block|,
comment|/* 57  */
block|{
literal|46776
block|,
literal|59
block|,
literal|13
block|}
block|,
comment|/* 58  */
block|{
literal|48961
block|,
literal|60
block|,
literal|13
block|}
block|,
comment|/* 59  */
block|{
literal|51258
block|,
literal|61
block|,
literal|13
block|}
block|,
comment|/* 60  */
block|{
literal|53677
block|,
literal|62
block|,
literal|12
block|}
block|,
comment|/* 61  */
block|{
literal|56230
block|,
literal|63
block|,
literal|12
block|}
block|,
comment|/* 62  */
block|{
literal|58932
block|,
literal|64
block|,
literal|12
block|}
block|,
comment|/* 63  */
block|{
literal|61799
block|,
literal|65
block|,
literal|12
block|}
block|,
comment|/* 64  */
block|{
literal|64851
block|,
literal|66
block|,
literal|11
block|}
block|,
comment|/* 65  */
block|{
literal|68113
block|,
literal|67
block|,
literal|11
block|}
block|,
comment|/* 66  */
block|{
literal|71617
block|,
literal|68
block|,
literal|11
block|}
block|,
comment|/* 67  */
block|{
literal|75401
block|,
literal|69
block|,
literal|10
block|}
block|,
comment|/* 68  */
block|{
literal|79517
block|,
literal|70
block|,
literal|10
block|}
block|,
comment|/* 69  */
block|{
literal|84035
block|,
literal|71
block|,
literal|10
block|}
block|,
comment|/* 70  */
block|{
literal|89053
block|,
literal|72
block|,
literal|10
block|}
block|,
comment|/* 71  */
block|{
literal|94717
block|,
literal|73
block|,
literal|9
block|}
comment|/* 72  */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|sctp_hs_cwnd_increase
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|cur_val
decl_stmt|,
name|i
decl_stmt|,
name|indx
decl_stmt|,
name|incr
decl_stmt|;
name|cur_val
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|10
expr_stmt|;
name|indx
operator|=
name|SCTP_HS_TABLE_SIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
literal|0
index|]
operator|.
name|cwnd
condition|)
block|{
comment|/* normal mode */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|mtu
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|net
operator|->
name|last_hs_used
init|;
name|i
operator|<
name|SCTP_HS_TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
name|i
index|]
operator|.
name|cwnd
condition|)
block|{
name|indx
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
name|net
operator|->
name|last_hs_used
operator|=
name|indx
expr_stmt|;
name|incr
operator|=
operator|(
operator|(
name|sctp_cwnd_adjust
index|[
name|indx
index|]
operator|.
name|increase
operator|)
operator|<<
literal|10
operator|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|+=
name|incr
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|incr
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_hs_cwnd_decrease
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|cur_val
decl_stmt|,
name|i
decl_stmt|,
name|indx
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
endif|#
directive|endif
name|cur_val
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|10
expr_stmt|;
name|indx
operator|=
name|net
operator|->
name|last_hs_used
expr_stmt|;
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
literal|0
index|]
operator|.
name|cwnd
condition|)
block|{
comment|/* normal mode */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
block|}
else|else
block|{
comment|/* drop by the proper amount */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
call|(
name|int
call|)
argument_list|(
operator|(
name|net
operator|->
name|cwnd
operator|/
literal|100
operator|)
operator|*
name|sctp_cwnd_adjust
index|[
name|net
operator|->
name|last_hs_used
index|]
operator|.
name|drop_percent
argument_list|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
comment|/* now where are we */
name|indx
operator|=
name|net
operator|->
name|last_hs_used
expr_stmt|;
name|cur_val
operator|=
name|net
operator|->
name|cwnd
operator|>>
literal|10
expr_stmt|;
comment|/* reset where we are in the table */
if|if
condition|(
name|cur_val
operator|<
name|sctp_cwnd_adjust
index|[
literal|0
index|]
operator|.
name|cwnd
condition|)
block|{
comment|/* feel out of hs */
name|net
operator|->
name|last_hs_used
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|indx
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|cur_val
operator|>
name|sctp_cwnd_adjust
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|cwnd
condition|)
block|{
break|break;
block|}
block|}
name|net
operator|->
name|last_hs_used
operator|=
name|indx
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|sctp_early_fr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sctp_L2_abc_variable
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|void
name|sctp_cwnd_update
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|accum_moved
parameter_list|,
name|int
name|reneged_all
parameter_list|,
name|int
name|will_exit
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/******************************/
comment|/* update cwnd and Early FR   */
comment|/******************************/
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
ifdef|#
directive|ifdef
name|JANA_CODE_WHY_THIS
comment|/* 		 * CMT fast recovery code. Need to debug. 		 */
if|if
condition|(
name|net
operator|->
name|fast_retran_loss_recovery
operator|&&
name|net
operator|->
name|new_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
operator|||
name|compare_with_wrap
argument_list|(
name|net
operator|->
name|pseudo_cumack
argument_list|,
name|net
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|net
operator|->
name|pseudo_cumack
operator|==
name|net
operator|->
name|fast_recovery_tsn
operator|)
condition|)
block|{
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
comment|/* 			 * So, first of all do we need to have a Early FR 			 * timer running? 			 */
if|if
condition|(
operator|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|net
operator|->
name|ref_count
operator|>
literal|1
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|<
name|net
operator|->
name|cwnd
operator|)
operator|)
operator|||
operator|(
name|reneged_all
operator|)
condition|)
block|{
comment|/* 				 * yes, so in this case stop it if its 				 * running, and then restart it. Reneging 				 * all is a special case where we want to 				 * run the Early FR timer and then force the 				 * last few unacked to be sent, causing us 				 * to illicit a sack with gaps to force out 				 * the others. 				 */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck2
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_20
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstrid
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No, stop it if its running */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck3
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_21
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* if nothing was acked on this destination skip it */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|net
operator|->
name|net_ack2
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Karn's rule applies to clearing error count, this 			 * is optional. 			 */
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/* addr came good */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RECEIVED_SACK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|)
expr_stmt|;
comment|/* now was it the primary? if so restore */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_WAS_PRIMARY
condition|)
block|{
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|JANA_CODE_WHY_THIS
comment|/* 		 * Cannot skip for CMT. Need to come back and check these 		 * variables for CMT. CMT fast recovery code. Need to debug. 		 */
if|if
condition|(
name|sctp_cmt_on_off
operator|==
literal|1
operator|&&
name|net
operator|->
name|fast_retran_loss_recovery
operator|&&
name|net
operator|->
name|will_exit_fast_recovery
operator|==
literal|0
condition|)
endif|#
directive|endif
if|if
condition|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|will_exit
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If we are in loss recovery we skip any 				 * cwnd update 				 */
goto|goto
name|skip_cwnd_update
goto|;
block|}
comment|/* 		 * CMT: CUC algorithm. Update cwnd if pseudo-cumack has 		 * moved. 		 */
if|if
condition|(
name|accum_moved
operator|||
operator|(
name|sctp_cmt_on_off
operator|&&
name|net
operator|->
name|new_pseudo_cumack
operator|)
condition|)
block|{
comment|/* If the cumulative ack moved we can proceed */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<=
name|net
operator|->
name|ssthresh
condition|)
block|{
comment|/* We are in slow start */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_HIGH_SPEED
name|sctp_hs_cwnd_increase
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
operator|(
name|net
operator|->
name|mtu
operator|*
name|sctp_L2_abc_variable
operator|)
condition|)
block|{
name|net
operator|->
name|cwnd
operator|+=
operator|(
name|net
operator|->
name|mtu
operator|*
name|sctp_L2_abc_variable
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_FROM_SS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_SS
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* We are in congestion avoidance */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* 					 * add to pba only if we had a 					 * cwnd's worth (or so) in flight OR 					 * the burst limit was applied. 					 */
name|net
operator|->
name|partial_bytes_acked
operator|+=
name|net
operator|->
name|net_ack
expr_stmt|;
comment|/* 					 * Do we need to increase (if pba is 					 *> cwnd)? 					 */
if|if
condition|(
name|net
operator|->
name|partial_bytes_acked
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|partial_bytes_acked
condition|)
block|{
name|net
operator|->
name|partial_bytes_acked
operator|-=
name|net
operator|->
name|cwnd
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|+=
name|net
operator|->
name|mtu
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_FROM_CA
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
else|else
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|unsigned
name|int
name|dif
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|net_ack
argument_list|,
name|SCTP_CWND_LOG_NOADV_CA
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dif
operator|=
name|net
operator|->
name|cwnd
operator|-
operator|(
name|net
operator|->
name|flight_size
operator|+
name|net
operator|->
name|net_ack
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|,
name|SCTP_CWND_LOG_NO_CUMACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|skip_cwnd_update
label|:
comment|/* 		 * NOW, according to Karn's rule do we need to restore the 		 * RTO timer back? Check our net_ack2. If not set then we 		 * have a ambiguity.. i.e. all data ack'd was sent to more 		 * than one place. 		 */
if|if
condition|(
name|net
operator|->
name|net_ack2
condition|)
block|{
comment|/* restore any doubled timers */
name|net
operator|->
name|RTO
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_express_handle_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|,
name|int
name|nonce_sum_flag
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|int
name|j
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* First setup for CC stuff */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|cumack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
comment|/* process the new consecutive TSN first */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|cumack
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 				 * ECN Nonce: Add the nonce to the sender's 				 * nonce sum 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
block|}
else|else
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|asoc
operator|->
name|total_flight
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight_count
operator|>
literal|0
condition|)
name|asoc
operator|->
name|total_flight_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
operator|(
name|tp1
operator|->
name|do_rtt
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|rto_pending
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|rto_pending
operator|=
literal|0
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_WAKE_LOGGING
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cumack
argument_list|,
literal|1
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_WAKE_LOGGING
block|}
else|else
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cumack
argument_list|,
literal|1
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|asoc
operator|->
name|last_acked_seq
operator|!=
name|cumack
condition|)
name|sctp_cwnd_update
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Fix up the a-p-a-p for future PR-SCTP sends */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cumack
expr_stmt|;
block|}
comment|/* ECN Nonce updates */
if|if
condition|(
name|asoc
operator|->
name|ecn_nonce_allowed
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_sum_check
condition|)
block|{
if|if
condition|(
name|nonce_sum_flag
operator|!=
operator|(
operator|(
name|asoc
operator|->
name|nonce_sum_expect_base
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_wait_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|nonce_wait_tsn
operator|)
condition|)
block|{
comment|/* 						 * Misbehaving peer. We need 						 * to react to this guy 						 */
name|asoc
operator|->
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* See if Resynchronization Possible */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_resync_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
comment|/* 				 * now we must calculate what the base is. 				 * We do this based on two things, we know 				 * the total's for all the segments 				 * gap-acked in the SACK (none), We also 				 * know the SACK's nonce sum, its in 				 * nonce_sum_flag. So we can build a truth 				 * table to back-calculate the new value of 				 * asoc->nonce_sum_expect_base: 				 *  				 * SACK-flag-Value         Seg-Sums Base 0 0 0 				 * 1                    0 1 0 1 1 1 				 * 1 0 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
operator|(
literal|0
operator|^
name|nonce_sum_flag
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
block|}
block|}
block|}
comment|/* RWND update */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|sctp_peer_chunk_oh
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now assure a timer where data is queued at */
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|int
name|to_ticks
decl_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
name|j
operator|++
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* huh, this should not happen */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Flight size incorrect? fixing??"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Flight size incorrect?  fixing\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|asoc
operator|->
name|total_flight
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* 			 * I may be in a state where we got all across.. but 			 * cannot write more due to a shutdown... we abort 			 * since the user did not indicate EOR in this case. 			 * The sp will be cleaned during free of the asoc. 			 */
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|oper
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
expr_stmt|;
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_SACK_RWND_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sctp_handle_sack
parameter_list|(
name|struct
name|sctp_sack_chunk
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net_from
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_sack
modifier|*
name|sack
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|cum_ack
decl_stmt|,
name|last_tsn
decl_stmt|,
name|biggest_tsn_acked
decl_stmt|,
name|biggest_tsn_newly_acked
decl_stmt|,
name|this_sack_lowest_newack
decl_stmt|;
name|uint16_t
name|num_seg
decl_stmt|,
name|num_dup
decl_stmt|;
name|uint16_t
name|wake_him
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|sack_length
decl_stmt|;
name|uint32_t
name|send_s
decl_stmt|;
name|long
name|j
decl_stmt|;
name|int
name|accum_moved
init|=
literal|0
decl_stmt|;
name|int
name|will_exit_fast_recovery
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|int
name|nonce_sum_flag
decl_stmt|,
name|ecn_seg_sums
init|=
literal|0
decl_stmt|;
name|uint8_t
name|reneged_all
init|=
literal|0
decl_stmt|;
name|uint8_t
name|cmt_dac_flag
decl_stmt|;
comment|/* 	 * we take any chance we can to service our queues since we cannot 	 * get awoken when the socket is read from :< 	 */
comment|/* 	 * Now perform the actual SACK handling: 1) Verify that it is not an 	 * old sack, if so discard. 2) If there is nothing left in the send 	 * queue (cum-ack is equal to last acked) then you have a duplicate 	 * too, update any rwnd change and verify no timers are running. 	 * then return. 3) Process any new consequtive data i.e. cum-ack 	 * moved process these first and note that it moved. 4) Process any 	 * sack blocks. 5) Drop any acked from the queue. 6) Check for any 	 * revoked blocks and mark. 7) Update the cwnd. 8) Nothing left, 	 * sync up flightsizes and things, stop all timers and also check 	 * for shutdown_pending state. If so then go ahead and send off the 	 * shutdown. If in shutdown recv, send off the shutdown-ack and 	 * start that timer, Ret. 9) Strike any non-acked things and do FR 	 * procedure if needed being sure to set the FR flag. 10) Do pr-sctp 	 * procedures. 11) Apply any FR penalties. 12) Assure we will SACK 	 * if in shutdown_recv state. 	 */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sack
operator|=
operator|&
name|ch
operator|->
name|sack
expr_stmt|;
comment|/* CMT DAC algo */
name|this_sack_lowest_newack
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|sack_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sack_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Bad size on sack chunk .. to small\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
comment|/* ECN Nonce */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_slowpath_sack
argument_list|)
expr_stmt|;
name|nonce_sum_flag
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
name|cum_ack
operator|=
name|last_tsn
operator|=
name|ntohl
argument_list|(
name|sack
operator|->
name|cum_tsn_ack
argument_list|)
expr_stmt|;
name|num_seg
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|num_gap_ack_blks
argument_list|)
expr_stmt|;
name|a_rwnd
operator|=
operator|(
name|uint32_t
operator|)
name|ntohl
argument_list|(
name|sack
operator|->
name|a_rwnd
argument_list|)
expr_stmt|;
comment|/* CMT DAC algo */
name|cmt_dac_flag
operator|=
name|ch
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_SACK_CMT_DAC
expr_stmt|;
name|num_dup
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|num_dup_tsns
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
literal|0
argument_list|,
name|num_seg
argument_list|,
name|num_dup
argument_list|,
name|SCTP_LOG_NEW_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SCTP_FR_LOGGING
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_EARLYFR_LOGGING
argument_list|)
if|if
condition|(
name|num_dup
condition|)
block|{
name|int
name|off_to_dup
decl_stmt|,
name|iii
decl_stmt|;
name|uint32_t
modifier|*
name|dupdata
decl_stmt|;
name|off_to_dup
operator|=
operator|(
name|num_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off_to_dup
operator|+
operator|(
name|num_dup
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
operator|<=
name|sack_length
condition|)
block|{
name|dupdata
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|off_to_dup
operator|)
expr_stmt|;
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
name|num_dup
condition|;
name|iii
operator|++
control|)
block|{
name|sctp_log_fr
argument_list|(
operator|*
name|dupdata
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_DUPED
argument_list|)
expr_stmt|;
name|dupdata
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Size invalid offset to dups:%d number dups:%d sack_len:%d num gaps:%d\n"
argument_list|,
name|off_to_dup
argument_list|,
name|num_dup
argument_list|,
name|sack_length
argument_list|,
name|num_seg
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* reality check */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
condition|)
block|{
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
if|if
condition|(
name|sctp_strict_sacks
condition|)
block|{
if|if
condition|(
name|cum_ack
operator|==
name|send_s
operator|||
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
comment|/* 			 * no way, we have not even sent this TSN out yet. 			 * Peer is hopelessly messed up with us. 			 */
name|hopeless_peer
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|,
name|oper
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/**********************/
comment|/* 1) check the range */
comment|/**********************/
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|last_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* acking something behind */
return|return;
block|}
comment|/* update the Rwnd of the peer */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing left on send/sent and strmq */
ifdef|#
directive|ifdef
name|SCTP_LOG_RWND
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* stop any timers */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck1
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * We init netAckSz and netAckSz2 to 0. These are used to track 2 	 * things. The total byte count acked is tracked in netAckSz AND 	 * netAck2 is used to track the total bytes acked that are un- 	 * amibguious and were never retransmitted. We track these on a per 	 * destination address basis. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC algo variable before SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
block|}
comment|/* process the new consecutive TSN first */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|last_tsn
operator|==
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 				 * ECN Nonce: Add the nonce to the sender's 				 * nonce sum 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
expr_stmt|;
name|accum_moved
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* 						 * If there was no retran 						 * and the address is 						 * un-confirmed and we sent 						 * there and are now 						 * sacked.. its confirmed, 						 * mark it so. 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
block|}
else|else
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>=
name|tp1
operator|->
name|book_size
condition|)
block|{
name|asoc
operator|->
name|total_flight
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight_count
operator|>
literal|0
condition|)
name|asoc
operator|->
name|total_flight_count
operator|--
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* CMT SFR and DAC algos */
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|rto_pending
operator|=
literal|0
expr_stmt|;
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB3
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
name|biggest_tsn_newly_acked
operator|=
name|biggest_tsn_acked
operator|=
name|last_tsn
expr_stmt|;
comment|/* always set this up to cum-ack */
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|last_tsn
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|num_seg
operator|*
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|)
operator|>
name|sack_length
condition|)
block|{
comment|/* skip corrupt segments */
goto|goto
name|skip_segments
goto|;
block|}
if|if
condition|(
name|num_seg
operator|>
literal|0
condition|)
block|{
comment|/* 		 * CMT: SFR algo (and HTNA) - this_sack_highest_newack has 		 * to be greater than the cumack. Also reset saw_newack to 0 		 * for all dests. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|saw_newack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|this_sack_highest_newack
operator|=
name|last_tsn
expr_stmt|;
block|}
comment|/* 		 * thisSackHighestGap will increase while handling NEW 		 * segments this_sack_highest_newack will increase while 		 * handling NEWLY ACKED chunks. this_sack_lowest_newack is 		 * used for CMT DAC algo. saw_newack will also change. 		 */
name|sctp_handle_segments
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ch
argument_list|,
name|last_tsn
argument_list|,
operator|&
name|biggest_tsn_acked
argument_list|,
operator|&
name|biggest_tsn_newly_acked
argument_list|,
operator|&
name|this_sack_lowest_newack
argument_list|,
name|num_seg
argument_list|,
operator|&
name|ecn_seg_sums
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_strict_sacks
condition|)
block|{
comment|/* 			 * validate the biggest_tsn_acked in the gap acks if 			 * strict adherence is wanted. 			 */
if|if
condition|(
operator|(
name|biggest_tsn_acked
operator|==
name|send_s
operator|)
operator|||
operator|(
name|compare_with_wrap
argument_list|(
name|biggest_tsn_acked
argument_list|,
name|send_s
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * peer is either confused or we are under 				 * attack. We must abort. 				 */
goto|goto
name|hopeless_peer
goto|;
block|}
block|}
block|}
name|skip_segments
label|:
comment|/*******************************************/
comment|/* cancel ALL T3-send timer if accum moved */
comment|/*******************************************/
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|new_pseudo_cumack
condition|)
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_27
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|accum_moved
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_28
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/********************************************/
comment|/* drop the acked chunks from the sendqueue */
comment|/********************************************/
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cum_ack
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
goto|goto
name|done_with_it
goto|;
do|do
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|cum_ack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* no more sent on list */
break|break;
block|}
name|tp2
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* 		 * Friendlier printf in lieu of panic now that I think its 		 * fixed 		 */
if|if
condition|(
name|tp1
operator|->
name|pr_sctp_on
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|!=
literal|0
condition|)
name|asoc
operator|->
name|pr_sctp_cnt
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"Warning flight size incorrect should be 0 is %d\n"
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_SACK_LOGGING
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|wake_him
operator|++
expr_stmt|;
name|tp1
operator|=
name|tp2
expr_stmt|;
block|}
do|while
condition|(
name|tp1
operator|!=
name|NULL
condition|)
do|;
name|done_with_it
label|:
if|if
condition|(
operator|(
name|wake_him
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_socket
operator|)
condition|)
block|{
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_WAKE_LOGGING
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|wake_him
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_WAKE_LOGGING
block|}
else|else
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|wake_him
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
operator|&&
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|accum_moved
condition|)
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|fast_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|fast_recovery_tsn
condition|)
block|{
comment|/* Setup so we will exit RFC2582 fast recovery */
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for revoked fragments: 	 *  	 * if Previous sack - Had no frags then we can't have any revoked if 	 * Previous sack - Had frag's then - If we now have frags aka 	 * num_seg> 0 call sctp_check_for_revoked() to tell if peer revoked 	 * some of them. else - The peer revoked all ACKED fragments, since 	 * we had some before and now we have NONE. 	 */
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
comment|/* 		 * Don't check for revoked if CMT is ON. CMT causes 		 * reordering of data and acks (received on different 		 * interfaces) can be persistently reordered. Acking 		 * followed by apparent revoking and re-acking causes 		 * unexpected weird behavior. So, at this time, CMT does not 		 * respect renegs. Renegs will have to be recovered through 		 * a timeout. Not a big deal for such a rare event. 		 */
block|}
elseif|else
if|if
condition|(
name|num_seg
condition|)
name|sctp_check_for_revoked
argument_list|(
name|asoc
argument_list|,
name|cum_ack
argument_list|,
name|biggest_tsn_acked
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|asoc
operator|->
name|saw_sack_with_frags
condition|)
block|{
name|int
name|cnt_revoked
init|=
literal|0
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|!=
name|NULL
condition|)
block|{
comment|/* Peer revoked all dg's marked or acked */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_FORWARD_TSN_SKIP
operator|)
condition|)
block|{
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|++
expr_stmt|;
name|asoc
operator|->
name|total_flight
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|cnt_revoked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_revoked
condition|)
block|{
name|reneged_all
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_seg
condition|)
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|1
expr_stmt|;
else|else
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
name|sctp_cwnd_update
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|accum_moved
argument_list|,
name|reneged_all
argument_list|,
name|will_exit_fast_recovery
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* stop all timers */
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpidsck4
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_29
argument_list|)
expr_stmt|;
block|}
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_30
argument_list|)
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
ifdef|#
directive|ifdef
name|SCTP_LOG_RWND
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* 			 * I may be in a state where we got all across.. but 			 * cannot write more due to a shutdown... we abort 			 * since the user did not indicate EOR in this case. 			 */
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|->
name|locked_on_sending
operator|)
operator|->
name|outqueue
operator|)
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|oper
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|oper
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|oper
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
expr_stmt|;
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now here we are going to recycle net_ack for a different use... 	 * HEADS UP. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT DAC algorithm: If SACK DAC flag was 0, then no extra marking 	 * to be done. Setting this_sack_lowest_newack to the cum_ack will 	 * automatically ensure that. 	 */
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_use_dac
operator|&&
operator|(
name|cmt_dac_flag
operator|==
literal|0
operator|)
condition|)
block|{
name|this_sack_lowest_newack
operator|=
name|cum_ack
expr_stmt|;
block|}
if|if
condition|(
name|num_seg
operator|>
literal|0
condition|)
block|{
name|sctp_strike_gap_ack_chunks
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|biggest_tsn_newly_acked
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|accum_moved
argument_list|)
expr_stmt|;
block|}
comment|/*********************************************/
comment|/* Here we perform PR-SCTP procedures        */
comment|/* (section 4.2)                             */
comment|/*********************************************/
comment|/* C1. update advancedPeerAckPoint */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cum_ack
expr_stmt|;
block|}
comment|/* C2. try to further move advancedPeerAckPoint ahead */
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|cum_ack
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing for notes 			 * on issues that will occur when the ECN NONCE 			 * stuff is put into SCTP for cross checking. 			 */
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* 			 * ECN Nonce: Disable Nonce Sum check when FWD TSN 			 * is sent and store resync tsn 			 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * CMT fast recovery code. Need to debug. ((sctp_cmt_on_off == 1)&& 	 * (net->fast_retran_loss_recovery == 0))) 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|==
literal|0
operator|)
operator|||
operator|(
name|sctp_cmt_on_off
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* out of a RFC2582 Fast recovery window? */
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 				 * per section 7.2.3, are there any 				 * destinations that had a fast retransmit 				 * to them. If so what we need to do is 				 * adjust ssthresh and cwnd. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_HIGH_SPEED
name|sctp_hs_cwnd_decrease
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
endif|#
directive|endif
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
literal|2
operator|*
name|net
operator|->
name|mtu
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_FR
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
comment|/* Turn on fast recovery window */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * CMT fast recovery -- per destination 				 * recovery variable. 				 */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
comment|/* Mark end of the window */
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|fast_recovery_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 				 * Disable Nonce Sum Checking and store the 				 * resync tsn 				 */
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nonce_resync_tsn
operator|=
name|asoc
operator|->
name|fast_recovery_tsn
operator|+
literal|1
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_32
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|net_ack
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Mark a peg that we WOULD have done a cwnd 			 * reduction but RFC2582 prevented this action. 			 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_fastretransinrtt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/****************************************************************** 	 *  Here we do the stuff with ECN Nonce checking. 	 *  We basically check to see if the nonce sum flag was incorrect 	 *  or if resynchronization needs to be done. Also if we catch a 	 *  misbehaving receiver we give him the kick. 	 ******************************************************************/
if|if
condition|(
name|asoc
operator|->
name|ecn_nonce_allowed
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_sum_check
condition|)
block|{
if|if
condition|(
name|nonce_sum_flag
operator|!=
operator|(
operator|(
name|asoc
operator|->
name|nonce_sum_expect_base
operator|+
name|ecn_seg_sums
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|nonce_wait_for_ecne
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|lchk
condition|)
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|nonce_wait_tsn
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_wait_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|nonce_wait_tsn
operator|)
condition|)
block|{
comment|/* 						 * Misbehaving peer. We need 						 * to react to this guy 						 */
name|asoc
operator|->
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* See if Resynchronization Possible */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|nonce_resync_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|nonce_sum_check
operator|=
literal|1
expr_stmt|;
comment|/* 				 * now we must calculate what the base is. 				 * We do this based on two things, we know 				 * the total's for all the segments 				 * gap-acked in the SACK, its stored in 				 * ecn_seg_sums. We also know the SACK's 				 * nonce sum, its in nonce_sum_flag. So we 				 * can build a truth table to back-calculate 				 * the new value of 				 * asoc->nonce_sum_expect_base: 				 *  				 * SACK-flag-Value         Seg-Sums Base 0 0 0 				 * 1                    0 1 0 1 1 1 				 * 1 0 				 */
name|asoc
operator|->
name|nonce_sum_expect_base
operator|=
operator|(
name|ecn_seg_sums
operator|^
name|nonce_sum_flag
operator|)
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
block|}
block|}
block|}
comment|/* Now are we exiting loss recovery ? */
if|if
condition|(
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|sat_t3_recovery_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|asoc
operator|->
name|sat_t3_recovery_tsn
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* end satellite t3 loss recovery */
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Adjust and set the new rwnd value */
ifdef|#
directive|ifdef
name|SCTP_LOG_RWND
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|sctp_peer_chunk_oh
operator|)
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|a_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|sent_queue_cnt
operator|*
name|sctp_peer_chunk_oh
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now we must setup so we have a timer up for anyone with 	 * outstanding data. 	 */
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* huh, this should not happen */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Flight size incorrect? fixing??"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Flight size incorrect? fixing??\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|asoc
operator|->
name|total_flight
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
block|}
block|}
endif|#
directive|endif
goto|goto
name|again
goto|;
block|}
ifdef|#
directive|ifdef
name|SCTP_SACK_RWND_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|a_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sctp_update_acked
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_shutdown_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|netp
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* Copy cum-ack */
name|uint32_t
name|cum_ack
decl_stmt|,
name|a_rwnd
decl_stmt|;
name|cum_ack
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|cumulative_tsn_ack
argument_list|)
expr_stmt|;
comment|/* Arrange so a_rwnd does NOT change */
name|a_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
comment|/* Now call the express sack handling */
name|sctp_express_handle_sack
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
literal|0
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_kick_prsctp_reorder_queue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strmin
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|tt
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|tt
operator|=
name|strmin
operator|->
name|last_sequence_delivered
expr_stmt|;
comment|/* 	 * First deliver anything prior to and including the stream no that 	 * came in 	 */
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tt
argument_list|,
name|ctl
operator|->
name|sinfo_ssn
argument_list|,
name|MAX_SEQ
argument_list|)
operator|||
operator|(
name|tt
operator|==
name|ctl
operator|->
name|sinfo_ssn
operator|)
condition|)
block|{
comment|/* this is deliverable now */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* subtract pending on streams */
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|ctl
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
comment|/* deliver it to at least the delivery-q */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ctl
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no more delivery now. */
break|break;
block|}
name|ctl
operator|=
name|nctl
expr_stmt|;
block|}
comment|/* 	 * now we must deliver things in queue the normal way  if any are 	 * now ready. 	 */
name|tt
operator|=
name|strmin
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tt
operator|==
name|ctl
operator|->
name|sinfo_ssn
condition|)
block|{
comment|/* this is deliverable now */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* subtract pending on streams */
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|ctl
operator|->
name|length
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
comment|/* deliver it to at least the delivery-q */
name|strmin
operator|->
name|last_sequence_delivered
operator|=
name|ctl
operator|->
name|sinfo_ssn
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ctl
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|tt
operator|=
name|strmin
operator|->
name|last_sequence_delivered
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
name|ctl
operator|=
name|nctl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_handle_forward_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_forward_tsn_chunk
modifier|*
name|fwd
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* 	 * ISSUES that MUST be fixed for ECN! When we are the sender of the 	 * forward TSN, when the SACK comes back that acknowledges the 	 * FWD-TSN we must reset the NONCE sum to match correctly. This will 	 * get quite tricky since we may have sent more data interveneing 	 * and must carefully account for what the SACK says on the nonce 	 * and any gaps that are reported. This work will NOT be done here, 	 * but I note it here since it is really related to PR-SCTP and 	 * FWD-TSN's 	 */
comment|/* The pr-sctp fwd tsn */
comment|/* 	 * here we will perform all the data receiver side steps for 	 * processing FwdTSN, as required in by pr-sctp draft: 	 *  	 * Assume we get FwdTSN(x): 	 *  	 * 1) update local cumTSN to x 2) try to further advance cumTSN to x + 	 * others we have 3) examine and update re-ordering queue on 	 * pr-in-streams 4) clean up re-assembly queue 5) Send a sack to 	 * report where we are. 	 */
name|struct
name|sctp_strseq
modifier|*
name|stseq
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|new_cum_tsn
decl_stmt|,
name|gap
decl_stmt|,
name|back_out_htsn
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|cnt_gone
decl_stmt|,
name|fwd_sz
decl_stmt|,
name|cumack_set_flag
decl_stmt|,
name|m_size
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|at
decl_stmt|;
name|cumack_set_flag
operator|=
literal|0
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|cnt_gone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|fwd_sz
operator|=
name|ntohs
argument_list|(
name|fwd
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Bad size too small/big fwd-tsn\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
name|m_size
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/*************************************************************/
comment|/* 1. Here we update local cumTSN and shift the bitmap array */
comment|/*************************************************************/
name|new_cum_tsn
operator|=
name|ntohl
argument_list|(
name|fwd
operator|->
name|new_cumulative_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|new_cum_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|new_cum_tsn
condition|)
block|{
comment|/* Already got there ... */
return|return;
block|}
name|back_out_htsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|new_cum_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|new_cum_tsn
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * now we know the new TSN is more advanced, let's find the actual 	 * gap 	 */
if|if
condition|(
operator|(
name|compare_with_wrap
argument_list|(
name|new_cum_tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|new_cum_tsn
operator|==
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
condition|)
block|{
name|gap
operator|=
name|new_cum_tsn
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* try to prevent underflow here */
name|gap
operator|=
name|new_cum_tsn
operator|+
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|gap
operator|>
name|m_size
operator|||
name|gap
operator|<
literal|0
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|back_out_htsn
expr_stmt|;
if|if
condition|(
operator|(
name|long
operator|)
name|gap
operator|>
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
comment|/* 			 * out of range (of single byte chunks in the rwnd I 			 * give out) too questionable. better to drop it 			 * silently 			 */
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|>
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|gap
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
block|}
else|else
block|{
name|gap
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
expr_stmt|;
block|}
name|cumack_set_flag
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|gap
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now after marking all, slide thing forward but no sack please. 	 */
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
return|return;
if|if
condition|(
name|cumack_set_flag
condition|)
block|{
comment|/* 		 * fwd-tsn went outside my gap array - not a common 		 * occurance. Do the same thing we do when a cookie-echo 		 * arrives. 		 */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|new_cum_tsn
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|new_cum_tsn
expr_stmt|;
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|last_echo_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
block|}
comment|/*************************************************************/
comment|/* 2. Clear up re-assembly queue                             */
comment|/*************************************************************/
comment|/* 	 * First service it if pd-api is up, just in case we can progress it 	 * forward 	 */
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
name|sctp_service_reassembly
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
condition|)
block|{
comment|/* For each one on here see if we need to toss it */
comment|/* 		 * For now large messages held on the reasmqueue that are 		 * complete will be tossed too. We could in theory do more 		 * work to spin through and stop after dumping one msg aka 		 * seeing the start of a new msg at the head, and call the 		 * delivery function... to see if it can be delivered... But 		 * for now we just dump everything on the queue. 		 */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|at
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* It needs to be tossed */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|reasmqueue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|tsn_last_delivered
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|str_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|ssn_of_pdapi
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|fragment_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
block|}
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|cnt_gone
operator|++
expr_stmt|;
comment|/* Clear up any stream problem */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|!=
name|SCTP_DATA_UNORDERED
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
argument_list|,
name|MAX_SEQ
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We must dump forward this streams 					 * sequence number if the chunk is 					 * not unordered that is being 					 * skipped. There is a chance that 					 * if the peer does not include the 					 * last fragment in its FWD-TSN we 					 * WILL have a problem here since 					 * you would have a partial chunk in 					 * queue that may not be 					 * deliverable. Also if a Partial 					 * delivery API as started the user 					 * may get a partial chunk. The next 					 * read returning a new chunk... 					 * really ugly but I see no way 					 * around it! Maybe a notify?? 					 */
name|asoc
operator|->
name|strmin
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
index|]
operator|.
name|last_sequence_delivered
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Ok we have gone beyond the end of the 				 * fwd-tsn's mark. Some checks... 				 */
if|if
condition|(
operator|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
condition|)
block|{
comment|/* 					 * Special case PD-API is up and 					 * what we fwd-tsn' over includes 					 * one that had the LAST_FRAG. We no 					 * longer need to do the PD-API. 					 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
argument_list|,
name|stcb
argument_list|,
name|SCTP_PARTIAL_DELIVERY_ABORTED
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|chk
operator|=
name|at
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|fragmented_delivery_inprogress
condition|)
block|{
comment|/* 		 * Ok we removed cnt_gone chunks in the PD-API queue that 		 * were being delivered. So now we must turn off the flag. 		 */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
argument_list|,
name|stcb
argument_list|,
name|SCTP_PARTIAL_DELIVERY_ABORTED
argument_list|,
operator|(
name|void
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
block|}
comment|/*************************************************************/
comment|/* 3. Update the PR-stream re-ordering queues                */
comment|/*************************************************************/
name|stseq
operator|=
operator|(
expr|struct
name|sctp_strseq
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|fwd
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
operator|)
expr_stmt|;
name|fwd_sz
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
expr_stmt|;
block|{
comment|/* New method. */
name|int
name|num_str
decl_stmt|,
name|i
decl_stmt|;
name|num_str
operator|=
name|fwd_sz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_str
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|st
decl_stmt|;
name|unsigned
name|char
modifier|*
name|xx
decl_stmt|;
comment|/* Convert */
name|xx
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|&
name|stseq
index|[
name|i
index|]
expr_stmt|;
name|st
operator|=
name|ntohs
argument_list|(
name|stseq
index|[
name|i
index|]
operator|.
name|stream
argument_list|)
expr_stmt|;
name|stseq
index|[
name|i
index|]
operator|.
name|stream
operator|=
name|st
expr_stmt|;
name|st
operator|=
name|ntohs
argument_list|(
name|stseq
index|[
name|i
index|]
operator|.
name|sequence
argument_list|)
expr_stmt|;
name|stseq
index|[
name|i
index|]
operator|.
name|sequence
operator|=
name|st
expr_stmt|;
comment|/* now process */
if|if
condition|(
name|stseq
index|[
name|i
index|]
operator|.
name|stream
operator|>
name|asoc
operator|->
name|streamincnt
condition|)
block|{
comment|/* 				 * It is arguable if we should continue. 				 * Since the peer sent bogus stream info we 				 * may be in deep trouble.. a return may be 				 * a better choice? 				 */
continue|continue;
block|}
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|stseq
index|[
name|i
index|]
operator|.
name|stream
index|]
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stseq
index|[
name|i
index|]
operator|.
name|sequence
argument_list|,
name|strm
operator|->
name|last_sequence_delivered
argument_list|,
name|MAX_SEQ
argument_list|)
condition|)
block|{
comment|/* Update the sequence number */
name|strm
operator|->
name|last_sequence_delivered
operator|=
name|stseq
index|[
name|i
index|]
operator|.
name|sequence
expr_stmt|;
block|}
comment|/* now kick the stream the new way */
name|sctp_kick_prsctp_reorder_queue
argument_list|(
name|stcb
argument_list|,
name|strm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

