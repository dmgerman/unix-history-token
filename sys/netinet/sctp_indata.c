begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_lock_bsd.h>
end_include

begin_comment
comment|/*  * NOTES: On the outbound side of things I need to check the sack timer to  * see if I should generate a sack into the chunk queue (if I have data to  * send that is and will be sending it .. for bundling.  *  * The callback in sctp_usrreq.c will get called when the socket is read from.  * This will cause sctp_service_queues() to get called on the top entry in  * the list.  */
end_comment

begin_function_decl
specifier|static
name|uint32_t
name|sctp_add_chk_to_control
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strm
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|lock_held
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|sctp_set_rwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|asoc
operator|->
name|my_rwnd
operator|=
name|sctp_calc_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Calculate what the rwnd would be */
end_comment

begin_function
name|uint32_t
name|sctp_calc_rwnd
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|uint32_t
name|calc
init|=
literal|0
decl_stmt|;
comment|/* 	 * This is really set wrong with respect to a 1-2-m socket. Since 	 * the sb_cc is the count that everyone as put up. When we re-write 	 * sctp_soreceive then we will fix this so that ONLY this 	 * associations data is taken into account. 	 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|calc
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sb_cc
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_reasm_queue
operator|==
literal|0
operator|&&
name|asoc
operator|->
name|size_on_all_streams
operator|==
literal|0
condition|)
block|{
comment|/* Full rwnd granted */
name|KASSERT
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|==
literal|0
argument_list|,
operator|(
literal|"cnt_on_reasm_queue is %u"
operator|,
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|==
literal|0
argument_list|,
operator|(
literal|"cnt_on_all_streams is %u"
operator|,
name|asoc
operator|->
name|cnt_on_all_streams
operator|)
argument_list|)
expr_stmt|;
name|calc
operator|=
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
expr_stmt|;
return|return
operator|(
name|calc
operator|)
return|;
block|}
comment|/* get actual space */
name|calc
operator|=
operator|(
name|uint32_t
operator|)
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* 	 * take out what has NOT been put on socket queue and we yet hold 	 * for putting up. 	 */
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|size_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|*
name|MSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|size_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_all_streams
operator|*
name|MSIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc
operator|==
literal|0
condition|)
block|{
comment|/* out of space */
return|return
operator|(
name|calc
operator|)
return|;
block|}
comment|/* what is the overhead of all these rwnd's */
name|calc
operator|=
name|sctp_sbspace_sub
argument_list|(
name|calc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd_control_len
argument_list|)
expr_stmt|;
comment|/* 	 * If the window gets too small due to ctrl-stuff, reduce it to 1, 	 * even it is 0. SWS engaged 	 */
if|if
condition|(
name|calc
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd_control_len
condition|)
block|{
name|calc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|calc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build out our readq entry based on the incoming packet.  */
end_comment

begin_function
name|struct
name|sctp_queued_to_read
modifier|*
name|sctp_build_readq_entry
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|tsn
parameter_list|,
name|uint32_t
name|ppid
parameter_list|,
name|uint32_t
name|context
parameter_list|,
name|uint16_t
name|sid
parameter_list|,
name|uint32_t
name|mid
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|dm
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|read_queue_e
init|=
name|NULL
decl_stmt|;
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|read_queue_e
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_queue_e
operator|==
name|NULL
condition|)
block|{
goto|goto
name|failed_build
goto|;
block|}
name|memset
argument_list|(
name|read_queue_e
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_queued_to_read
argument_list|)
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_stream
operator|=
name|sid
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_flags
operator|=
operator|(
name|flags
operator|<<
literal|8
operator|)
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_ppid
operator|=
name|ppid
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_context
operator|=
name|context
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_tsn
operator|=
name|tsn
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_cumtsn
operator|=
name|tsn
expr_stmt|;
name|read_queue_e
operator|->
name|sinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|mid
operator|=
name|mid
expr_stmt|;
name|read_queue_e
operator|->
name|top_fsn
operator|=
name|read_queue_e
operator|->
name|fsn_included
operator|=
literal|0xffffffff
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|read_queue_e
operator|->
name|reasm
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|whoFrom
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|read_queue_e
operator|->
name|data
operator|=
name|dm
expr_stmt|;
name|read_queue_e
operator|->
name|stcb
operator|=
name|stcb
expr_stmt|;
name|read_queue_e
operator|->
name|port_from
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|failed_build
label|:
return|return
operator|(
name|read_queue_e
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_build_ctl_nchunk
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sinfo
parameter_list|)
block|{
name|struct
name|sctp_extrcvinfo
modifier|*
name|seinfo
decl_stmt|;
name|struct
name|sctp_sndrcvinfo
modifier|*
name|outinfo
decl_stmt|;
name|struct
name|sctp_rcvinfo
modifier|*
name|rcvinfo
decl_stmt|;
name|struct
name|sctp_nxtinfo
modifier|*
name|nxtinfo
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|ret
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|use_extended
decl_stmt|;
name|int
name|provide_nxt
decl_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
operator|&&
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
operator|&&
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
condition|)
block|{
comment|/* user does not want any ancillary data */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
condition|)
block|{
name|len
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_rcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|seinfo
operator|=
operator|(
expr|struct
name|sctp_extrcvinfo
operator|*
operator|)
name|sinfo
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
operator|&&
operator|(
name|seinfo
operator|->
name|serinfo_next_flags
operator|&
name|SCTP_NEXT_MSG_AVAIL
operator|)
condition|)
block|{
name|provide_nxt
operator|=
literal|1
expr_stmt|;
name|len
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nxtinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|provide_nxt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
condition|)
block|{
name|use_extended
operator|=
literal|1
expr_stmt|;
name|len
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|use_extended
operator|=
literal|0
expr_stmt|;
name|len
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|use_extended
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* No space */
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* We need a CMSG header followed by the struct */
name|cmh
operator|=
name|mtod
argument_list|(
name|ret
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that there is no un-initialized padding between the 	 * cmsg header and cmsg data and after the cmsg data. 	 */
name|memset
argument_list|(
name|cmh
argument_list|,
literal|0
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
condition|)
block|{
name|cmh
operator|->
name|cmsg_level
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_rcvinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_RCVINFO
expr_stmt|;
name|rcvinfo
operator|=
operator|(
expr|struct
name|sctp_rcvinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmh
argument_list|)
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_sid
operator|=
name|sinfo
operator|->
name|sinfo_stream
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_ssn
operator|=
name|sinfo
operator|->
name|sinfo_ssn
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_flags
operator|=
name|sinfo
operator|->
name|sinfo_flags
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_ppid
operator|=
name|sinfo
operator|->
name|sinfo_ppid
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_tsn
operator|=
name|sinfo
operator|->
name|sinfo_tsn
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_cumtsn
operator|=
name|sinfo
operator|->
name|sinfo_cumtsn
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_context
operator|=
name|sinfo
operator|->
name|sinfo_context
expr_stmt|;
name|rcvinfo
operator|->
name|rcv_assoc_id
operator|=
name|sinfo
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|cmh
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cmh
operator|+
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_rcvinfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_rcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|provide_nxt
condition|)
block|{
name|cmh
operator|->
name|cmsg_level
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|cmh
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nxtinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_NXTINFO
expr_stmt|;
name|nxtinfo
operator|=
operator|(
expr|struct
name|sctp_nxtinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmh
argument_list|)
expr_stmt|;
name|nxtinfo
operator|->
name|nxt_sid
operator|=
name|seinfo
operator|->
name|serinfo_next_stream
expr_stmt|;
name|nxtinfo
operator|->
name|nxt_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|seinfo
operator|->
name|serinfo_next_flags
operator|&
name|SCTP_NEXT_MSG_IS_UNORDERED
condition|)
block|{
name|nxtinfo
operator|->
name|nxt_flags
operator||=
name|SCTP_UNORDERED
expr_stmt|;
block|}
if|if
condition|(
name|seinfo
operator|->
name|serinfo_next_flags
operator|&
name|SCTP_NEXT_MSG_IS_NOTIFICATION
condition|)
block|{
name|nxtinfo
operator|->
name|nxt_flags
operator||=
name|SCTP_NOTIFICATION
expr_stmt|;
block|}
if|if
condition|(
name|seinfo
operator|->
name|serinfo_next_flags
operator|&
name|SCTP_NEXT_MSG_ISCOMPLETE
condition|)
block|{
name|nxtinfo
operator|->
name|nxt_flags
operator||=
name|SCTP_COMPLETE
expr_stmt|;
block|}
name|nxtinfo
operator|->
name|nxt_ppid
operator|=
name|seinfo
operator|->
name|serinfo_next_ppid
expr_stmt|;
name|nxtinfo
operator|->
name|nxt_length
operator|=
name|seinfo
operator|->
name|serinfo_next_length
expr_stmt|;
name|nxtinfo
operator|->
name|nxt_assoc_id
operator|=
name|seinfo
operator|->
name|serinfo_next_aid
expr_stmt|;
name|cmh
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cmh
operator|+
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nxtinfo
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nxtinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
block|{
name|cmh
operator|->
name|cmsg_level
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|outinfo
operator|=
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmh
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_extended
condition|)
block|{
name|cmh
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_EXTRCV
expr_stmt|;
name|memcpy
argument_list|(
name|outinfo
argument_list|,
name|sinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_extrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmh
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmh
operator|->
name|cmsg_type
operator|=
name|SCTP_SNDRCV
expr_stmt|;
operator|*
name|outinfo
operator|=
operator|*
name|sinfo
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|+=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_mark_non_revokable
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|tsn
parameter_list|)
block|{
name|uint32_t
name|gap
decl_stmt|,
name|i
decl_stmt|,
name|cumackp1
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
name|int
name|in_r
init|=
literal|0
decl_stmt|,
name|in_nr
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_do_drain
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|cumackp1
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|cumackp1
argument_list|,
name|tsn
argument_list|)
condition|)
block|{
comment|/* 		 * this tsn is behind the cum ack and thus we don't need to 		 * worry about it being moved from one to the other. 		 */
return|return;
block|}
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
name|in_r
operator|=
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
name|in_nr
operator|=
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in_r
operator|==
literal|0
operator|)
operator|&&
operator|(
name|in_nr
operator|==
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Things are really messed up now"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"gap:%x tsn:%x\n"
argument_list|,
name|gap
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
name|sctp_print_mapping_array
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|in_nr
operator|==
literal|0
condition|)
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_r
condition|)
name|SCTP_UNSET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|tsn
operator|==
name|asoc
operator|->
name|highest_tsn_inside_map
condition|)
block|{
comment|/* We must back down to see what the new highest is */
for|for
control|(
name|i
operator|=
name|tsn
operator|-
literal|1
init|;
name|SCTP_TSN_GE
argument_list|(
name|i
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
condition|;
name|i
operator|--
control|)
block|{
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|i
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|i
expr_stmt|;
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_place_control_in_stream
parameter_list|(
name|struct
name|sctp_stream_in
modifier|*
name|strm
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|at
decl_stmt|;
name|struct
name|sctp_readhead
modifier|*
name|q
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|,
name|unordered
decl_stmt|;
name|flags
operator|=
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
expr_stmt|;
name|unordered
operator|=
name|flags
operator|&
name|SCTP_DATA_UNORDERED
expr_stmt|;
if|if
condition|(
name|unordered
condition|)
block|{
name|q
operator|=
operator|&
name|strm
operator|->
name|uno_inqueue
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|/* 				 * Only one stream can be here in old style 				 * -- abort 				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|q
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_UNORDERED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|q
operator|=
operator|&
name|strm
operator|->
name|inqueue
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|first_frag_seen
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|last_frag_seen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
name|q
argument_list|)
condition|)
block|{
comment|/* Empty queue */
name|TAILQ_INSERT_HEAD
argument_list|(
name|q
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|unordered
condition|)
block|{
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_UNORDERED
expr_stmt|;
block|}
else|else
block|{
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_ORDERED
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|q
argument_list|,
argument|next_instrm
argument_list|)
block|{
if|if
condition|(
name|SCTP_MID_GT
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|at
operator|->
name|mid
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
comment|/* 				 * one in queue is bigger than the new one, 				 * insert before this one 				 */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|unordered
condition|)
block|{
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_UNORDERED
expr_stmt|;
block|}
else|else
block|{
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_ORDERED
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|at
operator|->
name|mid
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
comment|/* 				 * Gak, He sent me a duplicate msg id 				 * number?? return -1 to abort. 				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|next_instrm
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * We are at the end, insert it 					 * after this one 					 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
name|SCTP_STR_LOG_FROM_INSERT_TL
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
name|q
argument_list|,
name|at
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|unordered
condition|)
block|{
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_UNORDERED
expr_stmt|;
block|}
else|else
block|{
name|control
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_ORDERED
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_abort_in_reasm
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|int
name|opspot
parameter_list|)
block|{
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|idata_supported
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Reass %x,CF:%x,TSN=%8.8x,SID=%4.4x,FSN=%8.8x,MID:%8.8x"
argument_list|,
name|opspot
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Reass %x,CI:%x,TSN=%8.8x,SID=%4.4x,FSN=%4.4x,SSN:%4.4x"
argument_list|,
name|opspot
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
operator|(
name|uint16_t
operator|)
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
argument_list|)
expr_stmt|;
block|}
name|oper
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_1
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|oper
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_clean_up_control
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|)
block|{
comment|/* 	 * The control could not be placed and must be cleaned. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&control->reasm
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Queue the chunk either right into the socket buffer if it is the next one  * to go OR put it in the correct place in the delivery queue.  If we do  * append to the so_buf, keep doing so until we are out of order as  * long as the control's entered are non-fragmented.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_queue_data_to_stream
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|int
modifier|*
name|need_reasm
parameter_list|)
block|{
comment|/* 	 * FIX-ME maybe? What happens when the ssn wraps? If we are getting 	 * all the data in one stream this could happen quite rapidly. One 	 * could use the TSN to keep track of things, but this scheme breaks 	 * down in the other type of stream usage that could occur. Send a 	 * single msg to stream 0, send 4Billion messages to stream 1, now 	 * send a message to stream 0. You have a situation where the TSN 	 * has wrapped but not in the stream. Is this worth worrying about 	 * or should we just change our queue sort at the bottom to be by 	 * TSN. 	 * 	 * Could it also be legal for a peer to send ssn 1 with TSN 2 and 	 * ssn 2 with TSN 1? If the peer is doing some sort of funky TSN/SSN 	 * assignment this could happen... and I don't see how this would be 	 * a violation. So for now I am undecided an will leave the sort by 	 * SSN alone. Maybe a hybred approach is the answer 	 * 	 */
name|struct
name|sctp_queued_to_read
modifier|*
name|at
decl_stmt|;
name|int
name|queue_needed
decl_stmt|;
name|uint32_t
name|nxt_todel
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_INTO_STRD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_MID_GT
argument_list|(
operator|(
name|asoc
operator|->
name|idata_supported
operator|)
argument_list|,
name|strm
operator|->
name|last_mid_delivered
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
comment|/* The incoming sseq is behind where we last delivered? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Duplicate S-SEQ: %u delivered: %u from peer, Abort association\n"
argument_list|,
name|strm
operator|->
name|last_mid_delivered
argument_list|,
name|control
operator|->
name|mid
argument_list|)
expr_stmt|;
comment|/* 		 * throw it in the stream so it gets cleaned up in 		 * association destruction 		 */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|idata_supported
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Delivered MID=%8.8x, got TSN=%8.8x, SID=%4.4x, MID=%8.8x"
argument_list|,
name|strm
operator|->
name|last_mid_delivered
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|control
operator|->
name|sinfo_stream
argument_list|,
name|control
operator|->
name|mid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Delivered SSN=%4.4x, got TSN=%8.8x, SID=%4.4x, SSN=%4.4x"
argument_list|,
operator|(
name|uint16_t
operator|)
name|strm
operator|->
name|last_mid_delivered
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|control
operator|->
name|sinfo_stream
argument_list|,
operator|(
name|uint16_t
operator|)
name|control
operator|->
name|mid
argument_list|)
expr_stmt|;
block|}
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_2
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|queue_needed
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|+=
name|control
operator|->
name|length
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|nxt_todel
operator|=
name|strm
operator|->
name|last_mid_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|nxt_todel
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* can be delivered right away? */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_IMMED_DEL
argument_list|)
expr_stmt|;
block|}
comment|/* EY it wont be queued if it could be delivered directly */
name|queue_needed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_mid_delivered
operator|++
expr_stmt|;
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&strm->inqueue
argument_list|,
argument|next_instrm
argument_list|,
argument|at
argument_list|)
block|{
comment|/* all delivered */
name|nxt_todel
operator|=
name|strm
operator|->
name|last_mid_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|nxt_todel
argument_list|,
name|control
operator|->
name|mid
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
operator|)
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Huh control: %p is on_strm_q: %d"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|last_mid_delivered
operator|++
expr_stmt|;
comment|/* 				 * We ignore the return of deliver_data here 				 * since we always can hold the chunk on the 				 * d-queue. And we have a finite number that 				 * can be delivered from the strq. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del
argument_list|(
name|control
argument_list|,
name|NULL
argument_list|,
name|SCTP_STR_LOG_FROM_IMMED_DEL
argument_list|)
expr_stmt|;
block|}
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|nxt_todel
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
operator|*
name|need_reasm
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|queue_needed
condition|)
block|{
comment|/* 		 * Ok, we did not deliver this guy, find the correct place 		 * to put it on the queue. 		 */
if|if
condition|(
name|sctp_place_control_in_stream
argument_list|(
name|strm
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Queue to str MID: %u duplicate"
argument_list|,
name|control
operator|->
name|mid
argument_list|)
expr_stmt|;
name|sctp_clean_up_control
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_3
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_setup_tail_pointer
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
name|control
operator|->
name|held_length
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip mbufs with NO length */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First one */
name|control
operator|->
name|data
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
continue|continue;
block|}
name|prev
operator|=
name|m
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
condition|)
block|{
comment|/* 			 * On read queue so we must increment the SB stuff, 			 * we assume caller has done any locks of SB. 			 */
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_add_to_tail_pointer
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
modifier|*
name|added
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Control broken"
argument_list|)
expr_stmt|;
else|#
directive|else
return|return;
endif|#
directive|endif
block|}
if|if
condition|(
name|control
operator|->
name|tail_mbuf
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
name|control
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|sctp_setup_tail_pointer
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|tail_mbuf
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Skip mbufs with NO length */
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
comment|/* First one */
name|control
operator|->
name|tail_mbuf
operator|->
name|m_next
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|tail_mbuf
operator|->
name|m_next
expr_stmt|;
block|}
else|else
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
operator|=
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
continue|continue;
block|}
name|prev
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
condition|)
block|{
comment|/* 			 * On read queue so we must increment the SB stuff, 			 * we assume caller has done any locks of SB. 			 */
name|sctp_sballoc
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
operator|*
name|added
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|control
operator|->
name|length
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
block|{
name|control
operator|->
name|tail_mbuf
operator|=
name|prev
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_build_readq_entry_from_ctl
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|nc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|)
block|{
name|memset
argument_list|(
name|nc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_queued_to_read
argument_list|)
argument_list|)
expr_stmt|;
name|nc
operator|->
name|sinfo_stream
operator|=
name|control
operator|->
name|sinfo_stream
expr_stmt|;
name|nc
operator|->
name|mid
operator|=
name|control
operator|->
name|mid
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nc
operator|->
name|reasm
argument_list|)
expr_stmt|;
name|nc
operator|->
name|top_fsn
operator|=
name|control
operator|->
name|top_fsn
expr_stmt|;
name|nc
operator|->
name|mid
operator|=
name|control
operator|->
name|mid
expr_stmt|;
name|nc
operator|->
name|sinfo_flags
operator|=
name|control
operator|->
name|sinfo_flags
expr_stmt|;
name|nc
operator|->
name|sinfo_ppid
operator|=
name|control
operator|->
name|sinfo_ppid
expr_stmt|;
name|nc
operator|->
name|sinfo_context
operator|=
name|control
operator|->
name|sinfo_context
expr_stmt|;
name|nc
operator|->
name|fsn_included
operator|=
literal|0xffffffff
expr_stmt|;
name|nc
operator|->
name|sinfo_tsn
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|nc
operator|->
name|sinfo_cumtsn
operator|=
name|control
operator|->
name|sinfo_cumtsn
expr_stmt|;
name|nc
operator|->
name|sinfo_assoc_id
operator|=
name|control
operator|->
name|sinfo_assoc_id
expr_stmt|;
name|nc
operator|->
name|whoFrom
operator|=
name|control
operator|->
name|whoFrom
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|nc
operator|->
name|whoFrom
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|nc
operator|->
name|stcb
operator|=
name|control
operator|->
name|stcb
expr_stmt|;
name|nc
operator|->
name|port_from
operator|=
name|control
operator|->
name|port_from
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_reset_a_control
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|tsn
parameter_list|)
block|{
name|control
operator|->
name|fsn_included
operator|=
name|tsn
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
condition|)
block|{
comment|/* 		 * We have to purge it from there, hopefully this will work 		 * :-) 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|inp
operator|->
name|read_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_read_q
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_old_unordered_data
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strm
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|uint32_t
name|pd_point
parameter_list|,
name|int
name|inp_read_lock_held
parameter_list|)
block|{
comment|/* 	 * Special handling for the old un-ordered data chunk. All the 	 * chunks/TSN's go to mid 0. So we have to do the old style watching 	 * to see if we have it all. If you return one, no other control 	 * entries on the un-ordered queue will be looked at. In theory 	 * there should be no others entries in reality, unless the guy is 	 * sending both unordered NDATA and unordered DATA... 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|lchk
decl_stmt|,
modifier|*
name|tchk
decl_stmt|;
name|uint32_t
name|fsn
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|nc
decl_stmt|;
name|int
name|cnt_added
decl_stmt|;
if|if
condition|(
name|control
operator|->
name|first_frag_seen
operator|==
literal|0
condition|)
block|{
comment|/* Nothing we can do, we have not seen the first piece yet */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Collapse any we can */
name|cnt_added
operator|=
literal|0
expr_stmt|;
name|restart
label|:
name|fsn
operator|=
name|control
operator|->
name|fsn_included
operator|+
literal|1
expr_stmt|;
comment|/* Now what can we add? */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&control->reasm
argument_list|,
argument|sctp_next
argument_list|,
argument|lchk
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|==
name|fsn
condition|)
block|{
comment|/* Ok lets add it */
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|nc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nc
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|memset
argument_list|(
name|nc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_queued_to_read
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_add_chk_to_control
argument_list|(
name|control
argument_list|,
name|strm
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|)
expr_stmt|;
name|fsn
operator|++
expr_stmt|;
name|cnt_added
operator|++
expr_stmt|;
name|chk
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
comment|/* We are done */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|)
condition|)
block|{
comment|/* 					 * Ok we have to move anything left 					 * on the control queue to a new 					 * control. 					 */
name|sctp_build_readq_entry_from_ctl
argument_list|(
name|nc
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|tchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|)
expr_stmt|;
if|if
condition|(
name|tchk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|tchk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_reasm_queue
operator|>=
name|tchk
operator|->
name|send_size
condition|)
block|{
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|tchk
operator|->
name|send_size
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_reasm_queue = %u smaller than chunk length %u"
argument_list|,
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|,
name|tchk
operator|->
name|send_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|nc
operator|->
name|first_frag_seen
operator|=
literal|1
expr_stmt|;
name|nc
operator|->
name|fsn_included
operator|=
name|tchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|nc
operator|->
name|data
operator|=
name|tchk
operator|->
name|data
expr_stmt|;
name|nc
operator|->
name|sinfo_ppid
operator|=
name|tchk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
name|nc
operator|->
name|sinfo_tsn
operator|=
name|tchk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|tchk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|tchk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tchk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_setup_tail_pointer
argument_list|(
name|nc
argument_list|)
expr_stmt|;
name|tchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|)
expr_stmt|;
block|}
comment|/* Spin the rest onto the queue */
while|while
condition|(
name|tchk
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|tchk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nc
operator|->
name|reasm
argument_list|,
name|tchk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|tchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|)
expr_stmt|;
block|}
comment|/* 					 * Now lets add it to the queue 					 * after removing control 					 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|nc
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|nc
operator|->
name|on_strm_q
operator|=
name|SCTP_ON_UNORDERED
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|control
operator|->
name|pdapi_started
condition|)
block|{
name|strm
operator|->
name|pd_api_started
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|pdapi_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_reasmusrmsgs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|==
literal|0
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|inp_read_lock_held
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|sctp_wakeup_the_read_socket
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nc
operator|->
name|first_frag_seen
operator|)
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|nc
operator|->
name|reasm
argument_list|)
condition|)
block|{
comment|/* 					 * Switch to the new guy and 					 * continue 					 */
name|control
operator|=
name|nc
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
else|else
block|{
if|if
condition|(
name|nc
operator|->
name|on_strm_q
operator|==
literal|0
condition|)
block|{
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|nc
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|nc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Can't add more */
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|>
name|pd_point
operator|)
operator|&&
operator|(
name|strm
operator|->
name|pd_api_started
operator|==
literal|0
operator|)
condition|)
block|{
name|strm
operator|->
name|pd_api_started
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|pdapi_started
operator|=
literal|1
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|inp_read_lock_held
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_wakeup_the_read_socket
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_inject_old_unordered_data
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|;
name|int
name|inserted
decl_stmt|;
comment|/* 	 * Here we need to place the chunk into the control structure sorted 	 * in the correct order. 	 */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* Its the very first one. */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"chunk is a first fsn: %u becomes fsn_included\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|first_frag_seen
condition|)
block|{
comment|/* 			 * In old un-ordered we can reassembly on one 			 * control multiple messages. As long as the next 			 * FIRST is greater then the old first (TSN i.e. FSN 			 * wise) 			 */
name|struct
name|mbuf
modifier|*
name|tdata
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|)
condition|)
block|{
comment|/* 				 * Easy way the start of a new guy beyond 				 * the lowest 				 */
goto|goto
name|place_chunk
goto|;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|==
name|control
operator|->
name|fsn_included
operator|)
operator|||
operator|(
name|control
operator|->
name|pdapi_started
operator|)
condition|)
block|{
comment|/* 				 * Ok this should not happen, if it does we 				 * started the pd-api on the higher TSN 				 * (since the equals part is a TSN failure 				 * it must be that). 				 * 				 * We are completly hosed in that case since 				 * I have no way to recover. This really 				 * will only happen if we can get more TSN's 				 * higher before the pd-api-point. 				 */
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * Ok we have two firsts and the one we just got is 			 * smaller than the one we previously placed.. yuck! 			 * We must swap them out. 			 */
comment|/* swap the mbufs */
name|tdata
operator|=
name|control
operator|->
name|data
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|tdata
expr_stmt|;
comment|/* Save the lengths */
name|chk
operator|->
name|send_size
operator|=
name|control
operator|->
name|length
expr_stmt|;
comment|/* Recompute length of control and tail pointer */
name|sctp_setup_tail_pointer
argument_list|(
name|control
argument_list|)
expr_stmt|;
comment|/* Fix the FSN included */
name|tmp
operator|=
name|control
operator|->
name|fsn_included
expr_stmt|;
name|control
operator|->
name|fsn_included
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|=
name|tmp
expr_stmt|;
comment|/* Fix the TSN included */
name|tmp
operator|=
name|control
operator|->
name|sinfo_tsn
expr_stmt|;
name|control
operator|->
name|sinfo_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|=
name|tmp
expr_stmt|;
comment|/* Fix the PPID included */
name|tmp
operator|=
name|control
operator|->
name|sinfo_ppid
expr_stmt|;
name|control
operator|->
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
operator|=
name|tmp
expr_stmt|;
comment|/* Fix tail pointer */
goto|goto
name|place_chunk
goto|;
block|}
name|control
operator|->
name|first_frag_seen
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|fsn_included
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|control
operator|->
name|top_fsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|control
operator|->
name|sinfo_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|control
operator|->
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_setup_tail_pointer
argument_list|(
name|control
argument_list|)
expr_stmt|;
return|return;
block|}
name|place_chunk
label|:
name|inserted
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&control->reasm
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
condition|)
block|{
comment|/* 			 * This one in queue is bigger than the new one, 			 * insert the new one before at. 			 */
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
condition|)
block|{
comment|/* 			 * They sent a duplicate fsn number. This really 			 * should not happen since the FSN is a TSN and it 			 * should have been dropped earlier. 			 */
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|inserted
operator|==
literal|0
condition|)
block|{
comment|/* Its at the end */
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|control
operator|->
name|top_fsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_deliver_reasm_check
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strm
parameter_list|,
name|int
name|inp_read_lock_held
parameter_list|)
block|{
comment|/* 	 * Given a stream, strm, see if any of the SSN's on it that are 	 * fragmented are ready to deliver. If so go ahead and place them on 	 * the read queue. In so placing if we have hit the end, then we 	 * need to remove them from the stream's queue. 	 */
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|nctl
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|next_to_del
decl_stmt|;
name|uint32_t
name|pd_point
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|pd_point
operator|=
name|min
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
operator|>>
name|SCTP_PARTIAL_DELIVERY_SHIFT
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pd_point
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|partial_delivery_point
expr_stmt|;
block|}
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|control
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Special handling needed for "old" data format */
if|if
condition|(
name|sctp_handle_old_unordered_data
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strm
argument_list|,
name|control
argument_list|,
name|pd_point
argument_list|,
name|inp_read_lock_held
argument_list|)
condition|)
block|{
goto|goto
name|done_un
goto|;
block|}
block|}
if|if
condition|(
name|strm
operator|->
name|pd_api_started
condition|)
block|{
comment|/* Can't add more */
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|control
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Looking at control: %p e(%d) ssn: %u top_fsn: %u inc_fsn: %u -uo\n"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|)
expr_stmt|;
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
comment|/* We just put the last bit on */
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|!=
name|SCTP_ON_UNORDERED
condition|)
block|{
name|panic
argument_list|(
literal|"Huh control: %p on_q: %d -- not unordered?"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_reasmusrmsgs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|==
literal|0
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|inp_read_lock_held
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Can we do a PD-API for this un-ordered guy? */
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|>=
name|pd_point
operator|)
operator|&&
operator|(
name|strm
operator|->
name|pd_api_started
operator|==
literal|0
operator|)
condition|)
block|{
name|strm
operator|->
name|pd_api_started
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|pdapi_started
operator|=
literal|1
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|inp_read_lock_held
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|control
operator|=
name|nctl
expr_stmt|;
block|}
name|done_un
label|:
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|pd_api_started
condition|)
block|{
comment|/* Can't add more */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|strm
operator|->
name|last_mid_delivered
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
comment|/* 		 * Ok the guy at the top was being partially delivered 		 * completed, so we remove it. Note the pd_api flag was 		 * taken off when the chunk was merged on in 		 * sctp_queue_data_for_reasm below. 		 */
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Looking at control: %p e(%d) ssn: %u top_fsn: %u inc_fsn: %u (lastdel: %u)- o\n"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|,
name|strm
operator|->
name|last_mid_delivered
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|!=
name|SCTP_ON_ORDERED
condition|)
block|{
name|panic
argument_list|(
literal|"Huh control: %p on_q: %d -- not ordered?"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_reasmusrmsgs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strm
operator|->
name|pd_api_started
operator|&&
name|control
operator|->
name|pdapi_started
condition|)
block|{
name|control
operator|->
name|pdapi_started
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|pd_api_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|==
literal|0
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|inp_read_lock_held
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|control
operator|=
name|nctl
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strm
operator|->
name|pd_api_started
condition|)
block|{
comment|/* 		 * Can't add more must have gotten an un-ordered above being 		 * partially delivered. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|deliver_more
label|:
name|next_to_del
operator|=
name|strm
operator|->
name|last_mid_delivered
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Looking at control: %p e(%d) ssn: %u top_fsn: %u inc_fsn: %u (nxtdel: %u)- o\n"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|,
name|next_to_del
argument_list|)
expr_stmt|;
name|nctl
operator|=
name|TAILQ_NEXT
argument_list|(
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|next_to_del
argument_list|)
operator|&&
operator|(
name|control
operator|->
name|first_frag_seen
operator|)
condition|)
block|{
name|int
name|done
decl_stmt|;
comment|/* Ok we can deliver it onto the stream. */
if|if
condition|(
name|control
operator|->
name|end_added
condition|)
block|{
comment|/* We are done with it afterwards */
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|!=
name|SCTP_ON_ORDERED
condition|)
block|{
name|panic
argument_list|(
literal|"Huh control: %p on_q: %d -- not ordered?"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_reasmusrmsgs
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
name|ret
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
comment|/* 				 * A singleton now slipping through - mark 				 * it non-revokable too 				 */
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|end_added
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Check if we can defer adding until its 				 * all there 				 */
if|if
condition|(
operator|(
name|control
operator|->
name|length
operator|<
name|pd_point
operator|)
operator|||
operator|(
name|strm
operator|->
name|pd_api_started
operator|)
condition|)
block|{
comment|/* 					 * Don't need it or cannot add more 					 * (one being delivered that way) 					 */
goto|goto
name|out
goto|;
block|}
block|}
name|done
operator|=
operator|(
name|control
operator|->
name|end_added
operator|)
operator|&&
operator|(
name|control
operator|->
name|last_frag_seen
operator|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|==
literal|0
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|inp_read_lock_held
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|strm
operator|->
name|last_mid_delivered
operator|=
name|next_to_del
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|control
operator|=
name|nctl
expr_stmt|;
goto|goto
name|deliver_more
goto|;
block|}
else|else
block|{
comment|/* We are now doing PD API */
name|strm
operator|->
name|pd_api_started
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|pdapi_started
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|sctp_add_chk_to_control
parameter_list|(
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strm
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|hold_rlock
parameter_list|)
block|{
comment|/* 	 * Given a control and a chunk, merge the data from the chk onto the 	 * control and free up the chunk resources. 	 */
name|uint32_t
name|added
init|=
literal|0
decl_stmt|;
name|int
name|i_locked
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|&&
operator|(
name|hold_rlock
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Its being pd-api'd so we must do some locks. 		 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|i_locked
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|control
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|sctp_setup_tail_pointer
argument_list|(
name|control
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_to_tail_pointer
argument_list|(
name|control
argument_list|,
name|chk
operator|->
name|data
argument_list|,
operator|&
name|added
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|fsn_included
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|control
operator|->
name|first_frag_seen
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|sinfo_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|control
operator|->
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* Its complete */
if|if
condition|(
operator|(
name|control
operator|->
name|on_strm_q
operator|)
operator|&&
operator|(
name|control
operator|->
name|on_read_q
operator|)
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|pdapi_started
condition|)
block|{
name|control
operator|->
name|pdapi_started
operator|=
literal|0
expr_stmt|;
name|strm
operator|->
name|pd_api_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_UNORDERED
condition|)
block|{
comment|/* Unordered */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
comment|/* Ordered */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|panic
argument_list|(
literal|"Unknown state on ctrl: %p on_strm_q: %d"
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|last_frag_seen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i_locked
condition|)
block|{
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
name|added
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump onto the re-assembly queue, in its proper place. After dumping on the  * queue, see if anthing can be delivered. If so pull it off (or as much as  * we can. If we run out of space then we must dump what we can and set the  * appropriate flag to say we queued what we could.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_queue_data_for_reasm
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_queued_to_read
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|created_control
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|uint32_t
name|tsn
parameter_list|)
block|{
name|uint32_t
name|next_fsn
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|,
modifier|*
name|nat
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|int
name|do_wakeup
decl_stmt|,
name|unordered
decl_stmt|;
name|uint32_t
name|lenadded
decl_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
expr_stmt|;
comment|/* 	 * For old un-ordered data chunks. 	 */
if|if
condition|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
name|unordered
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|unordered
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Must be added to the stream-in queue */
if|if
condition|(
name|created_control
condition|)
block|{
if|if
condition|(
name|unordered
operator|==
literal|0
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_place_control_in_stream
argument_list|(
name|strm
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|)
condition|)
block|{
comment|/* Duplicate SSN? */
name|sctp_clean_up_control
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|tsn
operator|==
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 			 * Ok we created this control and now lets validate 			 * that its legal i.e. there is a B bit set, if not 			 * and we have up to the cum-ack then its invalid. 			 */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
condition|)
block|{
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|0
operator|)
operator|&&
operator|(
name|unordered
operator|==
literal|1
operator|)
condition|)
block|{
name|sctp_inject_old_unordered_data
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Ok we must queue the chunk into the reasembly portion: o if its 	 * the first it goes to the control mbuf. o if its not first but the 	 * next in sequence it goes to the control, and each succeeding one 	 * in order also goes. o if its not in order we place it on the list 	 * in its place. 	 */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
comment|/* Its the very first one. */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"chunk is a first fsn: %u becomes fsn_included\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|first_frag_seen
condition|)
block|{
comment|/* 			 * Error on senders part, they either sent us two 			 * data chunks with FIRST, or they sent two 			 * un-ordered chunks that were fragmented at the 			 * same time in the same stream. 			 */
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
return|return;
block|}
name|control
operator|->
name|first_frag_seen
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|sinfo_ppid
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
expr_stmt|;
name|control
operator|->
name|sinfo_tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|control
operator|->
name|fsn_included
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_setup_tail_pointer
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|+=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
comment|/* Place the chunk in our list */
name|int
name|inserted
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|control
operator|->
name|last_frag_seen
operator|==
literal|0
condition|)
block|{
comment|/* Still willing to raise highest FSN seen */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"We have a new top_fsn: %u\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|control
operator|->
name|top_fsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"The last fsn is now in place fsn: %u\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|control
operator|->
name|last_frag_seen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|idata_supported
operator|||
name|control
operator|->
name|first_frag_seen
condition|)
block|{
comment|/* 				 * For IDATA we always check since we know 				 * that the first fragment is 0. For old 				 * DATA we have to receive the first before 				 * we know the first FSN (which is the TSN). 				 */
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|control
operator|->
name|fsn_included
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
condition|)
block|{
comment|/* 					 * We have already delivered up to 					 * this so its a dup 					 */
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
condition|)
block|{
comment|/* Second last? huh? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Duplicate last fsn: %u (top: %u) -- abort\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|)
expr_stmt|;
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|idata_supported
operator|||
name|control
operator|->
name|first_frag_seen
condition|)
block|{
comment|/* 				 * For IDATA we always check since we know 				 * that the first fragment is 0. For old 				 * DATA we have to receive the first before 				 * we know the first FSN (which is the TSN). 				 */
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|control
operator|->
name|fsn_included
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
condition|)
block|{
comment|/* 					 * We have already delivered up to 					 * this so its a dup 					 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"New fsn: %u is already seen in included_fsn: %u -- abort\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|)
expr_stmt|;
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_11
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 			 * validate not beyond top FSN if we have seen last 			 * one 			 */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"New fsn: %u is beyond or at top_fsn: %u -- abort\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|)
expr_stmt|;
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_12
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 		 * If we reach here, we need to place the new chunk in the 		 * reassembly for this control. 		 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"chunk is a not first fsn: %u needs to be inserted\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&control->reasm
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
condition|)
block|{
comment|/* 				 * This one in queue is bigger than the new 				 * one, insert the new one before at. 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Insert it before fsn: %u\n"
argument_list|,
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|at
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
condition|)
block|{
comment|/* 				 * Gak, He sent me a duplicate str seq 				 * number 				 */
comment|/* 				 * foo bar, I guess I will just free this 				 * new guy, should we abort too? FIX ME 				 * MAYBE? Or it COULD be that the SSN's have 				 * wrapped. Maybe I should compare to TSN 				 * somehow... sigh for now just blow away 				 * the chunk! 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Duplicate to fsn: %u -- abort\n"
argument_list|,
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|sctp_abort_in_reasm
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|abort_flag
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_13
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|inserted
operator|==
literal|0
condition|)
block|{
comment|/* Goes on the end */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Inserting at tail of list fsn: %u\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_reasm_queue
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Ok lets see if we can suck any up into the control structure that 	 * are in seq if it makes sense. 	 */
name|do_wakeup
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If the first fragment has not been seen there is no sense in 	 * looking. 	 */
if|if
condition|(
name|control
operator|->
name|first_frag_seen
condition|)
block|{
name|next_fsn
operator|=
name|control
operator|->
name|fsn_included
operator|+
literal|1
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|at
argument_list|,
argument|&control->reasm
argument_list|,
argument|sctp_next
argument_list|,
argument|nat
argument_list|)
block|{
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|==
name|next_fsn
condition|)
block|{
comment|/* We can add this one now to the control */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Adding more to control: %p at: %p fsn: %u next_fsn: %u included: %u\n"
argument_list|,
name|control
argument_list|,
name|at
argument_list|,
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
argument_list|,
name|next_fsn
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|at
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|lenadded
operator|=
name|sctp_add_chk_to_control
argument_list|(
name|control
argument_list|,
name|strm
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|at
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|size_on_all_streams
operator|+=
name|lenadded
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
condition|)
block|{
name|do_wakeup
operator|=
literal|1
expr_stmt|;
block|}
name|next_fsn
operator|++
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|end_added
operator|&&
name|control
operator|->
name|pdapi_started
condition|)
block|{
if|if
condition|(
name|strm
operator|->
name|pd_api_started
condition|)
block|{
name|strm
operator|->
name|pd_api_started
operator|=
literal|0
expr_stmt|;
name|control
operator|->
name|pdapi_started
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|==
literal|0
condition|)
block|{
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
name|control
operator|->
name|end_added
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|do_wakeup
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|do_wakeup
condition|)
block|{
comment|/* Need to wakeup the reader */
name|sctp_wakeup_the_read_socket
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_queued_to_read
modifier|*
name|sctp_find_reasm_entry
parameter_list|(
name|struct
name|sctp_stream_in
modifier|*
name|strm
parameter_list|,
name|uint32_t
name|mid
parameter_list|,
name|int
name|ordered
parameter_list|,
name|int
name|idata_supported
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
if|if
condition|(
name|ordered
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|control
argument_list|,
argument|&strm->inqueue
argument_list|,
argument|next_instrm
argument_list|)
block|{
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|idata_supported
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|mid
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|idata_supported
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|control
argument_list|,
argument|&strm->uno_inqueue
argument_list|,
argument|next_instrm
argument_list|)
block|{
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|idata_supported
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|mid
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
name|control
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|control
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_process_a_data_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|chk_length
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
modifier|*
name|high_tsn
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|int
modifier|*
name|break_flag
parameter_list|,
name|int
name|last_chunk
parameter_list|,
name|uint8_t
name|chk_type
parameter_list|)
block|{
comment|/* Process a data chunk */
comment|/* struct sctp_tmit_chunk *chk; */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|,
name|fsn
decl_stmt|,
name|gap
decl_stmt|,
name|mid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|dmbuf
decl_stmt|;
name|int
name|the_len
decl_stmt|;
name|int
name|need_reasm_check
init|=
literal|0
decl_stmt|;
name|uint16_t
name|sid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|ncontrol
decl_stmt|;
name|uint32_t
name|ppid
decl_stmt|;
name|uint8_t
name|chk_flags
decl_stmt|;
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
name|int
name|ordered
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|int
name|created_control
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|chk_type
operator|==
name|SCTP_IDATA
condition|)
block|{
name|struct
name|sctp_idata_chunk
modifier|*
name|chunk
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|sctp_idata_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
operator|*
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
name|chk_flags
operator|=
name|chunk
operator|->
name|ch
operator|.
name|chunk_flags
expr_stmt|;
name|clen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
expr_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|sid
operator|=
name|ntohs
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|sid
argument_list|)
expr_stmt|;
name|mid
operator|=
name|ntohl
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|fsn
operator|=
literal|0
expr_stmt|;
name|ppid
operator|=
name|chunk
operator|->
name|dp
operator|.
name|ppid_fsn
operator|.
name|ppid
expr_stmt|;
block|}
else|else
block|{
name|fsn
operator|=
name|ntohl
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|ppid_fsn
operator|.
name|fsn
argument_list|)
expr_stmt|;
name|ppid
operator|=
literal|0xffffffff
expr_stmt|;
comment|/* Use as an invalid value. */
block|}
block|}
else|else
block|{
name|struct
name|sctp_data_chunk
modifier|*
name|chunk
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|chunk
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
operator|*
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
name|chk_flags
operator|=
name|chunk
operator|->
name|ch
operator|.
name|chunk_flags
expr_stmt|;
name|clen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|tsn
argument_list|)
expr_stmt|;
name|sid
operator|=
name|ntohs
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|sid
argument_list|)
expr_stmt|;
name|mid
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|ntohs
argument_list|(
name|chunk
operator|->
name|dp
operator|.
name|ssn
argument_list|)
argument_list|)
expr_stmt|;
name|fsn
operator|=
name|tsn
expr_stmt|;
name|ppid
operator|=
name|chunk
operator|->
name|dp
operator|.
name|ppid
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|size_t
operator|)
name|chk_length
operator|==
name|clen
condition|)
block|{
comment|/* 		 * Need to send an abort since we had a empty data chunk. 		 */
name|op_err
operator|=
name|sctp_generate_no_user_data_cause
argument_list|(
name|tsn
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_14
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_SACK_IMMEDIATELY
operator|)
operator|==
name|SCTP_DATA_SACK_IMMEDIATELY
condition|)
block|{
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
name|ordered
operator|=
operator|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_TSN_ENTERS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_LTRACE_CHK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk_type
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|tsn
argument_list|)
condition|)
block|{
comment|/* It is a duplicate */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdupdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|numduptsns
operator|<
name|SCTP_MAX_DUP_TSNS
condition|)
block|{
comment|/* Record a dup for the next outbound sack */
name|asoc
operator|->
name|dup_tsns
index|[
name|asoc
operator|->
name|numduptsns
index|]
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|numduptsns
operator|++
expr_stmt|;
block|}
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Calculate the number of TSN's between the base and this TSN */
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|gap
operator|>=
operator|(
name|SCTP_MAPPING_ARRAY
operator|<<
literal|3
operator|)
condition|)
block|{
comment|/* Can't hold the bit in the mapping at max array, toss it */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|gap
operator|>=
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|mapping_array_size
operator|<<
literal|3
argument_list|)
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_expand_mapping_array
argument_list|(
name|asoc
argument_list|,
name|gap
argument_list|)
condition|)
block|{
comment|/* Can't expand, drop it */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
operator|*
name|high_tsn
argument_list|)
condition|)
block|{
operator|*
name|high_tsn
operator|=
name|tsn
expr_stmt|;
block|}
comment|/* See if we have received this one already */
if|if
condition|(
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
operator|||
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdupdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|numduptsns
operator|<
name|SCTP_MAX_DUP_TSNS
condition|)
block|{
comment|/* Record a dup for the next outbound sack */
name|asoc
operator|->
name|dup_tsns
index|[
name|asoc
operator|->
name|numduptsns
index|]
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|numduptsns
operator|++
expr_stmt|;
block|}
name|asoc
operator|->
name|send_sack
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to see about the GONE flag, duplicates would cause a sack 	 * to be sent up above 	 */
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
operator|)
condition|)
block|{
comment|/* 		 * wait a minute, this guy is gone, there is no longer a 		 * receiver. Send peer an ABORT! 		 */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now before going further we see if there is room. If NOT then we 	 * MAY let one through only IF this TSN is the one we are waiting 	 * for on a partial delivery API. 	 */
comment|/* Is the stream valid? */
if|if
condition|(
name|sid
operator|>=
name|asoc
operator|->
name|streamincnt
condition|)
block|{
name|struct
name|sctp_error_invalid_stream
modifier|*
name|cause
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_invalid_stream
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|!=
name|NULL
condition|)
block|{
comment|/* add some space up front so prepend will work well */
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
name|cause
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_error_invalid_stream
operator|*
argument_list|)
expr_stmt|;
comment|/* 			 * Error causes are just param's and this one has 			 * two back to back phdr, one with the error type 			 * and size, the other with the streamid and a rsvd 			 */
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_invalid_stream
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_INVALID_STREAM
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_invalid_stream
argument_list|)
argument_list|)
expr_stmt|;
name|cause
operator|->
name|stream_id
operator|=
name|htons
argument_list|(
name|sid
argument_list|)
expr_stmt|;
name|cause
operator|->
name|reserved
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsid
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|tsn
operator|==
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Update cum-ack */
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|tsn
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If its a fragmented message, lets see if we can find the control 	 * on the reassembly queues. 	 */
if|if
condition|(
operator|(
name|chk_type
operator|==
name|SCTP_IDATA
operator|)
operator|&&
operator|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fsn
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * The first *must* be fsn 0, and other (middle/end) pieces 		 * can *not* be fsn 0. XXX: This can happen in case of a 		 * wrap around. Ignore is for now. 		 */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"FSN zero for MID=%8.8x, but flags=%2.2x"
argument_list|,
name|mid
argument_list|,
name|chk_flags
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
name|control
operator|=
name|sctp_find_reasm_entry
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
argument_list|,
name|mid
argument_list|,
name|ordered
argument_list|,
name|asoc
operator|->
name|idata_supported
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"chunk_flags:0x%x look for control on queues %p\n"
argument_list|,
name|chk_flags
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|!=
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
comment|/* See if we can find the re-assembly entity */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
comment|/* We found something, does it belong? */
if|if
condition|(
name|ordered
operator|&&
operator|(
name|mid
operator|!=
name|control
operator|->
name|mid
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Reassembly problem (MID=%8.8x)"
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|err_out
label|:
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_15
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ordered
operator|&&
operator|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_UNORDERED
operator|)
condition|)
block|{
comment|/* 				 * We can't have a switched order with an 				 * unordered chunk 				 */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"All fragments of a user message must be ordered or unordered (TSN=%8.8x)"
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
if|if
condition|(
operator|!
name|ordered
operator|&&
operator|(
operator|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * We can't have a switched unordered with a 				 * ordered chunk 				 */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"All fragments of a user message must be ordered or unordered (TSN=%8.8x)"
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
block|}
block|}
else|else
block|{
comment|/* 		 * Its a complete segment. Lets validate we don't have a 		 * re-assembly going on with the same Stream/Seq (for 		 * ordered) or in the same Stream for unordered. 		 */
if|if
condition|(
name|control
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ordered
operator|||
name|asoc
operator|->
name|idata_supported
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"chunk_flags: 0x%x dup detected on MID: %u\n"
argument_list|,
name|chk_flags
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Duplicate MID=%8.8x detected."
argument_list|,
name|mid
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tsn
operator|==
name|control
operator|->
name|fsn_included
operator|+
literal|1
operator|)
operator|&&
operator|(
name|control
operator|->
name|end_added
operator|==
literal|0
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Illegal message sequence, missing end for MID: %8.8x"
argument_list|,
name|control
operator|->
name|fsn_included
argument_list|)
expr_stmt|;
goto|goto
name|err_out
goto|;
block|}
else|else
block|{
name|control
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* now do the tests */
if|if
condition|(
operator|(
operator|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_msg_on_sb
operator|)
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|int
operator|)
name|asoc
operator|->
name|my_rwnd
operator|)
operator|<=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * When we have NO room in the rwnd we check to make sure 		 * the reader is doing its job... 		 */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_cc
condition|)
block|{
comment|/* some to read, wake-up */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* now is it in the mapping array of what we have accepted? */
if|if
condition|(
name|chk_type
operator|==
name|SCTP_DATA
condition|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
comment|/* Nope not in the valid range dump it */
name|dump_packet
label|:
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|cnt_on_all_streams
operator|+
name|asoc
operator|->
name|cnt_on_reasm_queue
operator|+
name|asoc
operator|->
name|cnt_msg_on_sb
operator|)
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_datadropchklmt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_datadroprwnd
argument_list|)
expr_stmt|;
block|}
operator|*
name|break_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
goto|goto
name|dump_packet
goto|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|fsn
argument_list|,
name|control
operator|->
name|top_fsn
argument_list|)
condition|)
block|{
goto|goto
name|dump_packet
goto|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|tsn_in_at
operator|>=
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|asoc
operator|->
name|tsn_in_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_in_wrapped
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|strm
operator|=
name|sid
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|seq
operator|=
name|mid
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|sz
operator|=
name|chk_length
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|flgs
operator|=
name|chunk_flags
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|in_pos
operator|=
name|asoc
operator|->
name|tsn_in_at
expr_stmt|;
name|asoc
operator|->
name|in_tsnlog
index|[
name|asoc
operator|->
name|tsn_in_at
index|]
operator|.
name|in_out
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|tsn_in_at
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Before we continue lets validate that we are not being fooled by 	 * an evil attacker. We can only have Nk chunks based on our TSN 	 * spread allowed by the mapping array N * 8 bits, so there is no 	 * way our stream sequence numbers could have wrapped. We of course 	 * only validate the FIRST fragment so the bit must be set. 	 */
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|&&
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
operator|&&
name|SCTP_MID_GE
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|last_mid_delivered
argument_list|,
name|mid
argument_list|)
condition|)
block|{
comment|/* The incoming sseq is behind where we last delivered? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"EVIL/Broken-Dup S-SEQ: %u delivered: %u from peer, Abort!\n"
argument_list|,
name|mid
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|last_mid_delivered
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|idata_supported
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Delivered MID=%8.8x, got TSN=%8.8x, SID=%4.4x, MID=%8.8x"
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|last_mid_delivered
argument_list|,
name|tsn
argument_list|,
name|sid
argument_list|,
name|mid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Delivered SSN=%4.4x, got TSN=%8.8x, SID=%4.4x, SSN=%4.4x"
argument_list|,
operator|(
name|uint16_t
operator|)
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|last_mid_delivered
argument_list|,
name|tsn
argument_list|,
name|sid
argument_list|,
operator|(
name|uint16_t
operator|)
name|mid
argument_list|)
expr_stmt|;
block|}
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_16
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|chk_type
operator|==
name|SCTP_IDATA
condition|)
block|{
name|the_len
operator|=
operator|(
name|chk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|the_len
operator|=
operator|(
name|chk_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|chk_type
operator|==
name|SCTP_IDATA
condition|)
block|{
name|dmbuf
operator|=
name|SCTP_M_COPYM
argument_list|(
operator|*
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
operator|)
argument_list|,
name|the_len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmbuf
operator|=
name|SCTP_M_COPYM
argument_list|(
operator|*
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
argument_list|,
name|the_len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mbc
argument_list|(
name|dmbuf
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* We can steal the last chunk */
name|int
name|l_len
decl_stmt|;
name|dmbuf
operator|=
operator|*
name|m
expr_stmt|;
comment|/* lop off the top part */
if|if
condition|(
name|chk_type
operator|==
name|SCTP_IDATA
condition|)
block|{
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|dmbuf
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|l_len
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * need to count up the size hopefully does not hit 			 * this to often :-0 			 */
name|struct
name|mbuf
modifier|*
name|lat
decl_stmt|;
name|l_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|lat
operator|=
name|dmbuf
init|;
name|lat
condition|;
name|lat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|lat
argument_list|)
control|)
block|{
name|l_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|lat
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|l_len
operator|>
name|the_len
condition|)
block|{
comment|/* Trim the end round bytes off  too */
name|m_adj
argument_list|(
name|dmbuf
argument_list|,
operator|-
operator|(
name|l_len
operator|-
name|the_len
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dmbuf
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Now no matter what, we need a control, get one if we don't have 	 * one (we may have gotten it above when we found the message was 	 * fragmented 	 */
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
name|sctp_alloc_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
name|sctp_build_readq_entry_mac
argument_list|(
name|control
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|context
argument_list|,
name|net
argument_list|,
name|tsn
argument_list|,
name|ppid
argument_list|,
name|sid
argument_list|,
name|chk_flags
argument_list|,
name|NULL
argument_list|,
name|fsn
argument_list|,
name|mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|control
operator|->
name|data
operator|=
name|dmbuf
expr_stmt|;
name|m
operator|=
name|control
operator|->
name|data
expr_stmt|;
for|for
control|(
name|m
operator|=
name|control
operator|->
name|data
init|;
name|m
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
block|{
name|control
operator|->
name|length
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|control
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|last_frag_seen
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|first_frag_seen
operator|=
literal|1
expr_stmt|;
name|control
operator|->
name|fsn_included
operator|=
name|fsn
expr_stmt|;
name|control
operator|->
name|top_fsn
operator|=
name|fsn
expr_stmt|;
block|}
name|created_control
operator|=
literal|1
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"chunk_flags: 0x%x ordered: %d MID: %u control: %p\n"
argument_list|,
name|chk_flags
argument_list|,
name|ordered
argument_list|,
name|mid
argument_list|,
name|control
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|&&
operator|(
operator|(
name|ordered
operator|==
literal|0
operator|)
operator|||
operator|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|last_mid_delivered
operator|+
literal|1
argument_list|,
name|mid
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|inqueue
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Candidate for express delivery */
comment|/* 		 * Its not fragmented, No PD-API is up, Nothing in the 		 * delivery queue, Its un-ordered OR ordered and the next to 		 * deliver AND nothing else is stuck on the stream queue, 		 * And there is room for it in the socket buffer. Lets just 		 * stuff it up the buffer.... 		 */
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Injecting control: %p to be read (MID: %u)\n"
argument_list|,
name|control
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* for ordered, bump what we delivered */
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
operator|.
name|last_mid_delivered
operator|++
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvexpress
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del_alt
argument_list|(
name|stcb
argument_list|,
name|tsn
argument_list|,
name|mid
argument_list|,
name|sid
argument_list|,
name|SCTP_STR_LOG_FROM_EXPRS_DEL
argument_list|)
expr_stmt|;
block|}
name|control
operator|=
name|NULL
expr_stmt|;
goto|goto
name|finish_express_del
goto|;
block|}
comment|/* Now will we need a chunk too? */
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|!=
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the chunk */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_nomem
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_chunk
operator|==
literal|0
condition|)
block|{
comment|/* we copied it, free the copy */
name|sctp_m_freem
argument_list|(
name|dmbuf
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|=
name|tsn
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|fsn
operator|=
name|fsn
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|mid
operator|=
name|mid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
operator|=
name|sid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ppid
operator|=
name|ppid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
name|chk_flags
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|the_len
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Building ck: %p for control: %p to be read (MID: %u)\n"
argument_list|,
name|chk
argument_list|,
name|control
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|dmbuf
expr_stmt|;
block|}
comment|/* Set the appropriate TSN mark */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_do_drain
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|tsn
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|gap
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|tsn
expr_stmt|;
block|}
block|}
comment|/* Now is it complete (i.e. not fragmented)? */
if|if
condition|(
operator|(
name|chk_flags
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
comment|/* 		 * Special check for when streams are resetting. We could be 		 * more smart about this and check the actual stream to see 		 * if it is not being reset.. that way we would not create a 		 * HOLB when amongst streams being reset and those not being 		 * reset. 		 * 		 */
if|if
condition|(
operator|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|)
condition|)
block|{
comment|/* 			 * yep its past where we need to reset... go ahead 			 * and queue it. 			 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|)
condition|)
block|{
comment|/* first one on */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|lcontrol
decl_stmt|,
modifier|*
name|nlcontrol
decl_stmt|;
name|unsigned
name|char
name|inserted
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|lcontrol
argument_list|,
argument|&asoc->pending_reply_queue
argument_list|,
argument|next
argument_list|,
argument|nlcontrol
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|lcontrol
operator|->
name|sinfo_tsn
argument_list|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
comment|/* found it */
name|TAILQ_INSERT_BEFORE
argument_list|(
name|lcontrol
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|inserted
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|inserted
operator|==
literal|0
condition|)
block|{
comment|/* 					 * must be put at end, use prevP 					 * (all setup from loop) to setup 					 * nextP. 					 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|finish_express_del
goto|;
block|}
if|if
condition|(
name|chk_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* queue directly into socket buffer */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Unordered data to be read control: %p MID: %u\n"
argument_list|,
name|control
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Queue control: %p for reordering MID: %u\n"
argument_list|,
name|control
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|abort_flag
argument_list|,
operator|&
name|need_reasm_check
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
if|if
condition|(
name|last_chunk
condition|)
block|{
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
goto|goto
name|finish_express_del
goto|;
block|}
comment|/* If we reach here its a reassembly */
name|need_reasm_check
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_XXX
argument_list|,
literal|"Queue data to stream for reasm control: %p MID: %u\n"
argument_list|,
name|control
argument_list|,
name|mid
argument_list|)
expr_stmt|;
name|sctp_queue_data_for_reasm
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|chk
argument_list|,
name|created_control
argument_list|,
name|abort_flag
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
comment|/* 		 * the assoc is now gone and chk was put onto the reasm 		 * queue, which has all been freed. 		 */
if|if
condition|(
name|last_chunk
condition|)
block|{
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|finish_express_del
label|:
comment|/* Here we tidy up things */
if|if
condition|(
name|tsn
operator|==
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* Update cum-ack */
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|last_chunk
condition|)
block|{
operator|*
name|m
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ordered
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inorderchunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inunorderchunks
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdata
argument_list|)
expr_stmt|;
comment|/* Set it present please */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_STR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_strm_del_alt
argument_list|(
name|stcb
argument_list|,
name|tsn
argument_list|,
name|mid
argument_list|,
name|sid
argument_list|,
name|SCTP_STR_LOG_FROM_MARK_TSN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_reasm_check
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|)
expr_stmt|;
name|need_reasm_check
operator|=
literal|0
expr_stmt|;
block|}
comment|/* check the special flag for stream resets */
if|if
condition|(
operator|(
operator|(
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|)
condition|)
block|{
comment|/* 		 * we have finished working through the backlogged TSN's now 		 * time to reset streams. 1: call reset function. 2: free 		 * pending_reply space 3: distribute any chunks in 		 * pending_reply_queue. 		 */
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
name|liste
operator|->
name|number_entries
argument_list|,
name|liste
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|liste
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|sctp_send_deferred_reset_response
argument_list|(
name|stcb
argument_list|,
name|liste
argument_list|,
name|SCTP_STREAM_RESET_RESULT_PERFORMED
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|liste
argument_list|,
name|SCTP_M_STRESET
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
name|liste
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|)
condition|)
block|{
comment|/* All can be removed */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&asoc->pending_reply_queue
argument_list|,
argument|next
argument_list|,
argument|ncontrol
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|abort_flag
argument_list|,
operator|&
name|need_reasm_check
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|need_reasm_check
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|asoc
operator|->
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|)
expr_stmt|;
name|need_reasm_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&asoc->pending_reply_queue
argument_list|,
argument|next
argument_list|,
argument|ncontrol
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|control
operator|->
name|sinfo_tsn
argument_list|,
name|liste
operator|->
name|tsn
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* 				 * if control->sinfo_tsn is<= liste->tsn we 				 * can process it which is the NOT of 				 * control->sinfo_tsn> liste->tsn 				 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|pending_reply_queue
argument_list|,
name|control
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_queue_data_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|control
argument_list|,
name|abort_flag
argument_list|,
operator|&
name|need_reasm_check
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|need_reasm_check
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|asoc
operator|->
name|strmin
index|[
name|control
operator|->
name|sinfo_stream
index|]
argument_list|,
name|SCTP_READ_LOCK_NOT_HELD
argument_list|)
expr_stmt|;
name|need_reasm_check
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int8_t
name|sctp_map_lookup_tab
index|[
literal|256
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_slide_mapping_arrays
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* 	 * Now we also need to check the mapping array in a couple of ways. 	 * 1) Did we move the cum-ack point? 	 * 	 * When you first glance at this you might think that all entries 	 * that make up the position of the cum-ack would be in the 	 * nr-mapping array only.. i.e. things up to the cum-ack are always 	 * deliverable. Thats true with one exception, when its a fragmented 	 * message we may not deliver the data until some threshold (or all 	 * of it) is in place. So we must OR the nr_mapping_array and 	 * mapping_array to get a true picture of the cum-ack. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|at
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
name|int
name|slide_from
decl_stmt|,
name|slide_end
decl_stmt|,
name|lgap
decl_stmt|,
name|distance
decl_stmt|;
name|uint32_t
name|old_cumack
decl_stmt|,
name|old_base
decl_stmt|,
name|old_highest
decl_stmt|,
name|highest_tsn
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|old_cumack
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|old_base
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
name|old_highest
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
comment|/* 	 * We could probably improve this a small bit by calculating the 	 * offset of the current cum-ack as the starting point. 	 */
name|at
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|slide_from
operator|=
literal|0
init|;
name|slide_from
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
condition|;
name|slide_from
operator|++
control|)
block|{
name|val
operator|=
name|asoc
operator|->
name|nr_mapping_array
index|[
name|slide_from
index|]
operator||
name|asoc
operator|->
name|mapping_array
index|[
name|slide_from
index|]
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|0xff
condition|)
block|{
name|at
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
comment|/* there is a 0 bit */
name|at
operator|+=
name|sctp_map_lookup_tab
index|[
name|val
index|]
expr_stmt|;
break|break;
block|}
block|}
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
operator|(
name|at
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"huh, cumack 0x%x greater than high-tsn 0x%x in map"
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"huh, cumack 0x%x greater than high-tsn 0x%x in map - should panic?\n"
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
expr_stmt|;
name|sctp_print_mapping_array
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|6
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
condition|)
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_nr_map
expr_stmt|;
block|}
else|else
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|cumulative_tsn
operator|==
name|highest_tsn
operator|)
operator|&&
operator|(
name|at
operator|>=
literal|8
operator|)
condition|)
block|{
comment|/* The complete array was completed by a single FR */
comment|/* highest becomes the cum-ack */
name|int
name|clr
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|unsigned
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* clear the array */
name|clr
operator|=
operator|(
operator|(
name|at
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|clr
operator|>
name|asoc
operator|->
name|mapping_array_size
condition|)
block|{
name|clr
operator|=
name|asoc
operator|->
name|mapping_array_size
expr_stmt|;
block|}
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|clr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|clr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|mapping_array_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
operator|)
operator|||
operator|(
name|asoc
operator|->
name|nr_mapping_array
index|[
name|i
index|]
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Error Mapping array's not clean at clear\n"
argument_list|)
expr_stmt|;
name|sctp_print_mapping_array
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|at
operator|>=
literal|8
condition|)
block|{
comment|/* we can slide the mapping array down */
comment|/* slide_from holds where we hit the first NON 0xff byte */
comment|/* 		 * now calculate the ceiling of the move using our highest 		 * TSN value 		 */
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|lgap
argument_list|,
name|highest_tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
name|slide_end
operator|=
operator|(
name|lgap
operator|>>
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|slide_end
operator|<
name|slide_from
condition|)
block|{
name|sctp_print_mapping_array
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"impossible slide"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"impossible slide lgap: %x slide_end: %x slide_from: %x? at: %d\n"
argument_list|,
name|lgap
argument_list|,
name|slide_end
argument_list|,
name|slide_from
argument_list|,
name|at
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
block|}
if|if
condition|(
name|slide_end
operator|>
name|asoc
operator|->
name|mapping_array_size
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"would overrun buffer"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Gak, would have overrun map end: %d slide_end: %d\n"
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|slide_end
argument_list|)
expr_stmt|;
name|slide_end
operator|=
name|asoc
operator|->
name|mapping_array_size
expr_stmt|;
endif|#
directive|endif
block|}
name|distance
operator|=
operator|(
name|slide_end
operator|-
name|slide_from
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|old_base
argument_list|,
name|old_cumack
argument_list|,
name|old_highest
argument_list|,
name|SCTP_MAP_PREPARE_SLIDE
argument_list|)
expr_stmt|;
name|sctp_log_map
argument_list|(
operator|(
name|uint32_t
operator|)
name|slide_from
argument_list|,
operator|(
name|uint32_t
operator|)
name|slide_end
argument_list|,
operator|(
name|uint32_t
operator|)
name|lgap
argument_list|,
name|SCTP_MAP_SLIDE_FROM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|distance
operator|+
name|slide_from
operator|>
name|asoc
operator|->
name|mapping_array_size
operator|||
name|distance
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Here we do NOT slide forward the array so that 			 * hopefully when more data comes in to fill it up 			 * we will be able to slide it forward. Really I 			 * don't think this should happen :-0 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
operator|(
name|uint32_t
operator|)
name|distance
argument_list|,
operator|(
name|uint32_t
operator|)
name|slide_from
argument_list|,
operator|(
name|uint32_t
operator|)
name|asoc
operator|->
name|mapping_array_size
argument_list|,
name|SCTP_MAP_SLIDE_NONE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|int
name|ii
decl_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|distance
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|mapping_array
index|[
name|ii
index|]
operator|=
name|asoc
operator|->
name|mapping_array
index|[
name|slide_from
operator|+
name|ii
index|]
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array
index|[
name|ii
index|]
operator|=
name|asoc
operator|->
name|nr_mapping_array
index|[
name|slide_from
operator|+
name|ii
index|]
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
name|distance
init|;
name|ii
operator|<
name|asoc
operator|->
name|mapping_array_size
condition|;
name|ii
operator|++
control|)
block|{
name|asoc
operator|->
name|mapping_array
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|nr_mapping_array
index|[
name|ii
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
literal|1
operator|==
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+=
operator|(
name|slide_from
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|+
literal|1
operator|==
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|+=
operator|(
name|slide_from
operator|<<
literal|3
operator|)
expr_stmt|;
block|}
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+=
operator|(
name|slide_from
operator|<<
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_sack_check
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|was_a_gap
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|highest_tsn
decl_stmt|;
name|int
name|is_a_gap
decl_stmt|;
name|sctp_slide_mapping_arrays
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
condition|)
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_nr_map
expr_stmt|;
block|}
else|else
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
block|}
comment|/* Is there a gap now? */
name|is_a_gap
operator|=
name|SCTP_TSN_GT
argument_list|(
name|highest_tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|)
expr_stmt|;
comment|/* 	 * Now we need to see if we need to queue a sack or just start the 	 * timer (if allowed). 	 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* 		 * Ok special case, in SHUTDOWN-SENT case. here we maker 		 * sure SACK timer is off and instead send a SHUTDOWN and a 		 * SACK 		 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_17
argument_list|)
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|)
condition|?
name|stcb
operator|->
name|asoc
operator|.
name|alternate
else|:
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_a_gap
condition|)
block|{
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * CMT DAC algorithm: increase number of packets received 		 * since last ack 		 */
name|stcb
operator|->
name|asoc
operator|.
name|cmt_dac_pkts_rcvd
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|==
literal|1
operator|)
operator|||
comment|/* We need to send a 							 * SACK */
operator|(
operator|(
name|was_a_gap
operator|)
operator|&&
operator|(
name|is_a_gap
operator|==
literal|0
operator|)
operator|)
operator|||
comment|/* was a gap, but no 							 * longer is one */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|)
operator|||
comment|/* we have dup's */
operator|(
name|is_a_gap
operator|)
operator|||
comment|/* is still a gap */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|==
literal|0
operator|)
operator|||
comment|/* Delayed sack disabled */
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|data_pkts_seen
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
operator|)
comment|/* hit limit of pkts */
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|numduptsns
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|)
operator|&&
operator|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: With CMT, delay acks 				 * even in the face of 				 * 				 * reordering. Therefore, if acks that do 				 * not have to be sent because of the above 				 * reasons, will be delayed. That is, acks 				 * that would have been sent due to gap 				 * reports will be delayed with DAC. Start 				 * the delayed ack timer. 				 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Ok we must build a SACK since the timer 				 * is pending, we got our first packet OR 				 * there are gaps or duplicates. 				 */
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_process_data
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
modifier|*
name|high_tsn
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|num_chunks
init|=
literal|0
decl_stmt|;
comment|/* number of control chunks processed */
name|int
name|stop_proc
init|=
literal|0
decl_stmt|;
name|int
name|chk_length
decl_stmt|,
name|break_flag
decl_stmt|,
name|last_chunk
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|,
name|was_a_gap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint32_t
name|highest_tsn
decl_stmt|;
comment|/* set the rwnd */
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|m
operator|=
operator|*
name|mm
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
condition|)
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_nr_map
expr_stmt|;
block|}
else|else
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
block|}
name|was_a_gap
operator|=
name|SCTP_TSN_GT
argument_list|(
name|highest_tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|)
expr_stmt|;
comment|/* 	 * setup where we got the last DATA packet from for any SACK that 	 * may need to go out. Don't bump the net. This is done ONLY when a 	 * chunk is assigned. 	 */
name|asoc
operator|->
name|last_data_chunk_from
operator|=
name|net
expr_stmt|;
comment|/*- 	 * Now before we proceed we must figure out if this is a wasted 	 * cluster... i.e. it is a small packet sent in and yet the driver 	 * underneath allocated a full cluster for it. If so we must copy it 	 * to a smaller mbuf and free up the cluster mbuf. This will help 	 * with cluster starvation. Note for __Panda__ we don't do this 	 * since it has clusters all the way down to 64 bytes. 	 */
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|<
operator|(
name|long
operator|)
name|MLEN
operator|&&
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* we only handle mbufs that are singletons.. not chains */
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
comment|/* ok lets see if we can copy the data up */
name|caddr_t
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
comment|/* get the pointers and copy */
name|to
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
operator|*
argument_list|)
expr_stmt|;
name|from
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|,
name|caddr_t
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy the length and free up the old */
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|mm
operator|)
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
operator|*
name|mm
argument_list|)
expr_stmt|;
comment|/* success, back copy */
operator|*
name|mm
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* We are in trouble in the mbuf world .. yikes */
name|m
operator|=
operator|*
name|mm
expr_stmt|;
block|}
block|}
comment|/* get pointer to the first chunk header */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * process all DATA chunks... 	 */
operator|*
name|high_tsn
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|break_flag
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|data_pkts_seen
operator|++
expr_stmt|;
while|while
condition|(
name|stop_proc
operator|==
literal|0
condition|)
block|{
comment|/* validate chunk length */
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|-
operator|*
name|offset
operator|<
name|chk_length
condition|)
block|{
comment|/* all done, mutulated chunk */
name|stop_proc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_DATA
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
literal|"I-DATA chunk received when DATA was negotiated"
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_18
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_IDATA
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"%s"
argument_list|,
literal|"DATA chunk received when I-DATA was negotiated"
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_19
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_DATA
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_IDATA
operator|)
condition|)
block|{
name|int
name|clen
decl_stmt|;
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
name|clen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|clen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_idata_chunk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chk_length
operator|<
name|clen
condition|)
block|{
comment|/* 				 * Need to send an abort since we had a 				 * invalid data chunk. 				 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"DATA chunk of length %d"
argument_list|,
name|chk_length
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_20
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|==
operator|(
name|length
operator|-
operator|*
name|offset
operator|)
condition|)
block|{
name|last_chunk
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|last_chunk
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sctp_process_a_data_chunk
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|mm
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|net
argument_list|,
name|high_tsn
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|&
name|break_flag
argument_list|,
name|last_chunk
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|)
condition|)
block|{
name|num_chunks
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|abort_flag
condition|)
return|return
operator|(
literal|2
operator|)
return|;
if|if
condition|(
name|break_flag
condition|)
block|{
comment|/* 				 * Set because of out of rwnd space and no 				 * drop rep space left. 				 */
name|stop_proc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* not a data chunk in the data region */
switch|switch
condition|(
name|ch
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INITIATION
case|:
case|case
name|SCTP_INITIATION_ACK
case|:
case|case
name|SCTP_SELECTIVE_ACK
case|:
case|case
name|SCTP_NR_SELECTIVE_ACK
case|:
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
case|case
name|SCTP_HEARTBEAT_ACK
case|:
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
case|case
name|SCTP_SHUTDOWN
case|:
case|case
name|SCTP_SHUTDOWN_ACK
case|:
case|case
name|SCTP_OPERATION_ERROR
case|:
case|case
name|SCTP_COOKIE_ECHO
case|:
case|case
name|SCTP_COOKIE_ACK
case|:
case|case
name|SCTP_ECN_ECHO
case|:
case|case
name|SCTP_ECN_CWR
case|:
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
case|case
name|SCTP_AUTHENTICATION
case|:
case|case
name|SCTP_ASCONF_ACK
case|:
case|case
name|SCTP_PACKET_DROPPED
case|:
case|case
name|SCTP_STREAM_RESET
case|:
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
case|case
name|SCTP_ASCONF
case|:
block|{
comment|/* 					 * Now, what do we do with KNOWN 					 * chunks that are NOT in the right 					 * place? 					 * 					 * For now, I do nothing but ignore 					 * them. We may later want to add 					 * sysctl stuff to switch out and do 					 * either an ABORT() or possibly 					 * process them. 					 */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"DATA chunk followed by chunk of type %2.2x"
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|2
operator|)
return|;
block|}
default|default:
comment|/* unknown chunk type, use bit rules */
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|&
literal|0x40
condition|)
block|{
comment|/* Add a error report to the queue */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_gen_error_cause
modifier|*
name|cause
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gen_error_cause
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|!=
name|NULL
condition|)
block|{
name|cause
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_gen_error_cause
operator|*
argument_list|)
expr_stmt|;
name|cause
operator|->
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRECOG_CHUNK
argument_list|)
expr_stmt|;
name|cause
operator|->
name|length
operator|=
name|htons
argument_list|(
call|(
name|uint16_t
call|)
argument_list|(
name|chk_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gen_error_cause
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gen_error_cause
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|op_err
argument_list|)
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|op_err
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* discard the rest of this packet */
name|stop_proc
operator|=
literal|1
expr_stmt|;
block|}
comment|/* else skip this bad chunk and 					 * continue... */
break|break;
block|}
comment|/* switch of chunk type */
block|}
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|offset
operator|>=
name|length
operator|)
operator|||
name|stop_proc
condition|)
block|{
comment|/* no more data left in the mbuf chain */
name|stop_proc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
name|stop_proc
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
block|}
if|if
condition|(
name|break_flag
condition|)
block|{
comment|/* 		 * we need to report rwnd overrun drops. 		 */
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|*
name|mm
argument_list|,
name|length
argument_list|,
name|iphlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_chunks
condition|)
block|{
comment|/* 		 * Did we get data, if so update the time for auto-close and 		 * give peer credit for being alive. 		 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpktwithdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_last_rcvd
argument_list|)
expr_stmt|;
block|}
comment|/* now service all of the reassm queue if needed */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* Assure that we ack right away */
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Start a sack timer or QUEUE a SACK for sending */
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
name|was_a_gap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_process_segment_range
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
modifier|*
name|p_tp1
parameter_list|,
name|uint32_t
name|last_tsn
parameter_list|,
name|uint16_t
name|frag_strt
parameter_list|,
name|uint16_t
name|frag_end
parameter_list|,
name|int
name|nr_sacking
parameter_list|,
name|int
modifier|*
name|num_frs
parameter_list|,
name|uint32_t
modifier|*
name|biggest_newly_acked_tsn
parameter_list|,
name|uint32_t
modifier|*
name|this_sack_lowest_newack
parameter_list|,
name|int
modifier|*
name|rto_ok
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|unsigned
name|int
name|theTSN
decl_stmt|;
name|int
name|j
decl_stmt|,
name|wake_him
init|=
literal|0
decl_stmt|,
name|circled
init|=
literal|0
decl_stmt|;
comment|/* Recover the tp1 we last saw */
name|tp1
operator|=
operator|*
name|p_tp1
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
name|frag_strt
init|;
name|j
operator|<=
name|frag_end
condition|;
name|j
operator|++
control|)
block|{
name|theTSN
operator|=
name|j
operator|+
name|last_tsn
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
condition|)
operator|(
operator|*
name|num_frs
operator|)
operator|+=
literal|1
expr_stmt|;
comment|/*- 			 * CMT: CUCv2 algorithm. For each TSN being 			 * processed from the sent queue, track the 			 * next expected pseudo-cumack, or 			 * rtx_pseudo_cumack, if required. Separate 			 * cumack trackers for first transmissions, 			 * and retransmissions. 			 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|==
literal|1
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|pseudo_cumack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|==
literal|1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|>
literal|1
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rtx_pseudo_cumack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|theTSN
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/*- 					 * must be held until 					 * cum-ack passes 					 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/*- 						 * If it is less than RESEND, it is 						 * now no-longer in flight. 						 * Higher values may already be set 						 * via previous Gap Ack Blocks... 						 * i.e. ACKED or RESEND. 						 */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
operator|*
name|biggest_newly_acked_tsn
argument_list|)
condition|)
block|{
operator|*
name|biggest_newly_acked_tsn
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
comment|/*- 						 * CMT: SFR algo (and HTNA) - set 						 * saw_newack to 1 for dest being 						 * newly acked. update 						 * this_sack_highest_newack if 						 * appropriate. 						 */
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
argument_list|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
comment|/*- 						 * CMT DAC algo: also update 						 * this_sack_lowest_newack 						 */
if|if
condition|(
operator|*
name|this_sack_lowest_newack
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
operator|*
name|this_sack_lowest_newack
argument_list|,
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
operator|*
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
comment|/*- 						 * CMT: CUCv2 algorithm. If (rtx-)pseudo-cumack for corresp 						 * dest is being acked, then we have a new (rtx-)pseudo-cumack. Set 						 * new_(rtx_)pseudo_cumack to TRUE so that the cwnd for this dest can be 						 * updated. Also trigger search for the next expected (rtx-)pseudo-cumack. 						 * Separate pseudo_cumack trackers for first transmissions and 						 * retransmissions. 						 */
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|tp1
operator|->
name|whoTo
operator|->
name|pseudo_cumack
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|tp1
operator|->
name|whoTo
operator|->
name|rtx_pseudo_cumack
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|frag_strt
argument_list|,
name|frag_end
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_GAP
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
call|)
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/*- 							 * True non-retransmited chunk 							 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/*- 							 * update RTO too ? 							 */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
if|if
condition|(
operator|*
name|rto_ok
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|,
name|SCTP_RTT_FROM_DATA
argument_list|)
expr_stmt|;
operator|*
name|rto_ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|this_sack_highest_gap
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|this_sack_highest_gap
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB2
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/*- 					 * All chunks NOT UNSENT fall through here and are marked 					 * (leave PR-SCTP ones that are to skip alone though) 					 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
operator|)
condition|)
block|{
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_MARKED
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
comment|/* NR Sack code here */
if|if
condition|(
name|nr_sacking
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"No chunks on the queues for sid %u."
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|state
operator|==
name|SCTP_STREAM_RESET_PENDING
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|trigger_reset
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_NR_ACKED
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* 							 * sa_ignore 							 * NO_NULL_CHK 							 */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|wake_him
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* if (tp1->tsn == theTSN) */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|theTSN
argument_list|)
condition|)
block|{
break|break;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|circled
operator|==
literal|0
operator|)
condition|)
block|{
name|circled
operator|++
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end while (tp1) */
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|circled
operator|=
literal|0
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
block|}
comment|/* In case the fragments were not in order we must reset */
block|}
comment|/* end for (j = fragStart */
operator|*
name|p_tp1
operator|=
name|tp1
expr_stmt|;
return|return
operator|(
name|wake_him
operator|)
return|;
comment|/* Return value only used for nr-sack */
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_segments
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|last_tsn
parameter_list|,
name|uint32_t
modifier|*
name|biggest_tsn_acked
parameter_list|,
name|uint32_t
modifier|*
name|biggest_newly_acked_tsn
parameter_list|,
name|uint32_t
modifier|*
name|this_sack_lowest_newack
parameter_list|,
name|int
name|num_seg
parameter_list|,
name|int
name|num_nr_seg
parameter_list|,
name|int
modifier|*
name|rto_ok
parameter_list|)
block|{
name|struct
name|sctp_gap_ack_block
modifier|*
name|frag
decl_stmt|,
name|block
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|num_frs
init|=
literal|0
decl_stmt|;
name|int
name|chunk_freed
decl_stmt|;
name|int
name|non_revocable
decl_stmt|;
name|uint16_t
name|frag_strt
decl_stmt|,
name|frag_end
decl_stmt|,
name|prev_frag_end
decl_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
name|prev_frag_end
operator|=
literal|0
expr_stmt|;
name|chunk_freed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|num_seg
operator|+
name|num_nr_seg
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|num_seg
condition|)
block|{
name|prev_frag_end
operator|=
literal|0
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
name|frag
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|block
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|+=
sizeof|sizeof
argument_list|(
name|block
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|chunk_freed
operator|)
return|;
block|}
name|frag_strt
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|start
argument_list|)
expr_stmt|;
name|frag_end
operator|=
name|ntohs
argument_list|(
name|frag
operator|->
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|frag_strt
operator|>
name|frag_end
condition|)
block|{
comment|/* This gap report is malformed, skip it. */
continue|continue;
block|}
if|if
condition|(
name|frag_strt
operator|<=
name|prev_frag_end
condition|)
block|{
comment|/* This gap report is not in order, so restart. */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
operator|(
name|last_tsn
operator|+
name|frag_end
operator|)
argument_list|,
operator|*
name|biggest_tsn_acked
argument_list|)
condition|)
block|{
operator|*
name|biggest_tsn_acked
operator|=
name|last_tsn
operator|+
name|frag_end
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|num_seg
condition|)
block|{
name|non_revocable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|non_revocable
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sctp_process_segment_range
argument_list|(
name|stcb
argument_list|,
operator|&
name|tp1
argument_list|,
name|last_tsn
argument_list|,
name|frag_strt
argument_list|,
name|frag_end
argument_list|,
name|non_revocable
argument_list|,
operator|&
name|num_frs
argument_list|,
name|biggest_newly_acked_tsn
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|rto_ok
argument_list|)
condition|)
block|{
name|chunk_freed
operator|=
literal|1
expr_stmt|;
block|}
name|prev_frag_end
operator|=
name|frag_end
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|num_frs
condition|)
name|sctp_log_fr
argument_list|(
operator|*
name|biggest_tsn_acked
argument_list|,
operator|*
name|biggest_newly_acked_tsn
argument_list|,
name|last_tsn
argument_list|,
name|SCTP_FR_LOG_BIGGEST_TSNS
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|chunk_freed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_check_for_revoked
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|biggest_tsn_acked
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|cumack
argument_list|)
condition|)
block|{
comment|/* 			 * ok this guy is either ACK or MARKED. If it is 			 * ACKED it has been previously acked but not this 			 * time i.e. revoked.  If it is MARKED it was ACK'ed 			 * again. 			 */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|biggest_tsn_acked
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* it has been revoked */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
comment|/* 				 * We must add this stuff back in to assure 				 * timers and such get started. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_REVOKE
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
comment|/* 				 * We inflate the cwnd to compensate for our 				 * artificial inflation of the flight_size. 				 */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_REVOKED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_MARKED
condition|)
block|{
comment|/* it has been re-acked in this SACK */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_strike_gap_ack_chunks
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint32_t
name|biggest_tsn_acked
parameter_list|,
name|uint32_t
name|biggest_tsn_newly_acked
parameter_list|,
name|uint32_t
name|this_sack_lowest_newack
parameter_list|,
name|int
name|accum_moved
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|int
name|strike_flag
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|tot_retrans
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sending_seq
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|num_dests_sacked
init|=
literal|0
decl_stmt|;
comment|/* 	 * select the sending_seq, this is either the next thing ready to be 	 * sent but not transmitted, OR, the next seq we assign. 	 */
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|sending_seq
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|sending_seq
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
comment|/* CMT DAC algo: finding out if SACK is a mixed SACK */
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|saw_newack
condition|)
name|num_dests_sacked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|strike_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|no_fr_allowed
condition|)
block|{
comment|/* this one had a timeout or something */
continue|continue;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_CHECK_STRIKE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|biggest_tsn_acked
argument_list|)
operator|||
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* done */
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
condition|)
block|{
if|if
condition|(
operator|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
operator|&&
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* Is it expired? */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|asoc
operator|->
name|this_sack_highest_gap
argument_list|)
condition|)
block|{
comment|/* we are beyond the tsn in the sack  */
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|>=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* either a RESEND, ACKED, or MARKED */
comment|/* skip */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_FORWARD_TSN_SKIP
condition|)
block|{
comment|/* Continue strikin FWD-TSN chunks */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* 		 * CMT : SFR algo (covers part of DAC and HTNA as well) 		 */
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|&&
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|==
literal|0
condition|)
block|{
comment|/* 			 * No new acks were receieved for data sent to this 			 * dest. Therefore, according to the SFR algo for 			 * CMT, no data sent to this dest can be marked for 			 * FR using this SACK. 			 */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|this_sack_highest_newack
argument_list|)
condition|)
block|{
comment|/* 			 * CMT: New acks were receieved for data sent to 			 * this dest. But no new acks were seen for data 			 * sent after tp1. Therefore, according to the SFR 			 * algo for CMT, tp1 cannot be marked for FR using 			 * this SACK. This step covers part of the DAC algo 			 * and the HTNA algo as well. 			 */
continue|continue;
block|}
comment|/* 		 * Here we check to see if we were have already done a FR 		 * and if so we see if the biggest TSN we saw in the sack is 		 * smaller than the recovery point. If so we don't strike 		 * the tsn... otherwise we CAN strike the TSN. 		 */
comment|/* 		 * @@@ JRI: Check for CMT if (accum_moved&& 		 * asoc->fast_retran_loss_recovery&& (sctp_cmt_on_off == 		 * 0)) { 		 */
if|if
condition|(
name|accum_moved
operator|&&
name|asoc
operator|->
name|fast_retran_loss_recovery
condition|)
block|{
comment|/* 			 * Strike the TSN if in fast-recovery and cum-ack 			 * moved. 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: If SACK flag is set to 				 * 0, then lowest_newack test will not pass 				 * because it would have been set to the 				 * cumack earlier. If not already to be 				 * rtx'd, If not a mixed sack and if tp1 is 				 * not between two sacked TSNs, then mark by 				 * one more. NOTE that we are marking by one 				 * additional time since the SACK DAC flag 				 * indicates that two packets have been 				 * received after this missing TSN. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|16
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * For those that have done a FR we must take 			 * special consideration if we strike. I.e the 			 * biggest_newly_acked must be higher than the 			 * sending_seq at the time we did the FR. 			 */
if|if
condition|(
ifdef|#
directive|ifdef
name|SCTP_FR_TO_ALTERNATE
comment|/* 			 * If FR's go to new networks, then we must only do 			 * this for singly homed asoc's. However if the FR's 			 * go to the same network (Armando's work) then its 			 * ok to FR multiple times. 			 */
operator|(
name|asoc
operator|->
name|numnets
operator|<
literal|2
operator|)
else|#
directive|else
operator|(
literal|1
operator|)
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
argument_list|)
condition|)
block|{
comment|/* 					 * Strike the TSN, since this ack is 					 * beyond where things were when we 					 * did a FR. 					 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
name|strike_flag
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/* 						 * CMT DAC algorithm: If 						 * SACK flag is set to 0, 						 * then lowest_newack test 						 * will not pass because it 						 * would have been set to 						 * the cumack earlier. If 						 * not already to be rtx'd, 						 * If not a mixed sack and 						 * if tp1 is not between two 						 * sacked TSNs, then mark by 						 * one more. NOTE that we 						 * are marking by one 						 * additional time since the 						 * SACK DAC flag indicates 						 * that two packets have 						 * been received after this 						 * missing TSN. 						 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|32
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
comment|/* 			 * JRI: TODO: remove code for HTNA algo. CMT's SFR 			 * algo covers HTNA. 			 */
block|}
elseif|else
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|biggest_tsn_newly_acked
argument_list|)
condition|)
block|{
comment|/* 			 * We don't strike these: This is the  HTNA 			 * algorithm i.e. we don't strike If our TSN is 			 * larger than the Highest TSN Newly Acked. 			 */
empty_stmt|;
block|}
else|else
block|{
comment|/* Strike the TSN */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|biggest_tsn_newly_acked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/* 				 * CMT DAC algorithm: If SACK flag is set to 				 * 0, then lowest_newack test will not pass 				 * because it would have been set to the 				 * cumack earlier. If not already to be 				 * rtx'd, If not a mixed sack and if tp1 is 				 * not between two sacked TSNs, then mark by 				 * one more. NOTE that we are marking by one 				 * additional time since the SACK DAC flag 				 * indicates that two packets have been 				 * received after this missing TSN. 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
operator|)
operator|&&
operator|(
name|num_dests_sacked
operator|==
literal|1
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|this_sack_lowest_newack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
literal|48
operator|+
name|num_dests_sacked
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|sent
argument_list|,
name|SCTP_FR_LOG_STRIKE_CHUNK
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
comment|/* fix counts and things */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_RSND
argument_list|,
operator|(
name|tp1
operator|->
name|whoTo
condition|?
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
operator|)
else|:
literal|0
operator|)
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|whoTo
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|++
expr_stmt|;
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
call|)
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd
argument_list|(
name|SCTP_INCREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|tp1
operator|->
name|send_size
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* add back to the rwnd */
name|asoc
operator|->
name|peers_rwnd
operator|+=
operator|(
name|tp1
operator|->
name|send_size
operator|+
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
expr_stmt|;
comment|/* remove from the total flight */
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|)
operator|&&
operator|(
name|PR_SCTP_RTX_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * Has it been retransmitted tv_sec times? - 				 * we store the retran count there. 				 */
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|>
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
condition|)
block|{
comment|/* Yes, so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure to flag we had a FR */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* 			 * SCTP_PRINTF("OK, we are now ready to FR this 			 * guy\n"); 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_fr
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tp1
operator|->
name|snd_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_MARKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strike_flag
condition|)
block|{
comment|/* This is a subsequent FR */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendmultfastretrans
argument_list|)
expr_stmt|;
block|}
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
condition|)
block|{
comment|/* 				 * CMT: Using RTX_SSTHRESH policy for CMT. 				 * If CMT is being used, then pick dest with 				 * largest ssthresh for any retransmission. 				 */
name|tp1
operator|->
name|no_fr_allowed
operator|=
literal|1
expr_stmt|;
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
name|asoc
operator|->
name|sctp_cmt_pf
operator|>
literal|0
condition|)
block|{
comment|/* 					 * JRS 5/18/07 - If CMT PF is on, 					 * use the PF version of 					 * find_alt_net() 					 */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * JRS 5/18/07 - If only CMT is on, 					 * use the CMT version of 					 * find_alt_net() 					 */
comment|/* sa_ignore NO_NULL_CHK */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|alt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|==
name|NULL
condition|)
block|{
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
block|}
comment|/* 				 * CUCv2: If a different dest is picked for 				 * the retransmission, then new 				 * (rtx-)pseudo_cumack needs to be tracked 				 * for orig dest. Let CUCv2 track new (rtx-) 				 * pseudo-cumack always. 				 */
if|if
condition|(
name|tp1
operator|->
name|whoTo
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* CMT is OFF */
ifdef|#
directive|ifdef
name|SCTP_FR_TO_ALTERNATE
comment|/* Can we find an alternate? */
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 				 * default behavior is to NOT retransmit 				 * FR's to an alternate. Armando Caro's 				 * paper details why. 				 */
name|alt
operator|=
name|tp1
operator|->
name|whoTo
expr_stmt|;
endif|#
directive|endif
block|}
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|1
expr_stmt|;
name|tot_retrans
operator|++
expr_stmt|;
comment|/* mark the sending seq for possible subsequent FR's */
comment|/* 			 * SCTP_PRINTF("Marking TSN for FR new value %x\n", 			 * (uint32_t)tpi->rec.data.tsn); 			 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
condition|)
block|{
comment|/* 				 * If the queue of send is empty then its 				 * the next sequence number that will be 				 * assigned so we subtract one from this to 				 * get the one we last sent. 				 */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * If there are chunks on the send queue 				 * (unsent data that has made it from the 				 * stream queues but not out the door, we 				 * take the first one (which will have the 				 * lowest TSN) and subtract one to get the 				 * one we last sent. 				 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|ttt
decl_stmt|;
name|ttt
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|ttt
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
comment|/* 				 * this guy had a RTO calculation pending on 				 * it, cancel it 				 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|==
literal|0
operator|)
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|alt
operator|!=
name|tp1
operator|->
name|whoTo
condition|)
block|{
comment|/* yes, there is an alternate. */
name|sctp_free_remote_addr
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
name|tp1
operator|->
name|whoTo
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|alt
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|struct
name|sctp_tmit_chunk
modifier|*
name|sctp_try_advance_peer_ack_point
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|,
modifier|*
name|a_adv
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|prsctp_supported
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|tp2
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
operator|&&
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
operator|&&
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
comment|/* no chance to advance, out of here */
break|break;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_FORWARD_TSN_SKIP
operator|)
operator|||
operator|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_NR_ACKED
operator|)
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|PR_SCTP_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* 			 * We can't fwd-tsn past any that are reliable aka 			 * retransmitted until the asoc fails. 			 */
break|break;
block|}
if|if
condition|(
operator|!
name|now_filled
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|now_filled
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * now we got a chunk which is marked for another 		 * retransmission to a PR-stream but has run out its chances 		 * already maybe OR has been marked to skip now. Can we skip 		 * it if its a resend? 		 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
operator|&&
operator|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Now is this one marked for resend and its time is 			 * now up? 			 */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* Yes so drop it */
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * No, we are done when hit one for resend 				 * whos time as not expired. 				 */
break|break;
block|}
block|}
comment|/* 		 * Ok now if this chunk is marked to drop it we can clean up 		 * the chunk, advance our peer ack point and we can check 		 * the next chunk. 		 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_FORWARD_TSN_SKIP
operator|)
operator|||
operator|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_NR_ACKED
operator|)
condition|)
block|{
comment|/* advance PeerAckPoint goes forward */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|a_adv
operator|=
name|tp1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|asoc
operator|->
name|advanced_peer_ack_point
condition|)
block|{
comment|/* No update but we do save the chk */
name|a_adv
operator|=
name|tp1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * If it is still in RESEND we can advance no 			 * further 			 */
break|break;
block|}
block|}
return|return
operator|(
name|a_adv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_fs_audit
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|int
name|inflight
init|=
literal|0
decl_stmt|,
name|resend
init|=
literal|0
decl_stmt|,
name|inbetween
init|=
literal|0
decl_stmt|,
name|acked
init|=
literal|0
decl_stmt|,
name|above
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
ifndef|#
directive|ifndef
name|INVARIANTS
name|int
name|entry_flight
decl_stmt|,
name|entry_cnt
decl_stmt|;
endif|#
directive|endif
name|ret
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|INVARIANTS
name|entry_flight
operator|=
name|asoc
operator|->
name|total_flight
expr_stmt|;
name|entry_cnt
operator|=
name|asoc
operator|->
name|total_flight_count
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>=
name|asoc
operator|->
name|sent_queue_cnt
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Chk TSN: %u size: %d inflight cnt: %d\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|)
expr_stmt|;
name|inflight
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|resend
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
name|inbetween
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
name|above
operator|++
expr_stmt|;
block|}
else|else
block|{
name|acked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|inflight
operator|>
literal|0
operator|)
operator|||
operator|(
name|inbetween
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Flight size-express incorrect? \n"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"asoc->total_flight: %d cnt: %d\n"
argument_list|,
name|entry_flight
argument_list|,
name|entry_cnt
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"Flight size-express incorrect F: %d I: %d R: %d Ab: %d ACK: %d\n"
argument_list|,
name|inflight
argument_list|,
name|inbetween
argument_list|,
name|resend
argument_list|,
name|above
argument_list|,
name|acked
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_window_probe_recovery
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
parameter_list|)
block|{
name|tp1
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|->
name|sent
operator|>=
name|SCTP_DATAGRAM_ACKED
operator|)
operator|||
operator|(
name|tp1
operator|->
name|data
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* TSN's skipped we do NOT move back. */
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DWN_WP_FWD
argument_list|,
name|tp1
operator|->
name|whoTo
condition|?
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
else|:
literal|0
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First setup this by shrinking flight */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
call|)
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
comment|/* Now mark for resend */
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_WP
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_express_handle_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|cumack
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|,
name|int
name|ecne_seen
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|old_rwnd
decl_stmt|;
name|int
name|win_probe_recovery
init|=
literal|0
decl_stmt|;
name|int
name|win_probe_recovered
init|=
literal|0
decl_stmt|;
name|int
name|j
decl_stmt|,
name|done_once
init|=
literal|0
decl_stmt|;
name|int
name|rto_ok
init|=
literal|1
decl_stmt|;
name|uint32_t
name|send_s
decl_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_SACK_ARRIVALS_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_LOG_EXPRESS
argument_list|,
name|cumack
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
index|]
operator|=
name|cumack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|>
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|old_rwnd
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|)
condition|)
block|{
comment|/* old ack */
return|return;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|last_acked_seq
operator|==
name|cumack
condition|)
block|{
comment|/* Window update sack */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|total_flight_count
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
goto|goto
name|again
goto|;
block|}
return|return;
block|}
comment|/* First setup for CC stuff */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|cumack
argument_list|,
name|net
operator|->
name|cwr_window_tsn
argument_list|)
condition|)
block|{
comment|/* Drag along the window_tsn for cwr's */
name|net
operator|->
name|cwr_window_tsn
operator|=
name|cumack
expr_stmt|;
block|}
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC and Fast recovery algo variables before 		 * SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_prepare_net_for_sack
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_prepare_net_for_sack
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|cumack
argument_list|,
name|send_s
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Cum ack %8.8x greater or equal than TSN %8.8x"
argument_list|,
name|cumack
argument_list|,
name|send_s
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_21
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|last_acked_seq
argument_list|)
condition|)
block|{
comment|/* process the new consecutive TSN first */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|tp2
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Warning, an unsent is now acked?\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_CA
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
call|)
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
if|if
condition|(
name|rto_ok
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
comment|/* 								 * sa_ignore 								 * NO_NULL_CHK 								 */
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|,
name|SCTP_RTT_FROM_DATA
argument_list|)
expr_stmt|;
name|rto_ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"No chunks on the queues for sid %u."
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|state
operator|==
name|SCTP_STREAM_RESET_PENDING
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|trigger_reset
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cumack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
block|}
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* JRS - Use the congestion control given in the CC module */
if|if
condition|(
operator|(
name|asoc
operator|->
name|last_acked_seq
operator|!=
name|cumack
operator|)
operator|&&
operator|(
name|ecne_seen
operator|==
literal|0
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|net_ack2
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Karn's rule applies to clearing error 				 * count, this is optional. 				 */
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
comment|/* addr came good */
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
comment|/* 						 * release the alternate, 						 * primary is good 						 */
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_exit_pf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* Done with this net */
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore any doubled timers */
name|net
operator|->
name|RTO
operator|=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
operator|+
name|net
operator|->
name|lastsv
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
block|}
block|}
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_sack
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cumack
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* RWND update */
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|total_flight_count
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
name|win_probe_recovery
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now assure a timer where data is queued at */
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|int
name|to_ticks
decl_stmt|;
if|if
condition|(
name|win_probe_recovery
operator|&&
operator|(
name|net
operator|->
name|window_probe
operator|)
condition|)
block|{
name|win_probe_recovered
operator|=
literal|1
expr_stmt|;
comment|/* 			 * Find first chunk that was used with window probe 			 * and clear the sent 			 */
comment|/* sa_ignore FREED_MEMORY */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|window_probe
condition|)
block|{
comment|/* move back to data send queue */
name|sctp_window_probe_recovery
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|==
literal|0
condition|)
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|to_ticks
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
comment|/* 				 * In window probes we must assure a timer 				 * is still running there 				 */
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_OS_TIMER_START
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|,
name|to_ticks
argument_list|,
name|sctp_timeout_handler
argument_list|,
operator|&
name|net
operator|->
name|rxt_timer
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|win_probe_recovered
operator|==
literal|0
operator|)
operator|&&
operator|(
name|done_once
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * huh, this should not happen unless all packets are 		 * PR-SCTP and marked to skip of course. 		 */
if|if
condition|(
name|sctp_fs_audit
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done_once
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
call|(
modifier|*
name|asoc
operator|->
name|ss_functions
operator|.
name|sctp_ss_is_user_msgs_incomplete
call|)
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_24
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|alternate
condition|)
block|{
name|netp
operator|=
name|asoc
operator|->
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|alternate
condition|)
block|{
name|netp
operator|=
name|asoc
operator|->
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*********************************************/
comment|/* Here we perform PR-SCTP procedures        */
comment|/* (section 4.2)                             */
comment|/*********************************************/
comment|/* C1. update advancedPeerAckPoint */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|cumack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cumack
expr_stmt|;
block|}
comment|/* PR-Sctp issues need to be addressed too */
if|if
condition|(
operator|(
name|asoc
operator|->
name|prsctp_supported
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|uint32_t
name|old_adv_peer_ack_point
decl_stmt|;
name|old_adv_peer_ack_point
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|cumack
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing. 			 */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|)
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* try to FR fwd-tsn's that get lost too */
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|>=
literal|3
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_handle_sack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset_seg
parameter_list|,
name|int
name|offset_dup
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|num_seg
parameter_list|,
name|uint16_t
name|num_nr_seg
parameter_list|,
name|uint16_t
name|num_dup
parameter_list|,
name|int
modifier|*
name|abort_now
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint32_t
name|cum_ack
parameter_list|,
name|uint32_t
name|rwnd
parameter_list|,
name|int
name|ecne_seen
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|tp2
decl_stmt|;
name|uint32_t
name|last_tsn
decl_stmt|,
name|biggest_tsn_acked
decl_stmt|,
name|biggest_tsn_newly_acked
decl_stmt|,
name|this_sack_lowest_newack
decl_stmt|;
name|uint16_t
name|wake_him
init|=
literal|0
decl_stmt|;
name|uint32_t
name|send_s
init|=
literal|0
decl_stmt|;
name|long
name|j
decl_stmt|;
name|int
name|accum_moved
init|=
literal|0
decl_stmt|;
name|int
name|will_exit_fast_recovery
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|,
name|old_rwnd
decl_stmt|;
name|int
name|win_probe_recovery
init|=
literal|0
decl_stmt|;
name|int
name|win_probe_recovered
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|int
name|done_once
decl_stmt|;
name|int
name|rto_ok
init|=
literal|1
decl_stmt|;
name|uint8_t
name|reneged_all
init|=
literal|0
decl_stmt|;
name|uint8_t
name|cmt_dac_flag
decl_stmt|;
comment|/* 	 * we take any chance we can to service our queues since we cannot 	 * get awoken when the socket is read from :< 	 */
comment|/* 	 * Now perform the actual SACK handling: 1) Verify that it is not an 	 * old sack, if so discard. 2) If there is nothing left in the send 	 * queue (cum-ack is equal to last acked) then you have a duplicate 	 * too, update any rwnd change and verify no timers are running. 	 * then return. 3) Process any new consequtive data i.e. cum-ack 	 * moved process these first and note that it moved. 4) Process any 	 * sack blocks. 5) Drop any acked from the queue. 6) Check for any 	 * revoked blocks and mark. 7) Update the cwnd. 8) Nothing left, 	 * sync up flightsizes and things, stop all timers and also check 	 * for shutdown_pending state. If so then go ahead and send off the 	 * shutdown. If in shutdown recv, send off the shutdown-ack and 	 * start that timer, Ret. 9) Strike any non-acked things and do FR 	 * procedure if needed being sure to set the FR flag. 10) Do pr-sctp 	 * procedures. 11) Apply any FR penalties. 12) Assure we will SACK 	 * if in shutdown_recv state. 	 */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* CMT DAC algo */
name|this_sack_lowest_newack
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_slowpath_sack
argument_list|)
expr_stmt|;
name|last_tsn
operator|=
name|cum_ack
expr_stmt|;
name|cmt_dac_flag
operator|=
name|flags
operator|&
name|SCTP_SACK_CMT_DAC
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
index|]
operator|=
name|cum_ack
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|>
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_at
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|a_rwnd
operator|=
name|rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_SACK_ARRIVALS_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_LOG_NORMAL
argument_list|,
name|cum_ack
argument_list|,
name|rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|)
expr_stmt|;
block|}
name|old_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INDATA
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
literal|0
argument_list|,
name|num_seg
argument_list|,
name|num_dup
argument_list|,
name|SCTP_LOG_NEW_SACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num_dup
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FR_LOGGING_ENABLE
operator|)
condition|)
block|{
name|uint16_t
name|i
decl_stmt|;
name|uint32_t
modifier|*
name|dupdata
decl_stmt|,
name|dblock
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_dup
condition|;
name|i
operator|++
control|)
block|{
name|dupdata
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset_dup
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|dblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dupdata
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|sctp_log_fr
argument_list|(
operator|*
name|dupdata
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_FR_DUPED
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reality check */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
name|send_s
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|tp1
operator|=
name|NULL
expr_stmt|;
name|send_s
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|cum_ack
argument_list|,
name|send_s
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
comment|/* 		 * no way, we have not even sent this TSN out yet. Peer is 		 * hopelessly messed up with us. 		 */
name|SCTP_PRINTF
argument_list|(
literal|"NEW cum_ack:%x send_s:%x is smaller or equal\n"
argument_list|,
name|cum_ack
argument_list|,
name|send_s
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Got send_s from tsn:%x + 1 of tp1: %p\n"
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
operator|(
name|void
operator|*
operator|)
name|tp1
argument_list|)
expr_stmt|;
block|}
name|hopeless_peer
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Cum ack %8.8x greater or equal than TSN %8.8x"
argument_list|,
name|cum_ack
argument_list|,
name|send_s
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_25
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/**********************/
comment|/* 1) check the range */
comment|/**********************/
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|last_tsn
argument_list|)
condition|)
block|{
comment|/* acking something behind */
return|return;
block|}
comment|/* update the Rwnd of the peer */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing left on send/sent and strmq */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
condition|)
block|{
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* stop any timers */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* 	 * We init netAckSz and netAckSz2 to 0. These are used to track 2 	 * things. The total byte count acked is tracked in netAckSz AND 	 * netAck2 is used to track the total bytes acked that are un- 	 * amibguious and were never retransmitted. We track these on a per 	 * destination address basis. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|cum_ack
argument_list|,
name|net
operator|->
name|cwr_window_tsn
argument_list|)
condition|)
block|{
comment|/* Drag along the window_tsn for cwr's */
name|net
operator|->
name|cwr_window_tsn
operator|=
name|cum_ack
expr_stmt|;
block|}
name|net
operator|->
name|prev_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|net_ack2
operator|=
literal|0
expr_stmt|;
comment|/* 		 * CMT: Reset CUC and Fast recovery algo variables before 		 * SACK processing 		 */
name|net
operator|->
name|new_pseudo_cumack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|will_exit_fast_recovery
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_prepare_net_for_sack
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_prepare_net_for_sack
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* process the new consecutive TSN first */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|last_tsn
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
name|accum_moved
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
comment|/* 					 * If it is less than ACKED, it is 					 * now no-longer in flight. Higher 					 * values may occur during marking 					 */
if|if
condition|(
operator|(
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* 						 * If there was no retran 						 * and the address is 						 * un-confirmed and we sent 						 * there and are now 						 * sacked.. its confirmed, 						 * mark it so. 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_CA
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_tsn_acknowledged
call|)
argument_list|(
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
block|}
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* CMT SFR and DAC algos */
name|this_sack_lowest_newack
operator|=
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|saw_newack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|snd_count
operator|<
literal|2
condition|)
block|{
comment|/* 						 * True non-retransmited 						 * chunk 						 */
name|tp1
operator|->
name|whoTo
operator|->
name|net_ack2
operator|+=
name|tp1
operator|->
name|send_size
expr_stmt|;
comment|/* update RTO too? */
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
if|if
condition|(
name|rto_ok
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
operator|&
name|tp1
operator|->
name|sent_rcv_time
argument_list|,
name|sctp_align_safe_nocopy
argument_list|,
name|SCTP_RTT_FROM_DATA
argument_list|)
expr_stmt|;
name|rto_ok
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 					 * CMT: CUCv2 algorithm. From the 					 * cumack'd TSNs, for each TSN being 					 * acked for the first time, set the 					 * following variables for the 					 * corresp destination. 					 * new_pseudo_cumack will trigger a 					 * cwnd update. 					 * find_(rtx_)pseudo_cumack will 					 * trigger search for the next 					 * expected (rtx-)pseudo-cumack. 					 */
name|tp1
operator|->
name|whoTo
operator|->
name|new_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_pseudo_cumack
operator|=
literal|1
expr_stmt|;
name|tp1
operator|->
name|whoTo
operator|->
name|find_rtx_pseudo_cumack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_TSN_ACKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|SCTP_CWND_LOG_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB3
argument_list|,
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|&
literal|0x000000ff
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* deflate the cwnd */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_ACKED
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
name|biggest_tsn_newly_acked
operator|=
name|biggest_tsn_acked
operator|=
name|last_tsn
expr_stmt|;
comment|/* always set this up to cum-ack */
name|asoc
operator|->
name|this_sack_highest_gap
operator|=
name|last_tsn
expr_stmt|;
if|if
condition|(
operator|(
name|num_seg
operator|>
literal|0
operator|)
operator|||
operator|(
name|num_nr_seg
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 		 * CMT: SFR algo (and HTNA) - this_sack_highest_newack has 		 * to be greater than the cumack. Also reset saw_newack to 0 		 * for all dests. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|saw_newack
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|this_sack_highest_newack
operator|=
name|last_tsn
expr_stmt|;
block|}
comment|/* 		 * thisSackHighestGap will increase while handling NEW 		 * segments this_sack_highest_newack will increase while 		 * handling NEWLY ACKED chunks. this_sack_lowest_newack is 		 * used for CMT DAC algo. saw_newack will also change. 		 */
if|if
condition|(
name|sctp_handle_segments
argument_list|(
name|m
argument_list|,
operator|&
name|offset_seg
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|last_tsn
argument_list|,
operator|&
name|biggest_tsn_acked
argument_list|,
operator|&
name|biggest_tsn_newly_acked
argument_list|,
operator|&
name|this_sack_lowest_newack
argument_list|,
name|num_seg
argument_list|,
name|num_nr_seg
argument_list|,
operator|&
name|rto_ok
argument_list|)
condition|)
block|{
name|wake_him
operator|++
expr_stmt|;
block|}
comment|/* 		 * validate the biggest_tsn_acked in the gap acks if strict 		 * adherence is wanted. 		 */
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|biggest_tsn_acked
argument_list|,
name|send_s
argument_list|)
condition|)
block|{
comment|/* 			 * peer is either confused or we are under attack. 			 * We must abort. 			 */
name|SCTP_PRINTF
argument_list|(
literal|"Hopeless peer! biggest_tsn_acked:%x largest seq:%x\n"
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|send_s
argument_list|)
expr_stmt|;
goto|goto
name|hopeless_peer
goto|;
block|}
block|}
comment|/*******************************************/
comment|/* cancel ALL T3-send timer if accum moved */
comment|/*******************************************/
if|if
condition|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|new_pseudo_cumack
condition|)
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_27
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|accum_moved
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_28
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/********************************************/
comment|/* drop the acked chunks from the sentqueue */
comment|/********************************************/
name|asoc
operator|->
name|last_acked_seq
operator|=
name|cum_ack
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|tp2
argument_list|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|cum_ack
argument_list|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"No chunks on the queues for sid %u."
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|state
operator|==
name|SCTP_STREAM_RESET_PENDING
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|trigger_reset
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|PR_SCTP_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|!=
literal|0
condition|)
name|asoc
operator|->
name|pr_sctp_cnt
operator|--
expr_stmt|;
block|}
name|asoc
operator|->
name|sent_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|data
condition|)
block|{
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|tp1
operator|->
name|data
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|prsctp_supported
operator|&&
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|tp1
operator|->
name|flags
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|--
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_sack
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|cum_ack
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_LOG_FREE_SENT
argument_list|)
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|wake_him
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Warning flight size is positive and should be 0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Warning flight size incorrect should be 0 is %d\n"
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
block|}
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
operator|(
name|wake_him
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_socket
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|wake_him
argument_list|,
name|SCTP_WAKESND_FROM_SACK
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sowwakeup_locked
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_WAKE_LOGGING_ENABLE
condition|)
block|{
name|sctp_wakeup_log
argument_list|(
name|stcb
argument_list|,
name|wake_him
argument_list|,
name|SCTP_NOWAKE_FROM_SACK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|&&
name|accum_moved
condition|)
block|{
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|fast_recovery_tsn
argument_list|)
condition|)
block|{
comment|/* Setup so we will exit RFC2582 fast recovery */
name|will_exit_fast_recovery
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Check for revoked fragments: 	 * 	 * if Previous sack - Had no frags then we can't have any revoked if 	 * Previous sack - Had frag's then - If we now have frags aka 	 * num_seg> 0 call sctp_check_for_revoked() to tell if peer revoked 	 * some of them. else - The peer revoked all ACKED fragments, since 	 * we had some before and now we have NONE. 	 */
if|if
condition|(
name|num_seg
condition|)
block|{
name|sctp_check_for_revoked
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|cum_ack
argument_list|,
name|biggest_tsn_acked
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|saw_sack_with_frags
condition|)
block|{
name|int
name|cnt_revoked
init|=
literal|0
decl_stmt|;
comment|/* Peer revoked all dg's marked or acked */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_ACKED
condition|)
block|{
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_REVOKE
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|tp1
operator|->
name|whoTo
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|1
expr_stmt|;
comment|/* 				 * To ensure that this increase in 				 * flightsize, which is artificial, does not 				 * throttle the sender, we also increase the 				 * cwnd artificially. 				 */
name|tp1
operator|->
name|whoTo
operator|->
name|cwnd
operator|+=
name|tp1
operator|->
name|book_size
expr_stmt|;
name|cnt_revoked
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_revoked
condition|)
block|{
name|reneged_all
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|saw_sack_with_frags
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_nr_seg
operator|>
literal|0
condition|)
name|asoc
operator|->
name|saw_sack_with_nr_frags
operator|=
literal|1
expr_stmt|;
else|else
name|asoc
operator|->
name|saw_sack_with_nr_frags
operator|=
literal|0
expr_stmt|;
comment|/* JRS - Use the congestion control given in the CC module */
if|if
condition|(
name|ecne_seen
operator|==
literal|0
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|net_ack2
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Karn's rule applies to clearing error 				 * count, this is optional. 				 */
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
comment|/* addr came good */
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
comment|/* 						 * release the alternate, 						 * primary is good 						 */
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_29
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_exit_pf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* Done with this net */
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* restore any doubled timers */
name|net
operator|->
name|RTO
operator|=
operator|(
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
operator|)
operator|+
name|net
operator|->
name|lastsv
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|RTO
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|minrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|RTO
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
block|}
block|}
block|}
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_sack
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|accum_moved
argument_list|,
name|reneged_all
argument_list|,
name|will_exit_fast_recovery
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left in-flight */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* stop all timers */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_30
argument_list|)
expr_stmt|;
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/**********************************/
comment|/* Now what about shutdown issues */
comment|/**********************************/
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* nothing left on sendqueue.. consider done */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|a_rwnd
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
comment|/* clean up */
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
operator|&&
operator|(
call|(
modifier|*
name|asoc
operator|->
name|ss_functions
operator|.
name|sctp_ss_is_user_msgs_incomplete
call|)
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
comment|/* Need to abort here */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_out_now
label|:
operator|*
name|abort_now
operator|=
literal|1
expr_stmt|;
comment|/* XXX */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_31
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|alternate
condition|)
block|{
name|netp
operator|=
name|asoc
operator|->
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
condition|)
block|{
goto|goto
name|abort_out_now
goto|;
block|}
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|alternate
condition|)
block|{
name|netp
operator|=
name|asoc
operator|->
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Now here we are going to recycle net_ack for a different use... 	 * HEADS UP. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|net_ack
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT DAC algorithm: If SACK DAC flag was 0, then no extra marking 	 * to be done. Setting this_sack_lowest_newack to the cum_ack will 	 * automatically ensure that. 	 */
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
operator|&&
operator|(
name|cmt_dac_flag
operator|==
literal|0
operator|)
condition|)
block|{
name|this_sack_lowest_newack
operator|=
name|cum_ack
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num_seg
operator|>
literal|0
operator|)
operator|||
operator|(
name|num_nr_seg
operator|>
literal|0
operator|)
condition|)
block|{
name|sctp_strike_gap_ack_chunks
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|biggest_tsn_acked
argument_list|,
name|biggest_tsn_newly_acked
argument_list|,
name|this_sack_lowest_newack
argument_list|,
name|accum_moved
argument_list|)
expr_stmt|;
block|}
comment|/* JRS - Use the congestion control given in the CC module */
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_fr
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* Now are we exiting loss recovery ? */
if|if
condition|(
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|asoc
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|)
operator|&&
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|last_acked_seq
argument_list|,
name|asoc
operator|->
name|sat_t3_recovery_tsn
argument_list|)
condition|)
block|{
comment|/* end satellite t3 loss recovery */
name|asoc
operator|->
name|sat_t3_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * CMT Fast recovery 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|will_exit_fast_recovery
condition|)
block|{
comment|/* Ok, we must exit fast recovery */
name|net
operator|->
name|fast_retran_loss_recovery
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Adjust and set the new rwnd value */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd_set
argument_list|(
name|SCTP_SET_PEER_RWND_VIA_SACK
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|asoc
operator|->
name|total_flight
argument_list|,
operator|(
name|asoc
operator|->
name|total_flight_count
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|a_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|asoc
operator|->
name|total_flight
operator|+
operator|(
name|asoc
operator|->
name|total_flight_count
operator|*
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|>
name|old_rwnd
condition|)
block|{
name|win_probe_recovery
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now we must setup so we have a timer up for anyone with 	 * outstanding data. 	 */
name|done_once
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|j
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|win_probe_recovery
operator|&&
operator|(
name|net
operator|->
name|window_probe
operator|)
condition|)
block|{
name|win_probe_recovered
operator|=
literal|1
expr_stmt|;
comment|/*- 			 * Find first chunk that was used with 			 * window probe and clear the event. Put 			 * it back into the send queue as if has 			 * not been sent. 			 */
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|window_probe
condition|)
block|{
name|sctp_window_probe_recovery
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
condition|)
block|{
name|j
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|window_probe
condition|)
block|{
comment|/* 				 * In window probes we must assure a timer 				 * is still running there 				 */
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_32
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|j
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|win_probe_recovered
operator|==
literal|0
operator|)
operator|&&
operator|(
name|done_once
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * huh, this should not happen unless all packets are 		 * PR-SCTP and marked to skip of course. 		 */
if|if
condition|(
name|sctp_fs_audit
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|flight_size
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_increase
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|done_once
operator|=
literal|1
expr_stmt|;
goto|goto
name|again
goto|;
block|}
comment|/*********************************************/
comment|/* Here we perform PR-SCTP procedures        */
comment|/* (section 4.2)                             */
comment|/*********************************************/
comment|/* C1. update advancedPeerAckPoint */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|cum_ack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|cum_ack
expr_stmt|;
block|}
comment|/* C2. try to further move advancedPeerAckPoint ahead */
if|if
condition|(
operator|(
name|asoc
operator|->
name|prsctp_supported
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pr_sctp_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|uint32_t
name|old_adv_peer_ack_point
decl_stmt|;
name|old_adv_peer_ack_point
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
name|lchk
operator|=
name|sctp_try_advance_peer_ack_point
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
comment|/* C3. See if we need to send a Fwd-TSN */
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|cum_ack
argument_list|)
condition|)
block|{
comment|/* 			 * ISSUE with ECN, see FWD-TSN processing. 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
literal|0xee
argument_list|,
name|cum_ack
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|,
name|old_adv_peer_ack_point
argument_list|)
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* try to FR fwd-tsn's that get lost too */
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|>=
literal|3
condition|)
block|{
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lchk
condition|)
block|{
comment|/* Assure a timer is up */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|lchk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_SACK_RWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_SACK_RWND_UPDATE
argument_list|,
name|a_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_update_acked
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_shutdown_chunk
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
comment|/* Copy cum-ack */
name|uint32_t
name|cum_ack
decl_stmt|,
name|a_rwnd
decl_stmt|;
name|cum_ack
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|cumulative_tsn_ack
argument_list|)
expr_stmt|;
comment|/* Arrange so a_rwnd does NOT change */
name|a_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
comment|/* Now call the express sack handling */
name|sctp_express_handle_sack
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
name|abort_flag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_kick_prsctp_reorder_queue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_in
modifier|*
name|strmin
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|ncontrol
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|mid
decl_stmt|;
name|int
name|need_reasm_check
init|=
literal|0
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|mid
operator|=
name|strmin
operator|->
name|last_mid_delivered
expr_stmt|;
comment|/* 	 * First deliver anything prior to and including the stream no that 	 * came in. 	 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&strmin->inqueue
argument_list|,
argument|next_instrm
argument_list|,
argument|ncontrol
argument_list|)
block|{
if|if
condition|(
name|SCTP_MID_GE
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|mid
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
comment|/* this is deliverable now */
if|if
condition|(
operator|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_UNORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"strmin: %p ctl: %p unknown %d"
argument_list|,
name|strmin
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
comment|/* subtract pending on streams */
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
comment|/* deliver it to at least the delivery-q */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Its a fragmented message */
if|if
condition|(
name|control
operator|->
name|first_frag_seen
condition|)
block|{
comment|/* 					 * Make it so this is next to 					 * deliver, we restore later 					 */
name|strmin
operator|->
name|last_mid_delivered
operator|=
name|control
operator|->
name|mid
operator|-
literal|1
expr_stmt|;
name|need_reasm_check
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
comment|/* no more delivery now. */
break|break;
block|}
block|}
if|if
condition|(
name|need_reasm_check
condition|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|strmin
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_MID_GT
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|mid
argument_list|,
name|strmin
operator|->
name|last_mid_delivered
argument_list|)
condition|)
block|{
comment|/* Restore the next to deliver unless we are ahead */
name|strmin
operator|->
name|last_mid_delivered
operator|=
name|mid
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* Left the front Partial one on */
return|return;
block|}
name|need_reasm_check
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * now we must deliver things in queue the normal way  if any are 	 * now ready. 	 */
name|mid
operator|=
name|strmin
operator|->
name|last_mid_delivered
operator|+
literal|1
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|control
argument_list|,
argument|&strmin->inqueue
argument_list|,
argument|next_instrm
argument_list|,
argument|ncontrol
argument_list|)
block|{
if|if
condition|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|mid
argument_list|,
name|control
operator|->
name|mid
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|control
operator|->
name|sinfo_flags
operator|>>
literal|8
operator|)
operator|&
name|SCTP_DATA_NOT_FRAG
operator|)
operator|==
name|SCTP_DATA_NOT_FRAG
condition|)
block|{
comment|/* this is deliverable now */
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_UNORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strmin
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"strmin: %p ctl: %p unknown %d"
argument_list|,
name|strmin
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
comment|/* subtract pending on streams */
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
comment|/* deliver it to at least the delivery-q */
name|strmin
operator|->
name|last_mid_delivered
operator|=
name|control
operator|->
name|mid
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_mark_non_revokable
argument_list|(
name|asoc
argument_list|,
name|control
operator|->
name|sinfo_tsn
argument_list|)
expr_stmt|;
name|sctp_add_to_readq
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|,
literal|1
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|mid
operator|=
name|strmin
operator|->
name|last_mid_delivered
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* Its a fragmented message */
if|if
condition|(
name|control
operator|->
name|first_frag_seen
condition|)
block|{
comment|/* 					 * Make it so this is next to 					 * deliver 					 */
name|strmin
operator|->
name|last_mid_delivered
operator|=
name|control
operator|->
name|mid
operator|-
literal|1
expr_stmt|;
name|need_reasm_check
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
break|break;
block|}
block|}
if|if
condition|(
name|need_reasm_check
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|strmin
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_flush_reassm_for_str_seq
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|uint16_t
name|stream
parameter_list|,
name|uint32_t
name|mid
parameter_list|,
name|int
name|ordered
parameter_list|,
name|uint32_t
name|cumtsn
parameter_list|)
block|{
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|int
name|cnt_removed
init|=
literal|0
decl_stmt|;
comment|/* 	 * For now large messages held on the stream reasm that are complete 	 * will be tossed too. We could in theory do more work to spin 	 * through and stop after dumping one msg aka seeing the start of a 	 * new msg at the head, and call the delivery function... to see if 	 * it can be delivered... But for now we just dump everything on the 	 * queue. 	 */
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|stream
index|]
expr_stmt|;
name|control
operator|=
name|sctp_find_reasm_entry
argument_list|(
name|strm
argument_list|,
name|mid
argument_list|,
name|ordered
argument_list|,
name|asoc
operator|->
name|idata_supported
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|==
name|NULL
condition|)
block|{
comment|/* Not found */
return|return;
block|}
if|if
condition|(
operator|!
name|asoc
operator|->
name|idata_supported
operator|&&
operator|!
name|ordered
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|control
operator|->
name|fsn_included
argument_list|,
name|cumtsn
argument_list|)
condition|)
block|{
return|return;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&control->reasm
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
comment|/* Purge hanging chunks */
if|if
condition|(
operator|!
name|asoc
operator|->
name|idata_supported
operator|&&
operator|(
name|ordered
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|cumtsn
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
name|cnt_removed
operator|++
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_reasm_queue
operator|>=
name|chk
operator|->
name|send_size
condition|)
block|{
name|asoc
operator|->
name|size_on_reasm_queue
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_reasm_queue = %u smaller than chunk length %u"
argument_list|,
name|asoc
operator|->
name|size_on_reasm_queue
argument_list|,
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_reasm_queue
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_reasm_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|)
condition|)
block|{
comment|/* This has to be old data, unordered */
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_reset_a_control
argument_list|(
name|control
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|cumtsn
argument_list|)
expr_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|control
operator|->
name|reasm
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_add_chk_to_control
argument_list|(
name|control
argument_list|,
name|strm
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|)
expr_stmt|;
block|}
name|sctp_deliver_reasm_check
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strm
argument_list|,
name|SCTP_READ_LOCK_HELD
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_UNORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|panic
argument_list|(
literal|"strm: %p ctl: %p unknown %d"
argument_list|,
name|strm
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_read_q
operator|==
literal|0
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|control
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
operator|->
name|data
argument_list|)
expr_stmt|;
name|control
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_handle_forward_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_forward_tsn_chunk
modifier|*
name|fwd
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|/* The pr-sctp fwd tsn */
comment|/* 	 * here we will perform all the data receiver side steps for 	 * processing FwdTSN, as required in by pr-sctp draft: 	 * 	 * Assume we get FwdTSN(x): 	 * 	 * 1) update local cumTSN to x 2) try to further advance cumTSN to x 	 * + others we have 3) examine and update re-ordering queue on 	 * pr-in-streams 4) clean up re-assembly queue 5) Send a sack to 	 * report where we are. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|new_cum_tsn
decl_stmt|,
name|gap
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|fwd_sz
decl_stmt|,
name|m_size
decl_stmt|;
name|uint32_t
name|str_seq
decl_stmt|;
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|control
decl_stmt|,
modifier|*
name|sv
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|fwd_sz
operator|=
name|ntohs
argument_list|(
name|fwd
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Bad size too small/big fwd-tsn\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_size
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
operator|<<
literal|3
operator|)
expr_stmt|;
comment|/*************************************************************/
comment|/* 1. Here we update local cumTSN and shift the bitmap array */
comment|/*************************************************************/
name|new_cum_tsn
operator|=
name|ntohl
argument_list|(
name|fwd
operator|->
name|new_cumulative_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|new_cum_tsn
argument_list|)
condition|)
block|{
comment|/* Already got there ... */
return|return;
block|}
comment|/* 	 * now we know the new TSN is more advanced, let's find the actual 	 * gap 	 */
name|SCTP_CALC_TSN_TO_GAP
argument_list|(
name|gap
argument_list|,
name|new_cum_tsn
argument_list|,
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|new_cum_tsn
expr_stmt|;
if|if
condition|(
name|gap
operator|>=
name|m_size
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|gap
operator|>
name|sctp_sbspace
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
comment|/* 			 * out of range (of single byte chunks in the rwnd I 			 * give out). This must be an attacker. 			 */
operator|*
name|abort_flag
operator|=
literal|1
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"New cum ack %8.8x too high, highest TSN %8.8x"
argument_list|,
name|new_cum_tsn
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_INDATA
operator|+
name|SCTP_LOC_33
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_fwdtsn_map_over
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|new_cum_tsn
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|new_cum_tsn
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|new_cum_tsn
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|3
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|gap
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|SCTP_IS_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|SCTP_SET_TSN_PRESENT
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
name|i
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*************************************************************/
comment|/* 2. Clear up re-assembly queue                             */
comment|/*************************************************************/
comment|/* This is now done as part of clearing up the stream/seq */
if|if
condition|(
name|asoc
operator|->
name|idata_supported
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|sid
decl_stmt|;
comment|/* Flush all the un-ordered data based on cum-tsn */
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
for|for
control|(
name|sid
operator|=
literal|0
init|;
name|sid
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|sid
operator|++
control|)
block|{
name|sctp_flush_reassm_for_str_seq
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|sid
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|new_cum_tsn
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************/
comment|/* 3. Update the PR-stream re-ordering queues and fix  */
comment|/* delivery issues as needed.                       */
comment|/*******************************************************/
name|fwd_sz
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|&&
name|fwd_sz
condition|)
block|{
comment|/* New method. */
name|unsigned
name|int
name|num_str
decl_stmt|;
name|uint32_t
name|mid
decl_stmt|,
name|cur_mid
decl_stmt|;
name|uint16_t
name|sid
decl_stmt|;
name|uint16_t
name|ordered
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|sctp_strseq
modifier|*
name|stseq
decl_stmt|,
name|strseqbuf
decl_stmt|;
name|struct
name|sctp_strseq_mid
modifier|*
name|stseq_m
decl_stmt|,
name|strseqbuf_m
decl_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|fwd
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|idata_supported
condition|)
block|{
name|num_str
operator|=
name|fwd_sz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq_mid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|num_str
operator|=
name|fwd_sz
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_str
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|idata_supported
condition|)
block|{
name|stseq_m
operator|=
operator|(
expr|struct
name|sctp_strseq_mid
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq_mid
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|strseqbuf_m
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq_mid
argument_list|)
expr_stmt|;
if|if
condition|(
name|stseq_m
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|sid
operator|=
name|ntohs
argument_list|(
name|stseq_m
operator|->
name|sid
argument_list|)
expr_stmt|;
name|mid
operator|=
name|ntohl
argument_list|(
name|stseq_m
operator|->
name|mid
argument_list|)
expr_stmt|;
name|flags
operator|=
name|ntohs
argument_list|(
name|stseq_m
operator|->
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PR_SCTP_UNORDERED_FLAG
condition|)
block|{
name|ordered
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ordered
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|stseq
operator|=
operator|(
expr|struct
name|sctp_strseq
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|strseqbuf
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|stseq
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|sid
operator|=
name|ntohs
argument_list|(
name|stseq
operator|->
name|sid
argument_list|)
expr_stmt|;
name|mid
operator|=
operator|(
name|uint32_t
operator|)
name|ntohs
argument_list|(
name|stseq
operator|->
name|ssn
argument_list|)
expr_stmt|;
name|ordered
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Convert */
comment|/* now process */
comment|/* 			 * Ok we now look for the stream/seq on the read 			 * queue where its not all delivered. If we find it 			 * we transmute the read entry into a PDI_ABORTED. 			 */
if|if
condition|(
name|sid
operator|>=
name|asoc
operator|->
name|streamincnt
condition|)
block|{
comment|/* screwed up streams, stop!  */
break|break;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_of_pdapi
operator|==
name|sid
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|ssn_of_pdapi
operator|==
name|mid
operator|)
condition|)
block|{
comment|/* 				 * If this is the one we were partially 				 * delivering now then we no longer are. 				 * Note this will change with the reassembly 				 * re-write. 				 */
name|asoc
operator|->
name|fragmented_delivery_inprogress
operator|=
literal|0
expr_stmt|;
block|}
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|sid
index|]
expr_stmt|;
for|for
control|(
name|cur_mid
operator|=
name|strm
operator|->
name|last_mid_delivered
init|;
name|SCTP_MID_GE
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|mid
argument_list|,
name|cur_mid
argument_list|)
condition|;
name|cur_mid
operator|++
control|)
block|{
name|sctp_flush_reassm_for_str_seq
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|sid
argument_list|,
name|cur_mid
argument_list|,
name|ordered
argument_list|,
name|new_cum_tsn
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|control
argument_list|,
argument|&stcb->sctp_ep->read_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|(
name|control
operator|->
name|sinfo_stream
operator|==
name|sid
operator|)
operator|&&
operator|(
name|SCTP_MID_EQ
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|mid
argument_list|)
operator|)
condition|)
block|{
name|str_seq
operator|=
operator|(
name|sid
operator|<<
literal|16
operator|)
operator||
operator|(
literal|0x0000ffff
operator|&
name|mid
operator|)
expr_stmt|;
name|control
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|sv
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
expr_stmt|;
name|control
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|size_on_all_streams
operator|>=
name|control
operator|->
name|length
condition|)
block|{
name|asoc
operator|->
name|size_on_all_streams
operator|-=
name|control
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"size_on_all_streams = %u smaller than control length %u"
argument_list|,
name|asoc
operator|->
name|size_on_all_streams
argument_list|,
name|control
operator|->
name|length
argument_list|)
expr_stmt|;
else|#
directive|else
name|asoc
operator|->
name|size_on_all_streams
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|cnt_on_all_streams
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_UNORDERED
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|control
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
elseif|else
if|if
condition|(
name|control
operator|->
name|on_strm_q
condition|)
block|{
name|panic
argument_list|(
literal|"strm: %p ctl: %p unknown %d"
argument_list|,
name|strm
argument_list|,
name|control
argument_list|,
name|control
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|control
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|control
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PARTIAL_DELVIERY_INDICATION
argument_list|,
name|stcb
argument_list|,
name|SCTP_PARTIAL_DELIVERY_ABORTED
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|str_seq
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|control_pdapi
operator|=
name|sv
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|control
operator|->
name|sinfo_stream
operator|==
name|sid
operator|)
operator|&&
name|SCTP_MID_GT
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|control
operator|->
name|mid
argument_list|,
name|mid
argument_list|)
condition|)
block|{
comment|/* We are past our victim SSN */
break|break;
block|}
block|}
if|if
condition|(
name|SCTP_MID_GT
argument_list|(
name|asoc
operator|->
name|idata_supported
argument_list|,
name|mid
argument_list|,
name|strm
operator|->
name|last_mid_delivered
argument_list|)
condition|)
block|{
comment|/* Update the sequence number */
name|strm
operator|->
name|last_mid_delivered
operator|=
name|mid
expr_stmt|;
block|}
comment|/* now kick the stream the new way */
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_kick_prsctp_reorder_queue
argument_list|(
name|stcb
argument_list|,
name|strm
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now slide thing forward. 	 */
name|sctp_slide_mapping_arrays
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

