begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993, University of Vermont and State  *  Agricultural College.  * Copyright (c) 1993, Garrett A. Wollman.  *  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND AUTHOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR AUTHORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: in_mtudisc.c,v 1.1 1993/11/18 00:08:14 wollman Exp $  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MTUDISC
end_ifdef

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"in_systm.h"
end_include

begin_include
include|#
directive|include
file|"net/if.h"
end_include

begin_include
include|#
directive|include
file|"net/route.h"
end_include

begin_include
include|#
directive|include
file|"in.h"
end_include

begin_include
include|#
directive|include
file|"in_var.h"
end_include

begin_include
include|#
directive|include
file|"ip.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"in_pcb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_comment
comment|/*  * checkpcbs[] lists all the PCB heads that might call on the services  * of MTU discovery.  * This is really bogus 'cuz a ULP needs to both get its entry added here  * /and/ set INP_DISCOVERMTU in each PCB.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|inpcb
name|tcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX move to header file */
end_comment

begin_decl_stmt
name|struct
name|inpcb
modifier|*
name|checkpcbs
index|[]
init|=
block|{
operator|&
name|tcb
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table of likely MTU values, courtesy of RFC 1191.  * This MUST remain in sorted order.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|u_short
name|in_mtus
index|[]
init|=
block|{
literal|65535
block|,
comment|/* maximum */
literal|32767
block|,
comment|/* convenient power of 2 - 1 */
literal|17914
block|,
comment|/* 16Mb Token Ring */
literal|16383
block|,
comment|/* convenient power of 2 - 1 */
literal|8166
block|,
comment|/* IEEE 802.4 */
literal|6288
block|,
comment|/* convenient stopping point */
literal|4352
block|,
comment|/* FDDI */
literal|3144
block|,
comment|/* convenient stopping point */
literal|2002
block|,
comment|/* IEEE 802.5 */
literal|1492
block|,
comment|/* IEEE 802.3 */
literal|1006
block|,
comment|/* BBN 1822 */
literal|508
block|,
comment|/* ARCNET */
literal|296
block|,
comment|/* SLIP, PPP */
literal|128
comment|/* minimum we'll accept */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NMTUS
value|((sizeof in_mtus)/(sizeof in_mtus[0]))
end_define

begin_comment
comment|/*  * Find the next MTU in the sequence from CURRENT.  * If HIGHER, increase size; else decrease.  * Return of zero means we're stuck.  * NB: We might be called with a CURRENT MTU that's not in the  * table (as, for example, when an ICMP tells us there's a problem  * and reports a max path MTU value).  */
end_comment

begin_function
name|unsigned
name|in_nextmtu
parameter_list|(
name|unsigned
name|current
parameter_list|,
name|int
name|higher
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NMTUS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|in_mtus
index|[
name|i
index|]
operator|<=
operator|(
name|u_short
operator|)
name|current
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|NMTUS
condition|)
block|{
if|if
condition|(
name|higher
condition|)
return|return
name|in_mtus
index|[
name|NMTUS
operator|-
literal|1
index|]
return|;
else|else
return|return
literal|0
return|;
comment|/* error return */
block|}
comment|/*    * Now we know that CURRENT lies somewhere in the interval    * (in_mtus[i - 1], in_mtus[i]].  If we want to go higher,    * take in_mtus[i - 1] always.  If we want to go lower, we    * must check the lower bound to see if it's equal, and if so,    * take in_mtus[i + 1], unless i == NMTUS - 1, in which case    * we return failure.    * Got that?    */
if|if
condition|(
name|higher
condition|)
return|return
name|in_mtus
index|[
operator|(
name|i
operator|>=
literal|1
operator|)
condition|?
operator|(
name|i
operator|-
literal|1
operator|)
else|:
literal|0
index|]
return|;
comment|/* now we know it's lower */
if|if
condition|(
name|current
operator|==
name|in_mtus
index|[
name|i
index|]
condition|)
block|{
if|if
condition|(
name|i
operator|==
name|NMTUS
operator|-
literal|1
condition|)
return|return
literal|0
return|;
else|else
return|return
name|in_mtus
index|[
name|i
operator|+
literal|1
index|]
return|;
block|}
return|return
name|in_mtus
index|[
name|i
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Set up the route to do MTU discovery.  This only works for host routes,  * not net routes; in any case, ALL systems should have all IP routes  * marked with RTF_CLONING (and a genmask of zero), which will do the right  * thing, and also arrange for the pre-ARPing code to get called on  * on appropriate interfaces.  *  * We also go to some pains to keep listeners on the routing socket aware  * of what's going on when we fiddle the flags or metrics.  I don't know  * if this is really necessary or not (or even if we're doing it in the  * right way).  */
end_comment

begin_function
name|int
name|in_routemtu
parameter_list|(
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ro
operator|->
name|ro_rt
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_HOST
operator||
name|RTF_UP
operator|)
operator|)
operator|!=
operator|(
name|RTF_HOST
operator||
name|RTF_UP
operator|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
condition|)
block|{
comment|/*      * Let the user know that we've turned on MTU discovery for this      * route entry.  This doesn't do anything at present, but may      * be useful later on.      */
if|if
condition|(
operator|!
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_PROTO1
operator|)
condition|)
block|{
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator||=
name|RTF_PROTO1
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|&&
operator|!
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_locks
operator|&
name|RTV_MTU
operator|)
condition|)
block|{
name|ro
operator|->
name|ro_rt
operator|->
name|rt_flags
operator||=
name|RTF_PROTO1
expr_stmt|;
comment|/*      * Subtraction is necessary because the interface's MTU includes      * the interface's own headers.  We subtract the header length      * provided and hope for the best.      */
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|-
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_hdrlen
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Perform the PCB fiddling necessary when the route changes.  * Protect against recursion, since we might get called as a  * result of notifying someone else that the MTU is changing.  */
end_comment

begin_function
name|void
name|in_pcbmtu
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
specifier|static
name|int
name|notifying
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|timerstarted
init|=
literal|0
decl_stmt|;
name|unsigned
name|oldmtu
init|=
name|inp
operator|->
name|inp_pmtu
decl_stmt|;
name|int
name|oldflags
init|=
name|inp
operator|->
name|inp_flags
decl_stmt|;
if|if
condition|(
operator|!
name|timerstarted
condition|)
block|{
name|timeout
argument_list|(
name|in_mtutimer
argument_list|,
literal|0
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
name|timerstarted
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_DISCOVERMTU
condition|)
block|{
comment|/*      * If no route present, get one.      * If there is one present, but it's marked as being `down',      * try to get another one.      */
if|if
condition|(
operator|!
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
condition|)
name|rtalloc
argument_list|(
operator|&
name|inp
operator|->
name|inp_route
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|RTFREE
argument_list|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|inp
operator|->
name|inp_route
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|in_routemtu
argument_list|(
operator|&
name|inp
operator|->
name|inp_route
argument_list|)
condition|)
block|{
name|inp
operator|->
name|inp_flags
operator||=
name|INP_MTUDISCOVERED
expr_stmt|;
name|inp
operator|->
name|inp_pmtu
operator|=
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
expr_stmt|;
name|inp
operator|->
name|inp_ip
operator|.
name|ip_off
operator||=
name|IP_DF
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|inp_flags
operator|&=
operator|~
name|INP_MTUDISCOVERED
expr_stmt|;
name|inp
operator|->
name|inp_ip
operator|.
name|ip_off
operator|&=
operator|~
name|IP_DF
expr_stmt|;
block|}
comment|/*      * If nothing has changed since the last value we had,      * don't waste any time notifying everybody that nothing      * has changed.      */
if|if
condition|(
name|inp
operator|->
name|inp_pmtu
operator|!=
name|oldmtu
operator|||
operator|(
name|inp
operator|->
name|inp_flags
operator|^
name|oldflags
operator|)
condition|)
block|{
name|notifying
operator|=
literal|1
expr_stmt|;
comment|/*        * If the MTU has decreased, use timer 2.        */
name|inp
operator|->
name|inp_mtutimer
operator|=
operator|(
name|inp
operator|->
name|inp_pmtu
operator|<
name|oldmtu
operator|)
condition|?
name|in_mtutimer2
else|:
name|in_mtutimer1
expr_stmt|;
name|in_mtunotify
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|notifying
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Tell the clients that have the same destination as INP that they  * need to take a new look at the MTU value and flags.  */
end_comment

begin_function
name|void
name|in_mtunotify
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|in_pcbnotify
argument_list|(
name|inp
operator|->
name|inp_head
argument_list|,
operator|&
name|inp
operator|->
name|inp_route
operator|.
name|ro_dst
argument_list|,
literal|0
argument_list|,
name|zeroin_addr
argument_list|,
literal|0
argument_list|,
name|PRC_MTUCHANGED
argument_list|,
name|inp
operator|->
name|inp_mtunotify
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adjust the MTU listed in the route on the basis of an ICMP  * Unreachable: Need Fragmentation message.  * Note that the PRC_MSGSIZE error is still delivered; this just  * makes the adjustment in the route, and depends on the ULPs which  * are required to translate PRC_MSGSIZE into an in_pcbmtu() which will  * pick up the new size.  */
end_comment

begin_function
name|void
name|in_mtureduce
parameter_list|(
name|struct
name|in_addr
name|dst
parameter_list|,
name|unsigned
name|newsize
parameter_list|)
block|{
name|struct
name|route
name|ro
decl_stmt|;
name|ro
operator|.
name|ro_dst
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|ro
operator|.
name|ro_dst
operator|.
name|sa_len
operator|=
sizeof|sizeof
name|ro
operator|.
name|ro_dst
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
operator|)
operator|->
name|sin_addr
operator|=
name|dst
expr_stmt|;
name|ro
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
name|rtalloc
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
comment|/*    * If there was no route, just forget about it, can't do anything.    */
if|if
condition|(
operator|!
name|ro
operator|.
name|ro_rt
condition|)
return|return;
comment|/*    * If there was a route, but it's the wrong kind, forget it.    */
if|if
condition|(
operator|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_UP
operator||
name|RTF_HOST
operator|)
operator|)
operator|!=
operator|(
name|RTF_UP
operator||
name|RTF_HOST
operator|)
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * If the MTU is locked by some outside agency, forget it.    */
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_locks
operator|&
name|RTV_MTU
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * If newsize == 0, then we got an ICMP from a router    * which doesn't support the MTU extension, so just go down one.    */
name|newsize
operator|=
name|in_nextmtu
argument_list|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newsize
condition|)
block|{
name|ro
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
literal|0
expr_stmt|;
comment|/* we can't go any lower */
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * If the new MTU is greater than the old MTU, forget it.  (Prevent    * denial-of-service attack.)  Don't bother if the new MTU is the    * same as the old one.    */
if|if
condition|(
name|ro
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|<=
name|newsize
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*    * OK, do it.    */
name|ro
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|newsize
expr_stmt|;
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Walk through all the PCB lists in checkpcbs[] and decrement the  * timers on the ones still participating in MTU discovery.  * If the timers reach zero, bump the MTU (clamped to the interface  * MTU), assuming the route is still good.  */
end_comment

begin_function
name|void
name|in_mtutimer
parameter_list|(
name|caddr_t
name|dummy1
parameter_list|,
name|int
name|dummy2
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|checkpcbs
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
name|inp
operator|=
name|checkpcbs
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|inp
operator|=
name|inp
operator|->
name|inp_next
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_MTUDISCOVERED
condition|)
block|{
if|if
condition|(
operator|!
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|||
operator|!
operator|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
condition|)
block|{
name|inp
operator|->
name|inp_flags
operator|&=
operator|~
name|INP_MTUDISCOVERED
expr_stmt|;
continue|continue;
comment|/* we'll notice it later */
block|}
if|if
condition|(
operator|--
name|inp
operator|->
name|inp_mtutimer
operator|==
literal|0
condition|)
block|{
name|in_bumpmtu
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|inp_mtutimer
operator|=
name|in_mtutimer1
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_rtt
operator|&&
operator|(
operator|(
name|in_mtutimer1
operator|*
literal|60
operator|)
operator|>
operator|(
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_rtt
operator|/
name|RTM_RTTUNIT
operator|)
operator|)
condition|)
block|{
name|inp
operator|->
name|inp_mtutimer
operator|=
name|inp
operator|->
name|inp_route
operator|.
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_rtt
operator|/
name|RTM_RTTUNIT
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|in_mtutimer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
literal|60
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to increase the MTU and let everyone know that it has changed.  * Must be called with a valid route in inp->inp_route.  Probably  * must be at splnet(), too.  */
end_comment

begin_function
name|void
name|in_bumpmtu
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|unsigned
name|newmtu
decl_stmt|;
name|ro
operator|=
operator|&
name|inp
operator|->
name|inp_route
expr_stmt|;
name|newmtu
operator|=
name|in_nextmtu
argument_list|(
name|inp
operator|->
name|inp_pmtu
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newmtu
condition|)
return|return;
comment|/* doing the best we can */
if|if
condition|(
name|newmtu
operator|<=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_locks
operator|&
name|RTV_MTU
operator|)
condition|)
block|{
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|=
name|newmtu
expr_stmt|;
name|in_pcbmtu
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MTUDISC */
end_comment

end_unit

