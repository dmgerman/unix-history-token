begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_bootp.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipfw.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipstealth.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_route.h"
end_include

begin_include
include|#
directive|include
file|"opt_rss.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/sdt.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/pfil.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/rss_config.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_kdtrace.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_options.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_carp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip_ipsec.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_rss.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CTASSERT
end_ifdef

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|==
literal|20
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|rwlock
name|in_ifaddr_lock
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|RW_SYSINIT
argument_list|(
name|in_ifaddr_lock
argument_list|,
operator|&
name|in_ifaddr_lock
argument_list|,
literal|"in_ifaddr_lock"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|rsvp_on
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipforwarding
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_FORWARDING
argument_list|,
name|forwarding
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipforwarding
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable IP forwarding between interfaces"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipsendredirects
argument_list|)
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* XXX */
end_comment

begin_define
define|#
directive|define
name|V_ipsendredirects
value|VNET(ipsendredirects)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_SENDREDIRECTS
argument_list|,
name|redirect
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipsendredirects
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Enable sending IP redirects"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX - Setting ip_checkinterface mostly implements the receive side of  * the Strong ES model described in RFC 1122, but since the routing table  * and transmit implementation do not implement the Strong ES model,  * setting this to 1 results in an odd hybrid.  *  * XXX - ip_checkinterface currently must be disabled if you use ipnat  * to translate the destination address to another local interface.  *  * XXX - ip_checkinterface must be disabled if you add IP aliases  * to the loopback interface instead of the interface where the  * packets for those addresses are received.  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip_checkinterface
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ip_checkinterface
value|VNET(ip_checkinterface)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|check_interface
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ip_checkinterface
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Verify packet arrives on correct interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|pfil_head
argument_list|,
name|inet_pfil_hook
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Packet filter hooks */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|netisr_handler
name|ip_nh
init|=
block|{
operator|.
name|nh_name
operator|=
literal|"ip"
block|,
operator|.
name|nh_handler
operator|=
name|ip_input
block|,
operator|.
name|nh_proto
operator|=
name|NETISR_IP
block|,
ifdef|#
directive|ifdef
name|RSS
operator|.
name|nh_m2cpuid
operator|=
name|rss_soft_m2cpuid
block|,
operator|.
name|nh_policy
operator|=
name|NETISR_POLICY_CPU
block|,
operator|.
name|nh_dispatch
operator|=
name|NETISR_DISPATCH_HYBRID
block|,
else|#
directive|else
operator|.
name|nh_policy
operator|=
name|NETISR_POLICY_FLOW
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_comment
comment|/*  * Directly dispatched frames are currently assumed  * to have a flowid already calculated.  *  * It should likely have something that assert it  * actually has valid flow details.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|netisr_handler
name|ip_direct_nh
init|=
block|{
operator|.
name|nh_name
operator|=
literal|"ip_direct"
block|,
operator|.
name|nh_handler
operator|=
name|ip_direct_input
block|,
operator|.
name|nh_proto
operator|=
name|NETISR_IP_DIRECT
block|,
operator|.
name|nh_m2cpuid
operator|=
name|rss_m2cpuid
block|,
operator|.
name|nh_policy
operator|=
name|NETISR_POLICY_CPU
block|,
operator|.
name|nh_dispatch
operator|=
name|NETISR_DISPATCH_HYBRID
block|, }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inetdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|protosw
name|inetsw
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ip_protox
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|in_ifaddrhead
argument_list|,
name|in_ifaddrhead
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* first inet address */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|in_ifaddrhashhead
operator|*
argument_list|,
name|in_ifaddrhashtbl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* inet addr hash table  */
end_comment

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|u_long
argument_list|,
name|in_ifaddrhmask
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* mask for hash table */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uma_zone_t
argument_list|,
name|ipq_zone
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|TAILQ_HEAD
argument_list|(
name|ipqhead
argument_list|,
name|ipq
argument_list|)
argument_list|,
name|ipq
index|[
name|IPREASS_NHASH
index|]
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx_padalign
name|ipqlock
index|[
name|IPREASS_NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|V_ipq_zone
value|VNET(ipq_zone)
end_define

begin_define
define|#
directive|define
name|V_ipq
value|VNET(ipq)
end_define

begin_comment
comment|/*  * The ipqlock array is global, /not/ per-VNET.  */
end_comment

begin_define
define|#
directive|define
name|IPQ_LOCK
parameter_list|(
name|i
parameter_list|)
value|mtx_lock(&ipqlock[(i)])
end_define

begin_define
define|#
directive|define
name|IPQ_UNLOCK
parameter_list|(
name|i
parameter_list|)
value|mtx_unlock(&ipqlock[(i)])
end_define

begin_define
define|#
directive|define
name|IPQ_LOCK_INIT
parameter_list|(
name|i
parameter_list|)
value|mtx_init(&ipqlock[(i)], "ipqlock", NULL, MTX_DEF)
end_define

begin_define
define|#
directive|define
name|IPQ_LOCK_ASSERT
parameter_list|(
name|i
parameter_list|)
value|mtx_assert(&ipqlock[(i)], MA_OWNED)
end_define

begin_function_decl
specifier|static
name|void
name|maxnipq_update
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ipq_zone_change
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ip_drain_vnet
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|maxnipq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Administrative limit on # reass queues. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|nipq
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Total # of reass queues */
end_comment

begin_define
define|#
directive|define
name|V_maxnipq
value|VNET(maxnipq)
end_define

begin_define
define|#
directive|define
name|V_nipq
value|VNET(nipq)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|fragpackets
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|nipq
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Current number of IPv4 fragment reassembly queue entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|maxfragsperpacket
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_maxfragsperpacket
value|VNET(maxfragsperpacket)
end_define

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|maxfragsperpacket
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|maxfragsperpacket
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of IPv4 fragments allowed per packet"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPCTL_DEFMTU
end_ifdef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_DEFMTU
argument_list|,
name|mtu
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_mtu
argument_list|,
literal|0
argument_list|,
literal|"Default MTU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPSTEALTH
end_ifdef

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ipstealth
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|stealth
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|ipstealth
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"IP stealth mode, no TTL decrementation on forwarding"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|ip_freef
parameter_list|(
name|struct
name|ipqhead
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|ipq
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * IP statistics are stored in the "array" of counter(9)s.  */
end_comment

begin_expr_stmt
name|VNET_PCPUSTAT_DEFINE
argument_list|(
expr|struct
name|ipstat
argument_list|,
name|ipstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_PCPUSTAT_SYSINIT
argument_list|(
name|ipstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_VNET_PCPUSTAT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_STATS
argument_list|,
name|stats
argument_list|,
expr|struct
name|ipstat
argument_list|,
name|ipstat
argument_list|,
literal|"IP statistics (struct ipstat, netinet/ip_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_expr_stmt
name|VNET_PCPUSTAT_SYSUNINIT
argument_list|(
name|ipstat
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VIMAGE */
end_comment

begin_comment
comment|/*  * Kernel module interface for updating ipstat.  The argument is an index  * into ipstat treated as an array.  */
end_comment

begin_function
name|void
name|kmod_ipstat_inc
parameter_list|(
name|int
name|statnum
parameter_list|)
block|{
name|counter_u64_add
argument_list|(
name|VNET
argument_list|(
name|ipstat
argument_list|)
index|[
name|statnum
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kmod_ipstat_dec
parameter_list|(
name|int
name|statnum
parameter_list|)
block|{
name|counter_u64_add
argument_list|(
name|VNET
argument_list|(
name|ipstat
argument_list|)
index|[
name|statnum
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_netinet_intr_queue_maxlen
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qlimit
decl_stmt|;
name|netisr_getqlimit
argument_list|(
operator|&
name|ip_nh
argument_list|,
operator|&
name|qlimit
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qlimit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|qlimit
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|netisr_setqlimit
argument_list|(
operator|&
name|ip_nh
argument_list|,
name|qlimit
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_INTRQMAXLEN
argument_list|,
name|intr_queue_maxlen
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netinet_intr_queue_maxlen
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum size of the IP input queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_netinet_intr_queue_drops
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int64_t
name|qdrops_long
decl_stmt|;
name|int
name|error
decl_stmt|,
name|qdrops
decl_stmt|;
name|netisr_getqdrops
argument_list|(
operator|&
name|ip_nh
argument_list|,
operator|&
name|qdrops_long
argument_list|)
expr_stmt|;
name|qdrops
operator|=
name|qdrops_long
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qdrops
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|qdrops
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|netisr_clearqdrops
argument_list|(
operator|&
name|ip_nh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_INTRQDROPS
argument_list|,
name|intr_queue_drops
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netinet_intr_queue_drops
argument_list|,
literal|"I"
argument_list|,
literal|"Number of packets dropped from the IP input queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_function
specifier|static
name|int
name|sysctl_netinet_intr_direct_queue_maxlen
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|qlimit
decl_stmt|;
name|netisr_getqlimit
argument_list|(
operator|&
name|ip_direct_nh
argument_list|,
operator|&
name|qlimit
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qlimit
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|qlimit
operator|<
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|netisr_setqlimit
argument_list|(
operator|&
name|ip_direct_nh
argument_list|,
name|qlimit
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_INTRQMAXLEN
argument_list|,
name|intr_direct_queue_maxlen
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netinet_intr_direct_queue_maxlen
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum size of the IP direct input queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_netinet_intr_direct_queue_drops
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int64_t
name|qdrops_long
decl_stmt|;
name|int
name|error
decl_stmt|,
name|qdrops
decl_stmt|;
name|netisr_getqdrops
argument_list|(
operator|&
name|ip_direct_nh
argument_list|,
operator|&
name|qdrops_long
argument_list|)
expr_stmt|;
name|qdrops
operator|=
name|qdrops_long
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|qdrops
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|qdrops
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|netisr_clearqdrops
argument_list|(
operator|&
name|ip_direct_nh
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_INTRQDROPS
argument_list|,
name|intr_direct_queue_drops
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_netinet_intr_direct_queue_drops
argument_list|,
literal|"I"
argument_list|,
literal|"Number of packets dropped from the IP direct input queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RSS */
end_comment

begin_comment
comment|/*  * IP initialization: fill in IP protocol switch table.  * All protocols not implemented in kernel go to raw IP protocol handler.  */
end_comment

begin_function
name|void
name|ip_init
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|V_in_ifaddrhead
argument_list|)
expr_stmt|;
name|V_in_ifaddrhashtbl
operator|=
name|hashinit
argument_list|(
name|INADDR_NHASH
argument_list|,
name|M_IFADDR
argument_list|,
operator|&
name|V_in_ifaddrhmask
argument_list|)
expr_stmt|;
comment|/* Initialize IP reassembly queue. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|V_maxnipq
operator|=
name|nmbclusters
operator|/
literal|32
expr_stmt|;
name|V_maxfragsperpacket
operator|=
literal|16
expr_stmt|;
name|V_ipq_zone
operator|=
name|uma_zcreate
argument_list|(
literal|"ipq"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ipq
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|UMA_ALIGN_PTR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|maxnipq_update
argument_list|()
expr_stmt|;
comment|/* Initialize packet filter hooks. */
name|V_inet_pfil_hook
operator|.
name|ph_type
operator|=
name|PFIL_TYPE_AF
expr_stmt|;
name|V_inet_pfil_hook
operator|.
name|ph_af
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|pfil_head_register
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: unable to register pfil hook, "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Skip initialization of globals for non-default instances. */
if|if
condition|(
operator|!
name|IS_DEFAULT_VNET
argument_list|(
name|curvnet
argument_list|)
condition|)
return|return;
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"ip_init: PF_INET not found"
argument_list|)
expr_stmt|;
comment|/* Initialize the entire ip_protox[] array to IPPROTO_RAW. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
name|ip_protox
index|[
name|i
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
comment|/* 	 * Cycle through IP protocols and put them into the appropriate place 	 * in ip_protox[]. 	 */
for|for
control|(
name|pr
operator|=
name|inetdomain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
name|inetdomain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RAW
condition|)
block|{
comment|/* Be careful to only index valid IP protocols. */
if|if
condition|(
name|pr
operator|->
name|pr_protocol
operator|<
name|IPPROTO_MAX
condition|)
name|ip_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
block|}
name|EVENTHANDLER_REGISTER
argument_list|(
name|nmbclusters_change
argument_list|,
name|ipq_zone_change
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
comment|/* Initialize various other remaining things. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
name|IPQ_LOCK_INIT
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|netisr_register
argument_list|(
operator|&
name|ip_nh
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|netisr_register
argument_list|(
operator|&
name|ip_direct_nh
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE
end_ifdef

begin_function
name|void
name|ip_destroy
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|pfil_head_unregister
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
operator|)
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"%s: WARNING: unable to unregister pfil hook, "
literal|"error %d\n"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Cleanup in_ifaddr hash table; should be empty. */
name|hashdestroy
argument_list|(
name|V_in_ifaddrhashtbl
argument_list|,
name|M_IFADDR
argument_list|,
name|V_in_ifaddrhmask
argument_list|)
expr_stmt|;
name|ip_drain_vnet
argument_list|()
expr_stmt|;
name|uma_zdestroy
argument_list|(
name|V_ipq_zone
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RSS
end_ifdef

begin_comment
comment|/*  * IP direct input routine.  *  * This is called when reinjecting completed fragments where  * all of the previous checking and book-keeping has been done.  */
end_comment

begin_function
name|void
name|ip_direct_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|int
name|hlen
decl_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|IPSTAT_INC
argument_list|(
name|ips_delivered
argument_list|)
expr_stmt|;
operator|(
operator|*
name|inetsw
index|[
name|ip_protox
index|[
name|ip
operator|->
name|ip_p
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|hlen
operator|,
name|ip
operator|->
name|ip_p
operator|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Ip input routine.  Checksum and byte swap header.  If fragmented  * try to reassemble.  Process options.  Pass to next level.  */
end_comment

begin_function
name|void
name|ip_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
init|=
name|NULL
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|checkif
decl_stmt|,
name|hlen
init|=
literal|0
decl_stmt|;
name|uint16_t
name|sum
decl_stmt|,
name|ip_len
decl_stmt|;
name|int
name|dchg
init|=
literal|0
decl_stmt|;
comment|/* dest changed after fw */
name|struct
name|in_addr
name|odst
decl_stmt|;
comment|/* original dst address */
name|M_ASSERTPKTHDR
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FASTFWD_OURS
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_FASTFWD_OURS
expr_stmt|;
comment|/* Set up some basics that will be used later. */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
goto|goto
name|ours
goto|;
block|}
name|IPSTAT_INC
argument_list|(
name|ips_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
goto|goto
name|tooshort
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_toosmall
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
name|IPVERSION
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_badvers
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* minimum header length */
name|IPSTAT_INC
argument_list|(
name|ips_badhlen
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_badhlen
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|IP_PROBE
argument_list|(
name|receive
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ip
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|ip
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 127/8 must not appear on wire - RFC1122 */
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
operator|||
operator|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
condition|)
block|{
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_badaddr
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_CHECKED
condition|)
block|{
name|sum
operator|=
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_badsum
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|ALTQ
if|if
condition|(
name|altq_input
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|altq_input
call|)
argument_list|(
name|m
argument_list|,
name|AF_INET
argument_list|)
operator|==
literal|0
condition|)
comment|/* packet is dropped by traffic conditioner */
return|return;
endif|#
directive|endif
name|ip_len
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip_len
operator|<
name|hlen
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_badlen
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ip_len
condition|)
block|{
name|tooshort
label|:
name|IPSTAT_INC
argument_list|(
name|ips_tooshort
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|ip_len
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|ip_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ip_len
expr_stmt|;
block|}
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
name|ip_len
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * Bypass packet filtering for packets previously handled by IPsec. 	 */
if|if
condition|(
name|ip_ipsec_filtertunnel
argument_list|(
name|m
argument_list|)
condition|)
goto|goto
name|passin
goto|;
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 	 * Run through list of hooks for input packets. 	 * 	 * NB: Beware of the destination address changing (e.g. 	 *     by NAT rewriting).  When this happens, tell 	 *     ip_forward to do the right thing. 	 */
comment|/* Jump over all PFIL processing if hooks are not active. */
if|if
condition|(
operator|!
name|PFIL_HOOKED
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|)
condition|)
goto|goto
name|passin
goto|;
name|odst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
if|if
condition|(
name|pfil_run_hooks
argument_list|(
operator|&
name|V_inet_pfil_hook
argument_list|,
operator|&
name|m
argument_list|,
name|ifp
argument_list|,
name|PFIL_IN
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
comment|/* consumed by filter */
return|return;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|dchg
operator|=
operator|(
name|odst
operator|.
name|s_addr
operator|!=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|)
expr_stmt|;
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FASTFWD_OURS
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_FASTFWD_OURS
expr_stmt|;
goto|goto
name|ours
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_IP_NEXTHOP
condition|)
block|{
name|dchg
operator|=
operator|(
name|m_tag_find
argument_list|(
name|m
argument_list|,
name|PACKET_TAG_IPFORWARD
argument_list|,
name|NULL
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|dchg
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Directly ship the packet on.  This allows 			 * forwarding packets originally destined to us 			 * to some other directly connected host. 			 */
name|ip_forward
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|passin
label|:
comment|/* 	 * Process options and, if not destined for us, 	 * ship it on.  ip_dooptions returns 1 when an 	 * error was detected (causing an icmp message 	 * to be sent and the original packet to be freed). 	 */
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
name|ip_dooptions
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
condition|)
return|return;
comment|/* greedy RSVP, snatches any PATH packet of the RSVP protocol and no          * matter if it is destined to another node, or whether it is           * a multicast one, RSVP wants it! and prevents it from being forwarded          * anywhere else. Also checks if the rsvp daemon is running before 	 * grabbing the packet.          */
if|if
condition|(
name|V_rsvp_on
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_RSVP
condition|)
goto|goto
name|ours
goto|;
comment|/* 	 * Check our list of addresses, to see if the packet is for us. 	 * If we don't have any addresses, assume any unicast packet 	 * we receive might be for us (and let the upper layers deal 	 * with it). 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_in_ifaddrhead
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|ours
goto|;
comment|/* 	 * Enable a consistency check between the destination address 	 * and the arrival interface for a unicast packet (the RFC 1122 	 * strong ES model) if IP forwarding is disabled and the packet 	 * is not locally generated and the packet is not subject to 	 * 'ipfw fwd'. 	 * 	 * XXX - Checking also should be disabled if the destination 	 * address is ipnat'ed to a different interface. 	 * 	 * XXX - Checking is incompatible with IP aliases added 	 * to the loopback interface instead of the interface where 	 * the packets are received. 	 * 	 * XXX - This is the case for carp vhost IPs as well so we 	 * insert a workaround. If the packet got here, we already 	 * checked with carp_iamatch() and carp_forus(). 	 */
name|checkif
operator|=
name|V_ip_checkinterface
operator|&&
operator|(
name|V_ipforwarding
operator|==
literal|0
operator|)
operator|&&
name|ifp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
operator|)
operator|&&
name|ifp
operator|->
name|if_carp
operator|==
name|NULL
operator|&&
operator|(
name|dchg
operator|==
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Check for exact addresses in the hash bucket. 	 */
comment|/* IN_IFADDR_RLOCK(); */
name|LIST_FOREACH
argument_list|(
argument|ia
argument_list|,
argument|INADDR_HASH(ip->ip_dst.s_addr)
argument_list|,
argument|ia_hash
argument_list|)
block|{
comment|/* 		 * If the address matches, verify that the packet 		 * arrived via the correct interface if checking is 		 * enabled. 		 */
if|if
condition|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|&&
operator|(
operator|!
name|checkif
operator|||
name|ia
operator|->
name|ia_ifp
operator|==
name|ifp
operator|)
condition|)
block|{
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ipackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ibytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
comment|/* IN_IFADDR_RUNLOCK(); */
goto|goto
name|ours
goto|;
block|}
block|}
comment|/* IN_IFADDR_RUNLOCK(); */
comment|/* 	 * Check for broadcast addresses. 	 * 	 * Only accept broadcast packets that arrive via the matching 	 * interface.  Reception of forwarded directed broadcasts would 	 * be handled via ip_forward() and ether_output() with the loopback 	 * into the stack for SIMPLEX interfaces handled by ether_output(). 	 */
if|if
condition|(
name|ifp
operator|!=
name|NULL
operator|&&
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
name|IF_ADDR_RLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrhead
argument_list|,
argument|ifa_link
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
continue|continue;
name|ia
operator|=
name|ifatoia
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
if|if
condition|(
name|satosin
argument_list|(
operator|&
name|ia
operator|->
name|ia_broadaddr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
block|{
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ipackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ibytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|ours
goto|;
block|}
ifdef|#
directive|ifdef
name|BOOTP_COMPAT
if|if
condition|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ipackets
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|counter_u64_add
argument_list|(
name|ia
operator|->
name|ia_ifa
operator|.
name|ifa_ibytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
goto|goto
name|ours
goto|;
block|}
endif|#
directive|endif
block|}
name|IF_ADDR_RUNLOCK
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ia
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* RFC 3927 2.7: Do not forward datagrams for 169.254.0.0/16. */
if|if
condition|(
name|IN_LINKLOCAL
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_cantforward
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|V_ip_mrouter
condition|)
block|{
comment|/* 			 * If we are acting as a multicast router, all 			 * incoming multicast packets are passed to the 			 * kernel-level multicast forwarding function. 			 * The packet is returned (relatively) intact; if 			 * ip_mforward() returns a non-zero value, the packet 			 * must be discarded, else it may be accepted below. 			 */
if|if
condition|(
name|ip_mforward
operator|&&
name|ip_mforward
argument_list|(
name|ip
argument_list|,
name|ifp
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_cantforward
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * The process-level routing daemon needs to receive 			 * all multicast IGMP packets, whether or not this 			 * host belongs to their destination groups. 			 */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_IGMP
condition|)
goto|goto
name|ours
goto|;
name|IPSTAT_INC
argument_list|(
name|ips_forward
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Assume the packet is for us, to avoid prematurely taking 		 * a lock on the in_multi hash. Protocols must perform 		 * their own filtering and update statistics accordingly. 		 */
goto|goto
name|ours
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
operator|(
name|u_long
operator|)
name|INADDR_BROADCAST
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
goto|goto
name|ours
goto|;
comment|/* 	 * Not for us; forward if possible and desirable. 	 */
if|if
condition|(
name|V_ipforwarding
operator|==
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_cantforward
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip_forward
argument_list|(
name|m
argument_list|,
name|dchg
argument_list|)
expr_stmt|;
block|}
return|return;
name|ours
label|:
ifdef|#
directive|ifdef
name|IPSTEALTH
comment|/* 	 * IPSTEALTH: Process non-routing options only 	 * if the packet is destined for us. 	 */
if|if
condition|(
name|V_ipstealth
operator|&&
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
name|ip_dooptions
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
condition|)
return|return;
endif|#
directive|endif
comment|/* IPSTEALTH */
comment|/* 	 * Attempt reassembly; if it succeeds, proceed. 	 * ip_reass() will return a different mbuf. 	 */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
operator||
name|IP_OFFMASK
argument_list|)
condition|)
block|{
comment|/* XXXGL: shouldn't we save& set m_flags? */
name|m
operator|=
name|ip_reass
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Get the header length of the reassembled packet */
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * enforce IPsec policy checking if we are seeing last header. 	 * note that we do not visit this with protocols with pcb layer 	 * code - like udp/tcp/raw ip. 	 */
if|if
condition|(
name|ip_ipsec_input
argument_list|(
name|m
argument_list|,
name|ip
operator|->
name|ip_p
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 	 * Switch out to protocol's input routine. 	 */
name|IPSTAT_INC
argument_list|(
name|ips_delivered
argument_list|)
expr_stmt|;
operator|(
operator|*
name|inetsw
index|[
name|ip_protox
index|[
name|ip
operator|->
name|ip_p
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
operator|&
name|m
operator|,
operator|&
name|hlen
operator|,
name|ip
operator|->
name|ip_p
operator|)
expr_stmt|;
return|return;
name|bad
label|:
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * After maxnipq has been updated, propagate the change to UMA.  The UMA zone  * max has slightly different semantics than the sysctl, for historical  * reasons.  */
end_comment

begin_function
specifier|static
name|void
name|maxnipq_update
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * -1 for unlimited allocation. 	 */
if|if
condition|(
name|V_maxnipq
operator|<
literal|0
condition|)
name|uma_zone_set_max
argument_list|(
name|V_ipq_zone
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Positive number for specific bound. 	 */
if|if
condition|(
name|V_maxnipq
operator|>
literal|0
condition|)
name|uma_zone_set_max
argument_list|(
name|V_ipq_zone
argument_list|,
name|V_maxnipq
argument_list|)
expr_stmt|;
comment|/* 	 * Zero specifies no further fragment queue allocation -- set the 	 * bound very low, but rely on implementation elsewhere to actually 	 * prevent allocation and reclaim current queues. 	 */
if|if
condition|(
name|V_maxnipq
operator|==
literal|0
condition|)
name|uma_zone_set_max
argument_list|(
name|V_ipq_zone
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ipq_zone_change
parameter_list|(
name|void
modifier|*
name|tag
parameter_list|)
block|{
if|if
condition|(
name|V_maxnipq
operator|>
literal|0
operator|&&
name|V_maxnipq
operator|<
operator|(
name|nmbclusters
operator|/
literal|32
operator|)
condition|)
block|{
name|V_maxnipq
operator|=
name|nmbclusters
operator|/
literal|32
expr_stmt|;
name|maxnipq_update
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sysctl_maxnipq
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|i
operator|=
name|V_maxnipq
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|i
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * XXXRW: Might be a good idea to sanity check the argument and place 	 * an extreme upper bound. 	 */
if|if
condition|(
name|i
operator|<
operator|-
literal|1
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|V_maxnipq
operator|=
name|i
expr_stmt|;
name|maxnipq_update
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|maxfragpackets
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_maxnipq
argument_list|,
literal|"I"
argument_list|,
literal|"Maximum number of IPv4 fragment reassembly queue entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|M_IP_FRAG
value|M_PROTO9
end_define

begin_comment
comment|/*  * Attempt to purge something from the reassembly queue to make  * room.  *  * Must be called without any IPQ locks held, as it will attempt  * to lock each in turn.  *  * 'skip_bucket' is the bucket with which to skip over, or -1 to  * not skip over anything.  *  * Returns the bucket being freed, or -1 for no action.  */
end_comment

begin_function
specifier|static
name|int
name|ip_reass_purge_element
parameter_list|(
name|int
name|skip_bucket
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|ipq
modifier|*
name|r
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|skip_bucket
operator|>
operator|-
literal|1
operator|&&
name|i
operator|==
name|skip_bucket
condition|)
continue|continue;
name|IPQ_LOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|r
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|,
name|ipqhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
condition|)
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragtimeout
argument_list|,
name|r
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|IPQ_UNLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
name|IPQ_UNLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take incoming datagram fragment and try to reassemble it into  * whole datagram.  If the argument is the first fragment or one  * in between the function will return NULL and store the mbuf  * in the fragment chain.  If the argument is the last fragment  * the packet will be reassembled and the pointer to the new  * mbuf returned for further processing.  Only m_tags attached  * to the first packet/fragment are preserved.  * The IP header is *NOT* adjusted out of iplen.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ip_reass
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|nq
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|struct
name|ipq
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|struct
name|ipqhead
modifier|*
name|head
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hlen
decl_stmt|,
name|next
decl_stmt|;
name|u_int8_t
name|ecn
decl_stmt|,
name|ecn0
decl_stmt|;
name|u_short
name|hash
decl_stmt|;
ifdef|#
directive|ifdef
name|RSS
name|uint32_t
name|rss_hash
decl_stmt|,
name|rss_type
decl_stmt|;
endif|#
directive|endif
name|int
name|do_purge
init|=
literal|0
decl_stmt|;
comment|/* If maxnipq or maxfragsperpacket are 0, never accept fragments. */
if|if
condition|(
name|V_maxnipq
operator|==
literal|0
operator|||
name|V_maxfragsperpacket
operator|==
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_fragments
argument_list|)
expr_stmt|;
name|IPSTAT_INC
argument_list|(
name|ips_fragdropped
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
expr_stmt|;
name|hash
operator|=
name|IPREASS_HASH
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|V_ipq
index|[
name|hash
index|]
expr_stmt|;
name|IPQ_LOCK
argument_list|(
name|hash
argument_list|)
expr_stmt|;
comment|/* 	 * Look for queue of fragments 	 * of this datagram. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|fp
argument_list|,
argument|head
argument_list|,
argument|ipq_list
argument_list|)
if|if
condition|(
name|ip
operator|->
name|ip_id
operator|==
name|fp
operator|->
name|ipq_id
operator|&&
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_dst
operator|.
name|s_addr
operator|&&
ifdef|#
directive|ifdef
name|MAC
name|mac_ipq_match
argument_list|(
name|m
argument_list|,
name|fp
argument_list|)
operator|&&
endif|#
directive|endif
name|ip
operator|->
name|ip_p
operator|==
name|fp
operator|->
name|ipq_p
condition|)
goto|goto
name|found
goto|;
name|fp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Attempt to trim the number of allocated fragment queues if it 	 * exceeds the administrative limit. 	 */
if|if
condition|(
operator|(
name|V_nipq
operator|>
name|V_maxnipq
operator|)
operator|&&
operator|(
name|V_maxnipq
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 		 * drop something from the tail of the current queue 		 * before proceeding further 		 */
name|struct
name|ipq
modifier|*
name|q
init|=
name|TAILQ_LAST
argument_list|(
name|head
argument_list|,
name|ipqhead
argument_list|)
decl_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
comment|/* gak */
comment|/* 			 * Defer doing this until later; when the 			 * lock is no longer held. 			 */
name|do_purge
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragtimeout
argument_list|,
name|q
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
name|head
argument_list|,
name|hash
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|found
label|:
comment|/* 	 * Adjust ip_len to not reflect header, 	 * convert offset of this to bytes. 	 */
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
name|htons
argument_list|(
name|IP_MF
argument_list|)
condition|)
block|{
comment|/* 		 * Make sure that fragments have a data length 		 * that's a non-zero multiple of 8 bytes. 		 */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|==
name|htons
argument_list|(
literal|0
argument_list|)
operator|||
operator|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_toosmall
argument_list|)
expr_stmt|;
comment|/* XXX */
goto|goto
name|dropfrag
goto|;
block|}
name|m
operator|->
name|m_flags
operator||=
name|M_IP_FRAG
expr_stmt|;
block|}
else|else
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_IP_FRAG
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|<<
literal|3
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt reassembly; if it succeeds, proceed. 	 * ip_reass() will return a different mbuf. 	 */
name|IPSTAT_INC
argument_list|(
name|ips_fragments
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|PH_loc
operator|.
name|ptr
operator|=
name|ip
expr_stmt|;
comment|/* Previous ip_reass() started here. */
comment|/* 	 * Presence of header sizes in mbufs 	 * would confuse code below. 	 */
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
comment|/* 	 * If first fragment to arrive, create a reassembly queue. 	 */
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|fp
operator|=
name|uma_zalloc
argument_list|(
name|V_ipq_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
goto|goto
name|dropfrag
goto|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|mac_ipq_init
argument_list|(
name|fp
argument_list|,
name|M_NOWAIT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uma_zfree
argument_list|(
name|V_ipq_zone
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|dropfrag
goto|;
block|}
name|mac_ipq_create
argument_list|(
name|m
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|fp
argument_list|,
name|ipq_list
argument_list|)
expr_stmt|;
name|V_nipq
operator|++
expr_stmt|;
name|fp
operator|->
name|ipq_nfrags
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|ipq_ttl
operator|=
name|IPFRAGTTL
expr_stmt|;
name|fp
operator|->
name|ipq_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fp
operator|->
name|ipq_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|fp
operator|->
name|ipq_src
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|fp
operator|->
name|ipq_dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|fp
operator|->
name|ipq_frags
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
else|else
block|{
name|fp
operator|->
name|ipq_nfrags
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_ipq_update
argument_list|(
name|m
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
define|#
directive|define
name|GETIP
parameter_list|(
name|m
parameter_list|)
value|((struct ip*)((m)->m_pkthdr.PH_loc.ptr))
comment|/* 	 * Handle ECN by comparing this segment with the first one; 	 * if CE is set, do not lose CE. 	 * drop if CE and not-ECT are mixed for the same packet. 	 */
name|ecn
operator|=
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_ECN_MASK
expr_stmt|;
name|ecn0
operator|=
name|GETIP
argument_list|(
name|fp
operator|->
name|ipq_frags
argument_list|)
operator|->
name|ip_tos
operator|&
name|IPTOS_ECN_MASK
expr_stmt|;
if|if
condition|(
name|ecn
operator|==
name|IPTOS_ECN_CE
condition|)
block|{
if|if
condition|(
name|ecn0
operator|==
name|IPTOS_ECN_NOTECT
condition|)
goto|goto
name|dropfrag
goto|;
if|if
condition|(
name|ecn0
operator|!=
name|IPTOS_ECN_CE
condition|)
name|GETIP
argument_list|(
name|fp
operator|->
name|ipq_frags
argument_list|)
operator|->
name|ip_tos
operator||=
name|IPTOS_ECN_CE
expr_stmt|;
block|}
if|if
condition|(
name|ecn
operator|==
name|IPTOS_ECN_NOTECT
operator|&&
name|ecn0
operator|!=
name|IPTOS_ECN_NOTECT
condition|)
goto|goto
name|dropfrag
goto|;
comment|/* 	 * Find a segment which begins after this one does. 	 */
for|for
control|(
name|p
operator|=
name|NULL
operator|,
name|q
operator|=
name|fp
operator|->
name|ipq_frags
init|;
name|q
condition|;
name|p
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|m_nextpkt
control|)
if|if
condition|(
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
argument_list|)
operator|>
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
condition|)
break|break;
comment|/* 	 * If there is a preceding segment, it may provide some of 	 * our data already.  If so, drop the data from the incoming 	 * segment.  If it provides all of our data, drop us, otherwise 	 * stick new segment in the proper place. 	 * 	 * If some of the data is dropped from the preceding 	 * segment, then it's checksum is invalidated. 	 */
if|if
condition|(
name|p
condition|)
block|{
name|i
operator|=
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|p
argument_list|)
operator|->
name|ip_off
argument_list|)
operator|+
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|p
argument_list|)
operator|->
name|ip_len
argument_list|)
operator|-
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
condition|)
goto|goto
name|dropfrag
goto|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|p
operator|->
name|m_nextpkt
expr_stmt|;
name|p
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|fp
operator|->
name|ipq_frags
expr_stmt|;
name|fp
operator|->
name|ipq_frags
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * While we overlap succeeding segments trim them or, 	 * if they are completely covered, dequeue them. 	 */
for|for
control|(
init|;
name|q
operator|!=
name|NULL
operator|&&
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|>
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
argument_list|)
condition|;
name|q
operator|=
name|nq
control|)
block|{
name|i
operator|=
operator|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
operator|+
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
operator|)
operator|-
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
argument_list|)
condition|)
block|{
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
argument_list|)
operator|-
name|i
argument_list|)
expr_stmt|;
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
argument_list|)
operator|+
name|i
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|q
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|nq
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|nq
expr_stmt|;
name|IPSTAT_INC
argument_list|(
name|ips_fragdropped
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ipq_nfrags
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check for complete reassembly and perform frag per packet 	 * limiting. 	 * 	 * Frag limiting is performed here so that the nth frag has 	 * a chance to complete the packet before we drop the packet. 	 * As a result, n+1 frags are actually allowed per packet, but 	 * only n will ever be stored. (n = maxfragsperpacket.) 	 * 	 */
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|NULL
operator|,
name|q
operator|=
name|fp
operator|->
name|ipq_frags
init|;
name|q
condition|;
name|p
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|m_nextpkt
control|)
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
argument_list|)
operator|!=
name|next
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|ipq_nfrags
operator|>
name|V_maxfragsperpacket
condition|)
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragdropped
argument_list|,
name|fp
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
name|head
argument_list|,
name|hash
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
name|next
operator|+=
name|ntohs
argument_list|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the last packet didn't have the IP_MF flag */
if|if
condition|(
name|p
operator|->
name|m_flags
operator|&
name|M_IP_FRAG
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|ipq_nfrags
operator|>
name|V_maxfragsperpacket
condition|)
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragdropped
argument_list|,
name|fp
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
name|head
argument_list|,
name|hash
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Reassembly is complete.  Make sure the packet is a sane size. 	 */
name|q
operator|=
name|fp
operator|->
name|ipq_frags
expr_stmt|;
name|ip
operator|=
name|GETIP
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_toolong
argument_list|)
expr_stmt|;
name|IPSTAT_ADD
argument_list|(
name|ips_fragdropped
argument_list|,
name|fp
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
name|head
argument_list|,
name|hash
argument_list|,
name|fp
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Concatenate fragments. 	 */
name|m
operator|=
name|q
expr_stmt|;
name|t
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nq
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|q
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|q
operator|=
name|nq
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|nq
control|)
block|{
name|nq
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|q
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
name|q
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+=
name|q
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * In order to do checksumming faster we do 'end-around carry' here 	 * (and not in for{} loop), though it implies we are not going to 	 * reassemble more than 64k fragments. 	 */
while|while
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|&
literal|0xffff0000
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|&
literal|0xffff
operator|)
operator|+
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|>>
literal|16
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|mac_ipq_reassemble
argument_list|(
name|fp
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mac_ipq_destroy
argument_list|(
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Create header for new ip packet by modifying header of first 	 * packet;  dequeue and discard fragment reassembly header. 	 * Make header visible. 	 */
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|+
name|next
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|fp
operator|->
name|ipq_src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|fp
operator|->
name|ipq_dst
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|fp
argument_list|,
name|ipq_list
argument_list|)
expr_stmt|;
name|V_nipq
operator|--
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_ipq_zone
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* some debugging cruft by sklower, below, will go away soon */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
comment|/* XXX this should be done elsewhere */
name|m_fixhdr
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IPSTAT_INC
argument_list|(
name|ips_reassembled
argument_list|)
expr_stmt|;
name|IPQ_UNLOCK
argument_list|(
name|hash
argument_list|)
expr_stmt|;
comment|/* 	 * Do the delayed purge to keep fragment counts under 	 * the configured maximum. 	 * 	 * This is delayed so that it's not done with another IPQ bucket 	 * lock held. 	 * 	 * Note that we pass in the bucket to /skip/ over, not 	 * the bucket to /purge/. 	 */
if|if
condition|(
name|do_purge
condition|)
name|ip_reass_purge_element
argument_list|(
name|hash
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RSS
comment|/* 	 * Query the RSS layer for the flowid / flowtype for the 	 * mbuf payload. 	 * 	 * For now, just assume we have to calculate a new one. 	 * Later on we should check to see if the assigned flowid matches 	 * what RSS wants for the given IP protocol and if so, just keep it. 	 * 	 * We then queue into the relevant netisr so it can be dispatched 	 * to the correct CPU. 	 * 	 * Note - this may return 1, which means the flowid in the mbuf 	 * is correct for the configured RSS hash types and can be used. 	 */
if|if
condition|(
name|rss_mbuf_software_hash_v4
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
operator|&
name|rss_hash
argument_list|,
operator|&
name|rss_type
argument_list|)
operator|==
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|rss_hash
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|rss_type
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Queue/dispatch for reprocessing. 	 * 	 * Note: this is much slower than just handling the frame in the 	 * current receive context.  It's likely worth investigating 	 * why this is. 	 */
name|netisr_dispatch
argument_list|(
name|NETISR_IP_DIRECT
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
comment|/* Handle in-line */
return|return
operator|(
name|m
operator|)
return|;
name|dropfrag
label|:
name|IPSTAT_INC
argument_list|(
name|ips_fragdropped
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
name|fp
operator|->
name|ipq_nfrags
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|done
label|:
name|IPQ_UNLOCK
argument_list|(
name|hash
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
undef|#
directive|undef
name|GETIP
block|}
end_function

begin_comment
comment|/*  * Free a fragment reassembly header and all  * associated datagrams.  */
end_comment

begin_function
specifier|static
name|void
name|ip_freef
parameter_list|(
name|struct
name|ipqhead
modifier|*
name|fhp
parameter_list|,
name|int
name|i
parameter_list|,
name|struct
name|ipq
modifier|*
name|fp
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|q
decl_stmt|;
name|IPQ_LOCK_ASSERT
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|fp
operator|->
name|ipq_frags
condition|)
block|{
name|q
operator|=
name|fp
operator|->
name|ipq_frags
expr_stmt|;
name|fp
operator|->
name|ipq_frags
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
name|fhp
argument_list|,
name|fp
argument_list|,
name|ipq_list
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|V_ipq_zone
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|V_nipq
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IP timer processing;  * if a timer expires on a reassembly  * queue, discard it.  */
end_comment

begin_function
name|void
name|ip_slowtimo
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|IPQ_LOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
init|;
name|fp
condition|;
control|)
block|{
name|struct
name|ipq
modifier|*
name|fpp
decl_stmt|;
name|fpp
operator|=
name|fp
expr_stmt|;
name|fp
operator|=
name|TAILQ_NEXT
argument_list|(
name|fp
argument_list|,
name|ipq_list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|fpp
operator|->
name|ipq_ttl
operator|==
literal|0
condition|)
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragtimeout
argument_list|,
name|fpp
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|fpp
argument_list|)
expr_stmt|;
block|}
block|}
name|IPQ_UNLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we are over the maximum number of fragments 		 * (due to the limit being lowered), drain off 		 * enough to get down to the new limit. 		 */
if|if
condition|(
name|V_maxnipq
operator|>=
literal|0
operator|&&
name|V_nipq
operator|>
name|V_maxnipq
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|IPQ_LOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
name|V_nipq
operator|>
name|V_maxnipq
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragdropped
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IPQ_UNLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain off all datagram fragments.  */
end_comment

begin_function
specifier|static
name|void
name|ip_drain_vnet
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|IPQ_LOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|IPSTAT_ADD
argument_list|(
name|ips_fragdropped
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
operator|->
name|ipq_nfrags
argument_list|)
expr_stmt|;
name|ip_freef
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|,
name|i
argument_list|,
name|TAILQ_FIRST
argument_list|(
operator|&
name|V_ipq
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IPQ_UNLOCK
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ip_drain
parameter_list|(
name|void
parameter_list|)
block|{
name|VNET_ITERATOR_DECL
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|VNET_LIST_RLOCK_NOSLEEP
argument_list|()
expr_stmt|;
name|VNET_FOREACH
argument_list|(
argument|vnet_iter
argument_list|)
block|{
name|CURVNET_SET
argument_list|(
name|vnet_iter
argument_list|)
expr_stmt|;
name|ip_drain_vnet
argument_list|()
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
name|VNET_LIST_RUNLOCK_NOSLEEP
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The protocol to be inserted into ip_protox[] must be already registered  * in inetsw[], either statically or through pf_proto_register().  */
end_comment

begin_function
name|int
name|ipproto_register
parameter_list|(
name|short
name|ipproto
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
comment|/* Sanity checks. */
if|if
condition|(
name|ipproto
operator|<=
literal|0
operator|||
name|ipproto
operator|>=
name|IPPROTO_MAX
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
comment|/* 	 * The protocol slot must not be occupied by another protocol 	 * already.  An index pointing to IPPROTO_RAW is unused. 	 */
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPFNOSUPPORT
operator|)
return|;
if|if
condition|(
name|ip_protox
index|[
name|ipproto
index|]
operator|!=
name|pr
operator|-
name|inetsw
condition|)
comment|/* IPPROTO_RAW */
return|return
operator|(
name|EEXIST
operator|)
return|;
comment|/* Find the protocol position in inetsw[] and set the index. */
for|for
control|(
name|pr
operator|=
name|inetdomain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
name|inetdomain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
block|{
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|==
name|ipproto
condition|)
block|{
name|ip_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ipproto_unregister
parameter_list|(
name|short
name|ipproto
parameter_list|)
block|{
name|struct
name|protosw
modifier|*
name|pr
decl_stmt|;
comment|/* Sanity checks. */
if|if
condition|(
name|ipproto
operator|<=
literal|0
operator|||
name|ipproto
operator|>=
name|IPPROTO_MAX
condition|)
return|return
operator|(
name|EPROTONOSUPPORT
operator|)
return|;
comment|/* Check if the protocol was indeed registered. */
name|pr
operator|=
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
name|NULL
condition|)
return|return
operator|(
name|EPFNOSUPPORT
operator|)
return|;
if|if
condition|(
name|ip_protox
index|[
name|ipproto
index|]
operator|==
name|pr
operator|-
name|inetsw
condition|)
comment|/* IPPROTO_RAW */
return|return
operator|(
name|ENOENT
operator|)
return|;
comment|/* Reset the protocol slot to IPPROTO_RAW. */
name|ip_protox
index|[
name|ipproto
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given address of next destination (final or next hop), return (referenced)  * internet address info of interface to be used to get there.  */
end_comment

begin_function
name|struct
name|in_ifaddr
modifier|*
name|ip_rtaddr
parameter_list|(
name|struct
name|in_addr
name|dst
parameter_list|,
name|u_int
name|fibnum
parameter_list|)
block|{
name|struct
name|route
name|sro
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sro
argument_list|,
sizeof|sizeof
argument_list|(
name|sro
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sro
operator|.
name|ro_dst
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|dst
expr_stmt|;
name|in_rtalloc_ign
argument_list|(
operator|&
name|sro
argument_list|,
literal|0
argument_list|,
name|fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|sro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ia
operator|=
name|ifatoia
argument_list|(
name|sro
operator|.
name|ro_rt
operator|->
name|rt_ifa
argument_list|)
expr_stmt|;
name|ifa_ref
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|RTFREE
argument_list|(
name|sro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ia
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|u_char
name|inetctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EMSGSIZE
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
name|ENOPROTOOPT
block|,
name|ECONNREFUSED
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward a packet.  If some error occurs return the sender  * an icmp packet.  Note we can't always generate a meaningful  * icmp message because icmp doesn't have a large enough repertoire  * of codes and types.  *  * If not forwarding, just drop the packet.  This could be confusing  * if ipforwarding was zero but some routing protocol was advancing  * us as a gateway to somewhere.  However, we must let the routing  * protocol deal with that.  *  * The srcrt parameter indicates whether the packet is being forwarded  * via a source route.  */
end_comment

begin_function
name|void
name|ip_forward
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|srcrt
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcopy
decl_stmt|;
name|struct
name|in_addr
name|dest
decl_stmt|;
name|struct
name|route
name|ro
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|,
name|code
init|=
literal|0
decl_stmt|,
name|mtu
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|||
name|in_canforward
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_cantforward
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IPSEC
if|if
condition|(
name|ip_ipsec_fwd
argument_list|(
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IPSTAT_INC
argument_list|(
name|ips_cantforward
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* IPSEC */
ifdef|#
directive|ifdef
name|IPSTEALTH
if|if
condition|(
operator|!
name|V_ipstealth
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
name|IPTTLDEC
condition|)
block|{
name|icmp_error
argument_list|(
name|m
argument_list|,
name|ICMP_TIMXCEED
argument_list|,
name|ICMP_TIMXCEED_INTRANS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IPSTEALTH
block|}
endif|#
directive|endif
name|ia
operator|=
name|ip_rtaddr
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC
comment|/* 	 * 'ia' may be NULL if there is no route for this destination. 	 * In case of IPsec, Don't discard it just yet, but pass it to 	 * ip_output in case of outgoing IPsec policy. 	 */
if|if
condition|(
operator|!
name|srcrt
operator|&&
name|ia
operator|==
name|NULL
condition|)
block|{
name|icmp_error
argument_list|(
name|m
argument_list|,
name|ICMP_UNREACH
argument_list|,
name|ICMP_UNREACH_HOST
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Save the IP header and at most 8 bytes of the payload, 	 * in case we need to generate an ICMP message to the src. 	 * 	 * XXX this can be optimized a lot by saving the data in a local 	 * buffer on the stack (72 bytes at most), and only allocating the 	 * mbuf if really necessary. The vast majority of the packets 	 * are forwarded without having to send an ICMP back (either 	 * because unnecessary, or because rate limited), so we are 	 * really we are wasting a lot of work here. 	 * 	 * We don't use m_copy() because it might return a reference 	 * to a shared cluster. Both this function and ip_output() 	 * assume exclusive access to the IP header in `m', so any 	 * data in a cluster may change before we reach icmp_error(). 	 */
name|mcopy
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcopy
operator|!=
name|NULL
operator|&&
operator|!
name|m_dup_pkthdr
argument_list|(
name|mcopy
argument_list|,
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
condition|)
block|{
comment|/* 		 * It's probably ok if the pkthdr dup fails (because 		 * the deep copy of the tag chain failed), but for now 		 * be conservative and just discard the copy since 		 * code below may some day want the tags. 		 */
name|m_free
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
name|mcopy
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mcopy
operator|!=
name|NULL
condition|)
block|{
name|mcopy
operator|->
name|m_len
operator|=
name|min
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
argument_list|,
name|M_TRAILINGSPACE
argument_list|(
name|mcopy
argument_list|)
argument_list|)
expr_stmt|;
name|mcopy
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|mcopy
operator|->
name|m_len
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|mcopy
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|mcopy
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSTEALTH
if|if
condition|(
operator|!
name|V_ipstealth
condition|)
block|{
endif|#
directive|endif
name|ip
operator|->
name|ip_ttl
operator|-=
name|IPTTLDEC
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSTEALTH
block|}
endif|#
directive|endif
comment|/* 	 * If forwarding packet using same interface that it came in on, 	 * perhaps should send a redirect to sender to shortcut a hop. 	 * Only send redirect if source is sending directly to us, 	 * and if packet was not source routed (or has any options). 	 * Also, don't send redirect if forwarding using a default route 	 * or a route modified by a redirect. 	 */
name|dest
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|srcrt
operator|&&
name|V_ipsendredirects
operator|&&
name|ia
operator|!=
name|NULL
operator|&&
name|ia
operator|->
name|ia_ifp
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|.
name|ro_dst
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|in_rtalloc_ign
argument_list|(
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|M_GETFIB
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|ro
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
operator|)
operator|==
literal|0
operator|&&
name|satosin
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
define|#
directive|define
name|RTA
parameter_list|(
name|rt
parameter_list|)
value|((struct in_ifaddr *)(rt->rt_ifa))
name|u_long
name|src
init|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|RTA
argument_list|(
name|rt
argument_list|)
operator|&&
operator|(
name|src
operator|&
name|RTA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_subnetmask
operator|)
operator|==
name|RTA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_subnet
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|dest
operator|.
name|s_addr
operator|=
name|satosin
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
name|dest
operator|.
name|s_addr
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/* Router requirements says to only send host redirects */
name|type
operator|=
name|ICMP_REDIRECT
expr_stmt|;
name|code
operator|=
name|ICMP_REDIRECT_HOST
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
condition|)
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try to cache the route MTU from ip_output so we can consider it for 	 * the ICMP_UNREACH_NEEDFRAG "Next-Hop MTU" field described in RFC1191. 	 */
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
operator|&
name|ro
argument_list|,
name|IP_FORWARDING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EMSGSIZE
operator|&&
name|ro
operator|.
name|ro_rt
condition|)
name|mtu
operator|=
name|ro
operator|.
name|ro_rt
operator|->
name|rt_mtu
expr_stmt|;
name|RO_RTFREE
argument_list|(
operator|&
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|IPSTAT_INC
argument_list|(
name|ips_cantforward
argument_list|)
expr_stmt|;
else|else
block|{
name|IPSTAT_INC
argument_list|(
name|ips_forward
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|IPSTAT_INC
argument_list|(
name|ips_redirectsent
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mcopy
condition|)
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|mcopy
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* forwarded, but need redirect */
comment|/* type, code set above */
break|break;
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|EHOSTDOWN
case|:
default|default:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
break|break;
case|case
name|EMSGSIZE
case|:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_NEEDFRAG
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
comment|/*  		 * If IPsec is configured for this path, 		 * override any possibly mtu value set by ip_output. 		 */
name|mtu
operator|=
name|ip_ipsec_mtu
argument_list|(
name|mcopy
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 		 * If the MTU was set before make sure we are below the 		 * interface MTU. 		 * If the MTU wasn't set before use the interface mtu or 		 * fall back to the next smaller mtu step compared to the 		 * current packet size. 		 */
if|if
condition|(
name|mtu
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|mtu
operator|=
name|min
argument_list|(
name|mtu
argument_list|,
name|ia
operator|->
name|ia_ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|mtu
operator|=
name|ia
operator|->
name|ia_ifp
operator|->
name|if_mtu
expr_stmt|;
else|else
name|mtu
operator|=
name|ip_next_mtu
argument_list|(
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|IPSTAT_INC
argument_list|(
name|ips_cantfrag
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENOBUFS
case|:
case|case
name|EACCES
case|:
comment|/* ipfw denied packet */
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
name|ifa_free
argument_list|(
operator|&
name|ia
operator|->
name|ia_ifa
argument_list|)
expr_stmt|;
name|icmp_error
argument_list|(
name|mcopy
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|dest
operator|.
name|s_addr
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ip_savecontrol
parameter_list|(
name|struct
name|inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
operator|(
name|SO_BINTIME
operator||
name|SO_TIMESTAMP
operator|)
condition|)
block|{
name|struct
name|bintime
name|bt
decl_stmt|;
name|bintime
argument_list|(
operator|&
name|bt
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_BINTIME
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|bt
argument_list|,
sizeof|sizeof
argument_list|(
name|bt
argument_list|)
argument_list|,
name|SCM_BINTIME
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_TIMESTAMP
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|bintime2timeval
argument_list|(
operator|&
name|bt
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVDSTADDR
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IP_RECVDSTADDR
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVTTL
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|ip_ttl
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
name|IP_RECVTTL
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX 	 * Moving these out of udp_input() made them even more broken 	 * than they already were. 	 */
comment|/* options were tossed already */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVOPTS
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|opts_deleted_above
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IP_RECVOPTS
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* ip_srcroute doesn't do what we want here, need to fix */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVRETOPTS
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip_srcroute
argument_list|(
name|m
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IP_RECVRETOPTS
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVIF
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
struct|struct
name|sdlbuf
block|{
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|u_char
name|pad
index|[
literal|32
index|]
decl_stmt|;
block|}
name|sdlbuf
struct|;
name|struct
name|sockaddr_dl
modifier|*
name|sdp
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl2
init|=
operator|&
name|sdlbuf
operator|.
name|sdl
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
operator|&&
name|ifp
operator|->
name|if_index
operator|&&
name|ifp
operator|->
name|if_index
operator|<=
name|V_if_index
condition|)
block|{
name|sdp
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
name|ifp
operator|->
name|if_addr
operator|->
name|ifa_addr
expr_stmt|;
comment|/* 			 * Change our mind and don't try copy. 			 */
if|if
condition|(
name|sdp
operator|->
name|sdl_family
operator|!=
name|AF_LINK
operator|||
name|sdp
operator|->
name|sdl_len
operator|>
sizeof|sizeof
argument_list|(
name|sdlbuf
argument_list|)
condition|)
block|{
goto|goto
name|makedummy
goto|;
block|}
name|bcopy
argument_list|(
name|sdp
argument_list|,
name|sdl2
argument_list|,
name|sdp
operator|->
name|sdl_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|makedummy
label|:
name|sdl2
operator|->
name|sdl_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|,
name|sdl_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sdl2
operator|->
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|sdl2
operator|->
name|sdl_index
operator|=
literal|0
expr_stmt|;
name|sdl2
operator|->
name|sdl_nlen
operator|=
name|sdl2
operator|->
name|sdl_alen
operator|=
name|sdl2
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdl2
argument_list|,
name|sdl2
operator|->
name|sdl_len
argument_list|,
name|IP_RECVIF
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVTOS
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|ip_tos
argument_list|,
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|,
name|IP_RECVTOS
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_RECVFLOWID
condition|)
block|{
name|uint32_t
name|flowid
decl_stmt|,
name|flow_type
decl_stmt|;
name|flowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|flow_type
operator|=
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * XXX should handle the failure of one or the 		 * other - don't populate both? 		 */
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|flowid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|IP_FLOWID
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|flow_type
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|IP_FLOWTYPE
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|RSS
if|if
condition|(
name|inp
operator|->
name|inp_flags2
operator|&
name|INP_RECVRSSBUCKETID
condition|)
block|{
name|uint32_t
name|flowid
decl_stmt|,
name|flow_type
decl_stmt|;
name|uint32_t
name|rss_bucketid
decl_stmt|;
name|flowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|flow_type
operator|=
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rss_hash2bucket
argument_list|(
name|flowid
argument_list|,
name|flow_type
argument_list|,
operator|&
name|rss_bucketid
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|rss_bucketid
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|IP_RSSBUCKETID
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * XXXRW: Multicast routing code in ip_mroute.c is generally MPSAFE, but the  * ip_rsvp and ip_rsvp_on variables need to be interlocked with rsvp_on  * locking.  This code remains in ip_input.c as ip_mroute.c is optionally  * compiled.  */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|int
argument_list|,
name|ip_rsvp_on
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|VNET_DEFINE
argument_list|(
expr|struct
name|socket
operator|*
argument_list|,
name|ip_rsvpd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_ip_rsvp_on
value|VNET(ip_rsvp_on)
end_define

begin_function
name|int
name|ip_rsvp_init
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RSVP
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
name|V_ip_rsvpd
operator|!=
name|NULL
condition|)
return|return
name|EADDRINUSE
return|;
name|V_ip_rsvpd
operator|=
name|so
expr_stmt|;
comment|/* 	 * This may seem silly, but we need to be sure we don't over-increment 	 * the RSVP counter, in case something slips up. 	 */
if|if
condition|(
operator|!
name|V_ip_rsvp_on
condition|)
block|{
name|V_ip_rsvp_on
operator|=
literal|1
expr_stmt|;
name|V_rsvp_on
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ip_rsvp_done
parameter_list|(
name|void
parameter_list|)
block|{
name|V_ip_rsvpd
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This may seem silly, but we need to be sure we don't over-decrement 	 * the RSVP counter, in case something slips up. 	 */
if|if
condition|(
name|V_ip_rsvp_on
condition|)
block|{
name|V_ip_rsvp_on
operator|=
literal|0
expr_stmt|;
name|V_rsvp_on
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rsvp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rsvp_input_p
condition|)
block|{
comment|/* call the real one if loaded */
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|rsvp_input_p
argument_list|(
name|mp
argument_list|,
name|offp
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* Can still get packets with rsvp_on = 0 if there is a local member 	 * of the group to which the RSVP packet is addressed.  But in this 	 * case we want to throw the packet away. 	 */
if|if
condition|(
operator|!
name|V_rsvp_on
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
if|if
condition|(
name|V_ip_rsvpd
operator|!=
name|NULL
condition|)
block|{
operator|*
name|mp
operator|=
name|m
expr_stmt|;
name|rip_input
argument_list|(
name|mp
argument_list|,
name|offp
argument_list|,
name|proto
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
comment|/* Drop the packet */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

end_unit

