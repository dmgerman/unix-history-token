begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)ip_input.c	8.2 (Berkeley) 1/4/94  * $FreeBSD$  */
end_comment

begin_define
define|#
directive|define
name|_IP_VHL
end_define

begin_include
include|#
directive|include
file|"opt_bootp.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipfw.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipdn.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipdivert.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipfilter.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipstealth.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_random_ip_id.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/netisr.h>
end_include

begin_include
include|#
directive|include
file|<net/intrq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ipprotosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_fw.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"faith.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NFAITH
argument_list|)
operator|&&
name|NFAITH
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DUMMYNET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip_dummynet.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|rsvp_on
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_rsvp_on
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|socket
modifier|*
name|ip_rsvpd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ipforwarding
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_FORWARDING
argument_list|,
name|forwarding
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipforwarding
argument_list|,
literal|0
argument_list|,
literal|"Enable IP forwarding between interfaces"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ipsendredirects
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_SENDREDIRECTS
argument_list|,
name|redirect
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipsendredirects
argument_list|,
literal|0
argument_list|,
literal|"Enable sending IP redirects"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|ip_defttl
init|=
name|IPDEFTTL
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_DEFTTL
argument_list|,
name|ttl
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_defttl
argument_list|,
literal|0
argument_list|,
literal|"Maximum TTL on IP packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_dosourceroute
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_SOURCEROUTE
argument_list|,
name|sourceroute
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_dosourceroute
argument_list|,
literal|0
argument_list|,
literal|"Enable forwarding source routed IP packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_acceptsourceroute
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_ACCEPTSOURCEROUTE
argument_list|,
name|accept_sourceroute
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_acceptsourceroute
argument_list|,
literal|0
argument_list|,
literal|"Enable accepting source routed IP packets"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_keepfaith
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_KEEPFAITH
argument_list|,
name|keepfaith
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_keepfaith
argument_list|,
literal|0
argument_list|,
literal|"Enable packet capture for FAITH IPv4->IPv6 translater daemon"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_nfragpackets
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_maxfragpackets
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initialized in ip_init() */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|maxfragpackets
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_maxfragpackets
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of IPv4 fragment reassembly queue entries"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * XXX - Setting ip_checkinterface mostly implements the receive side of  * the Strong ES model described in RFC 1122, but since the routing table  * and transmit implementation do not implement the Strong ES model,  * setting this to 1 results in an odd hybrid.  *  * XXX - ip_checkinterface currently must be disabled if you use ipnat  * to translate the destination address to another local interface.  *  * XXX - ip_checkinterface must be disabled if you add IP aliases  * to the loopback interface instead of the interface where the  * packets for those addresses are received.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ip_checkinterface
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|check_interface
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_checkinterface
argument_list|,
literal|0
argument_list|,
literal|"Verify packet arrives on correct interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DIAGNOSTIC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ipprintfs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|domain
name|inetdomain
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|ipprotosw
name|inetsw
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ip_protox
index|[
name|IPPROTO_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ipqmaxlen
init|=
name|IFQ_MAXLEN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|in_ifaddrhead
name|in_ifaddrhead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* first inet address */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_INTRQMAXLEN
argument_list|,
name|intr_queue_maxlen
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipintrq
operator|.
name|ifq_maxlen
argument_list|,
literal|0
argument_list|,
literal|"Maximum size of the IP input queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_INTRQDROPS
argument_list|,
name|intr_queue_drops
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ipintrq
operator|.
name|ifq_drops
argument_list|,
literal|0
argument_list|,
literal|"Number of packets dropped from the IP input queue"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|ipstat
name|ipstat
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_STRUCT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_STATS
argument_list|,
name|stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|ipstat
argument_list|,
name|ipstat
argument_list|,
literal|"IP statistics (struct ipstat, netinet/ip_var.h)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Packet reassembly stuff */
end_comment

begin_define
define|#
directive|define
name|IPREASS_NHASH_LOG2
value|6
end_define

begin_define
define|#
directive|define
name|IPREASS_NHASH
value|(1<< IPREASS_NHASH_LOG2)
end_define

begin_define
define|#
directive|define
name|IPREASS_HMASK
value|(IPREASS_NHASH - 1)
end_define

begin_define
define|#
directive|define
name|IPREASS_HASH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|(((((x)& 0xF) | ((((x)>> 8)& 0xF)<< 4)) ^ (y))& IPREASS_HMASK)
end_define

begin_decl_stmt
specifier|static
name|struct
name|ipq
name|ipq
index|[
name|IPREASS_NHASH
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nipq
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total # of reass queues */
end_comment

begin_decl_stmt
specifier|static
name|int
name|maxnipq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|ipintrq_present
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPCTL_DEFMTU
end_ifdef

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|IPCTL_DEFMTU
argument_list|,
name|mtu
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ip_mtu
argument_list|,
literal|0
argument_list|,
literal|"Default MTU"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPSTEALTH
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ipstealth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_inet_ip
argument_list|,
name|OID_AUTO
argument_list|,
name|stealth
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ipstealth
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Firewall hooks */
end_comment

begin_decl_stmt
name|ip_fw_chk_t
modifier|*
name|ip_fw_chk_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ip_fw_ctl_t
modifier|*
name|ip_fw_ctl_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fw_enable
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DUMMYNET
end_ifdef

begin_decl_stmt
name|ip_dn_ctl_t
modifier|*
name|ip_dn_ctl_ptr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|int
argument_list|(
argument|*fr_checkp
argument_list|)
end_macro

begin_expr_stmt
name|__P
argument_list|(
operator|(
expr|struct
name|ip
operator|*
operator|,
name|int
operator|,
expr|struct
name|ifnet
operator|*
operator|,
name|int
operator|,
expr|struct
name|mbuf
operator|*
operator|*
operator|)
argument_list|)
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * We need to save the IP options in case a protocol wants to respond  * to an incoming packet over the same route if the packet got here  * using IP source routing.  This allows connection establishment and  * maintenance when the remote end is on a network that is not known  * to us.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ip_nhops
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|ip_srcrt
block|{
name|struct
name|in_addr
name|dst
decl_stmt|;
comment|/* final destination */
name|char
name|nop
decl_stmt|;
comment|/* one NOP to align */
name|char
name|srcopt
index|[
name|IPOPT_OFFSET
operator|+
literal|1
index|]
decl_stmt|;
comment|/* OPTVAL, OLEN and OFFSET */
name|struct
name|in_addr
name|route
index|[
name|MAX_IPOPTLEN
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
index|]
decl_stmt|;
block|}
name|ip_srcrt
struct|;
end_struct

begin_decl_stmt
name|struct
name|sockaddr_in
modifier|*
name|ip_fw_fwd_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|save_rte
name|__P
argument_list|(
operator|(
name|u_char
operator|*
operator|,
expr|struct
name|in_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ip_dooptions
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip_forward
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ip_freef
name|__P
argument_list|(
operator|(
expr|struct
name|ipq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IPDIVERT
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ip_reass
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|ipq
operator|*
operator|,
expr|struct
name|ipq
operator|*
operator|,
name|u_int32_t
operator|*
operator|,
name|u_int16_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|mbuf
modifier|*
name|ip_reass
name|__P
argument_list|(
operator|(
expr|struct
name|mbuf
operator|*
operator|,
expr|struct
name|ipq
operator|*
operator|,
expr|struct
name|ipq
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|in_ifaddr
modifier|*
name|ip_rtaddr
name|__P
argument_list|(
operator|(
expr|struct
name|in_addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|ipintr
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * IP initialization: fill in IP protocol switch table.  * All protocols not implemented in kernel go to raw IP protocol handler.  */
end_comment

begin_function
name|void
name|ip_init
parameter_list|()
block|{
specifier|register
name|struct
name|ipprotosw
modifier|*
name|pr
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|in_ifaddrhead
argument_list|)
expr_stmt|;
name|pr
operator|=
operator|(
expr|struct
name|ipprotosw
operator|*
operator|)
name|pffindproto
argument_list|(
name|PF_INET
argument_list|,
name|IPPROTO_RAW
argument_list|,
name|SOCK_RAW
argument_list|)
expr_stmt|;
if|if
condition|(
name|pr
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ip_init"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPPROTO_MAX
condition|;
name|i
operator|++
control|)
name|ip_protox
index|[
name|i
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
for|for
control|(
name|pr
operator|=
operator|(
expr|struct
name|ipprotosw
operator|*
operator|)
name|inetdomain
operator|.
name|dom_protosw
init|;
name|pr
operator|<
operator|(
expr|struct
name|ipprotosw
operator|*
operator|)
name|inetdomain
operator|.
name|dom_protoswNPROTOSW
condition|;
name|pr
operator|++
control|)
if|if
condition|(
name|pr
operator|->
name|pr_domain
operator|->
name|dom_family
operator|==
name|PF_INET
operator|&&
name|pr
operator|->
name|pr_protocol
operator|&&
name|pr
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RAW
condition|)
name|ip_protox
index|[
name|pr
operator|->
name|pr_protocol
index|]
operator|=
name|pr
operator|-
name|inetsw
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
name|ipq
index|[
name|i
index|]
operator|.
name|next
operator|=
name|ipq
index|[
name|i
index|]
operator|.
name|prev
operator|=
operator|&
name|ipq
index|[
name|i
index|]
expr_stmt|;
name|maxnipq
operator|=
name|nmbclusters
operator|/
literal|4
expr_stmt|;
name|ip_maxfragpackets
operator|=
name|nmbclusters
operator|/
literal|4
expr_stmt|;
ifndef|#
directive|ifndef
name|RANDOM_IP_ID
name|ip_id
operator|=
name|time_second
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
name|ipintrq
operator|.
name|ifq_maxlen
operator|=
name|ipqmaxlen
expr_stmt|;
name|register_netisr
argument_list|(
name|NETISR_IP
argument_list|,
name|ipintr
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|ipaddr
init|=
block|{
sizeof|sizeof
argument_list|(
name|ipaddr
argument_list|)
block|,
name|AF_INET
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|route
name|ipforward_rt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Ip input routine.  Checksum and byte swap header.  If fragmented  * try to reassemble.  Process options.  Pass to next level.  */
end_comment

begin_function
name|void
name|ip_input
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|struct
name|in_ifaddr
modifier|*
name|ia
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|hlen
decl_stmt|,
name|mff
decl_stmt|,
name|checkif
decl_stmt|;
name|u_short
name|sum
decl_stmt|;
name|u_int16_t
name|divert_cookie
decl_stmt|;
comment|/* firewall cookie */
name|struct
name|in_addr
name|pkt_dst
decl_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
name|u_int32_t
name|divert_info
init|=
literal|0
decl_stmt|;
comment|/* packet divert/tee info */
endif|#
directive|endif
name|struct
name|ip_fw_chain
modifier|*
name|rule
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
comment|/* Get and reset firewall cookie */
name|divert_cookie
operator|=
name|ip_divert_cookie
expr_stmt|;
name|ip_divert_cookie
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|divert_cookie
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IPFIREWALL
argument_list|)
operator|&&
name|defined
argument_list|(
name|DUMMYNET
argument_list|)
comment|/*          * dummynet packet are prepended a vestigial mbuf with          * m_type = MT_DUMMYNET and m_data pointing to the matching          * rule.          */
if|if
condition|(
name|m
operator|->
name|m_type
operator|==
name|MT_DUMMYNET
condition|)
block|{
name|rule
operator|=
operator|(
expr|struct
name|ip_fw_chain
operator|*
operator|)
operator|(
name|m
operator|->
name|m_data
operator|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|hlen
operator|=
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
expr_stmt|;
goto|goto
name|iphack
goto|;
block|}
else|else
name|rule
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|m
operator|==
name|NULL
operator|||
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"ip_input no HDR"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ipstat
operator|.
name|ips_total
operator|++
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
goto|goto
name|tooshort
goto|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_toosmall
operator|++
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|IP_VHL_V
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|!=
name|IPVERSION
condition|)
block|{
name|ipstat
operator|.
name|ips_badvers
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|hlen
operator|=
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
expr_stmt|;
if|if
condition|(
name|hlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
comment|/* minimum header length */
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|hlen
operator|>
name|m
operator|->
name|m_len
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_badhlen
operator|++
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* 127/8 must not appear on wire - RFC1122 */
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
operator|||
operator|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
operator|>>
name|IN_CLASSA_NSHIFT
operator|)
operator|==
name|IN_LOOPBACKNET
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_badaddr
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_CHECKED
condition|)
block|{
name|sum
operator|=
operator|!
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_IP_VALID
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
block|{
name|sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sum
condition|)
block|{
name|ipstat
operator|.
name|ips_badsum
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Convert fields to host representation. 	 */
name|NTOHS
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|<
name|hlen
condition|)
block|{
name|ipstat
operator|.
name|ips_badlen
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|NTOHS
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the amount of data in the buffers 	 * is as at least much as the IP header would have us expect. 	 * Trim mbufs if longer than we expect. 	 * Drop packet if shorter than we expect. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
name|ip
operator|->
name|ip_len
condition|)
block|{
name|tooshort
label|:
name|ipstat
operator|.
name|ips_tooshort
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|ip
operator|->
name|ip_len
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|m_len
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|len
condition|)
block|{
name|m
operator|->
name|m_len
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
block|}
else|else
name|m_adj
argument_list|(
name|m
argument_list|,
name|ip
operator|->
name|ip_len
operator|-
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
if|if
condition|(
name|ipsec_gethist
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|pass
goto|;
endif|#
directive|endif
comment|/* 	 * IpHack's section. 	 * Right now when no processing on packet has done 	 * and it is still fresh out of network we do our black 	 * deals with it. 	 * - Firewall: deny/allow/divert 	 * - Xlate: translate packet's addr/port (NAT). 	 * - Pipe: pass pkt through dummynet. 	 * - Wrap: fake packet's addr/port<unimpl.> 	 * - Encapsulate: put it in another IP and send out.<unimp.>  	 */
if|#
directive|if
name|defined
argument_list|(
name|IPFIREWALL
argument_list|)
operator|&&
name|defined
argument_list|(
name|DUMMYNET
argument_list|)
name|iphack
label|:
endif|#
directive|endif
comment|/* 	 * Check if we want to allow this packet to be processed. 	 * Consider it to be bad if not. 	 */
if|if
condition|(
name|fr_checkp
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m1
init|=
name|m
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|fr_checkp
call|)
argument_list|(
name|ip
argument_list|,
name|hlen
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
literal|0
argument_list|,
operator|&
name|m1
argument_list|)
operator|||
operator|!
name|m1
condition|)
return|return;
name|ip
operator|=
name|mtod
argument_list|(
name|m
operator|=
name|m1
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fw_enable
operator|&&
name|ip_fw_chk_ptr
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
comment|/* 		 * If we've been forwarded from the output side, then 		 * skip the firewall a second time 		 */
if|if
condition|(
name|ip_fw_fwd_addr
condition|)
goto|goto
name|ours
goto|;
endif|#
directive|endif
comment|/* IPFIREWALL_FORWARD */
comment|/* 		 * See the comment in ip_output for the return values 		 * produced by the firewall. 		 */
name|i
operator|=
call|(
modifier|*
name|ip_fw_chk_ptr
call|)
argument_list|(
operator|&
name|ip
argument_list|,
name|hlen
argument_list|,
name|NULL
argument_list|,
operator|&
name|divert_cookie
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|rule
argument_list|,
operator|&
name|ip_fw_fwd_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|&
name|IP_FW_PORT_DENY_FLAG
operator|)
operator|||
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* drop */
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return ;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* just in case m changed */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ip_fw_fwd_addr
operator|==
name|NULL
condition|)
comment|/* common case */
goto|goto
name|pass
goto|;
ifdef|#
directive|ifdef
name|DUMMYNET
if|if
condition|(
operator|(
name|i
operator|&
name|IP_FW_PORT_DYNT_FLAG
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Send packet to the appropriate pipe */
name|dummynet_io
argument_list|(
name|i
operator|&
literal|0xffff
argument_list|,
name|DN_TO_IP_IN
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|rule
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPDIVERT
if|if
condition|(
name|i
operator|!=
literal|0
operator|&&
operator|(
name|i
operator|&
name|IP_FW_PORT_DYNT_FLAG
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Divert or tee packet */
name|divert_info
operator|=
name|i
expr_stmt|;
goto|goto
name|ours
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|ip_fw_fwd_addr
operator|!=
name|NULL
condition|)
goto|goto
name|pass
goto|;
endif|#
directive|endif
comment|/* 		 * if we get here, the packet must be dropped 		 */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|pass
label|:
comment|/* 	 * Process options and, if not destined for us, 	 * ship it on.  ip_dooptions returns 1 when an 	 * error was detected (causing an icmp message 	 * to be sent and the original packet to be freed). 	 */
name|ip_nhops
operator|=
literal|0
expr_stmt|;
comment|/* for source routed packets */
if|if
condition|(
name|hlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|&&
name|ip_dooptions
argument_list|(
name|m
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
name|ip_fw_fwd_addr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* greedy RSVP, snatches any PATH packet of the RSVP protocol and no          * matter if it is destined to another node, or whether it is           * a multicast one, RSVP wants it! and prevents it from being forwarded          * anywhere else. Also checks if the rsvp daemon is running before 	 * grabbing the packet.          */
if|if
condition|(
name|rsvp_on
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_RSVP
condition|)
goto|goto
name|ours
goto|;
comment|/* 	 * Check our list of addresses, to see if the packet is for us. 	 * If we don't have any addresses, assume any unicast packet 	 * we receive might be for us (and let the upper layers deal 	 * with it). 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|in_ifaddrhead
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|ours
goto|;
comment|/* 	 * Cache the destination address of the packet; this may be 	 * changed by use of 'ipfw fwd'. 	 */
name|pkt_dst
operator|=
name|ip_fw_fwd_addr
operator|==
name|NULL
condition|?
name|ip
operator|->
name|ip_dst
else|:
name|ip_fw_fwd_addr
operator|->
name|sin_addr
expr_stmt|;
comment|/* 	 * Enable a consistency check between the destination address 	 * and the arrival interface for a unicast packet (the RFC 1122 	 * strong ES model) if IP forwarding is disabled and the packet 	 * is not locally generated and the packet is not subject to 	 * 'ipfw fwd'. 	 * 	 * XXX - Checking also should be disabled if the destination 	 * address is ipnat'ed to a different interface. 	 * 	 * XXX - Checking is incompatible with IP aliases added 	 * to the loopback interface instead of the interface where 	 * the packets are received. 	 */
name|checkif
operator|=
name|ip_checkinterface
operator|&&
operator|(
name|ipforwarding
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_flags
operator|&
name|IFF_LOOPBACK
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ip_fw_fwd_addr
operator|==
name|NULL
operator|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ia
argument_list|,
argument|&in_ifaddrhead
argument_list|,
argument|ia_link
argument_list|)
block|{
define|#
directive|define
name|satosin
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
ifdef|#
directive|ifdef
name|BOOTP_COMPAT
if|if
condition|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
goto|goto
name|ours
goto|;
endif|#
directive|endif
comment|/* 		 * If the address matches, verify that the packet 		 * arrived via the correct interface if checking is 		 * enabled. 		 */
if|if
condition|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|pkt_dst
operator|.
name|s_addr
operator|&&
operator|(
operator|!
name|checkif
operator|||
name|ia
operator|->
name|ia_ifp
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
condition|)
goto|goto
name|ours
goto|;
comment|/* 		 * Only accept broadcast packets that arrive via the 		 * matching interface.  Reception of forwarded directed 		 * broadcasts would be handled via ip_forward() and 		 * ether_output() with the loopback into the stack for 		 * SIMPLEX interfaces handled by ether_output(). 		 */
if|if
condition|(
name|ia
operator|->
name|ia_ifp
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|&&
name|ia
operator|->
name|ia_ifp
operator|&&
name|ia
operator|->
name|ia_ifp
operator|->
name|if_flags
operator|&
name|IFF_BROADCAST
condition|)
block|{
if|if
condition|(
name|satosin
argument_list|(
operator|&
name|ia
operator|->
name|ia_broadaddr
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|pkt_dst
operator|.
name|s_addr
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
name|ia
operator|->
name|ia_netbroadcast
operator|.
name|s_addr
operator|==
name|pkt_dst
operator|.
name|s_addr
condition|)
goto|goto
name|ours
goto|;
block|}
block|}
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|struct
name|in_multi
modifier|*
name|inm
decl_stmt|;
if|if
condition|(
name|ip_mrouter
condition|)
block|{
comment|/* 			 * If we are acting as a multicast router, all 			 * incoming multicast packets are passed to the 			 * kernel-level multicast forwarding function. 			 * The packet is returned (relatively) intact; if 			 * ip_mforward() returns a non-zero value, the packet 			 * must be discarded, else it may be accepted below. 			 */
if|if
condition|(
name|ip_mforward
argument_list|(
name|ip
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 			 * The process-level routing demon needs to receive 			 * all multicast IGMP packets, whether or not this 			 * host belongs to their destination groups. 			 */
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_IGMP
condition|)
goto|goto
name|ours
goto|;
name|ipstat
operator|.
name|ips_forward
operator|++
expr_stmt|;
block|}
comment|/* 		 * See if we belong to the destination multicast group on the 		 * arrival interface. 		 */
name|IN_LOOKUP_MULTI
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|,
name|inm
argument_list|)
expr_stmt|;
if|if
condition|(
name|inm
operator|==
name|NULL
condition|)
block|{
name|ipstat
operator|.
name|ips_notmember
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|ours
goto|;
block|}
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
operator|(
name|u_long
operator|)
name|INADDR_BROADCAST
condition|)
goto|goto
name|ours
goto|;
if|if
condition|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
goto|goto
name|ours
goto|;
if|#
directive|if
name|defined
argument_list|(
name|NFAITH
argument_list|)
operator|&&
literal|0
operator|<
name|NFAITH
comment|/* 	 * FAITH(Firewall Aided Internet Translator) 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|&&
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_type
operator|==
name|IFT_FAITH
condition|)
block|{
if|if
condition|(
name|ip_keepfaith
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_TCP
operator|||
name|ip
operator|->
name|ip_p
operator|==
name|IPPROTO_ICMP
condition|)
goto|goto
name|ours
goto|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* 	 * Not for us; forward if possible and desirable. 	 */
if|if
condition|(
name|ipforwarding
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|ip_forward
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
name|ip_fw_fwd_addr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return;
name|ours
label|:
comment|/* Count the packet in the ip address stats */
if|if
condition|(
name|ia
operator|!=
name|NULL
condition|)
block|{
name|ia
operator|->
name|ia_ifa
operator|.
name|if_ipackets
operator|++
expr_stmt|;
name|ia
operator|->
name|ia_ifa
operator|.
name|if_ibytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
comment|/* 	 * If offset or IP_MF are set, must reassemble. 	 * Otherwise, nothing need be done. 	 * (We could look in the reassembly queue to see 	 * if the packet was previously fragmented, 	 * but it's not worth the time; just let them time out.) 	 */
if|if
condition|(
name|ip
operator|->
name|ip_off
operator|&
operator|(
name|IP_MF
operator||
name|IP_OFFMASK
operator||
name|IP_RF
operator|)
condition|)
block|{
if|#
directive|if
literal|0
comment|/* 	 * Reassembly should be able to treat a mbuf cluster, for later 	 * operation of contiguous protocol headers on the cluster. (KAME) 	 */
block|if (m->m_flags& M_EXT) {
comment|/* XXX */
block|if ((m = m_pullup(m, hlen)) == 0) { 				ipstat.ips_toosmall++;
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
block|ip_fw_fwd_addr = NULL;
endif|#
directive|endif
block|return; 			} 			ip = mtod(m, struct ip *); 		}
endif|#
directive|endif
name|sum
operator|=
name|IPREASS_HASH
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_id
argument_list|)
expr_stmt|;
comment|/* 		 * Look for queue of fragments 		 * of this datagram. 		 */
for|for
control|(
name|fp
operator|=
name|ipq
index|[
name|sum
index|]
operator|.
name|next
init|;
name|fp
operator|!=
operator|&
name|ipq
index|[
name|sum
index|]
condition|;
name|fp
operator|=
name|fp
operator|->
name|next
control|)
if|if
condition|(
name|ip
operator|->
name|ip_id
operator|==
name|fp
operator|->
name|ipq_id
operator|&&
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_src
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|==
name|fp
operator|->
name|ipq_dst
operator|.
name|s_addr
operator|&&
name|ip
operator|->
name|ip_p
operator|==
name|fp
operator|->
name|ipq_p
condition|)
goto|goto
name|found
goto|;
name|fp
operator|=
literal|0
expr_stmt|;
comment|/* check if there's a place for the new queue */
if|if
condition|(
name|nipq
operator|>
name|maxnipq
condition|)
block|{
comment|/* 		     * drop something from the tail of the current queue 		     * before proceeding further 		     */
if|if
condition|(
name|ipq
index|[
name|sum
index|]
operator|.
name|prev
operator|==
operator|&
name|ipq
index|[
name|sum
index|]
condition|)
block|{
comment|/* gak */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ipq
index|[
name|i
index|]
operator|.
name|prev
operator|!=
operator|&
name|ipq
index|[
name|i
index|]
condition|)
block|{
name|ip_freef
argument_list|(
name|ipq
index|[
name|i
index|]
operator|.
name|prev
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|ip_freef
argument_list|(
name|ipq
index|[
name|sum
index|]
operator|.
name|prev
argument_list|)
expr_stmt|;
block|}
name|found
label|:
comment|/* 		 * Adjust ip_len to not reflect header, 		 * set ip_mff if more fragments are expected, 		 * convert offset of this to bytes. 		 */
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
name|mff
operator|=
operator|(
name|ip
operator|->
name|ip_off
operator|&
name|IP_MF
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|mff
condition|)
block|{
comment|/* 		         * Make sure that fragments have a data length 			 * that's a non-zero multiple of 8 bytes. 		         */
if|if
condition|(
name|ip
operator|->
name|ip_len
operator|==
literal|0
operator|||
operator|(
name|ip
operator|->
name|ip_len
operator|&
literal|0x7
operator|)
operator|!=
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_toosmall
operator|++
expr_stmt|;
comment|/* XXX */
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_flags
operator||=
name|M_FRAG
expr_stmt|;
block|}
name|ip
operator|->
name|ip_off
operator|<<=
literal|3
expr_stmt|;
comment|/* 		 * If datagram marked as having more fragments 		 * or if this is not the first fragment, 		 * attempt reassembly; if it succeeds, proceed. 		 */
if|if
condition|(
name|mff
operator|||
name|ip
operator|->
name|ip_off
condition|)
block|{
name|ipstat
operator|.
name|ips_fragments
operator|++
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|header
operator|=
name|ip
expr_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
name|m
operator|=
name|ip_reass
argument_list|(
name|m
argument_list|,
name|fp
argument_list|,
operator|&
name|ipq
index|[
name|sum
index|]
argument_list|,
operator|&
name|divert_info
argument_list|,
operator|&
name|divert_cookie
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|=
name|ip_reass
argument_list|(
name|m
argument_list|,
name|fp
argument_list|,
operator|&
name|ipq
index|[
name|sum
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
name|ip_fw_fwd_addr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
name|ipstat
operator|.
name|ips_reassembled
operator|++
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Get the header length of the reassembled packet */
name|hlen
operator|=
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
comment|/* Restore original checksum before diverting packet */
if|if
condition|(
name|divert_info
operator|!=
literal|0
condition|)
block|{
name|ip
operator|->
name|ip_len
operator|+=
name|hlen
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hlen
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
condition|)
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum_hdr
argument_list|(
name|ip
argument_list|)
expr_stmt|;
else|else
name|ip
operator|->
name|ip_sum
operator|=
name|in_cksum
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
name|NTOHS
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|fp
condition|)
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|ip
operator|->
name|ip_len
operator|-=
name|hlen
expr_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
comment|/* 	 * Divert or tee packet to the divert protocol if required. 	 * 	 * If divert_info is zero then cookie should be too, so we shouldn't 	 * need to clear them here.  Assume divert_packet() does so also. 	 */
if|if
condition|(
name|divert_info
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|clone
init|=
name|NULL
decl_stmt|;
comment|/* Clone packet if we're doing a 'tee' */
if|if
condition|(
operator|(
name|divert_info
operator|&
name|IP_FW_PORT_TEE_FLAG
operator|)
operator|!=
literal|0
condition|)
name|clone
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
comment|/* Restore packet header fields to original values */
name|ip
operator|->
name|ip_len
operator|+=
name|hlen
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|HTONS
argument_list|(
name|ip
operator|->
name|ip_off
argument_list|)
expr_stmt|;
comment|/* Deliver packet to divert input routine */
name|ip_divert_cookie
operator|=
name|divert_cookie
expr_stmt|;
name|divert_packet
argument_list|(
name|m
argument_list|,
literal|1
argument_list|,
name|divert_info
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
name|ipstat
operator|.
name|ips_delivered
operator|++
expr_stmt|;
comment|/* If 'tee', continue with original packet */
if|if
condition|(
name|clone
operator|==
name|NULL
condition|)
return|return;
name|m
operator|=
name|clone
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * enforce IPsec policy checking if we are seeing last header. 	 * note that we do not visit this with protocols with pcb layer 	 * code - like udp/tcp/raw ip. 	 */
if|if
condition|(
operator|(
name|inetsw
index|[
name|ip_protox
index|[
name|ip
operator|->
name|ip_p
index|]
index|]
operator|.
name|pr_flags
operator|&
name|PR_LASTHDR
operator|)
operator|!=
literal|0
operator|&&
name|ipsec4_in_reject
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ipsecstat
operator|.
name|in_polvio
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* 	 * Switch out to protocol's input routine. 	 */
name|ipstat
operator|.
name|ips_delivered
operator|++
expr_stmt|;
block|{
name|int
name|off
init|=
name|hlen
decl_stmt|,
name|nh
init|=
name|ip
operator|->
name|ip_p
decl_stmt|;
operator|(
operator|*
name|inetsw
index|[
name|ip_protox
index|[
name|ip
operator|->
name|ip_p
index|]
index|]
operator|.
name|pr_input
operator|)
operator|(
name|m
operator|,
name|off
operator|,
name|nh
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
name|ip_fw_fwd_addr
operator|=
name|NULL
expr_stmt|;
comment|/* tcp needed it */
endif|#
directive|endif
return|return;
block|}
name|bad
label|:
ifdef|#
directive|ifdef
name|IPFIREWALL_FORWARD
name|ip_fw_fwd_addr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IP software interrupt routine - to go away sometime soon  */
end_comment

begin_function
specifier|static
name|void
name|ipintr
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
name|IF_DEQUEUE
argument_list|(
operator|&
name|ipintrq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return;
name|ip_input
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take incoming datagram fragment and try to reassemble it into  * whole datagram.  If a chain for reassembly of this datagram already  * exists, then it is given as fp; otherwise have to make a chain.  *  * When IPDIVERT enabled, keep additional state with each packet that  * tells us if we need to divert or tee the packet we're building.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
ifdef|#
directive|ifdef
name|IPDIVERT
name|ip_reass
parameter_list|(
name|m
parameter_list|,
name|fp
parameter_list|,
name|where
parameter_list|,
name|divinfo
parameter_list|,
name|divcookie
parameter_list|)
else|#
directive|else
function|ip_reass
parameter_list|(
name|m
parameter_list|,
name|fp
parameter_list|,
name|where
parameter_list|)
endif|#
directive|endif
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|struct
name|ipq
modifier|*
name|where
decl_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
name|u_int32_t
modifier|*
name|divinfo
decl_stmt|;
name|u_int16_t
modifier|*
name|divcookie
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|p
init|=
literal|0
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|nq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|t
decl_stmt|;
name|int
name|hlen
init|=
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|next
decl_stmt|;
comment|/* 	 * Presence of header sizes in mbufs 	 * would confuse code below. 	 */
name|m
operator|->
name|m_data
operator|+=
name|hlen
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|hlen
expr_stmt|;
comment|/* 	 * If first fragment to arrive, create a reassembly queue. 	 */
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Enforce upper bound on number of fragmented packets 		 * for which we attempt reassembly; 		 * If maxfrag is 0, never accept fragments. 		 * If maxfrag is -1, accept all fragments without limitation. 		 */
if|if
condition|(
operator|(
name|ip_maxfragpackets
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ip_nfragpackets
operator|>=
name|ip_maxfragpackets
operator|)
condition|)
goto|goto
name|dropfrag
goto|;
name|ip_nfragpackets
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_FTABLE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|dropfrag
goto|;
name|fp
operator|=
name|mtod
argument_list|(
name|t
argument_list|,
expr|struct
name|ipq
operator|*
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|fp
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|nipq
operator|++
expr_stmt|;
name|fp
operator|->
name|ipq_ttl
operator|=
name|IPFRAGTTL
expr_stmt|;
name|fp
operator|->
name|ipq_p
operator|=
name|ip
operator|->
name|ip_p
expr_stmt|;
name|fp
operator|->
name|ipq_id
operator|=
name|ip
operator|->
name|ip_id
expr_stmt|;
name|fp
operator|->
name|ipq_src
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|fp
operator|->
name|ipq_dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|fp
operator|->
name|ipq_frags
operator|=
name|m
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|IPDIVERT
name|fp
operator|->
name|ipq_div_info
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|ipq_div_cookie
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
goto|goto
name|inserted
goto|;
block|}
define|#
directive|define
name|GETIP
parameter_list|(
name|m
parameter_list|)
value|((struct ip*)((m)->m_pkthdr.header))
comment|/* 	 * Find a segment which begins after this one does. 	 */
for|for
control|(
name|p
operator|=
name|NULL
operator|,
name|q
operator|=
name|fp
operator|->
name|ipq_frags
init|;
name|q
condition|;
name|p
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|m_nextpkt
control|)
if|if
condition|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
operator|>
name|ip
operator|->
name|ip_off
condition|)
break|break;
comment|/* 	 * If there is a preceding segment, it may provide some of 	 * our data already.  If so, drop the data from the incoming 	 * segment.  If it provides all of our data, drop us, otherwise 	 * stick new segment in the proper place. 	 * 	 * If some of the data is dropped from the the preceding 	 * segment, then it's checksum is invalidated. 	 */
if|if
condition|(
name|p
condition|)
block|{
name|i
operator|=
name|GETIP
argument_list|(
name|p
argument_list|)
operator|->
name|ip_off
operator|+
name|GETIP
argument_list|(
name|p
argument_list|)
operator|->
name|ip_len
operator|-
name|ip
operator|->
name|ip_off
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|ip
operator|->
name|ip_len
condition|)
goto|goto
name|dropfrag
goto|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|p
operator|->
name|m_nextpkt
expr_stmt|;
name|p
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|m
operator|->
name|m_nextpkt
operator|=
name|fp
operator|->
name|ipq_frags
expr_stmt|;
name|fp
operator|->
name|ipq_frags
operator|=
name|m
expr_stmt|;
block|}
comment|/* 	 * While we overlap succeeding segments trim them or, 	 * if they are completely covered, dequeue them. 	 */
for|for
control|(
init|;
name|q
operator|!=
name|NULL
operator|&&
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|>
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
condition|;
name|q
operator|=
name|nq
control|)
block|{
name|i
operator|=
operator|(
name|ip
operator|->
name|ip_off
operator|+
name|ip
operator|->
name|ip_len
operator|)
operator|-
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
condition|)
block|{
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
operator|-=
name|i
expr_stmt|;
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
operator|+=
name|i
expr_stmt|;
name|m_adj
argument_list|(
name|q
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|q
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|nq
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|nq
expr_stmt|;
name|m_freem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|inserted
label|:
ifdef|#
directive|ifdef
name|IPDIVERT
comment|/* 	 * Transfer firewall instructions to the fragment structure. 	 * Any fragment diverting causes the whole packet to divert. 	 */
name|fp
operator|->
name|ipq_div_info
operator|=
operator|*
name|divinfo
expr_stmt|;
name|fp
operator|->
name|ipq_div_cookie
operator|=
operator|*
name|divcookie
expr_stmt|;
operator|*
name|divinfo
operator|=
literal|0
expr_stmt|;
operator|*
name|divcookie
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Check for complete reassembly. 	 */
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|p
operator|=
name|NULL
operator|,
name|q
operator|=
name|fp
operator|->
name|ipq_frags
init|;
name|q
condition|;
name|p
operator|=
name|q
operator|,
name|q
operator|=
name|q
operator|->
name|m_nextpkt
control|)
block|{
if|if
condition|(
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_off
operator|!=
name|next
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|next
operator|+=
name|GETIP
argument_list|(
name|q
argument_list|)
operator|->
name|ip_len
expr_stmt|;
block|}
comment|/* Make sure the last packet didn't have the IP_MF flag */
if|if
condition|(
name|p
operator|->
name|m_flags
operator|&
name|M_FRAG
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Reassembly is complete.  Make sure the packet is a sane size. 	 */
name|q
operator|=
name|fp
operator|->
name|ipq_frags
expr_stmt|;
name|ip
operator|=
name|GETIP
argument_list|(
name|q
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|+
operator|(
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
operator|)
operator|>
name|IP_MAXPACKET
condition|)
block|{
name|ipstat
operator|.
name|ips_toolong
operator|++
expr_stmt|;
name|ip_freef
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Concatenate fragments. 	 */
name|m
operator|=
name|q
expr_stmt|;
name|t
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
literal|0
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|nq
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|q
operator|->
name|m_nextpkt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|nq
init|;
name|q
operator|!=
name|NULL
condition|;
name|q
operator|=
name|nq
control|)
block|{
name|nq
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|q
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&=
name|q
operator|->
name|m_pkthdr
operator|.
name|csum_flags
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|+=
name|q
operator|->
name|m_pkthdr
operator|.
name|csum_data
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPDIVERT
comment|/* 	 * Extract firewall instructions from the fragment structure. 	 */
operator|*
name|divinfo
operator|=
name|fp
operator|->
name|ipq_div_info
expr_stmt|;
operator|*
name|divcookie
operator|=
name|fp
operator|->
name|ipq_div_cookie
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Create header for new ip packet by 	 * modifying header of first packet; 	 * dequeue and discard fragment reassembly header. 	 * Make header visible. 	 */
name|ip
operator|->
name|ip_len
operator|=
name|next
expr_stmt|;
name|ip
operator|->
name|ip_src
operator|=
name|fp
operator|->
name|ipq_src
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|=
name|fp
operator|->
name|ipq_dst
expr_stmt|;
name|remque
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|nipq
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|ip_nfragpackets
operator|--
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
operator|(
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|-=
operator|(
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
operator|)
expr_stmt|;
comment|/* some debugging cruft by sklower, below, will go away soon */
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
block|{
comment|/* XXX this should be done elsewhere */
specifier|register
name|int
name|plen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|t
operator|=
name|m
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|m_next
control|)
name|plen
operator|+=
name|t
operator|->
name|m_len
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|plen
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
name|dropfrag
label|:
ifdef|#
directive|ifdef
name|IPDIVERT
operator|*
name|divinfo
operator|=
literal|0
expr_stmt|;
operator|*
name|divcookie
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|ipstat
operator|.
name|ips_fragdropped
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|GETIP
block|}
end_function

begin_comment
comment|/*  * Free a fragment reassembly header and all  * associated datagrams.  */
end_comment

begin_function
specifier|static
name|void
name|ip_freef
parameter_list|(
name|fp
parameter_list|)
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|q
decl_stmt|;
while|while
condition|(
name|fp
operator|->
name|ipq_frags
condition|)
block|{
name|q
operator|=
name|fp
operator|->
name|ipq_frags
expr_stmt|;
name|fp
operator|->
name|ipq_frags
operator|=
name|q
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
name|remque
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_free
argument_list|(
name|dtom
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
name|ip_nfragpackets
operator|--
expr_stmt|;
name|nipq
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IP timer processing;  * if a timer expires on a reassembly  * queue, discard it.  */
end_comment

begin_function
name|void
name|ip_slowtimo
parameter_list|()
block|{
specifier|register
name|struct
name|ipq
modifier|*
name|fp
decl_stmt|;
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
name|fp
operator|=
name|ipq
index|[
name|i
index|]
operator|.
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|==
literal|0
condition|)
continue|continue;
while|while
condition|(
name|fp
operator|!=
operator|&
name|ipq
index|[
name|i
index|]
condition|)
block|{
operator|--
name|fp
operator|->
name|ipq_ttl
expr_stmt|;
name|fp
operator|=
name|fp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|prev
operator|->
name|ipq_ttl
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_fragtimeout
operator|++
expr_stmt|;
name|ip_freef
argument_list|(
name|fp
operator|->
name|prev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we are over the maximum number of fragments 	 * (due to the limit being lowered), drain off 	 * enough to get down to the new limit. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ip_maxfragpackets
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
operator|(
name|ip_nfragpackets
operator|>
name|ip_maxfragpackets
operator|)
operator|&&
operator|(
name|ipq
index|[
name|i
index|]
operator|.
name|next
operator|!=
operator|&
name|ipq
index|[
name|i
index|]
operator|)
condition|)
block|{
name|ipstat
operator|.
name|ips_fragdropped
operator|++
expr_stmt|;
name|ip_freef
argument_list|(
name|ipq
index|[
name|i
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|ipflow_slowtimo
argument_list|()
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Drain off all datagram fragments.  */
end_comment

begin_function
name|void
name|ip_drain
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IPREASS_NHASH
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
name|ipq
index|[
name|i
index|]
operator|.
name|next
operator|!=
operator|&
name|ipq
index|[
name|i
index|]
condition|)
block|{
name|ipstat
operator|.
name|ips_fragdropped
operator|++
expr_stmt|;
name|ip_freef
argument_list|(
name|ipq
index|[
name|i
index|]
operator|.
name|next
argument_list|)
expr_stmt|;
block|}
block|}
name|in_rtqdrain
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do option processing on a datagram,  * possibly discarding it if bad options are encountered,  * or forwarding it if source-routed.  * Returns 1 if packet has been forwarded/freed,  * 0 if the packet should be processed further.  */
end_comment

begin_function
specifier|static
name|int
name|ip_dooptions
parameter_list|(
name|m
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|ip_timestamp
modifier|*
name|ipt
decl_stmt|;
specifier|register
name|struct
name|in_ifaddr
modifier|*
name|ia
decl_stmt|;
name|int
name|opt
decl_stmt|,
name|optlen
decl_stmt|,
name|cnt
decl_stmt|,
name|off
decl_stmt|,
name|code
decl_stmt|,
name|type
init|=
name|ICMP_PARAMPROB
decl_stmt|,
name|forward
init|=
literal|0
decl_stmt|;
name|struct
name|in_addr
modifier|*
name|sin
decl_stmt|,
name|dst
decl_stmt|;
name|n_time
name|ntime
decl_stmt|;
name|dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|(
name|ip
operator|+
literal|1
operator|)
expr_stmt|;
name|cnt
operator|=
operator|(
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|optlen
operator|,
name|cp
operator|+=
name|optlen
control|)
block|{
name|opt
operator|=
name|cp
index|[
name|IPOPT_OPTVAL
index|]
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|IPOPT_EOL
condition|)
break|break;
if|if
condition|(
name|opt
operator|==
name|IPOPT_NOP
condition|)
name|optlen
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|cnt
operator|<
name|IPOPT_OLEN
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OLEN
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|optlen
operator|=
name|cp
index|[
name|IPOPT_OLEN
index|]
expr_stmt|;
if|if
condition|(
name|optlen
operator|<
name|IPOPT_OLEN
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
operator|||
name|optlen
operator|>
name|cnt
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OLEN
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
default|default:
break|break;
comment|/* 		 * Source routing with record. 		 * Find interface with current destination address. 		 * If none on this machine then drop if strictly routed, 		 * or do nothing if loosely routed. 		 * Record interface address and bring up next address 		 * component.  If strictly routed make sure next 		 * address is on directly accessible net. 		 */
case|case
name|IPOPT_LSRR
case|:
case|case
name|IPOPT_SSRR
case|:
if|if
condition|(
name|optlen
operator|<
name|IPOPT_OFFSET
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OLEN
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|off
operator|=
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|)
operator|<
name|IPOPT_MINOFF
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ipaddr
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|ia
operator|=
operator|(
expr|struct
name|in_ifaddr
operator|*
operator|)
name|ifa_ifwithaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ipaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt
operator|==
name|IPOPT_SSRR
condition|)
block|{
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_SRCFAIL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|!
name|ip_dosourceroute
condition|)
goto|goto
name|nosourcerouting
goto|;
comment|/* 				 * Loose routing, and not at next destination 				 * yet; nothing to do except forward. 				 */
break|break;
block|}
name|off
operator|--
expr_stmt|;
comment|/* 0 origin */
if|if
condition|(
name|off
operator|>
name|optlen
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
comment|/* 				 * End of source route.  Should be for us. 				 */
if|if
condition|(
operator|!
name|ip_acceptsourceroute
condition|)
goto|goto
name|nosourcerouting
goto|;
name|save_rte
argument_list|(
name|cp
argument_list|,
name|ip
operator|->
name|ip_src
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ip_dosourceroute
condition|)
block|{
if|if
condition|(
name|ipforwarding
condition|)
block|{
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* aaa.bbb.ccc.ddd\0 */
comment|/* 					 * Acting as a router, so generate ICMP 					 */
name|nosourcerouting
label|:
name|strcpy
argument_list|(
name|buf
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
argument_list|)
expr_stmt|;
name|log
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"attempted source route from %s to %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|ip
operator|->
name|ip_src
argument_list|)
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_SRCFAIL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* 					 * Not acting as a router, so silently drop. 					 */
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 			 * locate outgoing interface 			 */
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|ipaddr
operator|.
name|sin_addr
argument_list|,
name|cp
operator|+
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt
operator|==
name|IPOPT_SSRR
condition|)
block|{
define|#
directive|define
name|INA
value|struct in_ifaddr *
define|#
directive|define
name|SA
value|struct sockaddr *
if|if
condition|(
operator|(
name|ia
operator|=
operator|(
name|INA
operator|)
name|ifa_ifwithdstaddr
argument_list|(
operator|(
name|SA
operator|)
operator|&
name|ipaddr
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|ia
operator|=
operator|(
name|INA
operator|)
name|ifa_ifwithnet
argument_list|(
operator|(
name|SA
operator|)
operator|&
name|ipaddr
argument_list|)
expr_stmt|;
block|}
else|else
name|ia
operator|=
name|ip_rtaddr
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_SRCFAIL
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ip
operator|->
name|ip_dst
operator|=
name|ipaddr
operator|.
name|sin_addr
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|cp
operator|+
name|off
argument_list|,
operator|&
operator|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
comment|/* 			 * Let ip_intr's mcast routing check handle mcast pkts 			 */
name|forward
operator|=
operator|!
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPOPT_RR
case|:
if|if
condition|(
name|optlen
operator|<
name|IPOPT_OFFSET
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
operator|(
name|off
operator|=
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|)
operator|<
name|IPOPT_MINOFF
condition|)
block|{
name|code
operator|=
operator|&
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 			 * If no space remains, ignore. 			 */
name|off
operator|--
expr_stmt|;
comment|/* 0 origin */
if|if
condition|(
name|off
operator|>
name|optlen
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
break|break;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|ipaddr
operator|.
name|sin_addr
argument_list|,
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * locate outgoing interface; if we're the destination, 			 * use the incoming interface (should be same). 			 */
if|if
condition|(
operator|(
name|ia
operator|=
operator|(
name|INA
operator|)
name|ifa_ifwithaddr
argument_list|(
operator|(
name|SA
operator|)
operator|&
name|ipaddr
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|ia
operator|=
name|ip_rtaddr
argument_list|(
name|ipaddr
operator|.
name|sin_addr
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|cp
operator|+
name|off
argument_list|,
operator|&
operator|(
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
index|[
name|IPOPT_OFFSET
index|]
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPOPT_TS
case|:
name|code
operator|=
name|cp
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
name|ipt
operator|=
operator|(
expr|struct
name|ip_timestamp
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
name|ipt
operator|->
name|ipt_len
operator|<
literal|4
operator|||
name|ipt
operator|->
name|ipt_len
operator|>
literal|40
condition|)
block|{
name|code
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ipt
operator|->
name|ipt_len
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|<
literal|5
condition|)
block|{
name|code
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ipt
operator|->
name|ipt_ptr
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|>
name|ipt
operator|->
name|ipt_len
operator|-
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
condition|)
block|{
if|if
condition|(
operator|++
name|ipt
operator|->
name|ipt_oflw
operator|==
literal|0
condition|)
block|{
name|code
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ipt
operator|->
name|ipt_ptr
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
break|break;
block|}
name|sin
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|cp
operator|+
name|ipt
operator|->
name|ipt_ptr
operator|-
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
name|ipt
operator|->
name|ipt_flg
condition|)
block|{
case|case
name|IPOPT_TS_TSONLY
case|:
break|break;
case|case
name|IPOPT_TS_TSANDADDR
case|:
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|>
name|ipt
operator|->
name|ipt_len
condition|)
block|{
name|code
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ipt
operator|->
name|ipt_ptr
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ipaddr
operator|.
name|sin_addr
operator|=
name|dst
expr_stmt|;
name|ia
operator|=
operator|(
name|INA
operator|)
name|ifaof_ifpforaddr
argument_list|(
operator|(
name|SA
operator|)
operator|&
name|ipaddr
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|sin
argument_list|,
operator|&
name|IA_SIN
argument_list|(
name|ia
argument_list|)
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ipt
operator|->
name|ipt_ptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|IPOPT_TS_PRESPEC
case|:
if|if
condition|(
name|ipt
operator|->
name|ipt_ptr
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|>
name|ipt
operator|->
name|ipt_len
condition|)
block|{
name|code
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ipt
operator|->
name|ipt_ptr
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|&
name|ipaddr
operator|.
name|sin_addr
argument_list|,
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa_ifwithaddr
argument_list|(
operator|(
name|SA
operator|)
operator|&
name|ipaddr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|ipt
operator|->
name|ipt_ptr
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* XXX can't take&ipt->ipt_flg */
name|code
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|ipt
operator|->
name|ipt_ptr
operator|-
operator|(
name|u_char
operator|*
operator|)
name|ip
operator|+
literal|1
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|ntime
operator|=
name|iptime
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|cp
operator|+
name|ipt
operator|->
name|ipt_ptr
operator|-
literal|1
argument_list|,
operator|&
name|ntime
argument_list|,
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
argument_list|)
expr_stmt|;
name|ipt
operator|->
name|ipt_ptr
operator|+=
sizeof|sizeof
argument_list|(
name|n_time
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|forward
operator|&&
name|ipforwarding
condition|)
block|{
name|ip_forward
argument_list|(
name|m
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|bad
label|:
name|icmp_error
argument_list|(
name|m
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ipstat
operator|.
name|ips_badoptions
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given address of next destination (final or next hop),  * return internet address info of interface to be used to get there.  */
end_comment

begin_function
specifier|static
name|struct
name|in_ifaddr
modifier|*
name|ip_rtaddr
parameter_list|(
name|dst
parameter_list|)
name|struct
name|in_addr
name|dst
decl_stmt|;
block|{
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ipforward_rt
operator|.
name|ro_dst
expr_stmt|;
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|==
literal|0
operator|||
name|dst
operator|.
name|s_addr
operator|!=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ipforward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ipforward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|dst
expr_stmt|;
name|rtalloc_ign
argument_list|(
operator|&
name|ipforward_rt
argument_list|,
name|RTF_PRCLONING
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|in_ifaddr
operator|*
operator|)
literal|0
operator|)
return|;
return|return
operator|(
operator|(
expr|struct
name|in_ifaddr
operator|*
operator|)
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Save incoming source route for use in replies,  * to be picked up later by ip_srcroute if the receiver is interested.  */
end_comment

begin_function
name|void
name|save_rte
parameter_list|(
name|option
parameter_list|,
name|dst
parameter_list|)
name|u_char
modifier|*
name|option
decl_stmt|;
name|struct
name|in_addr
name|dst
decl_stmt|;
block|{
name|unsigned
name|olen
decl_stmt|;
name|olen
operator|=
name|option
index|[
name|IPOPT_OLEN
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"save_rte: olen %d\n"
argument_list|,
name|olen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|olen
operator|>
sizeof|sizeof
argument_list|(
name|ip_srcrt
argument_list|)
operator|-
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|dst
argument_list|)
operator|)
condition|)
return|return;
name|bcopy
argument_list|(
name|option
argument_list|,
name|ip_srcrt
operator|.
name|srcopt
argument_list|,
name|olen
argument_list|)
expr_stmt|;
name|ip_nhops
operator|=
operator|(
name|olen
operator|-
name|IPOPT_OFFSET
operator|-
literal|1
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|ip_srcrt
operator|.
name|dst
operator|=
name|dst
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retrieve incoming source route for use in replies,  * in the same form used by setsockopt.  * The first hop is placed before the options, will be removed later.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ip_srcroute
parameter_list|()
block|{
specifier|register
name|struct
name|in_addr
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|ip_nhops
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
return|;
name|m
operator|=
name|m_get
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
operator|)
return|;
define|#
directive|define
name|OPTSIZ
value|(sizeof(ip_srcrt.nop) + sizeof(ip_srcrt.srcopt))
comment|/* length is (nhops+1)*sizeof(addr) + sizeof(nop + srcrt header) */
name|m
operator|->
name|m_len
operator|=
name|ip_nhops
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|+
name|OPTSIZ
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"ip_srcroute: nhops %d mlen %d"
argument_list|,
name|ip_nhops
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * First save first hop for return route 	 */
name|p
operator|=
operator|&
name|ip_srcrt
operator|.
name|route
index|[
name|ip_nhops
operator|-
literal|1
index|]
expr_stmt|;
operator|*
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|in_addr
operator|*
argument_list|)
operator|)
operator|=
operator|*
name|p
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|" hops %lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|in_addr
operator|*
argument_list|)
operator|->
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Copy option fields and padding (nop) to mbuf. 	 */
name|ip_srcrt
operator|.
name|nop
operator|=
name|IPOPT_NOP
expr_stmt|;
name|ip_srcrt
operator|.
name|srcopt
index|[
name|IPOPT_OFFSET
index|]
operator|=
name|IPOPT_MINOFF
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|&
name|ip_srcrt
operator|.
name|nop
argument_list|,
name|OPTSIZ
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|+
name|OPTSIZ
operator|)
expr_stmt|;
undef|#
directive|undef
name|OPTSIZ
comment|/* 	 * Record return path as an IP source route, 	 * reversing the path (pointers are now aligned). 	 */
while|while
condition|(
name|p
operator|>=
name|ip_srcrt
operator|.
name|route
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|" %lx"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|q
operator|->
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|--
expr_stmt|;
block|}
comment|/* 	 * Last hop goes to final destination. 	 */
operator|*
name|q
operator|=
name|ip_srcrt
operator|.
name|dst
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|" %lx\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ntohl
argument_list|(
name|q
operator|->
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Strip out IP options, at higher  * level protocol in the kernel.  * Second argument is buffer to which options  * will be moved, and return value is their length.  * XXX should be deleted; last arg currently ignored.  */
end_comment

begin_function
name|void
name|ip_stripoptions
parameter_list|(
name|m
parameter_list|,
name|mopt
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mopt
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|caddr_t
name|opts
decl_stmt|;
name|int
name|olen
decl_stmt|;
name|olen
operator|=
operator|(
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|opts
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ip
operator|+
literal|1
argument_list|)
expr_stmt|;
name|i
operator|=
name|m
operator|->
name|m_len
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
name|olen
operator|)
expr_stmt|;
name|bcopy
argument_list|(
name|opts
operator|+
name|olen
argument_list|,
name|opts
argument_list|,
operator|(
name|unsigned
operator|)
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
name|olen
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
condition|)
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-=
name|olen
expr_stmt|;
name|ip
operator|->
name|ip_vhl
operator|=
name|IP_MAKE_VHL
argument_list|(
name|IPVERSION
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|u_char
name|inetctlerrmap
index|[
name|PRC_NCMDS
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|EMSGSIZE
block|,
name|EHOSTDOWN
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|EHOSTUNREACH
block|,
name|ECONNREFUSED
block|,
name|ECONNREFUSED
block|,
name|EMSGSIZE
block|,
name|EHOSTUNREACH
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|ENOPROTOOPT
block|,
name|ECONNREFUSED
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward a packet.  If some error occurs return the sender  * an icmp packet.  Note we can't always generate a meaningful  * icmp message because icmp doesn't have a large enough repertoire  * of codes and types.  *  * If not forwarding, just drop the packet.  This could be confusing  * if ipforwarding was zero but some routing protocol was advancing  * us as a gateway to somewhere.  However, we must let the routing  * protocol deal with that.  *  * The srcrt parameter indicates whether the packet is being forwarded  * via a source route.  */
end_comment

begin_function
specifier|static
name|void
name|ip_forward
parameter_list|(
name|m
parameter_list|,
name|srcrt
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|srcrt
decl_stmt|;
block|{
specifier|register
name|struct
name|ip
modifier|*
name|ip
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|int
name|error
decl_stmt|,
name|type
init|=
literal|0
decl_stmt|,
name|code
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcopy
decl_stmt|;
name|n_long
name|dest
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|destifp
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
name|struct
name|ifnet
name|dummyifp
decl_stmt|;
endif|#
directive|endif
name|dest
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"forward: src %lx dst %lx ttl %x\n"
argument_list|,
operator|(
name|u_long
operator|)
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
operator|(
name|u_long
operator|)
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_ttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_BCAST
operator||
name|M_MCAST
operator|)
operator|||
name|in_canforward
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IPSTEALTH
if|if
condition|(
operator|!
name|ipstealth
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|ip
operator|->
name|ip_ttl
operator|<=
name|IPTTLDEC
condition|)
block|{
name|icmp_error
argument_list|(
name|m
argument_list|,
name|ICMP_TIMXCEED
argument_list|,
name|ICMP_TIMXCEED_INTRANS
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|IPSTEALTH
block|}
endif|#
directive|endif
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ipforward_rt
operator|.
name|ro_dst
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|ipforward_rt
operator|.
name|ro_rt
operator|)
operator|==
literal|0
operator|||
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|!=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ipforward_rt
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|ipforward_rt
operator|.
name|ro_rt
operator|=
literal|0
expr_stmt|;
block|}
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|rtalloc_ign
argument_list|(
operator|&
name|ipforward_rt
argument_list|,
name|RTF_PRCLONING
argument_list|)
expr_stmt|;
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
operator|==
literal|0
condition|)
block|{
name|icmp_error
argument_list|(
name|m
argument_list|,
name|ICMP_UNREACH
argument_list|,
name|ICMP_UNREACH_HOST
argument_list|,
name|dest
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|rt
operator|=
name|ipforward_rt
operator|.
name|ro_rt
expr_stmt|;
block|}
comment|/* 	 * Save the IP header and at most 8 bytes of the payload, 	 * in case we need to generate an ICMP message to the src. 	 * 	 * We don't use m_copy() because it might return a reference 	 * to a shared cluster. Both this function and ip_output() 	 * assume exclusive access to the IP header in `m', so any 	 * data in a cluster may change before we reach icmp_error(). 	 */
name|MGET
argument_list|(
name|mcopy
argument_list|,
name|M_DONTWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcopy
operator|!=
name|NULL
condition|)
block|{
name|M_COPY_PKTHDR
argument_list|(
name|mcopy
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|mcopy
operator|->
name|m_len
operator|=
name|imin
argument_list|(
operator|(
name|IP_VHL_HL
argument_list|(
name|ip
operator|->
name|ip_vhl
argument_list|)
operator|<<
literal|2
operator|)
operator|+
literal|8
argument_list|,
operator|(
name|int
operator|)
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|mcopy
operator|->
name|m_len
argument_list|,
name|mtod
argument_list|(
name|mcopy
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSTEALTH
if|if
condition|(
operator|!
name|ipstealth
condition|)
block|{
endif|#
directive|endif
name|ip
operator|->
name|ip_ttl
operator|-=
name|IPTTLDEC
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSTEALTH
block|}
endif|#
directive|endif
comment|/* 	 * If forwarding packet using same interface that it came in on, 	 * perhaps should send a redirect to sender to shortcut a hop. 	 * Only send redirect if source is sending directly to us, 	 * and if packet was not source routed (or has any options). 	 * Also, don't send redirect if forwarding using a default route 	 * or a route modified by a redirect. 	 */
define|#
directive|define
name|satosin
parameter_list|(
name|sa
parameter_list|)
value|((struct sockaddr_in *)(sa))
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|==
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_DYNAMIC
operator||
name|RTF_MODIFIED
operator|)
operator|)
operator|==
literal|0
operator|&&
name|satosin
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|!=
literal|0
operator|&&
name|ipsendredirects
operator|&&
operator|!
name|srcrt
condition|)
block|{
define|#
directive|define
name|RTA
parameter_list|(
name|rt
parameter_list|)
value|((struct in_ifaddr *)(rt->rt_ifa))
name|u_long
name|src
init|=
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|RTA
argument_list|(
name|rt
argument_list|)
operator|&&
operator|(
name|src
operator|&
name|RTA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_subnetmask
operator|)
operator|==
name|RTA
argument_list|(
name|rt
argument_list|)
operator|->
name|ia_subnet
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
name|dest
operator|=
name|satosin
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
else|else
name|dest
operator|=
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
comment|/* Router requirements says to only send host redirects */
name|type
operator|=
name|ICMP_REDIRECT
expr_stmt|;
name|code
operator|=
name|ICMP_REDIRECT_HOST
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
name|ipprintfs
condition|)
name|printf
argument_list|(
literal|"redirect (%d) to %lx\n"
argument_list|,
name|code
argument_list|,
operator|(
name|u_long
operator|)
name|dest
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|error
operator|=
name|ip_output
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
argument_list|,
operator|&
name|ipforward_rt
argument_list|,
name|IP_FORWARDING
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ipstat
operator|.
name|ips_cantforward
operator|++
expr_stmt|;
else|else
block|{
name|ipstat
operator|.
name|ips_forward
operator|++
expr_stmt|;
if|if
condition|(
name|type
condition|)
name|ipstat
operator|.
name|ips_redirectsent
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|mcopy
condition|)
block|{
name|ipflow_create
argument_list|(
operator|&
name|ipforward_rt
argument_list|,
name|mcopy
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
if|if
condition|(
name|mcopy
operator|==
name|NULL
condition|)
return|return;
name|destifp
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
literal|0
case|:
comment|/* forwarded, but need redirect */
comment|/* type, code set above */
break|break;
case|case
name|ENETUNREACH
case|:
comment|/* shouldn't happen, checked above */
case|case
name|EHOSTUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|EHOSTDOWN
case|:
default|default:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_HOST
expr_stmt|;
break|break;
case|case
name|EMSGSIZE
case|:
name|type
operator|=
name|ICMP_UNREACH
expr_stmt|;
name|code
operator|=
name|ICMP_UNREACH_NEEDFRAG
expr_stmt|;
ifndef|#
directive|ifndef
name|IPSEC
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
condition|)
name|destifp
operator|=
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
else|#
directive|else
comment|/* 		 * If the packet is routed over IPsec tunnel, tell the 		 * originator the tunnel MTU. 		 *	tunnel MTU = if MTU - sizeof(IP) - ESP/AH hdrsiz 		 * XXX quickhack!!! 		 */
if|if
condition|(
name|ipforward_rt
operator|.
name|ro_rt
condition|)
block|{
name|struct
name|secpolicy
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
name|int
name|ipsecerror
decl_stmt|;
name|int
name|ipsechdr
decl_stmt|;
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
name|sp
operator|=
name|ipsec4_getpolicybyaddr
argument_list|(
name|mcopy
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|,
name|IP_FORWARDING
argument_list|,
operator|&
name|ipsecerror
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
name|destifp
operator|=
name|ipforward_rt
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
else|else
block|{
comment|/* count IPsec header size */
name|ipsechdr
operator|=
name|ipsec4_hdrsiz
argument_list|(
name|mcopy
argument_list|,
name|IPSEC_DIR_OUTBOUND
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 				 * find the correct route for outer IPv4 				 * header, compute tunnel MTU. 				 * 				 * XXX BUG ALERT 				 * The "dummyifp" code relies upon the fact 				 * that icmp_error() touches only ifp->if_mtu. 				 */
comment|/*XXX*/
name|destifp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|req
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|req
operator|->
name|sav
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|req
operator|->
name|sav
operator|->
name|sah
operator|!=
name|NULL
condition|)
block|{
name|ro
operator|=
operator|&
name|sp
operator|->
name|req
operator|->
name|sav
operator|->
name|sah
operator|->
name|sa_route
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|&&
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
condition|)
block|{
name|dummyifp
operator|.
name|if_mtu
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
expr_stmt|;
name|dummyifp
operator|.
name|if_mtu
operator|-=
name|ipsechdr
expr_stmt|;
name|destifp
operator|=
operator|&
name|dummyifp
expr_stmt|;
block|}
block|}
name|key_freesp
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*IPSEC*/
name|ipstat
operator|.
name|ips_cantfrag
operator|++
expr_stmt|;
break|break;
case|case
name|ENOBUFS
case|:
name|type
operator|=
name|ICMP_SOURCEQUENCH
expr_stmt|;
name|code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|EACCES
case|:
comment|/* ipfw denied packet */
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
return|return;
block|}
name|icmp_error
argument_list|(
name|mcopy
argument_list|,
name|type
argument_list|,
name|code
argument_list|,
name|dest
argument_list|,
name|destifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ip_savecontrol
parameter_list|(
name|inp
parameter_list|,
name|mp
parameter_list|,
name|ip
parameter_list|,
name|m
parameter_list|)
specifier|register
name|struct
name|inpcb
modifier|*
name|inp
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
specifier|register
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
if|if
condition|(
name|inp
operator|->
name|inp_socket
operator|->
name|so_options
operator|&
name|SO_TIMESTAMP
condition|)
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|microtime
argument_list|(
operator|&
name|tv
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|,
name|SCM_TIMESTAMP
argument_list|,
name|SOL_SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVDSTADDR
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|ip
operator|->
name|ip_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IP_RECVDSTADDR
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notyet
comment|/* XXX 	 * Moving these out of udp_input() made them even more broken 	 * than they already were. 	 */
comment|/* options were tossed already */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVOPTS
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|opts_deleted_above
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IP_RECVOPTS
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
comment|/* ip_srcroute doesn't do what we want here, need to fix */
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVRETOPTS
condition|)
block|{
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|ip_srcroute
argument_list|()
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
name|IP_RECVRETOPTS
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|inp_flags
operator|&
name|INP_RECVIF
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
struct|struct
name|sdlbuf
block|{
name|struct
name|sockaddr_dl
name|sdl
decl_stmt|;
name|u_char
name|pad
index|[
literal|32
index|]
decl_stmt|;
block|}
name|sdlbuf
struct|;
name|struct
name|sockaddr_dl
modifier|*
name|sdp
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl2
init|=
operator|&
name|sdlbuf
operator|.
name|sdl
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|ifp
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|)
operator|)
operator|&&
operator|(
name|ifp
operator|->
name|if_index
operator|&&
operator|(
name|ifp
operator|->
name|if_index
operator|<=
name|if_index
operator|)
operator|)
condition|)
block|{
name|sdp
operator|=
operator|(
expr|struct
name|sockaddr_dl
operator|*
operator|)
operator|(
name|ifnet_addrs
index|[
name|ifp
operator|->
name|if_index
operator|-
literal|1
index|]
operator|->
name|ifa_addr
operator|)
expr_stmt|;
comment|/* 			 * Change our mind and don't try copy. 			 */
if|if
condition|(
operator|(
name|sdp
operator|->
name|sdl_family
operator|!=
name|AF_LINK
operator|)
operator|||
operator|(
name|sdp
operator|->
name|sdl_len
operator|>
sizeof|sizeof
argument_list|(
name|sdlbuf
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|makedummy
goto|;
block|}
name|bcopy
argument_list|(
name|sdp
argument_list|,
name|sdl2
argument_list|,
name|sdp
operator|->
name|sdl_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|makedummy
label|:
name|sdl2
operator|->
name|sdl_len
operator|=
name|offsetof
argument_list|(
expr|struct
name|sockaddr_dl
argument_list|,
name|sdl_data
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sdl2
operator|->
name|sdl_family
operator|=
name|AF_LINK
expr_stmt|;
name|sdl2
operator|->
name|sdl_index
operator|=
literal|0
expr_stmt|;
name|sdl2
operator|->
name|sdl_nlen
operator|=
name|sdl2
operator|->
name|sdl_alen
operator|=
name|sdl2
operator|->
name|sdl_slen
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|sbcreatecontrol
argument_list|(
operator|(
name|caddr_t
operator|)
name|sdl2
argument_list|,
name|sdl2
operator|->
name|sdl_len
argument_list|,
name|IP_RECVIF
argument_list|,
name|IPPROTO_IP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mp
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|m_next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ip_rsvp_init
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
if|if
condition|(
name|so
operator|->
name|so_type
operator|!=
name|SOCK_RAW
operator|||
name|so
operator|->
name|so_proto
operator|->
name|pr_protocol
operator|!=
name|IPPROTO_RSVP
condition|)
return|return
name|EOPNOTSUPP
return|;
if|if
condition|(
name|ip_rsvpd
operator|!=
name|NULL
condition|)
return|return
name|EADDRINUSE
return|;
name|ip_rsvpd
operator|=
name|so
expr_stmt|;
comment|/* 	 * This may seem silly, but we need to be sure we don't over-increment 	 * the RSVP counter, in case something slips up. 	 */
if|if
condition|(
operator|!
name|ip_rsvp_on
condition|)
block|{
name|ip_rsvp_on
operator|=
literal|1
expr_stmt|;
name|rsvp_on
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ip_rsvp_done
parameter_list|(
name|void
parameter_list|)
block|{
name|ip_rsvpd
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This may seem silly, but we need to be sure we don't over-decrement 	 * the RSVP counter, in case something slips up. 	 */
if|if
condition|(
name|ip_rsvp_on
condition|)
block|{
name|ip_rsvp_on
operator|=
literal|0
expr_stmt|;
name|rsvp_on
operator|--
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

