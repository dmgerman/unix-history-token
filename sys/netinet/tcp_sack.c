begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tcp_sack.c	8.12 (Berkeley) 5/24/95  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995  *  * NRL grants permission for redistribution and use in source and binary  * forms, with or without modification, of the software and documentation  * created at NRL provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgements:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  *	This product includes software developed at the Information  *	Technology Division, US Naval Research Laboratory.  * 4. Neither the name of the NRL nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS  * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation  * are those of the authors and should not be interpreted as representing  * official policies, either expressed or implied, of the US Naval  * Research Laboratory (NRL).  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcpdebug.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcp_input.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcp_sack.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for proc0 declaration */
end_comment

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* before tcp_seq.h, for tcp_random18() */
end_comment

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_icmp.h>
end_include

begin_comment
comment|/* for ICMP_BANDLIM		*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp_var.h>
end_include

begin_comment
comment|/* for ICMP_BANDLIM		*/
end_comment

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/tcp6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCPDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_debug.h>
end_include

begin_decl_stmt
name|u_char
name|tcp_saveipgen
index|[
literal|40
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the size must be of max ip header, now IPv6 */
end_comment

begin_decl_stmt
name|struct
name|tcphdr
name|tcp_savetcp
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPDEBUG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FAST_IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_include
include|#
directive|include
file|<netkey/key.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*IPSEC*/
end_comment

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|uma_zone
modifier|*
name|sack_hole_zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This function is called upon receipt of new valid data (while not in header  * prediction mode), and it updates the ordered list of sacks.  */
end_comment

begin_function
name|void
name|tcp_update_sack_list
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
block|{
comment|/* 	 * First reported block MUST be the most recent one.  Subsequent 	 * blocks SHOULD be in the order in which they arrived at the 	 * receiver.  These two conditions make the implementation fully 	 * compliant with RFC 2018. 	 */
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|lastpos
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|sackblk
name|sack
decl_stmt|,
name|firstsack
decl_stmt|,
name|temp
index|[
name|MAX_SACK_BLKS
index|]
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* First clean up current list of sacks */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|rcv_numsacks
condition|;
name|i
operator|++
control|)
block|{
name|sack
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sack
operator|.
name|start
operator|==
literal|0
operator|&&
name|sack
operator|.
name|end
operator|==
literal|0
condition|)
block|{
name|count
operator|++
expr_stmt|;
comment|/* count = number of blocks to be discarded */
continue|continue;
block|}
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|temp
index|[
name|j
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
expr_stmt|;
name|temp
index|[
name|j
operator|++
index|]
operator|.
name|end
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
expr_stmt|;
block|}
block|}
name|tp
operator|->
name|rcv_numsacks
operator|-=
name|count
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|rcv_numsacks
operator|==
literal|0
condition|)
block|{
comment|/* no sack blocks currently (fast path) */
name|tcp_clean_sackreport
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_laststart
argument_list|)
condition|)
block|{
comment|/* ==> need first sack block */
name|tp
operator|->
name|sackblks
index|[
literal|0
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|rcv_laststart
expr_stmt|;
name|tp
operator|->
name|sackblks
index|[
literal|0
index|]
operator|.
name|end
operator|=
name|tp
operator|->
name|rcv_lastend
expr_stmt|;
name|tp
operator|->
name|rcv_numsacks
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* Otherwise, sack blocks are already present. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|rcv_numsacks
condition|;
name|i
operator|++
control|)
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|=
name|temp
index|[
name|i
index|]
expr_stmt|;
comment|/* first copy back sack list */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|rcv_nxt
argument_list|,
name|tp
operator|->
name|rcv_lastend
argument_list|)
condition|)
return|return;
comment|/* sack list remains unchanged */
comment|/* 	 * From here, segment just received should be (part of) the 1st sack. 	 * Go through list, possibly coalescing sack block entries. 	 */
name|firstsack
operator|.
name|start
operator|=
name|tp
operator|->
name|rcv_laststart
expr_stmt|;
name|firstsack
operator|.
name|end
operator|=
name|tp
operator|->
name|rcv_lastend
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|rcv_numsacks
condition|;
name|i
operator|++
control|)
block|{
name|sack
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|firstsack
operator|.
name|start
argument_list|)
operator|||
name|SEQ_GT
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|firstsack
operator|.
name|end
argument_list|)
condition|)
continue|continue;
comment|/* no overlap */
if|if
condition|(
name|sack
operator|.
name|start
operator|==
name|firstsack
operator|.
name|start
operator|&&
name|sack
operator|.
name|end
operator|==
name|firstsack
operator|.
name|end
condition|)
block|{
comment|/* 			 * identical block; delete it here since we will 			 * move it to the front of the list. 			 */
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|lastpos
operator|=
name|i
expr_stmt|;
comment|/* last posn with a zero entry */
continue|continue;
block|}
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|firstsack
operator|.
name|start
argument_list|)
condition|)
name|firstsack
operator|.
name|start
operator|=
name|sack
operator|.
name|start
expr_stmt|;
comment|/* merge blocks */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|firstsack
operator|.
name|end
argument_list|)
condition|)
name|firstsack
operator|.
name|end
operator|=
name|sack
operator|.
name|end
expr_stmt|;
comment|/* merge blocks */
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
name|lastpos
operator|=
name|i
expr_stmt|;
comment|/* last posn with a zero entry */
block|}
if|if
condition|(
name|lastpos
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* at least one merge */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|1
init|;
name|i
operator|<
name|tp
operator|->
name|rcv_numsacks
condition|;
name|i
operator|++
control|)
block|{
name|sack
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sack
operator|.
name|start
operator|==
literal|0
operator|&&
name|sack
operator|.
name|end
operator|==
literal|0
condition|)
continue|continue;
name|temp
index|[
name|j
operator|++
index|]
operator|=
name|sack
expr_stmt|;
block|}
name|tp
operator|->
name|rcv_numsacks
operator|=
name|j
expr_stmt|;
comment|/* including first blk (added later) */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|tp
operator|->
name|rcv_numsacks
condition|;
name|i
operator|++
control|)
comment|/* now copy back */
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|=
name|temp
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* no merges -- shift sacks by 1 */
if|if
condition|(
name|tp
operator|->
name|rcv_numsacks
operator|<
name|MAX_SACK_BLKS
condition|)
name|tp
operator|->
name|rcv_numsacks
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tp
operator|->
name|rcv_numsacks
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
name|tp
operator|->
name|sackblks
index|[
literal|0
index|]
operator|=
name|firstsack
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Delete all receiver-side SACK information.  */
end_comment

begin_function
name|void
name|tcp_clean_sackreport
parameter_list|(
name|tp
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_numsacks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SACK_BLKS
condition|;
name|i
operator|++
control|)
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process the TCP SACK option.  Returns 1 if tcp_dooptions() should continue,  * and 0 otherwise, if the option was fine.  tp->snd_holes is an ordered list  * of holes (oldest to newest, in terms of the sequence space).  */
end_comment

begin_function
name|int
name|tcp_sack_option
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|optlen
parameter_list|)
block|{
name|int
name|tmp_olen
decl_stmt|;
name|u_char
modifier|*
name|tmp_cp
decl_stmt|;
name|struct
name|sackhole
modifier|*
name|cur
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|sack_enable
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Note: TCPOLEN_SACK must be 2*sizeof(tcp_seq) */
if|if
condition|(
name|optlen
operator|<=
literal|2
operator|||
operator|(
name|optlen
operator|-
literal|2
operator|)
operator|%
name|TCPOLEN_SACK
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|tmp_cp
operator|=
name|cp
operator|+
literal|2
expr_stmt|;
name|tmp_olen
operator|=
name|optlen
operator|-
literal|2
expr_stmt|;
name|tcpstat
operator|.
name|tcps_sack_rcv_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_numholes
operator|<
literal|0
condition|)
name|tp
operator|->
name|snd_numholes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_maxseg
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"tcp_sack_option"
argument_list|)
expr_stmt|;
comment|/* Should never happen */
name|next_block
label|:
while|while
condition|(
name|tmp_olen
operator|>
literal|0
condition|)
block|{
name|struct
name|sackblk
name|sack
decl_stmt|;
name|bcopy
argument_list|(
name|tmp_cp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|sack
operator|.
name|start
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tcp_seq
argument_list|)
argument_list|)
expr_stmt|;
name|sack
operator|.
name|start
operator|=
name|ntohl
argument_list|(
name|sack
operator|.
name|start
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tmp_cp
operator|+
sizeof|sizeof
argument_list|(
name|tcp_seq
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
name|sack
operator|.
name|end
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tcp_seq
argument_list|)
argument_list|)
expr_stmt|;
name|sack
operator|.
name|end
operator|=
name|ntohl
argument_list|(
name|sack
operator|.
name|end
argument_list|)
expr_stmt|;
name|tmp_olen
operator|-=
name|TCPOLEN_SACK
expr_stmt|;
name|tmp_cp
operator|+=
name|TCPOLEN_SACK
expr_stmt|;
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|sack
operator|.
name|start
argument_list|)
condition|)
continue|continue;
comment|/* bad SACK fields */
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
continue|continue;
comment|/* old block */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|th
operator|->
name|th_ack
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tp
operator|->
name|snd_holes
operator|==
name|NULL
condition|)
block|{
comment|/* first hole */
name|tp
operator|->
name|snd_holes
operator|=
operator|(
expr|struct
name|sackhole
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|sack_hole_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_holes
operator|==
name|NULL
condition|)
block|{
comment|/* ENOBUFS, so ignore SACKed block for now*/
continue|continue;
block|}
name|cur
operator|=
name|tp
operator|->
name|snd_holes
expr_stmt|;
name|cur
operator|->
name|start
operator|=
name|th
operator|->
name|th_ack
expr_stmt|;
name|cur
operator|->
name|end
operator|=
name|sack
operator|.
name|start
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|cur
operator|->
name|start
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tp
operator|->
name|snd_numholes
operator|=
literal|1
expr_stmt|;
name|tp
operator|->
name|rcv_lastsack
operator|=
name|sack
operator|.
name|end
expr_stmt|;
continue|continue;
comment|/* with next sack block */
block|}
comment|/* Go thru list of holes:  p = previous,  cur = current */
name|p
operator|=
name|cur
operator|=
name|tp
operator|->
name|snd_holes
expr_stmt|;
while|while
condition|(
name|cur
condition|)
block|{
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|cur
operator|->
name|start
argument_list|)
condition|)
comment|/* SACKs data before the current hole */
break|break;
comment|/* no use going through more holes */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
block|{
comment|/* SACKs data beyond the current hole */
name|p
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|cur
operator|->
name|start
argument_list|)
condition|)
block|{
comment|/* Data acks at least the beginning of hole */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
block|{
comment|/* Acks entire hole, so delete hole */
if|if
condition|(
name|p
operator|!=
name|cur
condition|)
block|{
name|p
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|uma_zfree
argument_list|(
name|sack_hole_zone
argument_list|,
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|uma_zfree
argument_list|(
name|sack_hole_zone
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|cur
expr_stmt|;
name|tp
operator|->
name|snd_holes
operator|=
name|p
expr_stmt|;
block|}
name|tp
operator|->
name|snd_numholes
operator|--
expr_stmt|;
continue|continue;
block|}
comment|/* otherwise, move start of hole forward */
name|cur
operator|->
name|start
operator|=
name|sack
operator|.
name|end
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|SEQ_MAX
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|start
argument_list|)
expr_stmt|;
name|p
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* move end of hole backward */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
block|{
name|cur
operator|->
name|end
operator|=
name|sack
operator|.
name|start
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|SEQ_MIN
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|end
argument_list|)
expr_stmt|;
name|p
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SEQ_LT
argument_list|(
name|cur
operator|->
name|start
argument_list|,
name|sack
operator|.
name|start
argument_list|)
operator|&&
name|SEQ_GT
argument_list|(
name|cur
operator|->
name|end
argument_list|,
name|sack
operator|.
name|end
argument_list|)
condition|)
block|{
comment|/* 				 * ACKs some data in middle of a hole; need to 				 * split current hole 				 */
name|temp
operator|=
operator|(
expr|struct
name|sackhole
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|sack_hole_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
goto|goto
name|next_block
goto|;
comment|/* ENOBUFS */
name|temp
operator|->
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|temp
operator|->
name|start
operator|=
name|sack
operator|.
name|end
expr_stmt|;
name|temp
operator|->
name|end
operator|=
name|cur
operator|->
name|end
expr_stmt|;
name|temp
operator|->
name|rxmit
operator|=
name|SEQ_MAX
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|temp
operator|->
name|start
argument_list|)
expr_stmt|;
name|cur
operator|->
name|end
operator|=
name|sack
operator|.
name|start
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|SEQ_MIN
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|end
argument_list|)
expr_stmt|;
name|cur
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|p
operator|=
name|temp
expr_stmt|;
name|cur
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|tp
operator|->
name|snd_numholes
operator|++
expr_stmt|;
block|}
block|}
comment|/* At this point, p points to the last hole on the list */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|rcv_lastsack
argument_list|,
name|sack
operator|.
name|start
argument_list|)
condition|)
block|{
comment|/* 			 * Need to append new hole at end. 			 * Last hole is p (and it's not NULL). 			 */
name|temp
operator|=
operator|(
expr|struct
name|sackhole
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|sack_hole_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
continue|continue;
comment|/* ENOBUFS */
name|temp
operator|->
name|start
operator|=
name|tp
operator|->
name|rcv_lastsack
expr_stmt|;
name|temp
operator|->
name|end
operator|=
name|sack
operator|.
name|start
expr_stmt|;
name|temp
operator|->
name|rxmit
operator|=
name|temp
operator|->
name|start
expr_stmt|;
name|temp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|temp
expr_stmt|;
name|tp
operator|->
name|rcv_lastsack
operator|=
name|sack
operator|.
name|end
expr_stmt|;
name|tp
operator|->
name|snd_numholes
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Delete stale (i.e, cumulatively ack'd) holes.  Hole is deleted only if  * it is completely acked; otherwise, tcp_sack_option(), called from  * tcp_dooptions(), will fix up the hole.  */
end_comment

begin_function
name|void
name|tcp_del_sackholes
parameter_list|(
name|tp
parameter_list|,
name|th
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
block|{
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|sack_enable
operator|&&
name|tp
operator|->
name|t_state
operator|!=
name|TCPS_LISTEN
condition|)
block|{
comment|/* max because this could be an older ack just arrived */
name|tcp_seq
name|lastack
init|=
name|SEQ_GT
argument_list|(
name|th
operator|->
name|th_ack
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|?
name|th
operator|->
name|th_ack
else|:
name|tp
operator|->
name|snd_una
decl_stmt|;
name|struct
name|sackhole
modifier|*
name|cur
init|=
name|tp
operator|->
name|snd_holes
decl_stmt|;
name|struct
name|sackhole
modifier|*
name|prev
decl_stmt|;
while|while
condition|(
name|cur
condition|)
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|cur
operator|->
name|end
argument_list|,
name|lastack
argument_list|)
condition|)
block|{
name|prev
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|uma_zfree
argument_list|(
name|sack_hole_zone
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_numholes
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SEQ_LT
argument_list|(
name|cur
operator|->
name|start
argument_list|,
name|lastack
argument_list|)
condition|)
block|{
name|cur
operator|->
name|start
operator|=
name|lastack
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|start
argument_list|)
condition|)
name|cur
operator|->
name|rxmit
operator|=
name|cur
operator|->
name|start
expr_stmt|;
break|break;
block|}
else|else
break|break;
name|tp
operator|->
name|snd_holes
operator|=
name|cur
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tcp_free_sackholes
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|q
operator|=
name|tp
operator|->
name|snd_holes
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|q
expr_stmt|;
name|q
operator|=
name|q
operator|->
name|next
expr_stmt|;
name|uma_zfree
argument_list|(
name|sack_hole_zone
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
name|tp
operator|->
name|snd_holes
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Checks for partial ack.  If partial ack arrives, turn off retransmission  * timer, deflate the window, do not clear tp->t_dupacks, and return 1.  * If the ack advances at least to tp->snd_recover, return 0.  */
end_comment

begin_function
name|void
name|tcp_sack_partialack
parameter_list|(
name|tp
parameter_list|,
name|th
parameter_list|)
name|struct
name|tcpcb
modifier|*
name|tp
decl_stmt|;
name|struct
name|tcphdr
modifier|*
name|th
decl_stmt|;
block|{
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|u_long
name|ocwnd
init|=
name|tp
operator|->
name|snd_cwnd
decl_stmt|;
name|callout_stop
argument_list|(
name|tp
operator|->
name|tt_rexmt
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set snd_cwnd to one segment beyond acknowledged offset 	 * (tp->snd_una has not yet been updated when this function is called.) 	 */
comment|/* 	 * Should really be 	 * min(tp->snd_cwnd, tp->t_maxseg + (th->th_ack - tp->snd_una)) 	 */
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|t_maxseg
operator|+
operator|(
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
operator|)
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
name|ocwnd
expr_stmt|;
comment|/* 	 * Partial window deflation.  Relies on fact that tp->snd_una 	 * not updated yet. 	 */
name|tp
operator|->
name|snd_cwnd
operator|-=
operator|(
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
operator|-
name|tp
operator|->
name|t_maxseg
operator|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TCP_SACK_DEBUG
end_ifdef

begin_function
name|void
name|tcp_print_holes
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|p
init|=
name|tp
operator|->
name|snd_holes
decl_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return;
name|printf
argument_list|(
literal|"Hole report: start--end dups rxmit\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
name|printf
argument_list|(
literal|"%x--%x r %x\n"
argument_list|,
name|p
operator|->
name|start
argument_list|,
name|p
operator|->
name|end
argument_list|,
name|p
operator|->
name|rxmit
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCP_SACK_DEBUG */
end_comment

begin_comment
comment|/*  * Returns pointer to a sackhole if there are any pending retransmissions;  * NULL otherwise.  */
end_comment

begin_function
name|struct
name|sackhole
modifier|*
name|tcp_sack_output
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|p
decl_stmt|;
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tp
operator|->
name|sack_enable
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|tp
operator|->
name|snd_holes
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|p
operator|->
name|rxmit
argument_list|,
name|p
operator|->
name|end
argument_list|)
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|p
operator|->
name|rxmit
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
condition|)
block|{
comment|/* old SACK hole */
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|TCP_SACK_DEBUG
if|if
condition|(
name|p
condition|)
name|tcp_print_holes
argument_list|(
name|tp
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|p
operator|)
return|;
block|}
name|p
operator|=
name|p
operator|->
name|next
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After a timeout, the SACK list may be rebuilt.  This SACK information  * should be used to avoid retransmitting SACKed data.  This function  * traverses the SACK list to see if snd_nxt should be moved forward.  */
end_comment

begin_function
name|void
name|tcp_sack_adjust
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|INP_LOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|struct
name|sackhole
modifier|*
name|cur
init|=
name|tp
operator|->
name|snd_holes
decl_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
return|return;
comment|/* No holes */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|rcv_lastsack
argument_list|)
condition|)
return|return;
comment|/* We're already beyond any SACKed blocks */
comment|/* 	 * Two cases for which we want to advance snd_nxt: 	 * i) snd_nxt lies between end of one hole and beginning of another 	 * ii) snd_nxt lies between end of last hole and rcv_lastsack 	 */
while|while
condition|(
name|cur
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|cur
operator|->
name|next
operator|->
name|start
argument_list|)
condition|)
name|cur
operator|=
name|cur
operator|->
name|next
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|snd_nxt
operator|=
name|cur
operator|->
name|next
operator|->
name|start
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
return|return;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|rcv_lastsack
expr_stmt|;
return|return;
block|}
end_function

end_unit

