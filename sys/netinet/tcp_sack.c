begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995  *	The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)tcp_sack.c	8.12 (Berkeley) 5/24/95  */
end_comment

begin_comment
comment|/*-  *	@@(#)COPYRIGHT	1.1 (NRL) 17 January 1995  *  * NRL grants permission for redistribution and use in source and binary  * forms, with or without modification, of the software and documentation  * created at NRL provided that the following conditions are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgements:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  *	This product includes software developed at the Information  *	Technology Division, US Naval Research Laboratory.  * 4. Neither the name of the NRL nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THE SOFTWARE PROVIDED BY NRL IS PROVIDED BY NRL AND CONTRIBUTORS ``AS  * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL NRL OR  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * The views and conclusions contained in the software and documentation  * are those of the authors and should not be interpreted as representing  * official policies, either expressed or implied, of the US Naval  * Research Laboratory (NRL).  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_tcpdebug.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_comment
comment|/* for proc0 declaration */
end_comment

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vimage.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_comment
comment|/* before tcp_seq.h, for tcp_random18() */
end_comment

begin_include
include|#
directive|include
file|<vm/uma.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_fsm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/tcp6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcpip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TCPDEBUG
end_ifdef

begin_include
include|#
directive|include
file|<netinet/tcp_debug.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TCPDEBUG */
end_comment

begin_include
include|#
directive|include
file|<netinet/vinet.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|uma_zone
modifier|*
name|sack_hole_zone
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|VIMAGE_GLOBALS
end_ifdef

begin_decl_stmt
name|int
name|tcp_do_sack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcp_sack_maxholes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcp_sack_globalmaxholes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tcp_sack_globalholes
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_tcp
argument_list|,
name|OID_AUTO
argument_list|,
name|sack
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"TCP SACK"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_V_INT
argument_list|(
name|V_NET
argument_list|,
name|vnet_inet
argument_list|,
name|_net_inet_tcp_sack
argument_list|,
name|OID_AUTO
argument_list|,
name|enable
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|tcp_do_sack
argument_list|,
literal|0
argument_list|,
literal|"Enable/Disable TCP SACK support"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"net.inet.tcp.sack.enable"
argument_list|,
operator|&
name|tcp_do_sack
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_V_INT
argument_list|(
name|V_NET
argument_list|,
name|vnet_inet
argument_list|,
name|_net_inet_tcp_sack
argument_list|,
name|OID_AUTO
argument_list|,
name|maxholes
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|tcp_sack_maxholes
argument_list|,
literal|0
argument_list|,
literal|"Maximum number of TCP SACK holes allowed per connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_V_INT
argument_list|(
name|V_NET
argument_list|,
name|vnet_inet
argument_list|,
name|_net_inet_tcp_sack
argument_list|,
name|OID_AUTO
argument_list|,
name|globalmaxholes
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|tcp_sack_globalmaxholes
argument_list|,
literal|0
argument_list|,
literal|"Global maximum number of TCP SACK holes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_V_INT
argument_list|(
name|V_NET
argument_list|,
name|vnet_inet
argument_list|,
name|_net_inet_tcp_sack
argument_list|,
name|OID_AUTO
argument_list|,
name|globalholes
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|tcp_sack_globalholes
argument_list|,
literal|0
argument_list|,
literal|"Global number of TCP SACK holes currently allocated"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * This function is called upon receipt of new valid data (while not in  * header prediction mode), and it updates the ordered list of sacks.  */
end_comment

begin_function
name|void
name|tcp_update_sack_list
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|tcp_seq
name|rcv_start
parameter_list|,
name|tcp_seq
name|rcv_end
parameter_list|)
block|{
comment|/* 	 * First reported block MUST be the most recent one.  Subsequent 	 * blocks SHOULD be in the order in which they arrived at the 	 * receiver.  These two conditions make the implementation fully 	 * compliant with RFC 2018. 	 */
name|struct
name|sackblk
name|head_blk
decl_stmt|,
name|saved_blks
index|[
name|MAX_SACK_BLKS
index|]
decl_stmt|;
name|int
name|num_head
decl_stmt|,
name|num_saved
decl_stmt|,
name|i
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
comment|/* Check arguments. */
name|KASSERT
argument_list|(
name|SEQ_LT
argument_list|(
name|rcv_start
argument_list|,
name|rcv_end
argument_list|)
argument_list|,
operator|(
literal|"rcv_start< rcv_end"
operator|)
argument_list|)
expr_stmt|;
comment|/* SACK block for the received segment. */
name|head_blk
operator|.
name|start
operator|=
name|rcv_start
expr_stmt|;
name|head_blk
operator|.
name|end
operator|=
name|rcv_end
expr_stmt|;
comment|/* 	 * Merge updated SACK blocks into head_blk, and save unchanged SACK 	 * blocks into saved_blks[].  num_saved will have the number of the 	 * saved SACK blocks. 	 */
name|num_saved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tp
operator|->
name|rcv_numsacks
condition|;
name|i
operator|++
control|)
block|{
name|tcp_seq
name|start
init|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
decl_stmt|;
name|tcp_seq
name|end
init|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
decl_stmt|;
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|||
name|SEQ_LEQ
argument_list|(
name|start
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
comment|/* 			 * Discard this SACK block. 			 */
block|}
elseif|else
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|head_blk
operator|.
name|start
argument_list|,
name|end
argument_list|)
operator|&&
name|SEQ_GEQ
argument_list|(
name|head_blk
operator|.
name|end
argument_list|,
name|start
argument_list|)
condition|)
block|{
comment|/* 			 * Merge this SACK block into head_blk.  This SACK 			 * block itself will be discarded. 			 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|head_blk
operator|.
name|start
argument_list|,
name|start
argument_list|)
condition|)
name|head_blk
operator|.
name|start
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|SEQ_LT
argument_list|(
name|head_blk
operator|.
name|end
argument_list|,
name|end
argument_list|)
condition|)
name|head_blk
operator|.
name|end
operator|=
name|end
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Save this SACK block. 			 */
name|saved_blks
index|[
name|num_saved
index|]
operator|.
name|start
operator|=
name|start
expr_stmt|;
name|saved_blks
index|[
name|num_saved
index|]
operator|.
name|end
operator|=
name|end
expr_stmt|;
name|num_saved
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Update SACK list in tp->sackblks[]. 	 */
name|num_head
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|head_blk
operator|.
name|start
argument_list|,
name|tp
operator|->
name|rcv_nxt
argument_list|)
condition|)
block|{
comment|/* 		 * The received data segment is an out-of-order segment.  Put 		 * head_blk at the top of SACK list. 		 */
name|tp
operator|->
name|sackblks
index|[
literal|0
index|]
operator|=
name|head_blk
expr_stmt|;
name|num_head
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If the number of saved SACK blocks exceeds its limit, 		 * discard the last SACK block. 		 */
if|if
condition|(
name|num_saved
operator|>=
name|MAX_SACK_BLKS
condition|)
name|num_saved
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|num_saved
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Copy the saved SACK blocks back. 		 */
name|bcopy
argument_list|(
name|saved_blks
argument_list|,
operator|&
name|tp
operator|->
name|sackblks
index|[
name|num_head
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sackblk
argument_list|)
operator|*
name|num_saved
argument_list|)
expr_stmt|;
block|}
comment|/* Save the number of SACK blocks. */
name|tp
operator|->
name|rcv_numsacks
operator|=
name|num_head
operator|+
name|num_saved
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Delete all receiver-side SACK information.  */
end_comment

begin_function
name|void
name|tcp_clean_sackreport
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tp
operator|->
name|rcv_numsacks
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_SACK_BLKS
condition|;
name|i
operator|++
control|)
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|sackblks
index|[
name|i
index|]
operator|.
name|end
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate struct sackhole.  */
end_comment

begin_function
specifier|static
name|struct
name|sackhole
modifier|*
name|tcp_sackhole_alloc
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|tcp_seq
name|start
parameter_list|,
name|tcp_seq
name|end
parameter_list|)
block|{
name|INIT_VNET_INET
argument_list|(
name|tp
operator|->
name|t_inpcb
operator|->
name|inp_vnet
argument_list|)
expr_stmt|;
name|struct
name|sackhole
modifier|*
name|hole
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_numholes
operator|>=
name|V_tcp_sack_maxholes
operator|||
name|V_tcp_sack_globalholes
operator|>=
name|V_tcp_sack_globalmaxholes
condition|)
block|{
name|V_tcpstat
operator|.
name|tcps_sack_sboverflow
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hole
operator|=
operator|(
expr|struct
name|sackhole
operator|*
operator|)
name|uma_zalloc
argument_list|(
name|sack_hole_zone
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|hole
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hole
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|hole
operator|->
name|end
operator|=
name|end
expr_stmt|;
name|hole
operator|->
name|rxmit
operator|=
name|start
expr_stmt|;
name|tp
operator|->
name|snd_numholes
operator|++
expr_stmt|;
name|V_tcp_sack_globalholes
operator|++
expr_stmt|;
return|return
name|hole
return|;
block|}
end_function

begin_comment
comment|/*  * Free struct sackhole.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_sackhole_free
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|sackhole
modifier|*
name|hole
parameter_list|)
block|{
name|INIT_VNET_INET
argument_list|(
name|tp
operator|->
name|t_vnet
argument_list|)
expr_stmt|;
name|uma_zfree
argument_list|(
name|sack_hole_zone
argument_list|,
name|hole
argument_list|)
expr_stmt|;
name|tp
operator|->
name|snd_numholes
operator|--
expr_stmt|;
name|V_tcp_sack_globalholes
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|snd_numholes
operator|>=
literal|0
argument_list|,
operator|(
literal|"tp->snd_numholes>= 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|V_tcp_sack_globalholes
operator|>=
literal|0
argument_list|,
operator|(
literal|"tcp_sack_globalholes>= 0"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert new SACK hole into scoreboard.  */
end_comment

begin_function
specifier|static
name|struct
name|sackhole
modifier|*
name|tcp_sackhole_insert
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|tcp_seq
name|start
parameter_list|,
name|tcp_seq
name|end
parameter_list|,
name|struct
name|sackhole
modifier|*
name|after
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|hole
decl_stmt|;
comment|/* Allocate a new SACK hole. */
name|hole
operator|=
name|tcp_sackhole_alloc
argument_list|(
name|tp
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|hole
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* Insert the new SACK hole into scoreboard. */
if|if
condition|(
name|after
operator|!=
name|NULL
condition|)
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|,
name|after
argument_list|,
name|hole
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|,
name|hole
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
comment|/* Update SACK hint. */
if|if
condition|(
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
operator|==
name|NULL
condition|)
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
operator|=
name|hole
expr_stmt|;
return|return
name|hole
return|;
block|}
end_function

begin_comment
comment|/*  * Remove SACK hole from scoreboard.  */
end_comment

begin_function
specifier|static
name|void
name|tcp_sackhole_remove
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|sackhole
modifier|*
name|hole
parameter_list|)
block|{
comment|/* Update SACK hint. */
if|if
condition|(
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
operator|==
name|hole
condition|)
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
operator|=
name|TAILQ_NEXT
argument_list|(
name|hole
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
comment|/* Remove this SACK hole. */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|,
name|hole
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
comment|/* Free this SACK hole. */
name|tcp_sackhole_free
argument_list|(
name|tp
argument_list|,
name|hole
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process cumulative ACK and the TCP SACK option to update the scoreboard.  * tp->snd_holes is an ordered list of holes (oldest to newest, in terms of  * the sequence space).  */
end_comment

begin_function
name|void
name|tcp_sack_doack
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcpopt
modifier|*
name|to
parameter_list|,
name|tcp_seq
name|th_ack
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|cur
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|struct
name|sackblk
name|sack
decl_stmt|,
name|sack_blocks
index|[
name|TCP_MAX_SACK
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|sblkp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|num_sack_blks
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|num_sack_blks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If SND.UNA will be advanced by SEG.ACK, and if SACK holes exist, 	 * treat [SND.UNA, SEG.ACK) as if it is a SACK block. 	 */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|th_ack
argument_list|)
operator|&&
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
condition|)
block|{
name|sack_blocks
index|[
name|num_sack_blks
index|]
operator|.
name|start
operator|=
name|tp
operator|->
name|snd_una
expr_stmt|;
name|sack_blocks
index|[
name|num_sack_blks
operator|++
index|]
operator|.
name|end
operator|=
name|th_ack
expr_stmt|;
block|}
comment|/* 	 * Append received valid SACK blocks to sack_blocks[], but only if we 	 * received new blocks from the other side. 	 */
if|if
condition|(
name|to
operator|->
name|to_flags
operator|&
name|TOF_SACK
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|to
operator|->
name|to_nsacks
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
operator|(
name|to
operator|->
name|to_sacks
operator|+
name|i
operator|*
name|TCPOLEN_SACK
operator|)
argument_list|,
operator|&
name|sack
argument_list|,
sizeof|sizeof
argument_list|(
name|sack
argument_list|)
argument_list|)
expr_stmt|;
name|sack
operator|.
name|start
operator|=
name|ntohl
argument_list|(
name|sack
operator|.
name|start
argument_list|)
expr_stmt|;
name|sack
operator|.
name|end
operator|=
name|ntohl
argument_list|(
name|sack
operator|.
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|sack
operator|.
name|start
argument_list|)
operator|&&
name|SEQ_GT
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|&&
name|SEQ_GT
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|th_ack
argument_list|)
operator|&&
name|SEQ_LT
argument_list|(
name|sack
operator|.
name|start
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
operator|&&
name|SEQ_GT
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|tp
operator|->
name|snd_una
argument_list|)
operator|&&
name|SEQ_LEQ
argument_list|(
name|sack
operator|.
name|end
argument_list|,
name|tp
operator|->
name|snd_max
argument_list|)
condition|)
name|sack_blocks
index|[
name|num_sack_blks
operator|++
index|]
operator|=
name|sack
expr_stmt|;
block|}
block|}
comment|/* 	 * Return if SND.UNA is not advanced and no valid SACK block is 	 * received. 	 */
if|if
condition|(
name|num_sack_blks
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Sort the SACK blocks so we can update the scoreboard with just one 	 * pass. The overhead of sorting upto 4+1 elements is less than 	 * making upto 4+1 passes over the scoreboard. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_sack_blks
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|num_sack_blks
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|sack_blocks
index|[
name|i
index|]
operator|.
name|end
argument_list|,
name|sack_blocks
index|[
name|j
index|]
operator|.
name|end
argument_list|)
condition|)
block|{
name|sack
operator|=
name|sack_blocks
index|[
name|i
index|]
expr_stmt|;
name|sack_blocks
index|[
name|i
index|]
operator|=
name|sack_blocks
index|[
name|j
index|]
expr_stmt|;
name|sack_blocks
index|[
name|j
index|]
operator|=
name|sack
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
condition|)
comment|/* 		 * Empty scoreboard. Need to initialize snd_fack (it may be 		 * uninitialized or have a bogus value). Scoreboard holes 		 * (from the sack blocks received) are created later below 		 * (in the logic that adds holes to the tail of the 		 * scoreboard). 		 */
name|tp
operator|->
name|snd_fack
operator|=
name|SEQ_MAX
argument_list|(
name|tp
operator|->
name|snd_una
argument_list|,
name|th_ack
argument_list|)
expr_stmt|;
comment|/* 	 * In the while-loop below, incoming SACK blocks (sack_blocks[]) and 	 * SACK holes (snd_holes) are traversed from their tails with just 	 * one pass in order to reduce the number of compares especially when 	 * the bandwidth-delay product is large. 	 * 	 * Note: Typically, in the first RTT of SACK recovery, the highest 	 * three or four SACK blocks with the same ack number are received. 	 * In the second RTT, if retransmitted data segments are not lost, 	 * the highest three or four SACK blocks with ack number advancing 	 * are received. 	 */
name|sblkp
operator|=
operator|&
name|sack_blocks
index|[
name|num_sack_blks
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Last SACK block */
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_fack
argument_list|,
name|sblkp
operator|->
name|start
argument_list|)
condition|)
block|{
comment|/* 		 * The highest SACK block is beyond fack.  Append new SACK 		 * hole at the tail.  If the second or later highest SACK 		 * blocks are also beyond the current fack, they will be 		 * inserted by way of hole splitting in the while-loop below. 		 */
name|temp
operator|=
name|tcp_sackhole_insert
argument_list|(
name|tp
argument_list|,
name|tp
operator|->
name|snd_fack
argument_list|,
name|sblkp
operator|->
name|start
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
name|tp
operator|->
name|snd_fack
operator|=
name|sblkp
operator|->
name|end
expr_stmt|;
comment|/* Go to the previous sack block. */
name|sblkp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/*  			 * We failed to add a new hole based on the current  			 * sack block.  Skip over all the sack blocks that  			 * fall completely to the right of snd_fack and 			 * proceed to trim the scoreboard based on the 			 * remaining sack blocks.  This also trims the 			 * scoreboard for th_ack (which is sack_blocks[0]). 			 */
while|while
condition|(
name|sblkp
operator|>=
name|sack_blocks
operator|&&
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_fack
argument_list|,
name|sblkp
operator|->
name|start
argument_list|)
condition|)
name|sblkp
operator|--
expr_stmt|;
if|if
condition|(
name|sblkp
operator|>=
name|sack_blocks
operator|&&
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_fack
argument_list|,
name|sblkp
operator|->
name|end
argument_list|)
condition|)
name|tp
operator|->
name|snd_fack
operator|=
name|sblkp
operator|->
name|end
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_fack
argument_list|,
name|sblkp
operator|->
name|end
argument_list|)
condition|)
comment|/* fack is advanced. */
name|tp
operator|->
name|snd_fack
operator|=
name|sblkp
operator|->
name|end
expr_stmt|;
comment|/* We must have at least one SACK hole in scoreboard. */
name|KASSERT
argument_list|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
argument_list|,
operator|(
literal|"SACK scoreboard must not be empty"
operator|)
argument_list|)
expr_stmt|;
name|cur
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|,
name|sackhole_head
argument_list|)
expr_stmt|;
comment|/* Last SACK hole. */
comment|/* 	 * Since the incoming sack blocks are sorted, we can process them 	 * making one sweep of the scoreboard. 	 */
while|while
condition|(
name|sblkp
operator|>=
name|sack_blocks
operator|&&
name|cur
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sblkp
operator|->
name|start
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
block|{
comment|/* 			 * SACKs data beyond the current hole.  Go to the 			 * previous sack block. 			 */
name|sblkp
operator|--
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sblkp
operator|->
name|end
argument_list|,
name|cur
operator|->
name|start
argument_list|)
condition|)
block|{
comment|/* 			 * SACKs data before the current hole.  Go to the 			 * previous hole. 			 */
name|cur
operator|=
name|TAILQ_PREV
argument_list|(
name|cur
argument_list|,
name|sackhole_head
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|-=
operator|(
name|cur
operator|->
name|rxmit
operator|-
name|cur
operator|->
name|start
operator|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|>=
literal|0
argument_list|,
operator|(
literal|"sackhint bytes rtx>= 0"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sblkp
operator|->
name|start
argument_list|,
name|cur
operator|->
name|start
argument_list|)
condition|)
block|{
comment|/* Data acks at least the beginning of hole. */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sblkp
operator|->
name|end
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
block|{
comment|/* Acks entire hole, so delete hole. */
name|temp
operator|=
name|cur
expr_stmt|;
name|cur
operator|=
name|TAILQ_PREV
argument_list|(
name|cur
argument_list|,
name|sackhole_head
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
name|tcp_sackhole_remove
argument_list|(
name|tp
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* 				 * The sack block may ack all or part of the 				 * next hole too, so continue onto the next 				 * hole. 				 */
continue|continue;
block|}
else|else
block|{
comment|/* Move start of hole forward. */
name|cur
operator|->
name|start
operator|=
name|sblkp
operator|->
name|end
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|SEQ_MAX
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|start
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Data acks at least the end of hole. */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|sblkp
operator|->
name|end
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
block|{
comment|/* Move end of hole backward. */
name|cur
operator|->
name|end
operator|=
name|sblkp
operator|->
name|start
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|SEQ_MIN
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * ACKs some data in middle of a hole; need 				 * to split current hole 				 */
name|temp
operator|=
name|tcp_sackhole_insert
argument_list|(
name|tp
argument_list|,
name|sblkp
operator|->
name|end
argument_list|,
name|cur
operator|->
name|end
argument_list|,
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|temp
operator|->
name|rxmit
argument_list|)
condition|)
block|{
name|temp
operator|->
name|rxmit
operator|=
name|cur
operator|->
name|rxmit
expr_stmt|;
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|+=
operator|(
name|temp
operator|->
name|rxmit
operator|-
name|temp
operator|->
name|start
operator|)
expr_stmt|;
block|}
name|cur
operator|->
name|end
operator|=
name|sblkp
operator|->
name|start
expr_stmt|;
name|cur
operator|->
name|rxmit
operator|=
name|SEQ_MIN
argument_list|(
name|cur
operator|->
name|rxmit
argument_list|,
name|cur
operator|->
name|end
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|+=
operator|(
name|cur
operator|->
name|rxmit
operator|-
name|cur
operator|->
name|start
operator|)
expr_stmt|;
comment|/* 		 * Testing sblkp->start against cur->start tells us whether 		 * we're done with the sack block or the sack hole. 		 * Accordingly, we advance one or the other. 		 */
if|if
condition|(
name|SEQ_LEQ
argument_list|(
name|sblkp
operator|->
name|start
argument_list|,
name|cur
operator|->
name|start
argument_list|)
condition|)
name|cur
operator|=
name|TAILQ_PREV
argument_list|(
name|cur
argument_list|,
name|sackhole_head
argument_list|,
name|scblink
argument_list|)
expr_stmt|;
else|else
name|sblkp
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Free all SACK holes to clear the scoreboard.  */
end_comment

begin_function
name|void
name|tcp_free_sackholes
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|q
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|q
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|tcp_sackhole_remove
argument_list|(
name|tp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|snd_numholes
operator|==
literal|0
argument_list|,
operator|(
literal|"tp->snd_numholes == 0"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
operator|==
name|NULL
argument_list|,
operator|(
literal|"tp->sackhint.nexthole == NULL"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Partial ack handling within a sack recovery episode.  Keeping this very  * simple for now.  When a partial ack is received, force snd_cwnd to a value  * that will allow the sender to transmit no more than 2 segments.  If  * necessary, a better scheme can be adopted at a later point, but for now,  * the goal is to prevent the sender from bursting a large amount of data in  * the midst of sack recovery.  */
end_comment

begin_function
name|void
name|tcp_sack_partialack
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|struct
name|tcphdr
modifier|*
name|th
parameter_list|)
block|{
name|int
name|num_segs
init|=
literal|1
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
name|tcp_timer_activate
argument_list|(
name|tp
argument_list|,
name|TT_REXMT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_rtttime
operator|=
literal|0
expr_stmt|;
comment|/* Send one or 2 segments based on how much new data was acked. */
if|if
condition|(
operator|(
operator|(
name|th
operator|->
name|th_ack
operator|-
name|tp
operator|->
name|snd_una
operator|)
operator|/
name|tp
operator|->
name|t_maxseg
operator|)
operator|>
literal|2
condition|)
name|num_segs
operator|=
literal|2
expr_stmt|;
name|tp
operator|->
name|snd_cwnd
operator|=
operator|(
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
operator|+
operator|(
name|tp
operator|->
name|snd_nxt
operator|-
name|tp
operator|->
name|sack_newdata
operator|)
operator|+
name|num_segs
operator|*
name|tp
operator|->
name|t_maxseg
operator|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|snd_cwnd
operator|>
name|tp
operator|->
name|snd_ssthresh
condition|)
name|tp
operator|->
name|snd_cwnd
operator|=
name|tp
operator|->
name|snd_ssthresh
expr_stmt|;
name|tp
operator|->
name|t_flags
operator||=
name|TF_ACKNOW
expr_stmt|;
operator|(
name|void
operator|)
name|tcp_output
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Debug version of tcp_sack_output() that walks the scoreboard.  Used for  * now to sanity check the hint.  */
end_comment

begin_comment
unit|static struct sackhole * tcp_sack_output_debug(struct tcpcb *tp, int *sack_bytes_rexmt) { 	struct sackhole *p;  	INP_WLOCK_ASSERT(tp->t_inpcb); 	*sack_bytes_rexmt = 0; 	TAILQ_FOREACH(p,&tp->snd_holes, scblink) { 		if (SEQ_LT(p->rxmit, p->end)) { 			if (SEQ_LT(p->rxmit, tp->snd_una)) {
comment|/* old SACK hole */
end_comment

begin_endif
unit|continue; 			} 			*sack_bytes_rexmt += (p->rxmit - p->start); 			break; 		} 		*sack_bytes_rexmt += (p->rxmit - p->start); 	} 	return (p); }
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Returns the next hole to retransmit and the number of retransmitted bytes  * from the scoreboard.  We store both the next hole and the number of  * retransmitted bytes as hints (and recompute these on the fly upon SACK/ACK  * reception).  This avoids scoreboard traversals completely.  *  * The loop here will traverse *at most* one link.  Here's the argument.  For  * the loop to traverse more than 1 link before finding the next hole to  * retransmit, we would need to have at least 1 node following the current  * hint with (rxmit == end).  But, for all holes following the current hint,  * (start == rxmit), since we have not yet retransmitted from them.  * Therefore, in order to traverse more 1 link in the loop below, we need to  * have at least one node following the current hint with (start == rxmit ==  * end).  But that can't happen, (start == end) means that all the data in  * that hole has been sacked, in which case, the hole would have been removed  * from the scoreboard.  */
end_comment

begin_function
name|struct
name|sackhole
modifier|*
name|tcp_sack_output
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|,
name|int
modifier|*
name|sack_bytes_rexmt
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|hole
init|=
name|NULL
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
operator|*
name|sack_bytes_rexmt
operator|=
name|tp
operator|->
name|sackhint
operator|.
name|sack_bytes_rexmit
expr_stmt|;
name|hole
operator|=
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
expr_stmt|;
if|if
condition|(
name|hole
operator|==
name|NULL
operator|||
name|SEQ_LT
argument_list|(
name|hole
operator|->
name|rxmit
argument_list|,
name|hole
operator|->
name|end
argument_list|)
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
operator|(
name|hole
operator|=
name|TAILQ_NEXT
argument_list|(
name|hole
argument_list|,
name|scblink
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|hole
operator|->
name|rxmit
argument_list|,
name|hole
operator|->
name|end
argument_list|)
condition|)
block|{
name|tp
operator|->
name|sackhint
operator|.
name|nexthole
operator|=
name|hole
expr_stmt|;
break|break;
block|}
block|}
name|out
label|:
return|return
operator|(
name|hole
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * After a timeout, the SACK list may be rebuilt.  This SACK information  * should be used to avoid retransmitting SACKed data.  This function  * traverses the SACK list to see if snd_nxt should be moved forward.  */
end_comment

begin_function
name|void
name|tcp_sack_adjust
parameter_list|(
name|struct
name|tcpcb
modifier|*
name|tp
parameter_list|)
block|{
name|struct
name|sackhole
modifier|*
name|p
decl_stmt|,
modifier|*
name|cur
init|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|tp
operator|->
name|snd_holes
argument_list|)
decl_stmt|;
name|INP_WLOCK_ASSERT
argument_list|(
name|tp
operator|->
name|t_inpcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|==
name|NULL
condition|)
return|return;
comment|/* No holes */
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|tp
operator|->
name|snd_fack
argument_list|)
condition|)
return|return;
comment|/* We're already beyond any SACKed blocks */
comment|/*- 	 * Two cases for which we want to advance snd_nxt: 	 * i) snd_nxt lies between end of one hole and beginning of another 	 * ii) snd_nxt lies between end of last hole and snd_fack 	 */
while|while
condition|(
operator|(
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|cur
argument_list|,
name|scblink
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
return|return;
if|if
condition|(
name|SEQ_GEQ
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|p
operator|->
name|start
argument_list|)
condition|)
name|cur
operator|=
name|p
expr_stmt|;
else|else
block|{
name|tp
operator|->
name|snd_nxt
operator|=
name|p
operator|->
name|start
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|SEQ_LT
argument_list|(
name|tp
operator|->
name|snd_nxt
argument_list|,
name|cur
operator|->
name|end
argument_list|)
condition|)
return|return;
name|tp
operator|->
name|snd_nxt
operator|=
name|tp
operator|->
name|snd_fack
expr_stmt|;
block|}
end_function

end_unit

