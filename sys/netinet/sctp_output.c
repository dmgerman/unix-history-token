begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_output.c,v 1.46 2005/03/06 16:04:17 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_define
define|#
directive|define
name|SCTP_MAX_GAPS_INARRAY
value|4
end_define

begin_struct
struct|struct
name|sack_track
block|{
name|uint8_t
name|right_edge
decl_stmt|;
comment|/* mergable on the right edge */
name|uint8_t
name|left_edge
decl_stmt|;
comment|/* mergable on the left edge */
name|uint8_t
name|num_entries
decl_stmt|;
name|uint8_t
name|spare
decl_stmt|;
name|struct
name|sctp_gap_ack_block
name|gaps
index|[
name|SCTP_MAX_GAPS_INARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|sack_track
name|sack_array
index|[
literal|256
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x01 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x02 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x03 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x04 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x05 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x06 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x07 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x08 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x09 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x0a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x0b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x0c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x0d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x0e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x0f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x10 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x11 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x12 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x13 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x14 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x15 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x16 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x17 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x18 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x19 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x1a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x1b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x1c */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x1d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x1e */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x1f */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x20 */
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x21 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x22 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x23 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x24 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x25 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x26 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x27 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x28 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x29 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x2a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x2b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x2c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x2d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x2e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x2f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x30 */
block|{
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x31 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x32 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x33 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x34 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x35 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x36 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x37 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x38 */
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x39 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x3a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x3b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x3c */
block|{
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x3d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x3e */
block|{
block|{
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x3f */
block|{
block|{
literal|0
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x40 */
block|{
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x41 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x42 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x43 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x44 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x45 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x46 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x47 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x48 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x49 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x4a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x4b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x4c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x4d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x4e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x4f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x50 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x51 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x52 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x53 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x54 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0x55 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x56 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x57 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x58 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x59 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x5a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x5b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x5c */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x5d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x5e */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x5f */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x60 */
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x61 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x62 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x63 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x64 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x65 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x66 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x67 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x68 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x69 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x6a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x6b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x6c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x6d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x6e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x6f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x70 */
block|{
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x71 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x72 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x73 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x74 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x75 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x76 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x77 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x78 */
block|{
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x79 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x7a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x7b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x7c */
block|{
block|{
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x7d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x7e */
block|{
block|{
literal|1
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x7f */
block|{
block|{
literal|0
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x80 */
block|{
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x81 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x82 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x83 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x84 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x85 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x86 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x87 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x88 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x89 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x8a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x8b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x8c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x8d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x8e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x8f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x90 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x91 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x92 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x93 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x94 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0x95 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x96 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x97 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x98 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x99 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x9a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x9b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x9c */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x9d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x9e */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x9f */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xa0 */
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xa5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa8 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xa9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xaa */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xab */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xac */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xad */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xae */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xaf */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xb0 */
block|{
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xb5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xb8 */
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xba */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xbb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xbc */
block|{
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xbd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xbe */
block|{
block|{
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xbf */
block|{
block|{
literal|0
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xc0 */
block|{
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xc5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc8 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xc9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xca */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xcb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xcc */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xcd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xce */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xcf */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xd0 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xd5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xd8 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xda */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xdb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xdc */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xdd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xde */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xdf */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xe0 */
block|{
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xe5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe8 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xe9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xea */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xeb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xec */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xed */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xee */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xef */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xf0 */
block|{
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xf5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xf8 */
block|{
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xfa */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xfb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xfc */
block|{
block|{
literal|2
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xfd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xfe */
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xff */
block|{
block|{
literal|0
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp_is_address_in_scope
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|int
name|ipv4_addr_legal
parameter_list|,
name|int
name|ipv6_addr_legal
parameter_list|,
name|int
name|loopback_scope
parameter_list|,
name|int
name|ipv4_local_scope
parameter_list|,
name|int
name|local_scope
parameter_list|,
name|int
name|site_scope
parameter_list|,
name|int
name|do_update
parameter_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifn_p
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|ifa
operator|->
name|ifn_p
argument_list|)
condition|)
block|{
comment|/* 		 * skip loopback if not in scope * 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* not in scope , unspecified */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* private address not in scope */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
comment|/* 		 * Must update the flags,  bummer, which means any IFA locks 		 * must now be applied HERE<-> 		 */
if|if
condition|(
name|do_update
condition|)
block|{
name|sctp_gather_internal_ifa_flags
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ok to use deprecated addresses? */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* skip unspecifed addresses */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
comment|/* (local_scope == 0)&& */
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_add_addr_to_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|parmh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mret
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unknown type */
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
name|len
condition|)
block|{
comment|/* easy side we just drop it on the end */
name|parmh
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|SCTP_BUF_AT
argument_list|(
name|m
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|mret
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* Need more space */
name|mret
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mret
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* We are hosed, can't add more addresses */
return|return
operator|(
name|m
operator|)
return|;
block|}
name|mret
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
expr_stmt|;
name|parmh
operator|=
name|mtod
argument_list|(
name|mret
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* now add the parameter */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|ipv4p
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|ipv4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|parmh
expr_stmt|;
name|parmh
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|parmh
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ipv4p
operator|->
name|addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|ipv6p
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
name|ipv6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|parmh
expr_stmt|;
name|parmh
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
name|parmh
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ipv6p
operator|->
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ipv6p
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear embedded scope in the address */
name|in6_clearscope
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ipv6p
operator|->
name|addr
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|m
operator|)
return|;
block|}
return|return
operator|(
name|mret
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_add_addresses_to_i_ia
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_scoping
modifier|*
name|scope
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_at
parameter_list|,
name|int
name|cnt_inits_to
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|limit_out
init|=
literal|0
decl_stmt|,
name|total_count
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|m_at
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
if|if
condition|(
name|vrf
operator|->
name|total_ifa_count
operator|>
name|SCTP_COUNT_LIMIT
condition|)
block|{
name|limit_out
operator|=
literal|1
expr_stmt|;
name|cnt
operator|=
name|SCTP_ADDRESS_LIMIT
expr_stmt|;
goto|goto
name|skip_count
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifnp
argument_list|)
condition|)
block|{
comment|/* 				 * Skip loopback devices if loopback_scope 				 * not set 				 */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|&sctp_ifnp->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|sctp_ifap
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cnt
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
break|break;
block|}
block|}
name|skip_count
label|:
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|total_count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifnp
argument_list|)
condition|)
block|{
comment|/* 					 * Skip loopback devices if 					 * loopback_scope not set 					 */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|&sctp_ifnp->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|sctp_ifap
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|m_at
operator|=
name|sctp_add_addr_to_mbuf
argument_list|(
name|m_at
argument_list|,
name|sctp_ifap
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit_out
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|total_count
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
literal|2
condition|)
block|{
comment|/* 							 * two from each 							 * address 							 */
break|break;
block|}
if|if
condition|(
name|total_count
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
comment|/* No more addresses */
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
comment|/* First, how many ? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
comment|/* 				 * Address being deleted by the system, dont 				 * list. 				 */
continue|continue;
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* 				 * Address being deleted on this ep don't 				 * list. 				 */
continue|continue;
block|}
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
name|limit_out
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * To get through a NAT we only list addresses if we have 		 * more than one. That way if you just bind a single address 		 * we let the source of the init dictate our address. 		 */
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|m_at
operator|=
name|sctp_add_addr_to_mbuf
argument_list|(
name|m_at
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|m_at
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_is_ifa_addr_preferred
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|uint8_t
name|dest_is_global
init|=
literal|0
decl_stmt|;
comment|/* dest_is_priv is true if destination is a private address */
comment|/* dest_is_loop is true if destination is a loopback addresses */
comment|/* 	 * Here we determine if its a preferred address. A preferred address 	 * means it is the same scope or higher scope then the destination. 	 * L = loopback, P = private, G = global 	 * ----------------------------------------- src    |  dest | result 	 * ---------------------------------------- L     |    L  |    yes 	 * ----------------------------------------- P     |    L  | 	 * yes-v4 no-v6 ----------------------------------------- G     | 	 * L  |    yes-v4 no-v6 ----------------------------------------- L 	 * |    P  |    no ----------------------------------------- P     | 	 * P  |    yes ----------------------------------------- G     | 	 * P  |    no ----------------------------------------- L     |    G 	 * |    no ----------------------------------------- P     |    G  | 	 * no ----------------------------------------- G     |    G  | 	 * yes ----------------------------------------- 	 */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|fam
condition|)
block|{
comment|/* forget mis-matched family */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dest_is_priv
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dest_is_loop
operator|==
literal|0
operator|)
condition|)
block|{
name|dest_is_global
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Is destination preferred:"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Ok the address may be ok */
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
comment|/* ok to use deprecated addresses? */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:1\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ifa
operator|->
name|src_is_priv
condition|)
block|{
if|if
condition|(
name|dest_is_loop
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:2\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ifa
operator|->
name|src_is_glob
condition|)
block|{
if|if
condition|(
name|dest_is_loop
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:3\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * Now that we know what is what, implement or table this could in 	 * theory be done slicker (it used to be), but this is 	 * straightforward and easier to validate :-) 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"src_loop:%d src_priv:%d src_glob:%d\n"
argument_list|,
name|ifa
operator|->
name|src_is_loop
argument_list|,
name|ifa
operator|->
name|src_is_priv
argument_list|,
name|ifa
operator|->
name|src_is_glob
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dest_loop:%d dest_priv:%d dest_glob:%d\n"
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_global
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:4\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_glob
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:5\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|)
operator|&&
operator|(
name|dest_is_global
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:6\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_priv
operator|)
operator|&&
operator|(
name|dest_is_global
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"NO:7\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"YES\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* its a preferred address */
return|return
operator|(
name|ifa
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_is_ifa_addr_acceptable
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|uint8_t
name|dest_is_global
init|=
literal|0
decl_stmt|;
comment|/* 	 * Here we determine if its a acceptable address. A acceptable 	 * address means it is the same scope or higher scope but we can 	 * allow for NAT which means its ok to have a global dest and a 	 * private src. 	 *  	 * L = loopback, P = private, G = global 	 * ----------------------------------------- src    |  dest | result 	 * ----------------------------------------- L     |   L   |    yes 	 * ----------------------------------------- P     |   L   | 	 * yes-v4 no-v6 ----------------------------------------- G     | 	 * L   |    yes ----------------------------------------- L     | 	 * P   |    no ----------------------------------------- P     |   P 	 * |    yes ----------------------------------------- G     |   P 	 * |    yes - May not work ----------------------------------------- 	 * L     |   G   |    no ----------------------------------------- P 	 * |   G   |    yes - May not work 	 * ----------------------------------------- G     |   G   |    yes 	 * ----------------------------------------- 	 */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|fam
condition|)
block|{
comment|/* forget non matching family */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Ok the address may be ok */
if|if
condition|(
operator|(
name|dest_is_loop
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|==
literal|0
operator|)
condition|)
block|{
name|dest_is_global
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
comment|/* ok to use deprecated addresses? */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ifa
operator|->
name|src_is_priv
condition|)
block|{
comment|/* Special case, linklocal to loop */
if|if
condition|(
name|dest_is_loop
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 	 * Now that we know what is what, implement our table. This could in 	 * theory be done slicker (it used to be), but this is 	 * straightforward and easier to validate :-) 	 */
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|==
literal|1
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|==
literal|1
operator|)
operator|&&
operator|(
name|dest_is_global
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* its an acceptable address */
return|return
operator|(
name|ifa
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_is_addr_restricted
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* There are no restrictions, no TCB :-) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_restricted_addrs
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Help I have fallen and I can't get up!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
comment|/* Yes it is on the list */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_is_addr_in_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Help I have fallen and I can't get up!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
operator|)
operator|&&
name|laddr
operator|->
name|action
operator|==
literal|0
condition|)
comment|/* same pointer */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_choose_boundspecific_inp
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|starting_point
decl_stmt|;
name|void
modifier|*
name|ifn
decl_stmt|;
name|int
name|resettotop
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|uint32_t
name|ifn_index
decl_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ifn
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|ifn_index
operator|=
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|sctp_ifn
operator|=
name|sctp_find_ifn
argument_list|(
name|vrf
argument_list|,
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want such an address. Note that we first looked for a preferred 	 * address. 	 */
if|if
condition|(
name|sctp_ifn
condition|)
block|{
comment|/* is a preferred one on the interface we route out? */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|sifa
argument_list|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * ok, now we now need to find one on the list of the addresses. We 	 * can't get one on the emitting interface so let's find first a 	 * preferred one. If not that an acceptable one otherwise... we 	 * return NULL. 	 */
name|starting_point
operator|=
name|inp
operator|->
name|next_addr_touse
expr_stmt|;
name|once_again
label|:
if|if
condition|(
name|inp
operator|->
name|next_addr_touse
operator|==
name|NULL
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
name|resettotop
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|laddr
operator|=
name|inp
operator|->
name|next_addr_touse
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|resettotop
operator|==
literal|0
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|NULL
expr_stmt|;
goto|goto
name|once_again
goto|;
block|}
name|inp
operator|->
name|next_addr_touse
operator|=
name|starting_point
expr_stmt|;
name|resettotop
operator|=
literal|0
expr_stmt|;
name|once_again_too
label|:
if|if
condition|(
name|inp
operator|->
name|next_addr_touse
operator|==
name|NULL
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
name|resettotop
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ok, what about an acceptable address in the inp */
for|for
control|(
name|laddr
operator|=
name|inp
operator|->
name|next_addr_touse
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|resettotop
operator|==
literal|0
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|NULL
expr_stmt|;
goto|goto
name|once_again_too
goto|;
block|}
comment|/* 	 * no address bound can be a source for the destination we are in 	 * trouble 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_choose_boundspecific_stcb
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|starting_point
decl_stmt|;
name|void
modifier|*
name|ifn
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|uint8_t
name|start_at_beginning
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|uint32_t
name|ifn_index
decl_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want that one. 	 */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ifn
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|ifn_index
operator|=
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|sctp_ifn
operator|=
name|sctp_find_ifn
argument_list|(
name|vrf
argument_list|,
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list?  If so, 	 * we want that one. First we look for a preferred. Second, we go 	 * for an acceptable. 	 */
if|if
condition|(
name|sctp_ifn
condition|)
block|{
comment|/* first try for a preferred address on the ep */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
block|{
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
comment|/* next try for an acceptable address on the ep */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
block|{
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * if we can't find one like that then we must look at all addresses 	 * bound to pick one at first preferable then secondly acceptable. 	 */
name|starting_point
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
expr_stmt|;
name|sctp_from_the_top
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|laddr
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctp_from_the_top
goto|;
block|}
comment|/* now try for any higher scope than the destination */
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|starting_point
expr_stmt|;
name|start_at_beginning
operator|=
literal|0
expr_stmt|;
name|sctp_from_the_top2
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|laddr
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctp_from_the_top2
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_select_nth_preferred_addr_from_ifn_boundall
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|int
name|addr_wanted
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
if|if
condition|(
name|num_eligible_addr
operator|>=
name|addr_wanted
condition|)
block|{
return|return
operator|(
name|sifa
operator|)
return|;
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_num_preferred_boundall
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num_eligible_addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_choose_boundall
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|int
name|cur_addr_num
init|=
literal|0
decl_stmt|,
name|num_preferred
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ifn
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|,
modifier|*
name|looked_at
init|=
name|NULL
decl_stmt|,
modifier|*
name|emit_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|uint32_t
name|ifn_index
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
comment|/* 	 * For boundall  we can use any address in the association. If 	 * non_asoc_addr_ok is set we can use any address (at least in 	 * theory). So we look for preferred addresses first. If we find 	 * one, we use it. Otherwise we next try to get an address on the 	 * interface, which we should be able to do (unless non_asoc_addr_ok 	 * is false and we are routed out that way). In these cases where we 	 * can't use the address of the interface we go through all the 	 * ifn's looking for an address we can use and fill that in. Punting 	 * means we send back address 0, which will probably cause problems 	 * actually since then IP will fill in the address of the route ifn, 	 * which means we probably already rejected it.. i.e. here comes an 	 * abort :-<. 	 */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ifn
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|ifn_index
operator|=
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|emit_ifn
operator|=
name|looked_at
operator|=
name|sctp_ifn
operator|=
name|sctp_find_ifn
argument_list|(
name|vrf
argument_list|,
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifn
operator|==
name|NULL
condition|)
block|{
comment|/* ?? We don't have this guy ?? */
goto|goto
name|bound_all_plan_b
goto|;
block|}
if|if
condition|(
name|net
condition|)
block|{
name|cur_addr_num
operator|=
name|net
operator|->
name|indx_of_eligible_next_to_use
expr_stmt|;
block|}
name|num_preferred
operator|=
name|sctp_count_num_preferred_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Found %d preferred source addresses\n"
argument_list|,
name|num_preferred
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_preferred
operator|==
literal|0
condition|)
block|{
comment|/* 		 * no eligible addresses, we must use some other interface 		 * address if we can find one. 		 */
goto|goto
name|bound_all_plan_b
goto|;
block|}
comment|/* 	 * Ok we have num_eligible_addr set with how many we can use, this 	 * may vary from call to call due to addresses being deprecated 	 * etc.. 	 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_preferred
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * select the nth address from the list (where cur_addr_num is the 	 * nth) and 0 is the first one, 1 is the second one etc... 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"cur_addr_num:%d\n"
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_ifa
operator|=
name|sctp_select_nth_preferred_addr_from_ifn_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|cur_addr_num
argument_list|,
name|fam
argument_list|)
expr_stmt|;
comment|/* if sctp_ifa is NULL something changed??, fall to plan b. */
if|if
condition|(
name|sctp_ifa
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* save off where the next one we will want */
name|net
operator|->
name|indx_of_eligible_next_to_use
operator|=
name|cur_addr_num
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|sctp_ifa
operator|)
return|;
block|}
comment|/* 	 * plan_b: Look at all interfaces and find a preferred address. If 	 * no preferred fall through to plan_c. 	 */
name|bound_all_plan_b
label|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Plan B?\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
name|dest_is_loop
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
if|if
condition|(
operator|(
name|sctp_ifn
operator|==
name|looked_at
operator|)
operator|&&
name|looked_at
condition|)
comment|/* already looked at this guy */
continue|continue;
name|num_preferred
operator|=
name|sctp_count_num_preferred_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Found ifn:%p %d preferred source addresses\n"
argument_list|,
name|ifn
argument_list|,
name|num_preferred
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_preferred
operator|==
literal|0
condition|)
block|{
comment|/* 			 * None on this interface. 			 */
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"num preferred:%d on interface:%p cur_addr_num:%d\n"
argument_list|,
name|num_preferred
argument_list|,
name|sctp_ifn
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Ok we have num_eligible_addr set with how many we can 		 * use, this may vary from call to call due to addresses 		 * being deprecated etc.. 		 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_preferred
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
name|sifa
operator|=
name|sctp_select_nth_preferred_addr_from_ifn_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|cur_addr_num
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|net
condition|)
block|{
name|net
operator|->
name|indx_of_eligible_next_to_use
operator|=
name|cur_addr_num
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"we selected %d\n"
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Source:"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|&
name|sifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Dest:"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
comment|/* 	 * plan_c: See if we have an acceptable address on the emit 	 * interface 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Plan C no preferred for Dest, acceptable for?\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&emit_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
comment|/* 	 * plan_d: We are in trouble. No preferred address on the emit 	 * interface. And not even a perfered address on all interfaces. Go 	 * out and see if we can find an acceptable address somewhere 	 * amongst all interfaces. 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Plan C fails plan D?\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
name|dest_is_loop
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
if|if
condition|(
operator|(
name|sctp_ifn
operator|==
name|looked_at
operator|)
operator|&&
name|looked_at
condition|)
comment|/* already looked at this guy */
continue|continue;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
condition|)
block|{
comment|/* 					 * It is restricted for some 					 * reason.. probably not yet added. 					 */
continue|continue;
block|}
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
comment|/* 	 * Ok we can find NO address to source from that is not on our 	 * negative list and non_asoc_address is NOT ok, or its on our 	 * negative list. We cant source to it :-( 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tcb may be NULL */
end_comment

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_source_address_selection
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|to6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|answer
decl_stmt|;
name|uint8_t
name|dest_is_priv
decl_stmt|,
name|dest_is_loop
decl_stmt|;
name|int
name|did_rtalloc
init|=
literal|0
decl_stmt|;
name|sa_family_t
name|fam
decl_stmt|;
comment|/* 	 * Rules: - Find the route if needed, cache if I can. - Look at 	 * interface address in route, Is it in the bound list. If so we 	 * have the best source. - If not we must rotate amongst the 	 * addresses. 	 *  	 * Cavets and issues 	 *  	 * Do we need to pay attention to scope. We can have a private address 	 * or a global address we are sourcing or sending to. So if we draw 	 * it out zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 	 * For V4 ------------------------------------------ source     * 	 * dest  *  result -----------------------------------------<a> 	 * Private    *    Global  *	NAT 	 * -----------------------------------------<b>  Private    * 	 * Private *  No problem ----------------------------------------- 	 *<c>  Global     *    Private *  Huh, How will this work? 	 * -----------------------------------------<d>  Global     * 	 * Global  *  No Problem ------------------------------------------ 	 * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz For V6 	 * ------------------------------------------ source     *      dest  * 	 * result -----------------------------------------<a>  Linklocal  * 	 * Global  *	-----------------------------------------<b> 	 * Linklocal  * Linklocal  *  No problem 	 * -----------------------------------------<c>  Global     * 	 * Linklocal  *  Huh, How will this work? 	 * -----------------------------------------<d>  Global     * 	 * Global  *  No Problem ------------------------------------------ 	 * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 	 *  	 * And then we add to that what happens if there are multiple addresses 	 * assigned to an interface. Remember the ifa on a ifn is a linked 	 * list of addresses. So one interface can have more than one IP 	 * address. What happens if we have both a private and a global 	 * address? Do we then use context of destination to sort out which 	 * one is best? And what about NAT's sending P->G may get you a NAT 	 * translation, or should you select the G thats on the interface in 	 * preference. 	 *  	 * Decisions: 	 *  	 * - count the number of addresses on the interface. - if its one, no 	 * problem except case<c>. For<a> we will assume a NAT out there. 	 * - if there are more than one, then we need to worry about scope P 	 * or G. We should prefer G -> G and P -> P if possible. Then as a 	 * secondary fall back to mixed types G->P being a last ditch one. - 	 * The above all works for bound all, but bound specific we need to 	 * use the same concept but instead only consider the bound 	 * addresses. If the bound set is NOT assigned to the interface then 	 * we must use rotation amongst the bound addresses.. 	 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Need a route to cache. 		 */
name|rtalloc_ign
argument_list|(
name|ro
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|did_rtalloc
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fam
operator|=
name|to
operator|->
name|sin_family
expr_stmt|;
name|dest_is_priv
operator|=
name|dest_is_loop
operator|=
literal|0
expr_stmt|;
comment|/* Setup our scopes for the destination */
if|if
condition|(
name|fam
operator|==
name|AF_INET
condition|)
block|{
comment|/* Scope based on outbound address */
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|dest_is_priv
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|dest_is_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* mark it as local */
name|net
operator|->
name|addr_is_local
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
comment|/* Scope based on outbound address */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 			 * If the route goes to the loopback address OR the 			 * address is a loopback address, we are loopback 			 * scope. But we don't use dest_is_priv (link local 			 * addresses). 			 */
name|dest_is_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* mark it as local */
name|net
operator|->
name|addr_is_local
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|dest_is_priv
operator|=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Select source for:"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|to
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* 		 * When bound to all if the address list is set it is a 		 * negative list. Addresses being added by asconf. 		 */
name|answer
operator|=
name|sctp_choose_boundall
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|vrf_id
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_loop
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|fam
argument_list|)
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
comment|/* 	 * Three possiblities here: 	 *  	 * a) stcb is NULL, which means we operate only from the list of 	 * addresses (ifa's) bound to the endpoint and we care not about the 	 * list. b) stcb is NOT-NULL, which means we have an assoc structure 	 * and auto-asconf is on. This means that the list of addresses is a 	 * NOT list. We use the list from the inp, but any listed address in 	 * our list is NOT yet added. However if the non_asoc_addr_ok is set 	 * we CAN use an address NOT available (i.e. being added). Its a 	 * negative list. c) stcb is NOT-NULL, which means we have an assoc 	 * structure and auto-asconf is off. This means that the list of 	 * addresses is the ONLY addresses I can use.. its positive. 	 *  	 * Note we collapse b& c into the same function just like in the v6 	 * address selection. 	 */
if|if
condition|(
name|stcb
condition|)
block|{
name|answer
operator|=
name|sctp_choose_boundspecific_stcb
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|vrf_id
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_loop
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|fam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
name|sctp_choose_boundspecific_inp
argument_list|(
name|inp
argument_list|,
name|ro
argument_list|,
name|vrf_id
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_loop
argument_list|,
name|fam
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_find_cmsg
parameter_list|(
name|int
name|c_type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|cpsize
parameter_list|)
block|{
name|struct
name|cmsghdr
name|cmh
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|at
decl_stmt|;
name|tlen
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Independent of how many mbufs, find the c_type inside the control 	 * structure and copy out the data. 	 */
while|while
condition|(
name|at
operator|<
name|tlen
condition|)
block|{
if|if
condition|(
operator|(
name|tlen
operator|-
name|at
operator|)
operator|<
operator|(
name|int
operator|)
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* not enough room for one more we are done. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cmh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cmh
operator|.
name|cmsg_len
operator|+
name|at
operator|)
operator|>
name|tlen
condition|)
block|{
comment|/* 			 * this is real messed up since there is not enough 			 * data here to cover the cmsg header. We are done. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cmh
operator|.
name|cmsg_level
operator|==
name|IPPROTO_SCTP
operator|)
operator|&&
operator|(
name|c_type
operator|==
name|cmh
operator|.
name|cmsg_type
operator|)
condition|)
block|{
comment|/* found the one we want, copy it out */
name|at
operator|+=
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
argument_list|)
argument_list|)
operator|<
name|cpsize
condition|)
block|{
comment|/* 				 * space of cmsg_len after header not big 				 * enough 				 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
name|cpsize
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|at
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cmh
operator|.
name|cmsg_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmh
operator|.
name|cmsg_len
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* not found */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_add_cookie
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|init
parameter_list|,
name|int
name|init_offset
parameter_list|,
name|struct
name|mbuf
modifier|*
name|initack
parameter_list|,
name|int
name|initack_offset
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|stc_in
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|copy_init
decl_stmt|,
modifier|*
name|copy_initack
decl_stmt|,
modifier|*
name|m_at
decl_stmt|,
modifier|*
name|sig
decl_stmt|,
modifier|*
name|mret
decl_stmt|;
name|struct
name|sctp_state_cookie
modifier|*
name|stc
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint8_t
modifier|*
name|signature
decl_stmt|;
name|int
name|sig_offset
decl_stmt|;
name|uint16_t
name|cookie_sz
decl_stmt|;
name|mret
operator|=
name|NULL
expr_stmt|;
name|mret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mret
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|copy_init
operator|=
name|SCTP_M_COPYM
argument_list|(
name|init
argument_list|,
name|init_offset
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_init
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|copy_initack
operator|=
name|SCTP_M_COPYM
argument_list|(
name|initack
argument_list|,
name|initack_offset
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_initack
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mret
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|copy_init
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* easy side we just drop it on the end */
name|ph
operator|=
name|mtod
argument_list|(
name|mret
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|stc
operator|=
operator|(
expr|struct
name|sctp_state_cookie
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ph
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STATE_COOKIE
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
literal|0
expr_stmt|;
comment|/* fill in at the end */
comment|/* Fill in the stc cookie data */
operator|*
name|stc
operator|=
operator|*
name|stc_in
expr_stmt|;
comment|/* tack the INIT and then the INIT-ACK onto the chain */
name|cookie_sz
operator|=
literal|0
expr_stmt|;
name|m_at
operator|=
name|mret
expr_stmt|;
for|for
control|(
name|m_at
operator|=
name|mret
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
name|cookie_sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|copy_init
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|m_at
operator|=
name|copy_init
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
name|cookie_sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|copy_initack
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|m_at
operator|=
name|copy_initack
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
name|cookie_sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
name|sig
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|SCTP_SECRET_SIZE
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|NULL
condition|)
block|{
comment|/* no space, so free the entire chain */
name|sctp_m_freem
argument_list|(
name|mret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|sig
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|sig
expr_stmt|;
name|sig_offset
operator|=
literal|0
expr_stmt|;
name|signature
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|sig
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|sig_offset
operator|)
expr_stmt|;
comment|/* Time to sign the cookie */
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|inp
operator|->
name|sctp_ep
operator|.
name|secret_key
index|[
call|(
name|int
call|)
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
argument_list|)
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|mret
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|signature
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|sig
argument_list|)
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|cookie_sz
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|cookie_sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|mret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
name|sctp_get_ect
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|)
block|{
name|uint8_t
name|this_random
decl_stmt|;
comment|/* Huh? */
if|if
condition|(
name|sctp_ecn_enable
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sctp_ecn_nonce
operator|==
literal|0
condition|)
comment|/* no nonce, always return ECT0 */
return|return
operator|(
name|SCTP_ECT0_BIT
operator|)
return|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_ecn_nonce
operator|==
literal|0
condition|)
block|{
comment|/* Peer does NOT support it, so we send a ECT0 only */
return|return
operator|(
name|SCTP_ECT0_BIT
operator|)
return|;
block|}
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
return|return
operator|(
name|SCTP_ECT0_BIT
operator|)
return|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|==
literal|3
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|>
literal|7
operator|)
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|>
literal|3
operator|)
condition|)
block|{
name|uint32_t
name|rndval
decl_stmt|;
name|rndval
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|,
operator|&
name|rndval
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
argument_list|)
argument_list|)
expr_stmt|;
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|>
literal|7
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
operator|++
expr_stmt|;
block|}
name|this_random
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_values
index|[
name|stcb
operator|->
name|asoc
operator|.
name|hb_random_idx
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|this_random
operator|>>
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|)
operator|&
literal|0x01
condition|)
block|{
if|if
condition|(
name|chk
operator|!=
name|NULL
condition|)
comment|/* ECN Nonce stuff */
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
operator|=
name|SCTP_ECT1_BIT
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|++
expr_stmt|;
return|return
operator|(
name|SCTP_ECT1_BIT
operator|)
return|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|hb_ect_randombit
operator|++
expr_stmt|;
return|return
operator|(
name|SCTP_ECT0_BIT
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_lowlevel_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
comment|/* may be NULL */
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
parameter_list|,
name|int
name|nofragment_flag
parameter_list|,
name|int
name|ecn_ok
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|out_of_asoc_ok
parameter_list|)
comment|/* nofragment_flag to tell if IP_DF should be set (IPv4 only) */
block|{
comment|/* 	 * Given a mbuf chain (via SCTP_BUF_NEXT()) that holds a packet 	 * header WITH an SCTPHDR but no IP header, endpoint inp and sa 	 * structure: - fill in the HMAC digest of any AUTH chunk in the 	 * packet. - calculate and fill in the SCTP checksum. - prepend an 	 * IP address header. - if boundall use INADDR_ANY. - if 	 * boundspecific do source address selection. - set fragmentation 	 * option for ipV4. - On return from IP output, check/adjust mtu 	 * size of output interface and smallest_mtu size as well. 	 */
comment|/* Will need ifdefs around this */
name|struct
name|mbuf
modifier|*
name|o_pak
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sctphdr
decl_stmt|;
name|int
name|packet_length
decl_stmt|;
name|int
name|o_flgs
decl_stmt|;
name|uint32_t
name|csum
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|int
name|have_mtu
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|sctp_route_t
modifier|*
name|ro
decl_stmt|;
if|if
condition|(
operator|(
name|net
operator|)
operator|&&
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_OUT_OF_SCOPE
operator|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
block|}
else|else
block|{
name|vrf_id
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
block|}
comment|/* fill in the HMAC digest for any AUTH chunk in the packet */
if|if
condition|(
operator|(
name|auth
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|sctp_fill_hmac_digest_m
argument_list|(
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate the csum and fill in the length of the packet */
name|sctphdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|have_mtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_no_csum_on_loopback
operator|&&
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|)
condition|)
block|{
name|sctphdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* 		 * This can probably now be taken out since my audit shows 		 * no more bad pktlen's coming in. But we will wait a while 		 * yet. 		 */
name|packet_length
operator|=
name|sctp_calculate_len
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctphdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|csum
operator|=
name|sctp_calculate_sum
argument_list|(
name|m
argument_list|,
operator|&
name|packet_length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sctphdr
operator|->
name|checksum
operator|=
name|csum
expr_stmt|;
block|}
if|if
condition|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|sctp_route_t
name|iproute
decl_stmt|;
name|uint8_t
name|tos_value
decl_stmt|;
name|o_pak
operator|=
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_pak
operator|==
name|NULL
condition|)
block|{
comment|/* failed to prepend data, give up */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_ALIGN_TO_END
argument_list|(
name|o_pak
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|packet_length
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|m
argument_list|,
name|packet_length
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|tos_value
operator|=
name|net
operator|->
name|tos_flowlabel
operator|&
literal|0x000000ff
expr_stmt|;
block|}
else|else
block|{
name|tos_value
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_tos
expr_stmt|;
block|}
if|if
condition|(
name|nofragment_flag
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|WITH_CONVERT_IP_OFF
argument_list|)
operator|||
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__APPLE__
argument_list|)
name|ip
operator|->
name|ip_off
operator|=
name|IP_DF
expr_stmt|;
else|#
directive|else
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
comment|/* FreeBSD has a function for ip_id's */
name|ip
operator|->
name|ip_id
operator|=
name|ip_newid
argument_list|()
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_ttl
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|)
operator|&&
name|ecn_ok
condition|)
block|{
comment|/* Enable ECN */
name|ip
operator|->
name|ip_tos
operator|=
operator|(
call|(
name|u_char
call|)
argument_list|(
name|tos_value
operator|&
literal|0xfc
argument_list|)
operator||
name|sctp_get_ect
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No ECN */
name|ip
operator|->
name|ip_tos
operator|=
call|(
name|u_char
call|)
argument_list|(
name|tos_value
operator|&
literal|0xfc
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* no association at all */
name|ip
operator|->
name|ip_tos
operator|=
operator|(
name|tos_value
operator|&
literal|0xfc
operator|)
expr_stmt|;
block|}
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|ro
operator|=
operator|&
name|iproute
expr_stmt|;
name|memset
argument_list|(
operator|&
name|iproute
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iproute
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|to
argument_list|,
name|to
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
expr_stmt|;
block|}
comment|/* Now the address selection part */
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* call the routine to select the src address */
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* Cache the source address */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
name|out_of_asoc_ok
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
block|{
comment|/* No route to host */
goto|goto
name|no_route
goto|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
name|ip
operator|->
name|ip_src
operator|=
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sctp_ifa
modifier|*
name|_lsrc
decl_stmt|;
name|_lsrc
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
name|out_of_asoc_ok
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lsrc
operator|==
name|NULL
condition|)
block|{
goto|goto
name|no_route
goto|;
block|}
name|ip
operator|->
name|ip_src
operator|=
name|_lsrc
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|_lsrc
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If source address selection fails and we find no route 		 * then the ip_output should fail as well with a 		 * NO_ROUTE_TO_HOST type error. We probably should catch 		 * that somewhere and abort the association right away 		 * (assuming this is an INIT being sent). 		 */
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 			 * src addr selection failed to find a route (or 			 * valid source addr), so we can't get there from 			 * here (yet)! 			 */
name|no_route
label|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"low_level_output: dropped packet - no valid source addr\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|printf
argument_list|(
literal|"Destination was "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_CONFIRMED
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|&&
name|stcb
condition|)
block|{
name|printf
argument_list|(
literal|"no route takes interface %p down\n"
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_FAILED_THRESHOLD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* need a new primary */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|net
condition|)
block|{
if|if
condition|(
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|alt
argument_list|)
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_WAS_PRIMARY
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|sctp_m_freem
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
else|else
block|{
name|have_mtu
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_socket
condition|)
block|{
name|o_flgs
operator|=
operator|(
name|IP_RAWOUTPUT
operator||
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_options
operator|&
operator|(
name|SO_DONTROUTE
operator||
name|SO_BROADCAST
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|o_flgs
operator|=
name|IP_RAWOUTPUT
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"Calling ipv4 output routine from low level src addr:%x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Destination is %x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"RTP route is %p through\n"
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|_WHY_THIS_CODE
if|if
condition|(
operator|(
name|have_mtu
operator|)
operator|&&
operator|(
name|net
operator|)
operator|&&
operator|(
name|have_mtu
operator|>
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ro
operator|!=
operator|&
name|iproute
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|iproute
argument_list|,
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|ip_output
argument_list|(
name|o_pak
argument_list|,
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_options
argument_list|,
name|ro
argument_list|,
name|o_flgs
argument_list|,
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_moptions
argument_list|,
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_WHY_THIS_CODE
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|)
operator|&&
operator|(
name|have_mtu
operator|)
operator|&&
operator|(
name|net
operator|)
operator|&&
operator|(
name|have_mtu
operator|>
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|->
name|if_mtu
operator|=
name|have_mtu
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_senderrors
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"Ip output returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* free tempy routes */
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PMTU check versus smallest asoc MTU goes here */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|)
condition|)
block|{
name|sctp_mtu_size_reset
argument_list|(
name|inp
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* route was freed */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
elseif|else
if|if
condition|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|uint32_t
name|flowlabel
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6h
decl_stmt|;
name|struct
name|route_in6
name|ip6route
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|u_char
name|flowTop
decl_stmt|;
name|uint16_t
name|flowBottom
decl_stmt|;
name|u_char
name|tosBottom
decl_stmt|,
name|tosTop
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
name|tmp
decl_stmt|,
modifier|*
name|lsa6
decl_stmt|,
name|lsa6_tmp
decl_stmt|;
name|struct
name|sockaddr_in6
name|lsa6_storage
decl_stmt|;
name|int
name|prev_scope
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_short
name|prev_port
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
name|flowlabel
operator|=
name|net
operator|->
name|tos_flowlabel
expr_stmt|;
block|}
else|else
block|{
name|flowlabel
operator|=
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
expr_stmt|;
block|}
name|o_pak
operator|=
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_pak
operator|==
name|NULL
condition|)
block|{
comment|/* failed to prepend data, give up */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_ALIGN_TO_END
argument_list|(
name|o_pak
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|packet_length
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|m
argument_list|,
name|packet_length
argument_list|)
expr_stmt|;
name|ip6h
operator|=
name|mtod
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 		 * We assume here that inp_flow is in host byte order within 		 * the TCB! 		 */
name|flowBottom
operator|=
name|flowlabel
operator|&
literal|0x0000ffff
expr_stmt|;
name|flowTop
operator|=
operator|(
operator|(
name|flowlabel
operator|&
literal|0x000f0000
operator|)
operator|>>
literal|16
operator|)
expr_stmt|;
name|tosTop
operator|=
operator|(
operator|(
operator|(
name|flowlabel
operator|&
literal|0xf0
operator|)
operator|>>
literal|4
operator|)
operator||
name|IPV6_VERSION
operator|)
expr_stmt|;
comment|/* protect *sin6 from overwrite */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|tmp
operator|=
operator|*
name|sin6
expr_stmt|;
name|sin6
operator|=
operator|&
name|tmp
expr_stmt|;
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|ip6_use_defzone
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ip6route
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6route
argument_list|)
argument_list|)
expr_stmt|;
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|ip6route
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|sin6
argument_list|,
name|sin6
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|)
operator|&&
name|ecn_ok
condition|)
block|{
comment|/* Enable ECN */
name|tosBottom
operator|=
operator|(
operator|(
operator|(
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
operator|&
literal|0x0c
operator|)
operator||
name|sctp_get_ect
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* No ECN */
name|tosBottom
operator|=
operator|(
operator|(
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
operator|&
literal|0x0c
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* we could get no asoc if it is a O-O-T-B packet */
name|tosBottom
operator|=
operator|(
operator|(
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
operator|&
literal|0x0c
operator|)
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
name|ip6h
operator|->
name|ip6_flow
operator|=
name|htonl
argument_list|(
operator|(
operator|(
name|tosTop
operator|<<
literal|24
operator|)
operator||
operator|(
operator|(
name|tosBottom
operator||
name|flowTop
operator|)
operator|<<
literal|16
operator|)
operator||
name|flowBottom
operator|)
argument_list|)
expr_stmt|;
name|ip6h
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|ip6h
operator|->
name|ip6_plen
operator|=
operator|(
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
name|ip6h
operator|->
name|ip6_dst
operator|=
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
comment|/* 		 * Add SRC address selection here: we can only reuse to a 		 * limited degree the kame src-addr-sel, since we can try 		 * their selection but it may not be bound. 		 */
name|bzero
argument_list|(
operator|&
name|lsa6_tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa6_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|lsa6_tmp
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|lsa6_tmp
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa6_tmp
argument_list|)
expr_stmt|;
name|lsa6
operator|=
operator|&
name|lsa6_tmp
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* Cache the source address */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
name|out_of_asoc_ok
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"V6:No route to host\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|no_route
goto|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
name|lsa6
operator|->
name|sin6_addr
operator|=
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sctp_ifa
modifier|*
name|_lsrc
decl_stmt|;
name|_lsrc
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
name|out_of_asoc_ok
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lsrc
operator|==
name|NULL
condition|)
block|{
goto|goto
name|no_route
goto|;
block|}
name|lsa6
operator|->
name|sin6_addr
operator|=
name|_lsrc
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|_lsrc
argument_list|)
expr_stmt|;
block|}
name|lsa6
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* 			 * src addr selection failed to find a route (or 			 * valid source addr), so we can't get there from 			 * here! 			 */
goto|goto
name|no_route
goto|;
block|}
comment|/* 		 * XXX: sa6 may not have a valid sin6_scope_id in the 		 * non-SCOPEDROUTING case. 		 */
name|bzero
argument_list|(
operator|&
name|lsa6_storage
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa6_storage
argument_list|)
argument_list|)
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa6_storage
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
operator|&
name|lsa6_storage
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX */
name|lsa6_storage
operator|.
name|sin6_addr
operator|=
name|lsa6
operator|->
name|sin6_addr
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|lsa6
operator|=
operator|&
name|lsa6_storage
expr_stmt|;
name|ip6h
operator|->
name|ip6_src
operator|=
name|lsa6
operator|->
name|sin6_addr
expr_stmt|;
comment|/* 		 * We set the hop limit now since there is a good chance 		 * that our ro pointer is now filled 		 */
name|ip6h
operator|->
name|ip6_hlim
operator|=
name|in6_selecthlim
argument_list|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
argument_list|,
operator|(
name|ro
condition|?
operator|(
name|ro
operator|->
name|ro_rt
condition|?
operator|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
operator|)
else|:
operator|(
name|NULL
operator|)
operator|)
else|:
operator|(
name|NULL
operator|)
operator|)
argument_list|)
expr_stmt|;
name|o_flgs
operator|=
literal|0
expr_stmt|;
name|ifp
operator|=
name|ro
operator|->
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
comment|/* Copy to be sure something bad is not happening */
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6h
operator|->
name|ip6_dst
expr_stmt|;
name|lsa6
operator|->
name|sin6_addr
operator|=
name|ip6h
operator|->
name|ip6_src
expr_stmt|;
name|printf
argument_list|(
literal|"Calling ipv6 output routine from low level\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|lsa6
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|net
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
comment|/* preserve the port and scope for link local send */
name|prev_scope
operator|=
name|sin6
operator|->
name|sin6_scope_id
expr_stmt|;
name|prev_port
operator|=
name|sin6
operator|->
name|sin6_port
expr_stmt|;
block|}
name|ret
operator|=
name|ip6_output
argument_list|(
name|o_pak
argument_list|,
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_outputopts
argument_list|,
operator|(
expr|struct
name|route_in6
operator|*
operator|)
name|ro
argument_list|,
name|o_flgs
argument_list|,
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_moptions
argument_list|,
operator|&
name|ifp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* for link local this must be done */
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|prev_scope
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|prev_port
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"return from send is %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG_OUTPUT */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_senderrors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* Now if we had a temp route free it */
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PMTU check versus smallest asoc MTU goes here */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* Route was freed */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
operator|)
condition|)
block|{
name|sctp_mtu_size_reset
argument_list|(
name|inp
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_rmx
operator|.
name|rmx_mtu
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
condition|)
block|{
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|)
condition|)
block|{
name|sctp_mtu_size_reset
argument_list|(
name|inp
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown protocol (TSNH) type %d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|to
operator|)
operator|->
name|sa_family
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_send_initiate
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_at
decl_stmt|,
modifier|*
name|mp_last
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_init_msg
modifier|*
name|initm
decl_stmt|;
name|struct
name|sctp_supported_addr_param
modifier|*
name|sup_addr
decl_stmt|;
name|struct
name|sctp_ecn_supported_param
modifier|*
name|ecn
decl_stmt|;
name|struct
name|sctp_prsctp_supported_param
modifier|*
name|prsctp
decl_stmt|;
name|struct
name|sctp_ecn_nonce_supported_param
modifier|*
name|ecn_nonce
decl_stmt|;
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|int
name|cnt_inits_to
init|=
literal|0
decl_stmt|;
name|int
name|padval
decl_stmt|,
name|ret
decl_stmt|;
name|int
name|num_ext
decl_stmt|;
name|int
name|p_len
decl_stmt|;
comment|/* INIT's always go to the primary (and usually ONLY address) */
name|mp_last
operator|=
name|NULL
expr_stmt|;
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
return|return;
block|}
comment|/* we confirm any address we send an INIT to */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we confirm any address we send an INIT to */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT4
condition|)
block|{
name|printf
argument_list|(
literal|"Sending INIT\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
operator|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* 		 * special hook, if we are sending to link local it will not 		 * show up in our private address count. 		 */
name|struct
name|sockaddr_in6
modifier|*
name|sin6l
decl_stmt|;
name|sin6l
operator|=
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6l
operator|->
name|sin6_addr
argument_list|)
condition|)
name|cnt_inits_to
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* This case should not happen */
return|return;
block|}
comment|/* start the INIT timer */
if|if
condition|(
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
comment|/* we are hosed since I can't start the INIT timer? */
return|return;
block|}
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No memory, INIT timer will re-attempt. */
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_msg
argument_list|)
expr_stmt|;
comment|/* Now lets put the SCTP header in place */
name|initm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_init_msg
operator|*
argument_list|)
expr_stmt|;
name|initm
operator|->
name|sh
operator|.
name|src_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|initm
operator|->
name|sh
operator|.
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|initm
operator|->
name|sh
operator|.
name|v_tag
operator|=
literal|0
expr_stmt|;
name|initm
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* calculate later */
comment|/* now the chunk header */
name|initm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_INITIATION
expr_stmt|;
name|initm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
comment|/* fill in later from mbuf we build */
name|initm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_length
operator|=
literal|0
expr_stmt|;
comment|/* place in my tag */
name|initm
operator|->
name|msg
operator|.
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|)
expr_stmt|;
comment|/* set up some of the credits. */
name|initm
operator|->
name|msg
operator|.
name|init
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
argument_list|)
expr_stmt|;
name|initm
operator|->
name|msg
operator|.
name|init
operator|.
name|num_outbound_streams
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
argument_list|)
expr_stmt|;
name|initm
operator|->
name|msg
operator|.
name|init
operator|.
name|num_inbound_streams
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|max_inbound_streams
argument_list|)
expr_stmt|;
name|initm
operator|->
name|msg
operator|.
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|init_seq_number
argument_list|)
expr_stmt|;
comment|/* now the address restriction */
name|sup_addr
operator|=
operator|(
expr|struct
name|sctp_supported_addr_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|initm
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|initm
argument_list|)
operator|)
expr_stmt|;
name|sup_addr
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUPPORTED_ADDRTYPE
argument_list|)
expr_stmt|;
comment|/* we support 2 types IPv6/IPv4 */
name|sup_addr
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sup_addr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|sup_addr
operator|->
name|addr_type
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|sup_addr
operator|->
name|addr_type
index|[
literal|1
index|]
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sup_addr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
condition|)
block|{
name|struct
name|sctp_adaptation_layer_indication
modifier|*
name|ali
decl_stmt|;
name|ali
operator|=
operator|(
expr|struct
name|sctp_adaptation_layer_indication
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sup_addr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sup_addr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ULP_ADAPTATION
argument_list|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ali
argument_list|)
argument_list|)
expr_stmt|;
name|ali
operator|->
name|indication
operator|=
name|ntohl
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ali
argument_list|)
expr_stmt|;
name|ecn
operator|=
operator|(
expr|struct
name|sctp_ecn_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ali
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ali
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ecn
operator|=
operator|(
expr|struct
name|sctp_ecn_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sup_addr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sup_addr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* now any cookie time extensions */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cookie_preserve_req
condition|)
block|{
name|struct
name|sctp_cookie_perserve_param
modifier|*
name|cookie_preserve
decl_stmt|;
name|cookie_preserve
operator|=
operator|(
expr|struct
name|sctp_cookie_perserve_param
operator|*
operator|)
operator|(
name|ecn
operator|)
expr_stmt|;
name|cookie_preserve
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_COOKIE_PRESERVE
argument_list|)
expr_stmt|;
name|cookie_preserve
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cookie_preserve
argument_list|)
argument_list|)
expr_stmt|;
name|cookie_preserve
operator|->
name|time
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cookie_preserve_req
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|cookie_preserve
argument_list|)
expr_stmt|;
name|ecn
operator|=
operator|(
expr|struct
name|sctp_ecn_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|cookie_preserve
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cookie_preserve
argument_list|)
operator|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cookie_preserve_req
operator|=
literal|0
expr_stmt|;
block|}
comment|/* ECN parameter */
if|if
condition|(
name|sctp_ecn_enable
operator|==
literal|1
condition|)
block|{
name|ecn
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ECN_CAPABLE
argument_list|)
expr_stmt|;
name|ecn
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ecn
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ecn
argument_list|)
expr_stmt|;
name|prsctp
operator|=
operator|(
expr|struct
name|sctp_prsctp_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ecn
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ecn
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|prsctp
operator|=
operator|(
expr|struct
name|sctp_prsctp_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ecn
operator|)
expr_stmt|;
block|}
comment|/* And now tell the peer we do pr-sctp */
name|prsctp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_PRSCTP_SUPPORTED
argument_list|)
expr_stmt|;
name|prsctp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|prsctp
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|prsctp
argument_list|)
expr_stmt|;
comment|/* And now tell the peer we do all the extensions */
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|prsctp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|prsctp
argument_list|)
operator|)
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUPPORTED_CHUNK_EXT
argument_list|)
expr_stmt|;
name|num_ext
operator|=
literal|0
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
if|if
condition|(
operator|!
name|sctp_auth_disable
condition|)
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_AUTHENTICATION
expr_stmt|;
name|p_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pr_supported
argument_list|)
operator|+
name|num_ext
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pr_supported
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* ECN nonce: And now tell the peer we support ECN nonce */
if|if
condition|(
name|sctp_ecn_nonce
condition|)
block|{
name|ecn_nonce
operator|=
operator|(
expr|struct
name|sctp_ecn_nonce_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|pr_supported
operator|+
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|)
expr_stmt|;
name|ecn_nonce
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ECN_NONCE_SUPPORTED
argument_list|)
expr_stmt|;
name|ecn_nonce
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ecn_nonce
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ecn_nonce
argument_list|)
expr_stmt|;
block|}
comment|/* add authentication parameters */
if|if
condition|(
operator|!
name|sctp_auth_disable
condition|)
block|{
name|struct
name|sctp_auth_random
modifier|*
name|random
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
decl_stmt|;
comment|/* attach RANDOM parameter, if available */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|!=
name|NULL
condition|)
block|{
name|random
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|p_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|random
argument_list|)
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUTH_DRAFT_04
name|random
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_RANDOM
argument_list|)
expr_stmt|;
name|random
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|->
name|key
argument_list|,
name|random
operator|->
name|random_data
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* random key already contains the header */
name|bcopy
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|->
name|key
argument_list|,
name|random
argument_list|,
name|p_len
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* zero out any padding required */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|random
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
block|}
comment|/* add HMAC_ALGO parameter */
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|p_len
operator|=
name|sctp_serialize_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|hmacs
operator|->
name|hmac_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_len
operator|>
literal|0
condition|)
block|{
name|p_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HMAC_LIST
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* zero out any padding required */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hmacs
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
block|}
comment|/* add CHUNKS parameter */
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|p_len
operator|=
name|sctp_serialize_auth_chunks
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|,
name|chunks
operator|->
name|chunk_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_len
operator|>
literal|0
condition|)
block|{
name|p_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CHUNK_LIST
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* zero out any padding required */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|chunks
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
block|}
block|}
name|m_at
operator|=
name|m
expr_stmt|;
comment|/* now the addresses */
block|{
name|struct
name|sctp_scoping
name|scp
decl_stmt|;
comment|/* 		 * To optimize this we could put the scoping stuff into a 		 * structure and remove the individual uint8's from the 		 * assoc structure. Then we could just sifa in the address 		 * within the stcb.. but for now this is a quick hack to get 		 * the address stuff teased apart. 		 */
name|scp
operator|.
name|ipv4_addr_legal
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_addr_legal
expr_stmt|;
name|scp
operator|.
name|ipv6_addr_legal
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv6_addr_legal
expr_stmt|;
name|scp
operator|.
name|loopback_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
expr_stmt|;
name|scp
operator|.
name|ipv4_local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
expr_stmt|;
name|scp
operator|.
name|local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
expr_stmt|;
name|scp
operator|.
name|site_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
expr_stmt|;
name|m_at
operator|=
name|sctp_add_addresses_to_i_ia
argument_list|(
name|inp
argument_list|,
operator|&
name|scp
argument_list|,
name|m_at
argument_list|,
name|cnt_inits_to
argument_list|)
expr_stmt|;
block|}
comment|/* calulate the size and update pkt header and chunk header */
name|p_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_at
operator|=
name|m
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
name|mp_last
operator|=
name|m_at
expr_stmt|;
name|p_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
name|initm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
operator|(
name|p_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * We sifa 0 here to NOT set IP_DF if its IPv4, we ignore the return 	 * here since the timer will drive a retranmission. 	 */
comment|/* I don't expect this to execute but we will be safe here */
name|padval
operator|=
name|p_len
operator|%
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|padval
operator|)
operator|&&
operator|(
name|mp_last
operator|)
condition|)
block|{
comment|/* 		 * The compiler worries that mp_last may not be set even 		 * though I think it is impossible :-> however we add 		 * mp_last here just in case. 		 */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_add_pad_tombuf
argument_list|(
name|mp_last
argument_list|,
operator|(
literal|4
operator|-
name|padval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Houston we have a problem, no space */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_len
operator|+=
name|padval
expr_stmt|;
block|}
name|ret
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_arethere_unrecognized_parameters
parameter_list|(
name|struct
name|mbuf
modifier|*
name|in_initpkt
parameter_list|,
name|int
name|param_offset
parameter_list|,
name|int
modifier|*
name|abort_processing
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|cp
parameter_list|)
block|{
comment|/* 	 * Given a mbuf containing an INIT or INIT-ACK with the param_offset 	 * being equal to the beginning of the params i.e. (iphlen + 	 * sizeof(struct sctp_init_msg) parse through the parameters to the 	 * end of the mbuf verifying that all parameters are known. 	 *  	 * For unknown parameters build and return a mbuf with 	 * UNRECOGNIZED_PARAMETER errors. If the flags indicate to stop 	 * processing this chunk stop, and set *abort_processing to 1. 	 *  	 * By having param_offset be pre-set to where parameters begin it is 	 * hoped that this routine may be reused in the future by new 	 * features. 	 */
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|params
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|,
modifier|*
name|op_err
decl_stmt|;
name|char
name|tempbuf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|at
decl_stmt|,
name|limit
decl_stmt|,
name|pad_needed
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|,
name|padded_size
decl_stmt|;
name|int
name|err_at
decl_stmt|;
operator|*
name|abort_processing
operator|=
literal|0
expr_stmt|;
name|mat
operator|=
name|in_initpkt
expr_stmt|;
name|err_at
operator|=
literal|0
expr_stmt|;
name|limit
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|at
operator|=
name|param_offset
expr_stmt|;
name|op_err
operator|=
name|NULL
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|phdr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|limit
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plen
operator|>
name|limit
operator|)
operator|||
operator|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
condition|)
block|{
comment|/* wacked parameter */
goto|goto
name|invalid_size
goto|;
block|}
name|limit
operator|-=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
comment|/*- 		 * All parameters for all chunks that we know/understand are 		 * listed here. We process them other places and make 		 * appropriate stop actions per the upper bits. However this 		 * is the generic routine processor's can call to get back 		 * an operr.. to either incorporate (init-ack) or send. 		 */
name|padded_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
comment|/* Param's with variable size */
case|case
name|SCTP_HEARTBEAT_INFO
case|:
case|case
name|SCTP_STATE_COOKIE
case|:
case|case
name|SCTP_UNRECOG_PARAM
case|:
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
comment|/* ok skip fwd */
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
comment|/* Param's with variable size within a range */
case|case
name|SCTP_CHUNK_LIST
case|:
case|case
name|SCTP_SUPPORTED_CHUNK_EXT
case|:
if|if
condition|(
name|padded_size
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_supported_chunk_types_param
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|SCTP_MAX_SUPPORTED_EXT
operator|)
operator|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_SUPPORTED_ADDRTYPE
case|:
if|if
condition|(
name|padded_size
operator|>
name|SCTP_MAX_ADDR_PARAMS_SIZE
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_RANDOM
case|:
if|if
condition|(
name|padded_size
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_random
argument_list|)
operator|+
name|SCTP_RANDOM_MAX_SIZE
operator|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
if|if
condition|(
operator|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
operator|)
operator|&&
operator|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
comment|/* Param's with a fixed size */
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_COOKIE_PRESERVE
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_perserve_param
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_ECN_NONCE_SUPPORTED
case|:
case|case
name|SCTP_PRSCTP_SUPPORTED
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_ECN_CAPABLE
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecn_supported_param
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_ULP_ADAPTATION
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_layer_indication
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
condition|)
block|{
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_HOSTNAME_ADDRESS
case|:
block|{
comment|/* We can NOT handle HOST NAME addresses!! */
name|int
name|l_len
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT4
condition|)
block|{
name|printf
argument_list|(
literal|"Can't handle hostname addresses.. abort processing\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|abort_processing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
comment|/* Ok need to try to get a mbuf */
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|l_len
operator|+=
name|plen
expr_stmt|;
name|l_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|l_len
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 						 * pre-reserve space for ip 						 * and sctp header  and 						 * chunk hdr 						 */
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* If we have space */
name|struct
name|sctp_paramhdr
name|s
decl_stmt|;
if|if
condition|(
name|err_at
operator|%
literal|4
condition|)
block|{
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|pad_needed
operator|=
literal|4
operator|-
operator|(
name|err_at
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|pad_needed
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|pad_needed
expr_stmt|;
block|}
name|s
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|)
expr_stmt|;
name|s
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|+
name|plen
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|err_at
operator|+=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|tempbuf
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
comment|/* 						 * we are out of memory but 						 * we still need to have a 						 * look at what to do (the 						 * system is in trouble 						 * though). 						 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|plen
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|plen
expr_stmt|;
block|}
return|return
operator|(
name|op_err
operator|)
return|;
break|break;
block|}
default|default:
comment|/* 			 * we do not recognize the parameter figure out what 			 * we do. 			 */
if|if
condition|(
operator|(
name|ptype
operator|&
literal|0x4000
operator|)
operator|==
literal|0x4000
condition|)
block|{
comment|/* Report bit is set?? */
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
name|int
name|l_len
decl_stmt|;
comment|/* Ok need to try to get an mbuf */
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|l_len
operator|+=
name|plen
expr_stmt|;
name|l_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|l_len
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* If we have space */
name|struct
name|sctp_paramhdr
name|s
decl_stmt|;
if|if
condition|(
name|err_at
operator|%
literal|4
condition|)
block|{
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|pad_needed
operator|=
literal|4
operator|-
operator|(
name|err_at
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|pad_needed
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|pad_needed
expr_stmt|;
block|}
name|s
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_UNRECOG_PARAM
argument_list|)
expr_stmt|;
name|s
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|+
name|plen
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|err_at
operator|+=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
condition|)
block|{
name|plen
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|tempbuf
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
comment|/* 						 * we are out of memory but 						 * we still need to have a 						 * look at what to do (the 						 * system is in trouble 						 * though). 						 */
name|op_err
operator|=
name|NULL
expr_stmt|;
goto|goto
name|more_processing
goto|;
block|}
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|plen
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|plen
expr_stmt|;
block|}
block|}
name|more_processing
label|:
if|if
condition|(
operator|(
name|ptype
operator|&
literal|0x8000
operator|)
operator|==
literal|0x0000
condition|)
block|{
return|return
operator|(
name|op_err
operator|)
return|;
block|}
else|else
block|{
comment|/* skip this chunk and continue processing */
name|at
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|op_err
operator|)
return|;
name|invalid_size
label|:
operator|*
name|abort_processing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|op_err
operator|==
name|NULL
operator|)
operator|&&
name|phdr
condition|)
block|{
name|int
name|l_len
decl_stmt|;
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|l_len
operator|+=
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|l_len
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|op_err
operator|)
operator|&&
name|phdr
condition|)
block|{
name|struct
name|sctp_paramhdr
name|s
decl_stmt|;
if|if
condition|(
name|err_at
operator|%
literal|4
condition|)
block|{
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|pad_needed
operator|=
literal|4
operator|-
operator|(
name|err_at
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|pad_needed
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|pad_needed
expr_stmt|;
block|}
name|s
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|s
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|err_at
operator|+=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Only copy back the p-hdr that caused the issue */
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|op_err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_are_there_new_addresses
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|in_initpkt
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
comment|/* 	 * Given a INIT packet, look through the packet to verify that there 	 * are NO new addresses. As we go through the parameters add reports 	 * of any un-understood parameters that require an error.  Also we 	 * must return (1) to drop the packet if we see a un-understood 	 * parameter that tells us to drop the chunk. 	 */
name|struct
name|sockaddr_in
name|sin4
decl_stmt|,
modifier|*
name|sa4
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|,
modifier|*
name|sa6
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa_touse
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|params
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|int
name|err_at
decl_stmt|;
name|uint8_t
name|fnd
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sin4
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin4
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin4
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sa_touse
operator|=
name|NULL
expr_stmt|;
comment|/* First what about the src address of the pkt ? */
name|iph
operator|=
name|mtod
argument_list|(
name|in_initpkt
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* source addr is IPv4 */
name|sin4
operator|.
name|sin_addr
operator|=
name|iph
operator|->
name|ip_src
expr_stmt|;
name|sa_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* source addr is IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6h
decl_stmt|;
name|ip6h
operator|=
name|mtod
argument_list|(
name|in_initpkt
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|ip6h
operator|->
name|ip6_src
expr_stmt|;
name|sa_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|sa_touse
operator|->
name|sa_family
condition|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sa4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sin4
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|fnd
operator|==
literal|0
condition|)
block|{
comment|/* New address added! no need to look futher. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Ok so far lets munge through the rest of the packet */
name|mat
operator|=
name|in_initpkt
expr_stmt|;
name|err_at
operator|=
literal|0
expr_stmt|;
name|sa_touse
operator|=
name|NULL
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|offset
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|p4
decl_stmt|,
name|p4_buf
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p4_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p4_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|sin4
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|p4
operator|->
name|addr
expr_stmt|;
name|sa_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p6
decl_stmt|,
name|p6_buf
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p6_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p6_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p6
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|sa_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin4
expr_stmt|;
block|}
if|if
condition|(
name|sa_touse
condition|)
block|{
comment|/* ok, sa_touse points to one to check */
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|sa_touse
operator|->
name|sa_family
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sa4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sin4
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
comment|/* New addr added! no need to look further */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|offset
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a MBUF chain that was sent into us containing an INIT. Build a  * INIT-ACK with COOKIE and send back. We assume that the in_initpkt has done  * a pullup to include IPv6/4header, SCTP header and initial part of INIT  * message (i.e. the struct sctp_init_msg).  */
end_comment

begin_function
name|void
name|sctp_send_initiate_ack
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|init_pkt
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_chunk
modifier|*
name|init_chk
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_at
decl_stmt|,
modifier|*
name|m_tmp
decl_stmt|,
modifier|*
name|m_cookie
decl_stmt|,
modifier|*
name|op_err
decl_stmt|,
modifier|*
name|mp_last
decl_stmt|;
name|struct
name|sctp_init_msg
modifier|*
name|initackm_out
decl_stmt|;
name|struct
name|sctp_ecn_supported_param
modifier|*
name|ecn
decl_stmt|;
name|struct
name|sctp_prsctp_supported_param
modifier|*
name|prsctp
decl_stmt|;
name|struct
name|sctp_ecn_nonce_supported_param
modifier|*
name|ecn_nonce
decl_stmt|;
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|struct
name|sockaddr_storage
name|store
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sctp_route_t
modifier|*
name|ro
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|to
decl_stmt|;
name|struct
name|sctp_state_cookie
name|stc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|int
name|cnt_inits_to
init|=
literal|0
decl_stmt|;
name|uint16_t
name|his_limit
decl_stmt|,
name|i_want
decl_stmt|;
name|int
name|abort_flag
decl_stmt|,
name|padval
decl_stmt|,
name|sz_of
decl_stmt|;
name|int
name|num_ext
decl_stmt|;
name|int
name|p_len
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|vrf_id
operator|=
name|asoc
operator|->
name|vrf_id
expr_stmt|;
block|}
else|else
block|{
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|asoc
operator|=
name|NULL
expr_stmt|;
block|}
name|mp_last
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|&&
operator|(
name|sctp_are_there_new_addresses
argument_list|(
name|asoc
argument_list|,
name|init_pkt
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|)
operator|)
condition|)
block|{
comment|/* new addresses, out of here in non-cookie-wait states */
comment|/* 		 * Send a ABORT, we don't add the new address error clause 		 * though we even set the T bit and copy in the 0 tag.. this 		 * looks no different than if no listener was present. 		 */
name|sctp_send_abort
argument_list|(
name|init_pkt
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort_flag
operator|=
literal|0
expr_stmt|;
name|op_err
operator|=
name|sctp_arethere_unrecognized_parameters
argument_list|(
name|init_pkt
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|)
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|init_chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
name|sctp_send_abort
argument_list|(
name|init_pkt
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No memory, INIT timer will re-attempt. */
if|if
condition|(
name|op_err
condition|)
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_msg
argument_list|)
expr_stmt|;
comment|/* the time I built cookie */
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* populate any tie tags */
if|if
condition|(
name|asoc
operator|!=
name|NULL
condition|)
block|{
comment|/* unlock before tag selections */
name|stc
operator|.
name|tie_tag_my_vtag
operator|=
name|asoc
operator|->
name|my_vtag_nonce
expr_stmt|;
name|stc
operator|.
name|tie_tag_peer_vtag
operator|=
name|asoc
operator|->
name|peer_vtag_nonce
expr_stmt|;
name|stc
operator|.
name|cookie_life
operator|=
name|asoc
operator|->
name|cookie_life
expr_stmt|;
name|net
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
else|else
block|{
name|stc
operator|.
name|tie_tag_my_vtag
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|tie_tag_peer_vtag
operator|=
literal|0
expr_stmt|;
comment|/* life I will award this cookie */
name|stc
operator|.
name|cookie_life
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
expr_stmt|;
block|}
comment|/* copy in the ports for later check */
name|stc
operator|.
name|myport
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|stc
operator|.
name|peerport
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
comment|/* 	 * If we wanted to honor cookie life extentions, we would add to 	 * stc.cookie_life. For now we should NOT honor any extension 	 */
name|stc
operator|.
name|site_scope
operator|=
name|stc
operator|.
name|local_scope
operator|=
name|stc
operator|.
name|loopback_scope
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|struct
name|inpcb
modifier|*
name|in_inp
decl_stmt|;
comment|/* Its a V6 socket */
name|in_inp
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|inp
expr_stmt|;
name|stc
operator|.
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
comment|/* Now look at the binding flag to see if V4 will be legal */
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|in_inp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|stc
operator|.
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* V4 addresses are NOT legal on the association */
name|stc
operator|.
name|ipv4_addr_legal
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Its a V4 socket, no - V6 */
name|stc
operator|.
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DONT_DO_PRIVADDR_SCOPE
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|stc
operator|.
name|ipv4_scope
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* now for scope setup */
name|memset
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|store
expr_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|init_pkt
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|addr
decl_stmt|;
name|sctp_route_t
name|iproute
decl_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|iph
operator|->
name|ip_src
expr_stmt|;
comment|/* lookup address */
name|stc
operator|.
name|address
index|[
literal|0
index|]
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
comment|/* local from address */
name|memset
argument_list|(
operator|&
name|iproute
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iproute
argument_list|)
argument_list|)
expr_stmt|;
name|ro
operator|=
operator|&
name|iproute
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|ro
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
name|stc
operator|.
name|laddress
index|[
literal|0
index|]
operator|=
name|addr
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
comment|/* scope_id is only for v6 */
name|stc
operator|.
name|scope_id
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SCTP_DONT_DO_PRIVADDR_SCOPE
if|if
condition|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DONT_DO_PRIVADDR_SCOPE */
comment|/* Must use the address in this case */
if|if
condition|(
name|sctp_is_address_on_local_host
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
name|stc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|addr
decl_stmt|;
name|struct
name|route_in6
name|iproute6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|init_pkt
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
comment|/* lookup address */
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|address
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|stc
operator|.
name|scope_id
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_is_address_on_local_host
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
name|stc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 				 * If the new destination is a LINK_LOCAL we 				 * must have common both site and local 				 * scope. Don't set local scope though since 				 * we must depend on the source to be added 				 * implicitly. We cannot assure just because 				 * we share one link that all links are 				 * common. 				 */
name|stc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
comment|/* 				 * we start counting for the private address 				 * stuff at 1. since the link local we 				 * source from won't show up in our scoped 				 * count. 				 */
name|cnt_inits_to
operator|=
literal|1
expr_stmt|;
comment|/* pull out the scope_id from incoming pkt */
comment|/* FIX ME: does this have scope from rcvif? */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|ip6_use_defzone
argument_list|)
expr_stmt|;
name|stc
operator|.
name|scope_id
operator|=
name|sin6
operator|->
name|sin6_scope_id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 				 * If the new destination is SITE_LOCAL then 				 * we must have site scope in common. 				 */
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
comment|/* local from address */
name|memset
argument_list|(
operator|&
name|iproute6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iproute6
argument_list|)
argument_list|)
expr_stmt|;
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|iproute6
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|ro
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|laddress
argument_list|,
operator|&
name|addr
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* set the scope per the existing tcb */
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|stc
operator|.
name|loopback_scope
operator|=
name|asoc
operator|->
name|loopback_scope
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
name|asoc
operator|->
name|ipv4_local_scope
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
name|asoc
operator|->
name|site_scope
expr_stmt|;
name|stc
operator|.
name|local_scope
operator|=
name|asoc
operator|->
name|local_scope
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|lnet
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|lnet
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * if we have a LL address, start 					 * counting at 1. 					 */
name|cnt_inits_to
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* use the net pointer */
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|0
index|]
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* 				 * strange case here, the INIT should have 				 * did the selection. 				 */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
return|return;
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
name|stc
operator|.
name|laddress
index|[
literal|0
index|]
operator|=
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|to
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|address
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* 				 * strange case here, the INIT should have 				 * did the selection. 				 */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
return|return;
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|laddress
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
block|}
block|}
comment|/* Now lets put the SCTP header in place */
name|initackm_out
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_init_msg
operator|*
argument_list|)
expr_stmt|;
name|initackm_out
operator|->
name|sh
operator|.
name|src_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|initackm_out
operator|->
name|sh
operator|.
name|dest_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|initackm_out
operator|->
name|sh
operator|.
name|v_tag
operator|=
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
expr_stmt|;
comment|/* Save it off for quick ref */
name|stc
operator|.
name|peers_vtag
operator|=
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
expr_stmt|;
name|initackm_out
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* calculate later */
comment|/* who are we */
name|memcpy
argument_list|(
name|stc
operator|.
name|identification
argument_list|,
name|SCTP_VERSION_STRING
argument_list|,
name|min
argument_list|(
name|strlen
argument_list|(
name|SCTP_VERSION_STRING
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|stc
operator|.
name|identification
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now the chunk header */
name|initackm_out
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_INITIATION_ACK
expr_stmt|;
name|initackm_out
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
comment|/* fill in later from mbuf we build */
name|initackm_out
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_length
operator|=
literal|0
expr_stmt|;
comment|/* place in my tag */
if|if
condition|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_INUSE
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|)
condition|)
block|{
comment|/* re-use the v-tags and init-seq here */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|my_vtag
argument_list|)
expr_stmt|;
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|init_seq_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|vtag
decl_stmt|;
if|if
condition|(
name|asoc
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|vtag
argument_list|)
expr_stmt|;
comment|/* get a TSN to use too */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|vtag
argument_list|)
expr_stmt|;
comment|/* get a TSN to use too */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* save away my tag to */
name|stc
operator|.
name|my_vtag
operator|=
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|initiate_tag
expr_stmt|;
comment|/* set up some of the credits. */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set what I want */
name|his_limit
operator|=
name|ntohs
argument_list|(
name|init_chk
operator|->
name|init
operator|.
name|num_inbound_streams
argument_list|)
expr_stmt|;
comment|/* choose what I want */
if|if
condition|(
name|asoc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|streamoutcnt
operator|>
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
condition|)
block|{
name|i_want
operator|=
name|asoc
operator|->
name|streamoutcnt
expr_stmt|;
block|}
else|else
block|{
name|i_want
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
block|}
block|}
else|else
block|{
name|i_want
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
block|}
if|if
condition|(
name|his_limit
operator|<
name|i_want
condition|)
block|{
comment|/* I Want more :< */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|num_outbound_streams
operator|=
name|init_chk
operator|->
name|init
operator|.
name|num_inbound_streams
expr_stmt|;
block|}
else|else
block|{
comment|/* I can have what I want :> */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|num_outbound_streams
operator|=
name|htons
argument_list|(
name|i_want
argument_list|)
expr_stmt|;
block|}
comment|/* tell him his limt. */
name|initackm_out
operator|->
name|msg
operator|.
name|init
operator|.
name|num_inbound_streams
operator|=
name|htons
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
argument_list|)
expr_stmt|;
comment|/* setup the ECN pointer */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
condition|)
block|{
name|struct
name|sctp_adaptation_layer_indication
modifier|*
name|ali
decl_stmt|;
name|ali
operator|=
operator|(
expr|struct
name|sctp_adaptation_layer_indication
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|initackm_out
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|initackm_out
argument_list|)
operator|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ULP_ADAPTATION
argument_list|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ali
argument_list|)
argument_list|)
expr_stmt|;
name|ali
operator|->
name|indication
operator|=
name|ntohl
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ali
argument_list|)
expr_stmt|;
name|ecn
operator|=
operator|(
expr|struct
name|sctp_ecn_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ali
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ali
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ecn
operator|=
operator|(
expr|struct
name|sctp_ecn_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|initackm_out
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|initackm_out
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* ECN parameter */
if|if
condition|(
name|sctp_ecn_enable
operator|==
literal|1
condition|)
block|{
name|ecn
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ECN_CAPABLE
argument_list|)
expr_stmt|;
name|ecn
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ecn
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ecn
argument_list|)
expr_stmt|;
name|prsctp
operator|=
operator|(
expr|struct
name|sctp_prsctp_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ecn
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ecn
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|prsctp
operator|=
operator|(
expr|struct
name|sctp_prsctp_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ecn
operator|)
expr_stmt|;
block|}
comment|/* And now tell the peer we do  pr-sctp */
name|prsctp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_PRSCTP_SUPPORTED
argument_list|)
expr_stmt|;
name|prsctp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|prsctp
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|prsctp
argument_list|)
expr_stmt|;
comment|/* And now tell the peer we do all the extensions */
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|prsctp
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|prsctp
argument_list|)
operator|)
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUPPORTED_CHUNK_EXT
argument_list|)
expr_stmt|;
name|num_ext
operator|=
literal|0
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
if|if
condition|(
operator|!
name|sctp_auth_disable
condition|)
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_AUTHENTICATION
expr_stmt|;
name|p_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|pr_supported
argument_list|)
operator|+
name|num_ext
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|pr_supported
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* ECN nonce: And now tell the peer we support ECN nonce */
if|if
condition|(
name|sctp_ecn_nonce
condition|)
block|{
name|ecn_nonce
operator|=
operator|(
expr|struct
name|sctp_ecn_nonce_supported_param
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|pr_supported
operator|+
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|)
expr_stmt|;
name|ecn_nonce
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ECN_NONCE_SUPPORTED
argument_list|)
expr_stmt|;
name|ecn_nonce
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ecn_nonce
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ecn_nonce
argument_list|)
expr_stmt|;
block|}
comment|/* add authentication parameters */
if|if
condition|(
operator|!
name|sctp_auth_disable
condition|)
block|{
name|struct
name|sctp_auth_random
modifier|*
name|random
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
decl_stmt|;
name|uint16_t
name|random_len
decl_stmt|;
comment|/* generate and add RANDOM parameter */
name|random_len
operator|=
name|SCTP_AUTH_RANDOM_SIZE_DEFAULT
expr_stmt|;
name|random
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|random
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_RANDOM
argument_list|)
expr_stmt|;
name|p_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|random
argument_list|)
operator|+
name|random_len
expr_stmt|;
name|random
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_READ_RANDOM
argument_list|(
name|random
operator|->
name|random_data
argument_list|,
name|random_len
argument_list|)
expr_stmt|;
comment|/* zero out any padding required */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|random
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* add HMAC_ALGO parameter */
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|p_len
operator|=
name|sctp_serialize_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|hmacs
operator|->
name|hmac_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_len
operator|>
literal|0
condition|)
block|{
name|p_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|hmacs
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HMAC_LIST
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* zero out any padding required */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|hmacs
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
block|}
comment|/* add CHUNKS parameter */
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|)
expr_stmt|;
name|p_len
operator|=
name|sctp_serialize_auth_chunks
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|,
name|chunks
operator|->
name|chunk_types
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_len
operator|>
literal|0
condition|)
block|{
name|p_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|chunks
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CHUNK_LIST
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
comment|/* zero out any padding required */
name|bzero
argument_list|(
operator|(
name|caddr_t
operator|)
name|chunks
operator|+
name|p_len
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
operator|-
name|p_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
block|}
block|}
name|m_at
operator|=
name|m
expr_stmt|;
comment|/* now the addresses */
block|{
name|struct
name|sctp_scoping
name|scp
decl_stmt|;
comment|/* 		 * To optimize this we could put the scoping stuff into a 		 * structure and remove the individual uint8's from the stc 		 * structure. Then we could just sifa in the address within 		 * the stc.. but for now this is a quick hack to get the 		 * address stuff teased apart. 		 */
name|scp
operator|.
name|ipv4_addr_legal
operator|=
name|stc
operator|.
name|ipv4_addr_legal
expr_stmt|;
name|scp
operator|.
name|ipv6_addr_legal
operator|=
name|stc
operator|.
name|ipv6_addr_legal
expr_stmt|;
name|scp
operator|.
name|loopback_scope
operator|=
name|stc
operator|.
name|loopback_scope
expr_stmt|;
name|scp
operator|.
name|ipv4_local_scope
operator|=
name|stc
operator|.
name|ipv4_scope
expr_stmt|;
name|scp
operator|.
name|local_scope
operator|=
name|stc
operator|.
name|local_scope
expr_stmt|;
name|scp
operator|.
name|site_scope
operator|=
name|stc
operator|.
name|site_scope
expr_stmt|;
name|m_at
operator|=
name|sctp_add_addresses_to_i_ia
argument_list|(
name|inp
argument_list|,
operator|&
name|scp
argument_list|,
name|m_at
argument_list|,
name|cnt_inits_to
argument_list|)
expr_stmt|;
block|}
comment|/* tack on the operational error if present */
if|if
condition|(
name|op_err
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|ol
decl_stmt|;
name|int
name|llen
decl_stmt|;
name|llen
operator|=
literal|0
expr_stmt|;
name|ol
operator|=
name|op_err
expr_stmt|;
while|while
condition|(
name|ol
condition|)
block|{
name|llen
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|ol
argument_list|)
expr_stmt|;
name|ol
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|ol
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|llen
operator|%
literal|4
condition|)
block|{
comment|/* must add a pad to the param */
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|int
name|padlen
decl_stmt|;
name|padlen
operator|=
literal|4
operator|-
operator|(
name|llen
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|llen
argument_list|,
name|padlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|op_err
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Get total size of init packet */
name|sz_of
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|init_chk
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pre-calulate the size and update pkt header and chunk header */
name|p_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_tmp
operator|=
name|m
init|;
name|m_tmp
condition|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
control|)
block|{
name|p_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* m_tmp should now point to last one */
break|break;
block|}
block|}
comment|/* 	 * Figure now the size of the cookie. We know the size of the 	 * INIT-ACK. The Cookie is going to be the size of INIT, INIT-ACK, 	 * COOKIE-STRUCTURE and SIGNATURE. 	 */
comment|/* 	 * take our earlier INIT calc and add in the sz we just calculated 	 * minus the size of the sctphdr (its not included in chunk size 	 */
comment|/* add once for the INIT-ACK */
name|sz_of
operator|+=
operator|(
name|p_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
comment|/* add a second time for the INIT-ACK in the cookie */
name|sz_of
operator|+=
operator|(
name|p_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
comment|/* Now add the cookie header and cookie message struct */
name|sz_of
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie_param
argument_list|)
expr_stmt|;
comment|/* ...and add the size of our signature */
name|sz_of
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|initackm_out
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|sz_of
argument_list|)
expr_stmt|;
comment|/* Now we must build a cookie */
name|m_cookie
operator|=
name|sctp_add_cookie
argument_list|(
name|inp
argument_list|,
name|init_pkt
argument_list|,
name|offset
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
operator|&
name|stc
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_cookie
operator|==
name|NULL
condition|)
block|{
comment|/* memory problem */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now append the cookie to the end and update the space/size */
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|=
name|m_cookie
expr_stmt|;
for|for
control|(
init|;
name|m_tmp
condition|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
control|)
block|{
name|p_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* m_tmp should now point to last one */
name|mp_last
operator|=
name|m_tmp
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * We sifa 0 here to NOT set IP_DF if its IPv4, we ignore the return 	 * here since the timer will drive a retranmission. 	 */
name|padval
operator|=
name|p_len
operator|%
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|padval
operator|)
operator|&&
operator|(
name|mp_last
operator|)
condition|)
block|{
comment|/* see my previous comments on mp_last */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_add_pad_tombuf
argument_list|(
name|mp_last
argument_list|,
operator|(
literal|4
operator|-
name|padval
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* Houston we have a problem, no space */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|p_len
operator|+=
name|padval
expr_stmt|;
block|}
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|to
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_insert_on_wheel
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_stream_out
modifier|*
name|strq
parameter_list|,
name|int
name|holds_lock
parameter_list|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|stre
decl_stmt|,
modifier|*
name|strn
decl_stmt|;
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strq
operator|->
name|next_spoke
operator|.
name|tqe_next
operator|)
operator|||
operator|(
name|strq
operator|->
name|next_spoke
operator|.
name|tqe_prev
operator|)
condition|)
block|{
comment|/* already on wheel */
goto|goto
name|outof_here
goto|;
block|}
name|stre
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
expr_stmt|;
if|if
condition|(
name|stre
operator|==
name|NULL
condition|)
block|{
comment|/* only one on wheel */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|,
name|strq
argument_list|,
name|next_spoke
argument_list|)
expr_stmt|;
goto|goto
name|outof_here
goto|;
block|}
for|for
control|(
init|;
name|stre
condition|;
name|stre
operator|=
name|strn
control|)
block|{
name|strn
operator|=
name|TAILQ_NEXT
argument_list|(
name|stre
argument_list|,
name|next_spoke
argument_list|)
expr_stmt|;
if|if
condition|(
name|stre
operator|->
name|stream_no
operator|>
name|strq
operator|->
name|stream_no
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|stre
argument_list|,
name|strq
argument_list|,
name|next_spoke
argument_list|)
expr_stmt|;
goto|goto
name|outof_here
goto|;
block|}
elseif|else
if|if
condition|(
name|stre
operator|->
name|stream_no
operator|==
name|strq
operator|->
name|stream_no
condition|)
block|{
comment|/* huh, should not happen */
goto|goto
name|outof_here
goto|;
block|}
elseif|else
if|if
condition|(
name|strn
operator|==
name|NULL
condition|)
block|{
comment|/* next one is null */
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|,
name|stre
argument_list|,
name|strq
argument_list|,
name|next_spoke
argument_list|)
expr_stmt|;
block|}
block|}
name|outof_here
label|:
if|if
condition|(
name|holds_lock
operator|==
literal|0
condition|)
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_remove_from_wheel
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_stream_out
modifier|*
name|strq
parameter_list|)
block|{
comment|/* take off and then setup so we know it is not on the wheel */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
condition|)
block|{
comment|/* more was added */
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|,
name|strq
argument_list|,
name|next_spoke
argument_list|)
expr_stmt|;
name|strq
operator|->
name|next_spoke
operator|.
name|tqe_next
operator|=
name|NULL
expr_stmt|;
name|strq
operator|->
name|next_spoke
operator|.
name|tqe_prev
operator|=
name|NULL
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_prune_prsctp
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|int
name|dataout
parameter_list|)
block|{
name|int
name|freed_spc
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|>
literal|0
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 			 * Look for chunks marked with the PR_SCTP flag AND 			 * the buffer space flag. If the one being sent is 			 * equal or greater priority then purge the old one 			 * and free some space. 			 */
if|if
condition|(
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* 				 * This one is PR-SCTP AND buffer space 				 * limited type 				 */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
operator|>=
operator|(
name|long
operator|)
name|srcv
operator|->
name|sinfo_timetolive
condition|)
block|{
comment|/* 					 * Lower numbers equates to higher 					 * priority so if the one we are 					 * looking at has a larger or equal 					 * priority we want to drop the data 					 * and NOT retransmit it. 					 */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
comment|/* 						 * We release the book_size 						 * if the mbuf is here 						 */
name|int
name|ret_spc
decl_stmt|;
name|int
name|cause
decl_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_UNSENT
condition|)
name|cause
operator|=
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_SENT
expr_stmt|;
else|else
name|cause
operator|=
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_UNSENT
expr_stmt|;
name|ret_spc
operator|=
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|cause
argument_list|,
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
name|freed_spc
operator|+=
name|ret_spc
expr_stmt|;
if|if
condition|(
name|freed_spc
operator|>=
name|dataout
condition|)
block|{
return|return;
block|}
block|}
comment|/* if chunk was present */
block|}
comment|/* if of sufficent priority */
block|}
comment|/* if chunk has enabled */
block|}
comment|/* tailqforeach */
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|nchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* Here we must move to the sent queue and mark */
if|if
condition|(
name|PR_SCTP_TTL_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
operator|>=
operator|(
name|long
operator|)
name|srcv
operator|->
name|sinfo_timetolive
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
comment|/* 						 * We release the book_size 						 * if the mbuf is here 						 */
name|int
name|ret_spc
decl_stmt|;
name|ret_spc
operator|=
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
operator||
name|SCTP_NOTIFY_DATAGRAM_UNSENT
argument_list|,
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
name|freed_spc
operator|+=
name|ret_spc
expr_stmt|;
if|if
condition|(
name|freed_spc
operator|>=
name|dataout
condition|)
block|{
return|return;
block|}
block|}
comment|/* end if chk->data */
block|}
comment|/* end if right class */
block|}
comment|/* end if chk pr-sctp */
name|chk
operator|=
name|nchk
expr_stmt|;
block|}
comment|/* end while (chk) */
block|}
comment|/* if enabled in asoc */
block|}
end_function

begin_function
name|__inline
name|int
name|sctp_get_frag_point
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|int
name|siz
decl_stmt|,
name|ovh
decl_stmt|;
comment|/* 	 * For endpoints that have both v6 and v4 addresses we must reserve 	 * room for the ipv6 header, for those that are only dealing with V4 	 * we use a larger frag point. 	 */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_frag_point
operator|>
name|asoc
operator|->
name|smallest_mtu
condition|)
name|siz
operator|=
name|asoc
operator|->
name|smallest_mtu
operator|-
name|ovh
expr_stmt|;
else|else
name|siz
operator|=
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_frag_point
operator|-
name|ovh
operator|)
expr_stmt|;
comment|/* 	 * if (siz> (MCLBYTES-sizeof(struct sctp_data_chunk))) { 	 */
comment|/* A data chunk MUST fit in a cluster */
comment|/* siz = (MCLBYTES - sizeof(struct sctp_data_chunk)); */
comment|/* } */
comment|/* adjust for an AUTH chunk if DATA requires auth */
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
name|siz
operator|-=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz
operator|%
literal|4
condition|)
block|{
comment|/* make it an even word boundary please */
name|siz
operator|-=
operator|(
name|siz
operator|%
literal|4
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|siz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_set_prsctp_policy
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|)
block|{
name|sp
operator|->
name|pr_sctp_on
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
condition|)
block|{
comment|/* 		 * We assume that the user wants PR_SCTP_TTL if the user 		 * provides a positive lifetime but does not specify any 		 * PR_SCTP policy. This is a BAD assumption and causes 		 * problems at least with the U-Vancovers MPI folks. I will 		 * change this to be no policy means NO PR-SCTP. 		 */
if|if
condition|(
name|PR_SCTP_ENABLED
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
condition|)
block|{
name|sp
operator|->
name|act_flags
operator||=
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
expr_stmt|;
name|sp
operator|->
name|pr_sctp_on
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
switch|switch
condition|(
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
condition|)
block|{
case|case
name|CHUNK_FLAGS_PR_SCTP_BUF
case|:
comment|/* 			 * Time to live is a priority stored in tv_sec when 			 * doing the buffer drop thing. 			 */
name|sp
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|timetolive
expr_stmt|;
name|sp
operator|->
name|ts
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CHUNK_FLAGS_PR_SCTP_TTL
case|:
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|timetolive
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|sp
operator|->
name|timetolive
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
name|timevaladd
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHUNK_FLAGS_PR_SCTP_RTX
case|:
comment|/* 			 * Time to live is a the number or retransmissions 			 * stored in tv_sec. 			 */
name|sp
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|timetolive
expr_stmt|;
name|sp
operator|->
name|ts
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_USRREQ1
condition|)
block|{
name|printf
argument_list|(
literal|"Unknown PR_SCTP policy %u.\n"
argument_list|,
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_msg_append
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|int
name|hold_stcb_lock
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|,
name|holds_lock
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|at
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|strm
decl_stmt|;
comment|/* 	 * Given an mbuf chain, put it into the association send queue and 	 * place it on the wheel 	 */
name|holds_lock
operator|=
name|hold_stcb_lock
expr_stmt|;
if|if
condition|(
name|srcv
operator|->
name|sinfo_stream
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
comment|/* Invalid stream number */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_locked
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_locked_on
operator|!=
name|srcv
operator|->
name|sinfo_stream
operator|)
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|strm
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|srcv
operator|->
name|sinfo_stream
index|]
expr_stmt|;
comment|/* Now can we send this? */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
comment|/* got data while shutting down */
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sctp_alloc_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sp
operator|->
name|sinfo_flags
operator|=
name|srcv
operator|->
name|sinfo_flags
expr_stmt|;
name|sp
operator|->
name|timetolive
operator|=
name|srcv
operator|->
name|sinfo_timetolive
expr_stmt|;
name|sp
operator|->
name|ppid
operator|=
name|srcv
operator|->
name|sinfo_ppid
expr_stmt|;
name|sp
operator|->
name|context
operator|=
name|srcv
operator|->
name|sinfo_context
expr_stmt|;
name|sp
operator|->
name|strseq
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
condition|)
block|{
name|sp
operator|->
name|net
operator|=
name|net
expr_stmt|;
name|sp
operator|->
name|addr_over
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
name|sp
operator|->
name|addr_over
operator|=
literal|0
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|at
operator|=
name|m
expr_stmt|;
name|sctp_set_prsctp_policy
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * We could in theory (for sendall) sifa the length in, but we would 	 * still have to hunt through the chain since we need to setup the 	 * tail_mbuf 	 */
while|while
condition|(
name|at
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|==
name|NULL
condition|)
name|sp
operator|->
name|tail_mbuf
operator|=
name|at
expr_stmt|;
name|sp
operator|->
name|length
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|strseq
operator|=
name|strm
operator|->
name|next_sequence_sent
expr_stmt|;
name|strm
operator|->
name|next_sequence_sent
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|strm
operator|->
name|next_spoke
operator|.
name|tqe_next
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|strm
operator|->
name|next_spoke
operator|.
name|tqe_prev
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Not on wheel, insert */
name|sctp_insert_on_wheel
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|strm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|NULL
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|out_now
label|:
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_copy_mbufchain
parameter_list|(
name|struct
name|mbuf
modifier|*
name|clonechain
parameter_list|,
name|struct
name|mbuf
modifier|*
name|outchain
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|endofchain
parameter_list|,
name|int
name|can_take_mbuf
parameter_list|,
name|int
name|sizeofcpy
parameter_list|,
name|uint8_t
name|copy_by_ref
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|appendchain
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|endofchain
operator|==
name|NULL
condition|)
block|{
comment|/* error */
name|error_out
label|:
if|if
condition|(
name|outchain
condition|)
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|can_take_mbuf
condition|)
block|{
name|appendchain
operator|=
name|clonechain
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|copy_by_ref
operator|&&
operator|(
name|sizeofcpy
operator|<=
operator|(
operator|(
operator|(
operator|(
name|sctp_mbuf_threshold_count
operator|-
literal|1
operator|)
operator|*
name|MLEN
operator|)
operator|+
name|MHLEN
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Its not in a cluster */
if|if
condition|(
operator|*
name|endofchain
operator|==
name|NULL
condition|)
block|{
comment|/* lets get a mbuf cluster */
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
comment|/* This is the general case */
name|new_mbuf
label|:
name|outchain
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error_out
goto|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|outchain
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|endofchain
operator|=
name|outchain
expr_stmt|;
comment|/* get the prepend space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|outchain
argument_list|,
operator|(
name|SCTP_FIRST_MBUF_RESV
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * We really should not get a NULL 					 * in endofchain 					 */
comment|/* find end */
name|m
operator|=
name|outchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* sanity */
if|if
condition|(
operator|*
name|endofchain
operator|==
name|NULL
condition|)
block|{
comment|/* 						 * huh, TSNH XXX maybe we 						 * should panic 						 */
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
goto|goto
name|new_mbuf
goto|;
block|}
block|}
comment|/* get the new end of length */
name|len
operator|=
name|M_TRAILINGSPACE
argument_list|(
operator|*
name|endofchain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* how much is left at the end? */
name|len
operator|=
name|M_TRAILINGSPACE
argument_list|(
operator|*
name|endofchain
argument_list|)
expr_stmt|;
block|}
comment|/* Find the end of the data, for appending */
name|cp
operator|=
operator|(
name|mtod
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Now lets copy it out */
if|if
condition|(
name|len
operator|>=
name|sizeofcpy
condition|)
block|{
comment|/* It all fits, copy it in */
name|m_copydata
argument_list|(
name|clonechain
argument_list|,
literal|0
argument_list|,
name|sizeofcpy
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|+=
name|sizeofcpy
expr_stmt|;
block|}
else|else
block|{
comment|/* fill up the end of the chain */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|m_copydata
argument_list|(
name|clonechain
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|+=
name|len
expr_stmt|;
comment|/* now we need another one */
name|sizeofcpy
operator|-=
name|len
expr_stmt|;
block|}
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* We failed */
goto|goto
name|error_out
goto|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|=
name|m
expr_stmt|;
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|clonechain
argument_list|,
name|len
argument_list|,
name|sizeofcpy
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|+=
name|sizeofcpy
expr_stmt|;
block|}
return|return
operator|(
name|outchain
operator|)
return|;
block|}
else|else
block|{
comment|/* copy the old fashion way */
name|appendchain
operator|=
name|SCTP_M_COPYM
argument_list|(
name|clonechain
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|appendchain
operator|==
name|NULL
condition|)
block|{
comment|/* error */
if|if
condition|(
name|outchain
condition|)
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|outchain
condition|)
block|{
comment|/* tack on to the end */
if|if
condition|(
operator|*
name|endofchain
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
operator|(
operator|(
operator|*
name|endofchain
operator|)
operator|)
argument_list|)
operator|=
name|appendchain
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|outchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|appendchain
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * save off the end and update the end-chain postion 		 */
name|m
operator|=
name|appendchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|outchain
operator|)
return|;
block|}
else|else
block|{
comment|/* save off the end and update the end-chain postion */
name|m
operator|=
name|appendchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|appendchain
operator|)
return|;
block|}
block|}
end_function

begin_function_decl
name|int
name|sctp_med_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
modifier|*
name|num_out
parameter_list|,
name|int
modifier|*
name|reason_code
parameter_list|,
name|int
name|control_only
parameter_list|,
name|int
modifier|*
name|cwnd_full
parameter_list|,
name|int
name|from_where
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
modifier|*
name|now_filled
parameter_list|,
name|int
name|frag_point
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sctp_sendall_iterator
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|sctp_copy_all
modifier|*
name|ca
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|added_control
init|=
literal|0
decl_stmt|;
name|int
name|un_sent
decl_stmt|,
name|do_chunk_output
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|ca
operator|=
operator|(
expr|struct
name|sctp_copy_all
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ca
operator|->
name|inp
operator|!=
name|inp
condition|)
block|{
comment|/* TSNH */
return|return;
block|}
if|if
condition|(
operator|(
name|ca
operator|->
name|m
operator|)
operator|&&
name|ca
operator|->
name|sndlen
condition|)
block|{
name|m
operator|=
name|SCTP_M_COPYM
argument_list|(
name|ca
operator|->
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* can't copy so we are done */
name|ca
operator|->
name|cnt_failed
operator|++
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|sndrcv
operator|.
name|sinfo_flags
operator|&
name|SCTP_ABORT
condition|)
block|{
comment|/* Abort this assoc with m as the user defined reason */
if|if
condition|(
name|m
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|SCTP_BUF_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|ph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|ca
operator|->
name|sndlen
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * We add one here to keep the assoc from 			 * dis-appearing on us. 			 */
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 			 * sctp_abort_an_association calls sctp_free_asoc() 			 * free association will NOT free it since we 			 * incremented the refcnt .. we do this to prevent 			 * it being freed and things getting tricky since we 			 * could end up (from free_asoc) calling inpcb_free 			 * which would get a recursive lock call to the 			 * iterator lock.. But as a consequence of that the 			 * stcb will return to us un-locked.. since 			 * free_asoc returns with either no TCB or the TCB 			 * unlocked, we must relock.. to unlock in the 			 * iterator timer :-0 			 */
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|no_chunk_output
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|m
condition|)
block|{
name|ret
operator|=
name|sctp_msg_append
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|m
argument_list|,
operator|&
name|ca
operator|->
name|sndrcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|sndrcv
operator|.
name|sinfo_flags
operator|&
name|SCTP_EOF
condition|)
block|{
comment|/* shutdown this assoc */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
comment|/* 				 * there is nothing queued to send, so I'm 				 * done... 				 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* 					 * only send SHUTDOWN the first time 					 * through 					 */
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|added_control
operator|=
literal|1
expr_stmt|;
name|do_chunk_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * we still got (or just got) data to send, 				 * so set SHUTDOWN_PENDING 				 */
comment|/* 				 * XXX sockets draft says that SCTP_EOF 				 * should be sent with no data.  currently, 				 * we will allow user data to be sent first 				 * and move to SHUTDOWN-PENDING 				 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* 						 * Locked to send out the 						 * data 						 */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|abort_anyway
label|:
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|no_chunk_output
goto|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
condition|)
block|{
name|do_chunk_output
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|do_chunk_output
condition|)
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|added_control
condition|)
block|{
name|int
name|num_out
init|=
literal|0
decl_stmt|,
name|reason
init|=
literal|0
decl_stmt|,
name|cwnd_full
init|=
literal|0
decl_stmt|,
name|now_filled
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|frag_point
decl_stmt|;
name|frag_point
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason
argument_list|,
literal|1
argument_list|,
operator|&
name|cwnd_full
argument_list|,
literal|1
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
block|}
name|no_chunk_output
label|:
if|if
condition|(
name|ret
condition|)
block|{
name|ca
operator|->
name|cnt_failed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ca
operator|->
name|cnt_sent
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_sendall_completes
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|struct
name|sctp_copy_all
modifier|*
name|ca
decl_stmt|;
name|ca
operator|=
operator|(
expr|struct
name|sctp_copy_all
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* 	 * Do a notify here? Kacheong suggests that the notify be done at 	 * the send time.. so you would push up a notification if any send 	 * failed. Don't know if this is feasable since the only failures we 	 * have is "memory" related and if you cannot get an mbuf to send 	 * the data you surely can't get an mbuf to send up to notify the 	 * user you can't send the data :-> 	 */
comment|/* now free everything */
name|sctp_m_freem
argument_list|(
name|ca
operator|->
name|m
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|ca
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MC_ALIGN
parameter_list|(
name|m
parameter_list|,
name|len
parameter_list|)
value|do {						\ 	SCTP_BUF_RESV_UF(m, ((MCLBYTES - (len))& ~(sizeof(long) - 1));	\ } while (0)
end_define

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_copy_out_all
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|ret
decl_stmt|,
modifier|*
name|at
decl_stmt|;
name|int
name|left
decl_stmt|,
name|willcpy
decl_stmt|,
name|cancpy
decl_stmt|,
name|error
decl_stmt|;
name|ret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_WAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|left
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* save space for the data chunk header */
name|cancpy
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|willcpy
operator|=
name|min
argument_list|(
name|cancpy
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|at
operator|=
name|ret
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
comment|/* Align data to the end */
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|at
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|willcpy
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|err_out_now
label|:
name|sctp_m_freem
argument_list|(
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
operator|=
name|willcpy
expr_stmt|;
name|SCTP_BUF_NEXT_PKT
argument_list|(
name|at
argument_list|)
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|=
literal|0
expr_stmt|;
name|left
operator|-=
name|willcpy
expr_stmt|;
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|M_WAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err_out_now
goto|;
block|}
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cancpy
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|willcpy
operator|=
name|min
argument_list|(
name|cancpy
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_sendall
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|sctp_copy_all
modifier|*
name|ca
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|ca
argument_list|,
expr|struct
name|sctp_copy_all
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_copy_all
argument_list|)
argument_list|,
literal|"CopyAll"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|ca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_copy_all
argument_list|)
argument_list|)
expr_stmt|;
name|ca
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
name|ca
operator|->
name|sndrcv
operator|=
operator|*
name|srcv
expr_stmt|;
comment|/* 	 * take off the sendall flag, it would be bad if we failed to do 	 * this :-0 	 */
name|ca
operator|->
name|sndrcv
operator|.
name|sinfo_flags
operator|&=
operator|~
name|SCTP_SENDALL
expr_stmt|;
comment|/* get length and mbuf chain */
if|if
condition|(
name|uio
condition|)
block|{
name|ca
operator|->
name|sndlen
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|ca
operator|->
name|m
operator|=
name|sctp_copy_out_all
argument_list|(
name|uio
argument_list|,
name|ca
operator|->
name|sndlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|ca
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Gather the length of the send */
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|mat
operator|=
name|m
expr_stmt|;
name|ca
operator|->
name|sndlen
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|ca
operator|->
name|sndlen
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|ca
operator|->
name|m
operator|=
name|m
expr_stmt|;
block|}
name|ret
operator|=
name|sctp_initiate_iterator
argument_list|(
name|NULL
argument_list|,
name|sctp_sendall_iterator
argument_list|,
name|NULL
argument_list|,
name|SCTP_PCB_ANY_FLAGS
argument_list|,
name|SCTP_PCB_ANY_FEATURES
argument_list|,
name|SCTP_ASOC_ANY_STATE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ca
argument_list|,
literal|0
argument_list|,
name|sctp_sendall_completes
argument_list|,
name|inp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Failed to initiate iterator for sendall\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_FREE
argument_list|(
name|ca
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_toss_old_cookies
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|chk
condition|)
block|{
name|nchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
name|chk
operator|=
name|nchk
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_toss_old_asconf
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|chk_tmp
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
for|for
control|(
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
init|;
name|chk
operator|!=
name|NULL
condition|;
name|chk
operator|=
name|chk_tmp
control|)
block|{
comment|/* get next chk */
name|chk_tmp
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* find SCTP_ASCONF chunk in queue (only one ever in queue) */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sctp_clean_up_datalist
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
modifier|*
name|data_list
parameter_list|,
name|int
name|bundle_at
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bundle_at
condition|;
name|i
operator|++
control|)
block|{
comment|/* off of the send queue */
if|if
condition|(
name|i
condition|)
block|{
comment|/* 			 * Any chunk NOT 0 you zap the time chunk 0 gets 			 * zapped or set based on if a RTO measurment is 			 * needed. 			 */
name|data_list
index|[
name|i
index|]
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* record time */
name|data_list
index|[
name|i
index|]
operator|->
name|sent_rcv_time
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
comment|/* on to the sent queue */
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|)
operator|&&
operator|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tpp
decl_stmt|;
comment|/* need to move back */
name|back_up_more
label|:
name|tpp
operator|=
name|TAILQ_PREV
argument_list|(
name|tp1
argument_list|,
name|sctpchunk_listhead
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpp
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tp1
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
goto|goto
name|all_done
goto|;
block|}
name|tp1
operator|=
name|tpp
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
goto|goto
name|back_up_more
goto|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
name|all_done
label|:
comment|/* This does not lower until the cum-ack passes it */
name|asoc
operator|->
name|sent_queue_cnt
operator|++
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bundle_at
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Mark the chunk as being a window probe */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_windowprobed
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_list
index|[
name|i
index|]
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|snd_count
operator|=
literal|1
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_flight_size_increase
argument_list|(
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_RWND
name|sctp_log_rwnd
argument_list|(
name|SCTP_DECREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
argument_list|,
name|sctp_peer_chunk_oh
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|peers_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
operator|+
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sctp_clean_up_ctl
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
for|for
control|(
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
init|;
name|chk
condition|;
name|chk
operator|=
name|nchk
control|)
block|{
name|nchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_REQUEST
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_OPERATION_ERROR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_PACKET_DROPPED
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_CWR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF_ACK
operator|)
condition|)
block|{
comment|/* Stray chunks must be cleaned up */
name|clean_up_anyway
label|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_STREAM_RESET
condition|)
block|{
comment|/* special handling, we must look into the param */
if|if
condition|(
name|chk
operator|!=
name|asoc
operator|->
name|str_reset
condition|)
block|{
goto|goto
name|clean_up_anyway
goto|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|sctp_can_we_split_this
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|,
name|int
name|goal_mtu
parameter_list|,
name|int
name|frag_point
parameter_list|,
name|int
name|eeor_on
parameter_list|)
block|{
comment|/* 	 * Make a decision on if I should split a msg into multiple parts. 	 * This is only asked of incomplete messages. 	 */
if|if
condition|(
name|eeor_on
condition|)
block|{
comment|/* 		 * If we are doing EEOR we need to always send it if its the 		 * entire thing, since it might be all the guy is putting in 		 * the hopper. 		 */
if|if
condition|(
name|goal_mtu
operator|>=
name|sp
operator|->
name|length
condition|)
block|{
comment|/*- 			 * If we have data outstanding, 			 * we get another chance when the sack 			 * arrives to transmit - wait for more data 			 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If nothing is in flight, we zero the 				 * packet counter. 				 */
return|return
operator|(
name|sp
operator|->
name|length
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* You can fill the rest */
return|return
operator|(
name|goal_mtu
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|<=
name|goal_mtu
operator|)
operator|||
operator|(
operator|(
name|sp
operator|->
name|length
operator|-
name|goal_mtu
operator|)
operator|<
name|sctp_min_residual
operator|)
condition|)
block|{
comment|/* Sub-optimial residual don't split in non-eeor mode. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we reach here sp->length is larger than the goal_mtu. Do we 	 * wish to split it for the sake of packet putting together? 	 */
if|if
condition|(
name|goal_mtu
operator|>=
name|min
argument_list|(
name|sctp_min_split_point
argument_list|,
name|frag_point
argument_list|)
condition|)
block|{
comment|/* Its ok to split it */
return|return
operator|(
name|min
argument_list|(
name|goal_mtu
argument_list|,
name|frag_point
argument_list|)
operator|)
return|;
block|}
comment|/* Nope, can't split */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_move_to_outqueue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sctp_stream_out
modifier|*
name|strq
parameter_list|,
name|int
name|goal_mtu
parameter_list|,
name|int
name|frag_point
parameter_list|,
name|int
modifier|*
name|locked
parameter_list|,
name|int
modifier|*
name|giveup
parameter_list|,
name|int
name|eeor_mode
parameter_list|)
block|{
comment|/* Move from the stream to the send_queue keeping track of the total */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_data_chunk
modifier|*
name|dchkh
decl_stmt|;
name|int
name|to_move
decl_stmt|;
name|uint8_t
name|rcv_flags
init|=
literal|0
decl_stmt|;
name|uint8_t
name|some_taken
decl_stmt|;
name|uint8_t
name|send_lock_up
init|=
literal|0
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|one_more_time
label|:
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
operator|*
name|locked
operator|=
literal|0
expr_stmt|;
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|one_more_time
goto|;
block|}
if|if
condition|(
name|strq
operator|->
name|last_msg_incomplete
condition|)
block|{
name|printf
argument_list|(
literal|"Huh? Stream:%d lm_in_c=%d but queue is NULL\n"
argument_list|,
name|strq
operator|->
name|stream_no
argument_list|,
name|strq
operator|->
name|last_msg_incomplete
argument_list|)
expr_stmt|;
name|strq
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|length
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|sender_all_done
condition|)
block|{
comment|/* 				 * We are doing differed cleanup. Last time 				 * through when we took all the data the 				 * sender_all_done was not set. 				 */
if|if
condition|(
name|sp
operator|->
name|put_last_out
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, put out entire msg with NO end!-1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sender_done:%d len:%d msg_comp:%d put_last_out:%d send_lock:%d\n"
argument_list|,
name|sp
operator|->
name|sender_all_done
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|sp
operator|->
name|msg_is_complete
argument_list|,
name|sp
operator|->
name|put_last_out
argument_list|,
name|send_lock_up
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* we can't be locked to it */
operator|*
name|locked
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|send_lock_up
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|0
expr_stmt|;
block|}
comment|/* back to get the next msg */
goto|goto
name|one_more_time
goto|;
block|}
else|else
block|{
comment|/* 				 * sender just finished this but still holds 				 * a reference 				 */
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* is there some to get */
if|if
condition|(
name|sp
operator|->
name|length
operator|==
literal|0
condition|)
block|{
comment|/* no */
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|some_taken
operator|=
name|sp
operator|->
name|some_taken
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
block|}
name|re_look
label|:
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
comment|/* The message is complete */
name|to_move
operator|=
name|min
argument_list|(
name|sp
operator|->
name|length
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_move
operator|==
name|sp
operator|->
name|length
condition|)
block|{
comment|/* All of it fits in the MTU */
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
name|sp
operator|->
name|put_last_out
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_NOT_FRAG
expr_stmt|;
name|sp
operator|->
name|put_last_out
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not all of it fits, we fragment */
if|if
condition|(
name|sp
operator|->
name|some_taken
operator|==
literal|0
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_FIRST_FRAG
expr_stmt|;
block|}
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|to_move
operator|=
name|sctp_can_we_split_this
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|goal_mtu
argument_list|,
name|frag_point
argument_list|,
name|eeor_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_move
condition|)
block|{
comment|/*- 			 * We use a snapshot of length in case it 			 * is expanding during the compare. 			 */
name|uint32_t
name|llen
decl_stmt|;
name|llen
operator|=
name|sp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|to_move
operator|>=
name|llen
condition|)
block|{
name|to_move
operator|=
name|llen
expr_stmt|;
if|if
condition|(
name|send_lock_up
operator|==
literal|0
condition|)
block|{
comment|/*- 					 * We are taking all of an incomplete msg 					 * thus we need a send lock. 					 */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
comment|/* 						 * the sender finished the 						 * msg 						 */
goto|goto
name|re_look
goto|;
block|}
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|some_taken
operator|==
literal|0
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_FIRST_FRAG
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing to take. */
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* If we reach here, we can copy out a chunk */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* No chunk memory */
name|out_gu
label|:
if|if
condition|(
name|send_lock_up
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Setup for unordered if needed by looking at the user sent info 	 * flags. 	 */
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_UNORDERED
expr_stmt|;
block|}
comment|/* clear out the chunk before setting up */
name|memset
argument_list|(
name|chk
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chk
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
name|rcv_flags
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|sp
operator|->
name|data
argument_list|)
condition|)
block|{
name|chk
operator|->
name|copy_by_ref
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|to_move
operator|>=
name|sp
operator|->
name|length
condition|)
block|{
comment|/* we can steal the whole thing */
name|chk
operator|->
name|data
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|chk
operator|->
name|last_mbuf
operator|=
name|sp
operator|->
name|tail_mbuf
expr_stmt|;
comment|/* register the stealing */
name|sp
operator|->
name|data
operator|=
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|chk
operator|->
name|data
operator|=
name|SCTP_M_COPYM
argument_list|(
name|sp
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|to_move
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|chk
operator|->
name|last_mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|some_taken
operator|=
name|some_taken
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
goto|goto
name|out_gu
goto|;
block|}
comment|/* Pull off the data */
name|m_adj
argument_list|(
name|sp
operator|->
name|data
argument_list|,
name|to_move
argument_list|)
expr_stmt|;
comment|/* Now lets work our way down and compact it */
name|m
operator|=
name|sp
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
operator|&&
operator|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sp
operator|->
name|data
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tail_mbuf
operator|==
name|m
condition|)
block|{
comment|/*- 				 * Freeing tail? TSNH since 				 * we supposedly were taking less 				 * than the sp->length. 				 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh, freing tail? - TSNH"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Huh, freeing tail? - TSNH\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|sp
operator|->
name|data
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_move
operator|>
name|sp
operator|->
name|length
condition|)
block|{
comment|/*- This should not happen either 		 * since we always lower to_move to the size 		 * of sp->length if its larger. 		 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh, how can to_move be larger?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Huh, how can to_move be larger?\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|sp
operator|->
name|length
argument_list|,
name|to_move
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
condition|)
block|{
comment|/* Not enough room for a chunk header, get some */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|0
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * we're in trouble here. _PREPEND below will free 			 * all the data if there is no leading space, so we 			 * must put the data back and restore. 			 */
if|if
condition|(
name|send_lock_up
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* unsteal the data */
name|sp
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|chk
operator|->
name|last_mbuf
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* reassemble the data */
name|m
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|sp
operator|->
name|data
argument_list|)
operator|=
name|m
expr_stmt|;
block|}
name|sp
operator|->
name|some_taken
operator|=
name|some_taken
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|length
argument_list|,
name|to_move
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
goto|goto
name|out_gu
goto|;
block|}
else|else
block|{
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|M_ALIGN
argument_list|(
name|chk
operator|->
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_PREPEND
argument_list|(
name|chk
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* HELP, TSNH since we assured it would not above? */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"prepend failes HELP?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"prepend fails HELP?\n"
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|out_gu
goto|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|chk
operator|->
name|send_size
operator|=
operator|(
name|to_move
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
comment|/* 	 * get last_mbuf and counts of mb useage This is ugly but hopefully 	 * its only one mbuf. 	 */
if|if
condition|(
name|chk
operator|->
name|last_mbuf
operator|==
name|NULL
condition|)
block|{
name|chk
operator|->
name|last_mbuf
operator|=
name|chk
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|chk
operator|->
name|last_mbuf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|last_mbuf
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|chk
operator|->
name|last_mbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|pad_inplace
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|=
name|sp
operator|->
name|strseq
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|=
name|sp
operator|->
name|stream
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
operator|=
literal|0
expr_stmt|;
comment|/* ECN Nonce */
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|=
name|sp
operator|->
name|ts
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
name|sp
operator|->
name|act_flags
expr_stmt|;
name|chk
operator|->
name|addr_over
operator|=
name|sp
operator|->
name|addr_over
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|asoc
operator|->
name|sending_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_SENDING_STR
name|sctp_misc_ints
argument_list|(
name|SCTP_STRMOUT_LOG_SEND
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sp
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dchkh
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_data_chunk
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Put the rest of the things in place now. Size was done earlier in 	 * previous loop prior to padding. 	 */
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|strm
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|seq
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|sz
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|flgs
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|asoc
operator|->
name|tsn_out_at
operator|++
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|tsn_out_at
operator|>=
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|asoc
operator|->
name|tsn_out_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_out_wrapped
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|dchkh
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_DATA
expr_stmt|;
name|dchkh
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|tsn
operator|=
name|htonl
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|stream_id
operator|=
name|htons
argument_list|(
name|strq
operator|->
name|stream_no
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|stream_sequence
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|protocol_id
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|dchkh
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
comment|/* Now advance the chk->send_size by the actual pad needed. */
if|if
condition|(
name|chk
operator|->
name|send_size
operator|<
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
condition|)
block|{
comment|/* need a pad */
name|struct
name|mbuf
modifier|*
name|lm
decl_stmt|;
name|int
name|pads
decl_stmt|;
name|pads
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
operator|-
name|chk
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|sctp_pad_lastmbuf
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|pads
argument_list|,
name|chk
operator|->
name|last_mbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|chk
operator|->
name|pad_inplace
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|lm
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|chk
operator|->
name|last_mbuf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* pad added an mbuf */
name|chk
operator|->
name|last_mbuf
operator|=
name|lm
expr_stmt|;
block|}
name|chk
operator|->
name|send_size
operator|+=
name|pads
expr_stmt|;
block|}
comment|/* We only re-set the policy if it is on */
if|if
condition|(
name|sp
operator|->
name|pr_sctp_on
condition|)
block|{
name|sctp_set_prsctp_policy
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|sender_all_done
operator|)
condition|)
block|{
comment|/* All done pull and kill the message */
name|atomic_subtract_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|put_last_out
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, put out entire msg with NO end!-2\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sender_done:%d len:%d msg_comp:%d put_last_out:%d send_lock:%d\n"
argument_list|,
name|sp
operator|->
name|sender_all_done
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|sp
operator|->
name|msg_is_complete
argument_list|,
name|sp
operator|->
name|put_last_out
argument_list|,
name|send_lock_up
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|send_lock_up
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
comment|/* we can't be locked to it */
operator|*
name|locked
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* more to go, we are locked */
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|chunks_on_out_queue
operator|++
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|pr_sctp_on
condition|)
block|{
name|asoc
operator|->
name|pr_sctp_cnt
operator|++
expr_stmt|;
name|chk
operator|->
name|pr_sctp_on
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|pr_sctp_on
operator|=
literal|0
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|send_lock_up
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|to_move
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_stream_out
modifier|*
name|sctp_select_a_stream
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|strq
decl_stmt|;
comment|/* Find the next stream to use */
if|if
condition|(
name|asoc
operator|->
name|last_out_stream
operator|==
name|NULL
condition|)
block|{
name|strq
operator|=
name|asoc
operator|->
name|last_out_stream
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|last_out_stream
operator|==
name|NULL
condition|)
block|{
comment|/* huh nothing on the wheel, TSNH */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
goto|goto
name|done_it
goto|;
block|}
name|strq
operator|=
name|TAILQ_NEXT
argument_list|(
name|asoc
operator|->
name|last_out_stream
argument_list|,
name|next_spoke
argument_list|)
expr_stmt|;
name|done_it
label|:
if|if
condition|(
name|strq
operator|==
name|NULL
condition|)
block|{
name|strq
operator|=
name|asoc
operator|->
name|last_out_stream
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|strq
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_fill_outqueue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|frag_point
parameter_list|,
name|int
name|eeor_mode
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|strq
decl_stmt|,
modifier|*
name|strqn
decl_stmt|,
modifier|*
name|strqt
decl_stmt|;
name|int
name|goal_mtu
decl_stmt|,
name|moved_how_much
decl_stmt|,
name|total_moved
init|=
literal|0
decl_stmt|;
name|int
name|locked
decl_stmt|,
name|giveup
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|goal_mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
comment|/* ?? not sure what else to do */
name|goal_mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
block|}
else|#
directive|else
name|goal_mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
expr_stmt|;
name|mtu_fromwheel
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Need an allowance for the data chunk header too */
name|goal_mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
comment|/* must make even word boundary */
name|goal_mtu
operator|&=
literal|0xfffffffc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* We are stuck on one stream until the message completes. */
name|strqn
operator|=
name|strq
operator|=
name|asoc
operator|->
name|locked_on_sending
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|strqn
operator|=
name|strq
operator|=
name|sctp_select_a_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|goal_mtu
operator|>
literal|0
operator|)
operator|&&
name|strq
condition|)
block|{
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
expr_stmt|;
comment|/* 		 * If CMT is off, we must validate that the stream in 		 * question has the first item pointed towards are network 		 * destionation requested by the caller. Note that if we 		 * turn out to be locked to a stream (assigning TSN's then 		 * we must stop, since we cannot look for another stream 		 * with data to send to that destination). In CMT's case, by 		 * skipping this check, we will send one data packet towards 		 * the requested net. 		 */
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|net
operator|!=
name|net
operator|)
operator|&&
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* none for this network */
if|if
condition|(
name|locked
condition|)
block|{
break|break;
block|}
else|else
block|{
name|strq
operator|=
name|sctp_select_a_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|strq
operator|==
name|NULL
condition|)
comment|/* none left */
break|break;
if|if
condition|(
name|strqn
operator|==
name|strq
condition|)
block|{
comment|/* I have circled */
break|break;
block|}
continue|continue;
block|}
block|}
name|giveup
operator|=
literal|0
expr_stmt|;
name|moved_how_much
operator|=
name|sctp_move_to_outqueue
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|strq
argument_list|,
name|goal_mtu
argument_list|,
name|frag_point
argument_list|,
operator|&
name|locked
argument_list|,
operator|&
name|giveup
argument_list|,
name|eeor_mode
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_out_stream
operator|=
name|strq
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
name|asoc
operator|->
name|locked_on_sending
operator|=
name|strq
expr_stmt|;
if|if
condition|(
operator|(
name|moved_how_much
operator|==
literal|0
operator|)
operator|||
operator|(
name|giveup
operator|)
condition|)
comment|/* no more to move for now */
break|break;
block|}
else|else
block|{
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
name|strqt
operator|=
name|sctp_select_a_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sctp_remove_from_wheel
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|giveup
condition|)
block|{
break|break;
block|}
name|strq
operator|=
name|strqt
expr_stmt|;
if|if
condition|(
name|strq
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
name|total_moved
operator|+=
name|moved_how_much
expr_stmt|;
name|goal_mtu
operator|-=
operator|(
name|moved_how_much
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
name|goal_mtu
operator|&=
literal|0xfffffffc
expr_stmt|;
block|}
if|if
condition|(
name|total_moved
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
operator|&&
operator|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
condition|)
block|{
comment|/* ran dry for primary network net */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_primary_randry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
comment|/* ran dry with CMT on */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_cmt_randry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|__inline
name|void
name|sctp_fix_ecn_echo
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_move_to_an_alt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|a_net
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|a_net
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a_net
operator|!=
name|net
operator|)
operator|&&
operator|(
operator|(
name|a_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
comment|/* 		 * We only proceed if a valid alternate is found that is not 		 * this one and is reachable. Here we must move all chunks 		 * queued in the send queue off of the destination address 		 * to our alternate. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|net
condition|)
block|{
comment|/* Move the chunk to our alternate */
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|a_net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|a_net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_med_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
modifier|*
name|num_out
parameter_list|,
name|int
modifier|*
name|reason_code
parameter_list|,
name|int
name|control_only
parameter_list|,
name|int
modifier|*
name|cwnd_full
parameter_list|,
name|int
name|from_where
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
modifier|*
name|now_filled
parameter_list|,
name|int
name|frag_point
parameter_list|)
block|{
comment|/* 	 * Ok this is the generic chunk service queue. we must do the 	 * following: - Service the stream queue that is next, moving any 	 * message (note I must get a complete message i.e. FIRST/MIDDLE and 	 * LAST to the out queue in one pass) and assigning TSN's - Check to 	 * see if the cwnd/rwnd allows any output, if so we go ahead and 	 * fomulate and send the low level chunks. Making sure to combine 	 * any control in the control chunk queue also. 	 */
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|outchain
decl_stmt|,
modifier|*
name|endoutchain
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|shdr
decl_stmt|;
comment|/* temp arrays for unlinking */
name|struct
name|sctp_tmit_chunk
modifier|*
name|data_list
index|[
name|SCTP_MAX_DATA_BUNDLING
index|]
decl_stmt|;
name|int
name|no_fragmentflg
decl_stmt|,
name|error
decl_stmt|;
name|int
name|one_chunk
decl_stmt|,
name|hbflag
decl_stmt|,
name|skip_data_for_this_net
decl_stmt|;
name|int
name|asconf
decl_stmt|,
name|cookie
decl_stmt|,
name|no_out_cnt
decl_stmt|;
name|int
name|bundle_at
decl_stmt|,
name|ctl_cnt
decl_stmt|,
name|no_data_chunks
decl_stmt|,
name|cwnd_full_ind
decl_stmt|,
name|eeor_mode
decl_stmt|;
name|unsigned
name|int
name|mtu
decl_stmt|,
name|r_mtu
decl_stmt|,
name|omtu
decl_stmt|,
name|mx_mtu
decl_stmt|,
name|to_out
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|start_at
decl_stmt|,
modifier|*
name|old_startat
init|=
name|NULL
decl_stmt|,
modifier|*
name|send_start_at
decl_stmt|;
name|int
name|tsns_sent
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
operator|*
name|num_out
operator|=
literal|0
expr_stmt|;
name|cwnd_full_ind
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
operator|)
condition|)
block|{
name|eeor_mode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|eeor_mode
operator|=
literal|0
expr_stmt|;
block|}
name|ctl_cnt
operator|=
name|no_out_cnt
operator|=
name|asconf
operator|=
name|cookie
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First lets prime the pump. For each destination, if there is room 	 * in the flight size, attempt to pull an MTU's worth out of the 	 * stream queues into the general send_queue 	 */
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hbflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|control_only
operator|)
operator|||
operator|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|)
condition|)
name|no_data_chunks
operator|=
literal|1
expr_stmt|;
else|else
name|no_data_chunks
operator|=
literal|0
expr_stmt|;
comment|/* Nothing to possible to send? */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|9
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|==
literal|0
condition|)
block|{
comment|/* No room in peers rwnd */
operator|*
name|cwnd_full
operator|=
literal|1
expr_stmt|;
operator|*
name|reason_code
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
condition|)
block|{
comment|/* we are allowed one chunk in flight */
name|no_data_chunks
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|no_data_chunks
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
comment|/* 			 * for CMT we start at the next one past the one we 			 * last added data to. 			 */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|!=
name|NULL
condition|)
block|{
goto|goto
name|skip_the_fill_from_streams
goto|;
block|}
if|if
condition|(
name|asoc
operator|->
name|last_net_data_came_from
condition|)
block|{
name|net
operator|=
name|TAILQ_NEXT
argument_list|(
name|asoc
operator|->
name|last_net_data_came_from
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* back to start */
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
block|}
name|start_at
operator|=
name|net
expr_stmt|;
name|one_more_time
label|:
for|for
control|(
init|;
name|net
operator|!=
name|NULL
condition|;
name|net
operator|=
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
control|)
block|{
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|old_startat
operator|&&
operator|(
name|old_startat
operator|==
name|net
operator|)
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
operator|&&
operator|(
name|net
operator|->
name|ref_count
operator|<
literal|2
operator|)
condition|)
block|{
comment|/* nothing can be in queue for this guy */
continue|continue;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* skip this network, no room */
name|cwnd_full_ind
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * @@@ JRI : this for loop we are in takes in each 			 * net, if its's got space in cwnd and has data sent 			 * to it (when CMT is off) then it calls 			 * sctp_fill_outqueue for the net. This gets data on 			 * the send queue for that network. 			 *  			 * In sctp_fill_outqueue TSN's are assigned and data is 			 * copied out of the stream buffers. Note mostly 			 * copy by reference (we hope). 			 */
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_LOG_FILL_OUTQ_CALLED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_fill_outqueue
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|frag_point
argument_list|,
name|eeor_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|start_at
operator|!=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
condition|)
block|{
comment|/* got to pick up the beginning stuff. */
name|old_startat
operator|=
name|start_at
expr_stmt|;
name|start_at
operator|=
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
goto|goto
name|one_more_time
goto|;
block|}
block|}
name|skip_the_fill_from_streams
label|:
operator|*
name|cwnd_full
operator|=
name|cwnd_full_ind
expr_stmt|;
comment|/* now service each destination and send out what we can for it */
comment|/* Nothing to send? */
if|if
condition|(
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
condition|)
block|{
name|send_start_at
operator|=
name|chk
operator|->
name|whoTo
expr_stmt|;
block|}
else|else
block|{
name|send_start_at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
name|old_startat
operator|=
name|NULL
expr_stmt|;
name|again_one_more_time
label|:
for|for
control|(
name|net
operator|=
name|send_start_at
init|;
name|net
operator|!=
name|NULL
condition|;
name|net
operator|=
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
control|)
block|{
comment|/* how much can we send? */
comment|/* printf("Examine for sending net:%x\n", (uint32_t)net); */
if|if
condition|(
name|old_startat
operator|&&
operator|(
name|old_startat
operator|==
name|net
operator|)
condition|)
block|{
comment|/* through list ocmpletely. */
break|break;
block|}
name|tsns_sent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ref_count
operator|<
literal|2
condition|)
block|{
comment|/* 			 * Ref-count of 1 so we cannot have data or control 			 * queued to this address. Skip it. 			 */
continue|continue;
block|}
name|ctl_cnt
operator|=
name|bundle_at
operator|=
literal|0
expr_stmt|;
name|endoutchain
operator|=
name|outchain
operator|=
name|NULL
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
name|one_chunk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|skip_data_for_this_net
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|skip_data_for_this_net
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|)
condition|)
block|{
comment|/* 			 * if we have a route and an ifp check to see if we 			 * have room to send to this guy 			 */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|+
literal|2
operator|)
operator|>=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_MAXBURST
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
argument_list|,
name|SCTP_MAX_IFP_APPLIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
block|}
name|mx_mtu
operator|=
name|mtu
expr_stmt|;
name|to_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|asoc
operator|->
name|peers_rwnd
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
condition|)
block|{
comment|/* We have a packet in flight somewhere */
name|r_mtu
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
block|}
else|else
block|{
comment|/* We are always allowed to send one MTU out */
name|one_chunk
operator|=
literal|1
expr_stmt|;
name|r_mtu
operator|=
name|mtu
expr_stmt|;
block|}
block|}
else|else
block|{
name|r_mtu
operator|=
name|mtu
expr_stmt|;
block|}
comment|/************************/
comment|/* Control transmission */
comment|/************************/
comment|/* Now first lets go through the control queue */
for|for
control|(
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
init|;
name|chk
condition|;
name|chk
operator|=
name|nchk
control|)
block|{
name|nchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
comment|/* 				 * No, not sent to the network we are 				 * looking at 				 */
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 				 * It must be unsent. Cookies and ASCONF's 				 * hang around but there timers will force 				 * when marked for resend. 				 */
continue|continue;
block|}
comment|/* 			 * if no AUTH is yet included and this chunk 			 * requires it, make sure to account for it.  We 			 * don't apply the size until the AUTH chunk is 			 * actually added below in case there is no room for 			 * this chunk. NOTE: we overload the use of "omtu" 			 * here 			 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|omtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
comment|/* Here we do NOT factor the r_mtu */
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|<
call|(
name|int
call|)
argument_list|(
name|mtu
operator|-
name|omtu
argument_list|)
operator|)
operator|||
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
condition|)
block|{
comment|/* 				 * We probably should glom the mbuf chain 				 * from the chk->data for control but the 				 * problem is it becomes yet one more level 				 * of tracking to do if for some reason 				 * output fails. Then I have got to 				 * reconstruct the merged control chain.. el 				 * yucko.. for now we take the easy way and 				 * do the copy 				 */
comment|/* 				 * Add an AUTH chunk, if chunk requires it 				 * save the offset into the chain for AUTH 				 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|outchain
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
name|outchain
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|(
name|int
operator|)
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|8
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
comment|/* update our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|to_out
operator|+=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
expr_stmt|;
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
condition|)
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* Mark things to be removed, if needed */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_REQUEST
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_OPERATION_ERROR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_CWR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_PACKET_DROPPED
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF_ACK
operator|)
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_REQUEST
condition|)
name|hbflag
operator|=
literal|1
expr_stmt|;
comment|/* remove these chunks at the end */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
condition|)
block|{
comment|/* turn off the timer */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
block|}
name|ctl_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Other chunks, since they have 					 * timers running (i.e. COOKIE or 					 * ASCONF) we just "trust" that it 					 * gets sent or retransmitted. 					 */
name|ctl_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
name|cookie
operator|=
literal|1
expr_stmt|;
name|no_out_cnt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
comment|/* 						 * set hb flag since we can 						 * use these for RTO 						 */
name|hbflag
operator|=
literal|1
expr_stmt|;
name|asconf
operator|=
literal|1
expr_stmt|;
block|}
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mtu
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Ok we are out of room but we can 					 * output without effecting the 					 * flight size since this little guy 					 * is a control only packet. 					 */
if|if
condition|(
name|asconf
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|asconf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cookie
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_BUF_PREPEND
argument_list|(
name|outchain
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|error_out_again
goto|;
block|}
name|shdr
operator|=
name|mtod
argument_list|(
name|outchain
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|src_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|shdr
operator|->
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|shdr
operator|->
name|v_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|auth_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|outchain
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|asconf
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
block|{
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|1
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_where
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerrusr
argument_list|)
expr_stmt|;
block|}
name|error_out_again
label|:
comment|/* error, could not output */
if|if
condition|(
name|hbflag
condition|)
block|{
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EHOSTUNREACH
condition|)
block|{
comment|/* 							 * Destination went 							 * unreachable 							 * during this send 							 */
name|sctp_move_to_an_alt
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|7
expr_stmt|;
continue|continue;
block|}
else|else
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
comment|/* Only HB or ASCONF advances time */
if|if
condition|(
name|hbflag
condition|)
block|{
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * increase the number we sent, if a 					 * cookie is sent we don't tell them 					 * any was sent out. 					 */
name|outchain
operator|=
name|endoutchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_out_cnt
condition|)
operator|*
name|num_out
operator|+=
name|ctl_cnt
expr_stmt|;
comment|/* recalc a clean slate and setup */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|mtu
operator|=
operator|(
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mtu
operator|=
operator|(
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
operator|)
expr_stmt|;
block|}
name|to_out
operator|=
literal|0
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/*********************/
comment|/* Data transmission */
comment|/*********************/
comment|/* 		 * if AUTH for DATA is required and no AUTH has been added 		 * yet, account for this in the mtu now... if no data can be 		 * bundled, this adjustment won't matter anyways since the 		 * packet will be going out... 		 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|mtu
operator|-=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
comment|/* now lets add any data within the MTU constraints */
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
condition|)
name|omtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
condition|)
name|omtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_OPEN
operator|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|&&
operator|(
name|skip_data_for_this_net
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|cookie
operator|)
condition|)
block|{
for|for
control|(
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
init|;
name|chk
condition|;
name|chk
operator|=
name|nchk
control|)
block|{
if|if
condition|(
name|no_data_chunks
condition|)
block|{
comment|/* let only control go out */
operator|*
name|reason_code
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* skip this net, no room for data */
operator|*
name|reason_code
operator|=
literal|2
expr_stmt|;
break|break;
block|}
name|nchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
comment|/* No, not sent to this net */
continue|continue;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|>
name|omtu
operator|)
operator|&&
operator|(
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 					 * strange, we have a chunk that is 					 * to big for its destination and 					 * yet no fragment ok flag. 					 * Something went wrong when the 					 * PMTU changed...we did not mark 					 * this chunk for some reason?? I 					 * will fix it here by letting IP 					 * fragment it for now and printing 					 * a warning. This really should not 					 * happen ... 					 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Warning chunk of %d bytes> mtu:%d and yet PMTU disc missed\n"
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|chk
operator|->
name|send_size
operator|<=
name|mtu
operator|)
operator|&&
operator|(
name|chk
operator|->
name|send_size
operator|<=
name|r_mtu
operator|)
operator|)
operator|||
operator|(
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
operator|&&
operator|(
name|chk
operator|->
name|send_size
operator|<=
name|asoc
operator|->
name|peers_rwnd
operator|)
operator|)
condition|)
block|{
comment|/* ok we will add this one */
comment|/* 					 * Add an AUTH chunk, if chunk 					 * requires it, save the offset into 					 * the chain for AUTH 					 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|outchain
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_DATA
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
name|outchain
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
literal|0
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"No memory?\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* upate our MTU size */
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* unsigned subtraction of mtu */
if|if
condition|(
name|mtu
operator|>
name|chk
operator|->
name|send_size
condition|)
name|mtu
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
comment|/* unsigned subtraction of r_mtu */
if|if
condition|(
name|r_mtu
operator|>
name|chk
operator|->
name|send_size
condition|)
name|r_mtu
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
else|else
name|r_mtu
operator|=
literal|0
expr_stmt|;
name|to_out
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
name|to_out
operator|>
name|mx_mtu
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Exceeding mtu of %d out size is %d"
argument_list|,
name|mx_mtu
argument_list|,
name|to_out
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Exceeding mtu of %d out size is %d\n"
argument_list|,
name|mx_mtu
argument_list|,
name|to_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|chk
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
name|data_list
index|[
name|bundle_at
operator|++
index|]
operator|=
name|chk
expr_stmt|;
if|if
condition|(
name|bundle_at
operator|>=
name|SCTP_MAX_DATA_BUNDLING
condition|)
block|{
name|mtu
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outorderchunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outunorderchunks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
operator|)
operator|&&
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* 							 * Count number of 							 * user msg's that 							 * were fragmented 							 * we do this by 							 * counting when we 							 * see a LAST 							 * fragment only. 							 */
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_fragusrmsgs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtu
operator|==
literal|0
operator|)
operator|||
operator|(
name|r_mtu
operator|==
literal|0
operator|)
operator|||
operator|(
name|one_chunk
operator|)
condition|)
block|{
if|if
condition|(
name|one_chunk
condition|)
block|{
name|data_list
index|[
literal|0
index|]
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* 					 * Must be sent in order of the 					 * TSN's (on a network) 					 */
break|break;
block|}
block|}
comment|/* for (chunk gather loop for this net) */
block|}
comment|/* if asoc.state OPEN */
comment|/* Is there something to send for this destination? */
if|if
condition|(
name|outchain
condition|)
block|{
comment|/* We may need to start a control timer or two */
if|if
condition|(
name|asconf
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|asconf
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cookie
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
comment|/* must start a send timer if data is being sent */
if|if
condition|(
name|bundle_at
operator|&&
operator|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * no timer running on this destination 				 * restart it. 				 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* Now send it, if there is anything to send :> */
name|SCTP_BUF_PREPEND
argument_list|(
name|outchain
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
comment|/* out of mbufs */
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|errored_send
goto|;
block|}
name|shdr
operator|=
name|mtod
argument_list|(
name|outchain
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|src_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|shdr
operator|->
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|shdr
operator|->
name|v_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|auth_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|outchain
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|no_fragmentflg
argument_list|,
name|bundle_at
argument_list|,
name|data_list
index|[
literal|0
index|]
argument_list|,
name|asconf
argument_list|)
operator|)
condition|)
block|{
comment|/* error, we could not output */
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|from_where
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerrusr
argument_list|)
expr_stmt|;
block|}
name|errored_send
label|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"Gak send error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|hbflag
condition|)
block|{
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EHOSTUNREACH
condition|)
block|{
comment|/* 					 * Destination went unreachable 					 * during this send 					 */
name|sctp_move_to_an_alt
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|6
expr_stmt|;
comment|/*- 				 * I add this line to be paranoid. As far as 				 * I can tell the continue, takes us back to 				 * the top of the for, but just to make sure 				 * I will reset these again here. 				 */
name|ctl_cnt
operator|=
name|bundle_at
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* This takes us back to the 						 * for() for the nets. */
block|}
else|else
block|{
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
block|}
name|outchain
operator|=
name|endoutchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bundle_at
operator|||
name|hbflag
condition|)
block|{
comment|/* For data/asconf and hb set time */
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|no_out_cnt
condition|)
block|{
operator|*
name|num_out
operator|+=
operator|(
name|ctl_cnt
operator|+
name|bundle_at
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|bundle_at
condition|)
block|{
comment|/* setup for a RTO measurement */
name|tsns_sent
operator|=
name|data_list
index|[
literal|0
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|data_list
index|[
literal|0
index|]
operator|->
name|do_rtt
operator|=
literal|1
expr_stmt|;
name|SCTP_STAT_INCR_BY
argument_list|(
name|sctps_senddata
argument_list|,
name|bundle_at
argument_list|)
expr_stmt|;
name|sctp_clean_up_datalist
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|data_list
argument_list|,
name|bundle_at
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_early_fr
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|flight_size
operator|<
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* start or restart it */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstrout
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* stop it if its running */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|fr_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_earlyfrstpout
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_EARLYFR
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|one_chunk
condition|)
block|{
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|tsns_sent
argument_list|,
name|SCTP_CWND_LOG_FROM_SEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|old_startat
operator|==
name|NULL
condition|)
block|{
name|old_startat
operator|=
name|send_start_at
expr_stmt|;
name|send_start_at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
goto|goto
name|again_one_more_time
goto|;
block|}
comment|/* 	 * At the end there should be no NON timed chunks hanging on this 	 * queue. 	 */
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|*
name|num_out
argument_list|,
name|SCTP_CWND_LOG_FROM_SEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|*
name|num_out
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|reason_code
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
operator|*
name|reason_code
operator|=
literal|5
expr_stmt|;
block|}
name|sctp_clean_up_ctl
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_queue_op_err
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|)
block|{
comment|/*- 	 * Prepend a OPERATIONAL_ERROR chunk header and put on the end of 	 * the control chunk queue. 	 */
name|struct
name|sctp_chunkhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_PREPEND
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|send_size
operator|=
literal|0
expr_stmt|;
name|mat
operator|=
name|op_err
expr_stmt|;
while|while
condition|(
name|mat
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|send_size
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|mat
argument_list|)
expr_stmt|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_OPERATION_ERROR
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|op_err
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|chk
operator|->
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|chunk_type
operator|=
name|SCTP_OPERATION_ERROR
expr_stmt|;
name|hdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_send_cookie_echo
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/*- 	 * pull out the cookie and put it at the front of the control chunk 	 * queue. 	 */
name|int
name|at
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|cookie
decl_stmt|;
name|struct
name|sctp_paramhdr
name|parm
decl_stmt|,
modifier|*
name|phdr
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
comment|/* First find the cookie in the param area */
name|cookie
operator|=
name|NULL
expr_stmt|;
name|at
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
do|do
block|{
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|at
argument_list|,
operator|&
name|parm
argument_list|,
sizeof|sizeof
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptype
operator|==
name|SCTP_STATE_COOKIE
condition|)
block|{
name|int
name|pad
decl_stmt|;
comment|/* found the cookie */
if|if
condition|(
operator|(
name|pad
operator|=
operator|(
name|plen
operator|%
literal|4
operator|)
operator|)
condition|)
block|{
name|plen
operator|+=
literal|4
operator|-
name|pad
expr_stmt|;
block|}
name|cookie
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
name|at
argument_list|,
name|plen
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
break|break;
block|}
name|at
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|phdr
condition|)
do|;
if|if
condition|(
name|cookie
operator|==
name|NULL
condition|)
block|{
comment|/* Did not find the cookie */
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
comment|/* ok, we got the cookie lets change it into a cookie echo chunk */
comment|/* first the change from param to cookie */
name|hdr
operator|=
name|mtod
argument_list|(
name|cookie
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|chunk_type
operator|=
name|SCTP_COOKIE_ECHO
expr_stmt|;
name|hdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
comment|/* get the chunk stuff now and place it in the FRONT of the queue */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|plen
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_COOKIE_ECHO
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|cookie
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|chk
operator|->
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_send_heartbeat_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|chk_length
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * take a HB request and make it into a HB ack and send it. 	 */
name|struct
name|mbuf
modifier|*
name|outchain
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|chdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
comment|/* must have a net pointer */
return|return;
name|outchain
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|chk_length
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
comment|/* gak out of memory */
return|return;
block|}
name|chdr
operator|=
name|mtod
argument_list|(
name|outchain
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|chdr
operator|->
name|chunk_type
operator|=
name|SCTP_HEARTBEAT_ACK
expr_stmt|;
name|chdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk_length
operator|%
literal|4
condition|)
block|{
comment|/* need pad */
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|int
name|padlen
decl_stmt|;
name|padlen
operator|=
literal|4
operator|-
operator|(
name|chk_length
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|outchain
argument_list|,
name|chk_length
argument_list|,
name|padlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|chk_length
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_HEARTBEAT_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|outchain
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_send_cookie_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* formulate and queue a cookie-ack back to sender */
name|struct
name|mbuf
modifier|*
name|cookie_ack
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|cookie_ack
operator|=
name|NULL
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|cookie_ack
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie_ack
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|cookie_ack
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|cookie_ack
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_COOKIE_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|cookie_ack
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|asoc
operator|->
name|last_control_chunk_from
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|chk
operator|->
name|asoc
operator|->
name|last_control_chunk_from
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|whoTo
operator|=
name|chk
operator|->
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|cookie_ack
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|chunk_type
operator|=
name|SCTP_COOKIE_ACK
expr_stmt|;
name|hdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|cookie_ack
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_send_shutdown_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* formulate and queue a SHUTDOWN-ACK back to the sender */
name|struct
name|mbuf
modifier|*
name|m_shutdown_ack
decl_stmt|;
name|struct
name|sctp_shutdown_ack_chunk
modifier|*
name|ack_cp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|m_shutdown_ack
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_ack_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_shutdown_ack
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_shutdown_ack
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_shutdown_ack
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_SHUTDOWN_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m_shutdown_ack
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ack_cp
operator|=
name|mtod
argument_list|(
name|m_shutdown_ack
argument_list|,
expr|struct
name|sctp_shutdown_ack_chunk
operator|*
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN_ACK
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_shutdown_ack
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_send_shutdown
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* formulate and queue a SHUTDOWN to the sender */
name|struct
name|mbuf
modifier|*
name|m_shutdown
decl_stmt|;
name|struct
name|sctp_shutdown_chunk
modifier|*
name|shutdown_cp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|m_shutdown
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_shutdown
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_shutdown
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_shutdown
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_SHUTDOWN
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m_shutdown
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|shutdown_cp
operator|=
name|mtod
argument_list|(
name|m_shutdown
argument_list|,
expr|struct
name|sctp_shutdown_chunk
operator|*
argument_list|)
expr_stmt|;
name|shutdown_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN
expr_stmt|;
name|shutdown_cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|shutdown_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|shutdown_cp
operator|->
name|cumulative_tsn_ack
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_shutdown
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_send_asconf
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * formulate and queue an ASCONF to the peer ASCONF parameters 	 * should be queued on the assoc queue 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_asconf
decl_stmt|;
name|struct
name|sctp_asconf_chunk
modifier|*
name|acp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* compose an ASCONF chunk, maximum length is PMTU */
name|m_asconf
operator|=
name|sctp_compose_asconf
argument_list|(
name|stcb
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_asconf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|acp
operator|=
name|mtod
argument_list|(
name|m_asconf
argument_list|,
expr|struct
name|sctp_asconf_chunk
operator|*
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_asconf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m_asconf
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|chk
operator|->
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_send_asconf_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|retrans
parameter_list|)
block|{
comment|/* 	 * formulate and queue a asconf-ack back to sender the asconf-ack 	 * must be stored in the tcb 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_ack
decl_stmt|,
modifier|*
name|m
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* is there a asconf-ack mbuf chain to send? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_asconf_ack_sent
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* copy the asconf_ack */
name|m_ack
operator|=
name|SCTP_M_COPYM
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|last_asconf_ack_sent
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_ack
operator|==
name|NULL
condition|)
block|{
comment|/* couldn't copy it */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
if|if
condition|(
name|m_ack
condition|)
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
comment|/* figure out where it goes to */
if|if
condition|(
name|retrans
condition|)
block|{
comment|/* we're doing a retransmission */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|used_alt_asconfack
operator|>
literal|2
condition|)
block|{
comment|/* tried alternate nets already, go back */
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* need to try and alternate net */
name|chk
operator|->
name|whoTo
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|used_alt_asconfack
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
comment|/* no alternate */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
else|else
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|used_alt_asconfack
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* normal case */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
else|else
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|used_alt_asconfack
operator|=
literal|0
expr_stmt|;
block|}
name|chk
operator|->
name|data
operator|=
name|m_ack
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
literal|0
expr_stmt|;
comment|/* Get size */
name|m
operator|=
name|m_ack
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
name|chk
operator|->
name|send_size
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_chunk_retransmission
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
modifier|*
name|cnt_out
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
modifier|*
name|now_filled
parameter_list|,
name|int
modifier|*
name|fr_done
parameter_list|)
block|{
comment|/*- 	 * send out one MTU of retransmission. If fast_retransmit is 	 * happening we ignore the cwnd. Otherwise we obey the cwnd and 	 * rwnd. For a Cookie or Asconf in the control chunk queue we 	 * retransmit them by themselves. 	 * 	 * For data chunks we will pick out the lowest TSN's in the sent_queue 	 * marked for resend and bundle them all together (up to a MTU of 	 * destination). The address to send to should have been 	 * selected/changed where the retransmission was marked (i.e. in FR 	 * or t3-timeout routines). 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|data_list
index|[
name|SCTP_MAX_DATA_BUNDLING
index|]
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|fwd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|endofchain
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|shdr
decl_stmt|;
name|int
name|asconf
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|uint32_t
name|tsns_sent
init|=
literal|0
decl_stmt|;
name|int
name|no_fragmentflg
decl_stmt|,
name|bundle_at
decl_stmt|,
name|cnt_thru
decl_stmt|;
name|unsigned
name|int
name|mtu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|one_chunk
decl_stmt|,
name|fwd_tsn
decl_stmt|,
name|ctl_cnt
decl_stmt|,
name|tmr_started
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|;
name|uint32_t
name|dmtu
init|=
literal|0
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|tmr_started
operator|=
name|ctl_cnt
operator|=
name|bundle_at
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
name|asconf
operator|=
literal|0
expr_stmt|;
name|fwd_tsn
operator|=
literal|0
expr_stmt|;
operator|*
name|cnt_out
operator|=
literal|0
expr_stmt|;
name|fwd
operator|=
name|NULL
expr_stmt|;
name|endofchain
operator|=
name|m
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP hits empty queue with cnt set to %d?\n"
argument_list|,
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|asoc
operator|->
name|sent_queue_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|=
literal|0
expr_stmt|;
comment|/* send back 0/0 so we enter normal transmission */
operator|*
name|cnt_out
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_STREAM_RESET
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
operator|)
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_STREAM_RESET
condition|)
block|{
if|if
condition|(
name|chk
operator|!=
name|asoc
operator|->
name|str_reset
condition|)
block|{
comment|/* 					 * not eligible for retran if its 					 * not ours 					 */
continue|continue;
block|}
block|}
name|ctl_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
name|asconf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
condition|)
block|{
name|fwd_tsn
operator|=
literal|1
expr_stmt|;
name|fwd
operator|=
name|chk
expr_stmt|;
block|}
comment|/* 			 * Add an AUTH chunk, if chunk requires it save the 			 * offset into the chain for AUTH 			 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
literal|0
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|one_chunk
operator|=
literal|0
expr_stmt|;
name|cnt_thru
operator|=
literal|0
expr_stmt|;
comment|/* do we have control chunks to retransmit? */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* Start a timer no matter if we suceed or fail */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|SCTP_BUF_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|shdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|src_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|shdr
operator|->
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|shdr
operator|->
name|v_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|auth_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|++
expr_stmt|;
comment|/* update our count */
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|asconf
argument_list|)
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m
operator|=
name|endofchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We don't want to mark the net->sent time here since this 		 * we use this for HB and retrans cannot measure RTT 		 */
comment|/* SCTP_GETTIME_TIMEVAL(&chk->whoTo->last_sent_time); */
operator|*
name|cnt_out
operator|+=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwd_tsn
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Clean up the fwd-tsn list */
name|sctp_clean_up_ctl
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Ok, it is just data retransmission we need to do or that and a 	 * fwd-tsn with it all. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
return|return
operator|(
name|SCTP_RETRAN_DONE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
condition|)
block|{
comment|/* not yet open, resend the cookie and that is it */
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|20
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* No, not sent to this net or not ready for rtx */
continue|continue;
block|}
if|if
condition|(
operator|(
name|sctp_max_retran_chunk
operator|)
operator|&&
operator|(
name|chk
operator|->
name|snd_count
operator|>=
name|sctp_max_retran_chunk
operator|)
condition|)
block|{
comment|/* Gak, we have exceeded max unlucky retran, abort! */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Gak, chk->snd_count:%d>= max:%d - send abort\n"
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|,
name|sctp_max_retran_chunk
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASOCKILL
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCTP_RETRAN_EXIT
operator|)
return|;
block|}
comment|/* pick up the net */
name|net
operator|=
name|chk
operator|->
name|whoTo
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|mtu
operator|=
operator|(
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
operator|)
expr_stmt|;
block|}
else|else
block|{
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|mtu
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* No room in peers rwnd */
name|uint32_t
name|tsn
decl_stmt|;
name|tsn
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsn
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* 				 * we make a special exception for this 				 * case. The peer has no rwnd but is missing 				 * the lowest chunk.. which is probably what 				 * is holding up the rwnd. 				 */
goto|goto
name|one_chunk_around
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|one_chunk_around
label|:
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|mtu
condition|)
block|{
name|one_chunk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|==
literal|0
operator|)
condition|)
block|{
name|chk
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bundle_at
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|fast_retran_ip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|==
literal|0
condition|)
block|{
comment|/* 			 * if no FR in progress skip destination that have 			 * flight_size> cwnd. 			 */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
comment|/* 			 * Mark the destination net to have FR recovery 			 * limits put on it. 			 */
operator|*
name|fr_done
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|fast_retran_ip
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * if no AUTH is yet included and this chunk requires it, 		 * make sure to account for it.  We don't apply the size 		 * until the AUTH chunk is actually added below in case 		 * there is no room for this chunk. 		 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|dmtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|dmtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|<=
operator|(
name|mtu
operator|-
name|dmtu
operator|)
operator|)
operator|||
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
condition|)
block|{
comment|/* ok we will add this one */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_DATA
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
literal|0
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* upate our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|chk
operator|->
name|send_size
operator|+
name|dmtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|dmtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|data_list
index|[
name|bundle_at
operator|++
index|]
operator|=
name|chk
expr_stmt|;
if|if
condition|(
name|one_chunk
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|<=
literal|0
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_windowprobed
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|one_chunk
operator|==
literal|0
condition|)
block|{
comment|/* 			 * now are there anymore forward from chk to pick 			 * up? 			 */
name|fwd
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
while|while
condition|(
name|fwd
condition|)
block|{
if|if
condition|(
name|fwd
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* Nope, not for retran */
name|fwd
operator|=
name|TAILQ_NEXT
argument_list|(
name|fwd
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|fwd
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
comment|/* Nope, not the net in question */
name|fwd
operator|=
name|TAILQ_NEXT
argument_list|(
name|fwd
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|dmtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|dmtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwd
operator|->
name|send_size
operator|<=
operator|(
name|mtu
operator|-
name|dmtu
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_DATA
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|fwd
operator|->
name|data
argument_list|,
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
literal|0
argument_list|,
name|fwd
operator|->
name|send_size
argument_list|,
name|fwd
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|fwd
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* upate our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|fwd
operator|->
name|send_size
operator|+
name|dmtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|fwd
operator|->
name|send_size
operator|+
name|dmtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|data_list
index|[
name|bundle_at
operator|++
index|]
operator|=
name|fwd
expr_stmt|;
if|if
condition|(
name|bundle_at
operator|>=
name|SCTP_MAX_DATA_BUNDLING
condition|)
block|{
break|break;
block|}
name|fwd
operator|=
name|TAILQ_NEXT
argument_list|(
name|fwd
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* can't fit so we are done */
break|break;
block|}
block|}
block|}
comment|/* Is there something to send for this destination? */
if|if
condition|(
name|m
condition|)
block|{
comment|/* 			 * No matter if we fail/or suceed we should start a 			 * timer. A failure is like a lost IP packet :-) 			 */
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* 				 * no timer running on this destination 				 * restart it. 				 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|tmr_started
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_BUF_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|shdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|src_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|shdr
operator|->
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|shdr
operator|->
name|v_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|auth_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
comment|/* Now lets send it, if there is anything to send :> */
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|asconf
argument_list|)
operator|)
condition|)
block|{
comment|/* error, we could not output */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|m
operator|=
name|endofchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
comment|/* For HB's */
comment|/* 			 * We don't want to mark the net->sent time here 			 * since this we use this for HB and retrans cannot 			 * measure RTT 			 */
comment|/* SCTP_GETTIME_TIMEVAL(&net->last_sent_time); */
comment|/* For auto-close */
name|cnt_thru
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_last_sent
argument_list|)
expr_stmt|;
operator|*
name|now
operator|=
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|time_last_sent
operator|=
operator|*
name|now
expr_stmt|;
block|}
operator|*
name|cnt_out
operator|+=
name|bundle_at
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC4
argument_list|,
name|bundle_at
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bundle_at
condition|)
block|{
name|tsns_sent
operator|=
name|data_list
index|[
literal|0
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bundle_at
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendretransdata
argument_list|)
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
comment|/* 				 * When we have a revoked data, and we 				 * retransmit it, then we clear the revoked 				 * flag since this flag dictates if we 				 * subtracted from the fs 				 */
if|if
condition|(
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* Deflate the cwnd */
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|data_list
index|[
name|i
index|]
operator|->
name|snd_count
operator|++
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
comment|/* record the time */
name|data_list
index|[
name|i
index|]
operator|->
name|sent_rcv_time
operator|=
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
if|if
condition|(
name|data_list
index|[
name|i
index|]
operator|->
name|book_size_scale
condition|)
block|{
comment|/* 					 * need to double the book size on 					 * this one 					 */
name|data_list
index|[
name|i
index|]
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
comment|/* 					 * Since we double the booksize, we 					 * must also double the output queue 					 * size, since this get shrunk when 					 * we free by this amount. 					 */
name|atomic_add_int
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|)
operator|->
name|total_output_queue_size
operator|)
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
operator|*=
literal|2
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_RWND
name|sctp_log_rwnd
argument_list|(
name|SCTP_DECREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
argument_list|,
name|sctp_peer_chunk_oh
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|peers_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
operator|+
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_RSND
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_flight_size_increase
argument_list|(
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendfastretrans
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data_list
index|[
name|i
index|]
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|tmr_started
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 						 * ok we just fast-retrans'd 						 * the lowest TSN, i.e the 						 * first on the list. In 						 * this case we want to give 						 * some more time to get a 						 * SACK back without a 						 * t3-expiring. 						 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|tsns_sent
argument_list|,
name|SCTP_CWND_LOG_FROM_RESEND
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|21
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* None will fit */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|<=
literal|0
condition|)
block|{
comment|/* all done we have no more to retran */
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|one_chunk
condition|)
block|{
comment|/* No more room in rwnd */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* stop the for loop here. we sent out a packet */
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_timer_validation
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|ret
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* Validate that a timer is running somewhere */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* Here is a timer */
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* Gak, we did not have a timer somewhere */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"Deadlock avoided starting timer on a dest at retran\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|from_where
parameter_list|)
block|{
comment|/*- 	 * Ok this is the generic chunk service queue. we must do the 	 * following: 	 * - See if there are retransmits pending, if so we must 	 *   do these first. 	 * - Service the stream queue that is next, moving any 	 *   message (note I must get a complete message i.e. 	 *   FIRST/MIDDLE and LAST to the out queue in one pass) and assigning 	 *   TSN's 	 * - Check to see if the cwnd/rwnd allows any output, if so we 	 *   go ahead and fomulate and send the low level chunks. Making sure 	 *   to combine any control in the control chunk queue also. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|num_out
init|=
literal|0
decl_stmt|,
name|tot_out
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|reason_code
init|=
literal|0
decl_stmt|,
name|burst_cnt
init|=
literal|0
decl_stmt|,
name|burst_limit
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
name|int
name|cwnd_full
init|=
literal|0
decl_stmt|;
name|int
name|nagle_on
init|=
literal|0
decl_stmt|;
name|int
name|frag_point
init|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
decl_stmt|;
name|int
name|un_sent
init|=
literal|0
decl_stmt|;
name|int
name|fr_done
decl_stmt|,
name|tot_frs
init|=
literal|0
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|from_where
operator|==
name|SCTP_OUTPUT_FROM_USR_SEND
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
condition|)
block|{
name|nagle_on
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nagle_on
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|un_sent
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|un_sent
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Nothing to do unless there is something to be sent left */
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Do we have something to send, data or control AND a sack timer 	 * running, if so piggy-back the sack. 	 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
condition|)
block|{
comment|/*- 		 * Ok, it is retransmission time only, we send out only ONE 		 * packet with a single call off to the retran code. 		 */
if|if
condition|(
name|from_where
operator|==
name|SCTP_OUTPUT_FROM_COOKIE_ACK
condition|)
block|{
comment|/*- 			 * Special hook for handling cookiess discarded 			 * by peer that carried data. Send cookie-ack only 			 * and then the next call with get the retran's. 			 */
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|1
argument_list|,
operator|&
name|cwnd_full
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|from_where
operator|!=
name|SCTP_OUTPUT_FROM_HB_TMR
condition|)
block|{
comment|/* if its not from a HB then do it */
name|fr_done
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|sctp_chunk_retransmission
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
operator|&
name|fr_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_done
condition|)
block|{
name|tot_frs
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * its from any other place, we don't allow retran 			 * output (only control) 			 */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
comment|/* Can't send anymore */
comment|/*- 			 * now lets push out control by calling med-level 			 * output once. this assures that we WILL send HB's 			 * if queued too. 			 */
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|1
argument_list|,
operator|&
name|cwnd_full
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|8
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|sctp_timer_validation
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
name|ret
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*- 			 * The count was off.. retran is not happening so do 			 * the normal retransmission. 			 */
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|9
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
name|SCTP_RETRAN_EXIT
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|from_where
operator|==
name|SCTP_OUTPUT_FROM_T3
condition|)
block|{
comment|/* Only one transmission allowed out of a timeout */
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|10
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Push out any control */
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|1
argument_list|,
operator|&
name|cwnd_full
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
name|tot_frs
operator|>
name|asoc
operator|->
name|max_burst
condition|)
block|{
comment|/* Hit FR burst limit */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|num_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ret
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* No more retrans to send */
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|12
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for bad destinations, if they exist move chunks around. */
name|burst_limit
operator|=
name|asoc
operator|->
name|max_burst
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|==
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
comment|/*- 			 * if possible move things off of this address we 			 * still may send below due to the dormant state but 			 * we try to find an alternate address to send to 			 * and if we have one we move all queued data on the 			 * out wheel to this alternate address. 			 */
if|if
condition|(
name|net
operator|->
name|ref_count
operator|>
literal|1
condition|)
name|sctp_move_to_an_alt
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*- 			 * if ((asoc->sat_network) || (net->addr_is_local)) 			 * { burst_limit = asoc->max_burst * 			 * SCTP_SAT_NETWORK_BURST_INCR; } 			 */
if|if
condition|(
name|sctp_use_cwnd_based_maxburst
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|+
operator|(
name|burst_limit
operator|*
name|net
operator|->
name|mtu
operator|)
operator|)
operator|<
name|net
operator|->
name|cwnd
condition|)
block|{
name|int
name|old_cwnd
decl_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
name|net
operator|->
name|cwnd
condition|)
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|net
operator|->
name|cwnd
operator|=
operator|(
name|net
operator|->
name|flight_size
operator|+
operator|(
name|burst_limit
operator|*
name|net
operator|->
name|mtu
operator|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_BRST
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_LOG_MAXBURST
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|burst_limit
argument_list|,
name|SCTP_MAX_BURST_APPLIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_maxburstqueued
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|fast_retran_ip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|flight_size
operator|==
literal|0
condition|)
block|{
comment|/* Should be decaying the cwnd here */
empty_stmt|;
block|}
block|}
block|}
block|}
name|burst_cnt
operator|=
literal|0
expr_stmt|;
name|cwnd_full
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|error
operator|=
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|0
argument_list|,
operator|&
name|cwnd_full
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Error %d was returned from med-c-op\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_LOG_MAXBURST
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|,
name|error
argument_list|,
name|burst_cnt
argument_list|,
name|SCTP_MAX_BURST_ERROR_STOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
literal|0xdeadbeef
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"m-c-o put out %d\n"
argument_list|,
name|num_out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tot_out
operator|+=
name|num_out
expr_stmt|;
name|burst_cnt
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|num_out
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_out
operator|==
literal|0
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|reason_code
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|nagle_on
condition|)
block|{
comment|/*- 			 * When nagle is on, we look at how much is un_sent, then 			 * if its smaller than an MTU and we have data in 			 * flight we stop. 			 */
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
condition|)
block|{
comment|/* Nothing left to send */
break|break;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Nothing left to send */
break|break;
block|}
block|}
do|while
condition|(
name|num_out
operator|&&
operator|(
name|sctp_use_cwnd_based_maxburst
operator|||
operator|(
name|burst_cnt
operator|<
name|burst_limit
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|sctp_use_cwnd_based_maxburst
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|burst_cnt
operator|>=
name|burst_limit
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_maxburstqueued
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|burst_limit_applied
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_MAXBURST
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|,
literal|0
argument_list|,
name|burst_cnt
argument_list|,
name|SCTP_MAX_BURST_APPLIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|asoc
operator|->
name|burst_limit_applied
operator|=
literal|0
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_LOGGING
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|tot_out
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Ok, we have put out %d chunks\n"
argument_list|,
name|tot_out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*- 	 * Now we need to clean up the control chunk chain if a ECNE is on 	 * it. It must be marked as UNSENT again so next call will continue 	 * to send it until such time that we get a CWR, to remove it. 	 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
condition|)
name|sctp_fix_ecn_echo
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_output
parameter_list|(
name|inp
parameter_list|,
name|m
parameter_list|,
name|addr
parameter_list|,
name|control
parameter_list|,
name|p
parameter_list|,
name|flags
parameter_list|)
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|control
decl_stmt|;
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|;
block|{
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|sctp_sosend
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|,
name|addr
argument_list|,
operator|(
expr|struct
name|uio
operator|*
operator|)
name|NULL
argument_list|,
name|m
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|send_forward_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_forward_tsn_chunk
modifier|*
name|fwdtsn
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
condition|)
block|{
comment|/* mark it to unsent */
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
comment|/* Do we correct its output location? */
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|asoc
operator|->
name|primary_destination
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
goto|goto
name|sctp_fill_in_rest
goto|;
block|}
block|}
comment|/* Ok if we reach here we must build one */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|sctp_fill_in_rest
label|:
comment|/*- 	 * Here we go through and fill out the part that deals with 	 * stream/seq of the ones we skip. 	 */
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
literal|0
expr_stmt|;
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|,
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|sctp_strseq
modifier|*
name|strseq
decl_stmt|;
name|unsigned
name|int
name|cnt_of_space
decl_stmt|,
name|i
decl_stmt|,
name|ovh
decl_stmt|;
name|unsigned
name|int
name|space_needed
decl_stmt|;
name|unsigned
name|int
name|cnt_of_skipped
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|at
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
condition|)
block|{
comment|/* no more to look at */
break|break;
block|}
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* We don't report these */
continue|continue;
block|}
name|cnt_of_skipped
operator|++
expr_stmt|;
block|}
name|space_needed
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
operator|+
operator|(
name|cnt_of_skipped
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
operator|)
operator|)
expr_stmt|;
name|cnt_of_space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MIN_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
name|cnt_of_space
operator|>
operator|(
name|asoc
operator|->
name|smallest_mtu
operator|-
name|ovh
operator|)
condition|)
block|{
comment|/* trim to a mtu size */
name|cnt_of_space
operator|=
name|asoc
operator|->
name|smallest_mtu
operator|-
name|ovh
expr_stmt|;
block|}
if|if
condition|(
name|cnt_of_space
operator|<
name|space_needed
condition|)
block|{
comment|/*- 			 * ok we must trim down the chunk by lowering the 			 * advance peer ack point. 			 */
name|cnt_of_skipped
operator|=
operator|(
name|cnt_of_space
operator|-
operator|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
operator|)
operator|)
expr_stmt|;
comment|/*- 			 * Go through and find the TSN that will be the one 			 * we report. 			 */
name|at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt_of_skipped
condition|;
name|i
operator|++
control|)
block|{
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|at
operator|=
name|tp1
expr_stmt|;
block|}
name|last
operator|=
name|at
expr_stmt|;
comment|/*- 			 * last now points to last one I can report, update 			 * peer ack point 			 */
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|last
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|space_needed
operator|-=
operator|(
name|cnt_of_skipped
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
operator|)
expr_stmt|;
block|}
name|chk
operator|->
name|send_size
operator|=
name|space_needed
expr_stmt|;
comment|/* Setup the chunk */
name|fwdtsn
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_forward_tsn_chunk
operator|*
argument_list|)
expr_stmt|;
name|fwdtsn
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|fwdtsn
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|fwdtsn
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|fwdtsn
operator|->
name|new_cumulative_tsn
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
operator|+
operator|(
name|cnt_of_skipped
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
operator|)
operator|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|fwdtsn
operator|++
expr_stmt|;
comment|/*- 		 * Move pointer to after the fwdtsn and transfer to the 		 * strseq pointer. 		 */
name|strseq
operator|=
operator|(
expr|struct
name|sctp_strseq
operator|*
operator|)
name|fwdtsn
expr_stmt|;
comment|/*- 		 * Now populate the strseq list. This is done blindly 		 * without pulling out duplicate stream info. This is 		 * inefficent but won't harm the process since the peer will 		 * look at these in sequence and will thus release anything. 		 * It could mean we exceed the PMTU and chop off some that 		 * we could have included.. but this is unlikely (aka 1432/4 		 * would mean 300+ stream seq's would have to be reported in 		 * one FWD-TSN. With a bit of work we can later FIX this to 		 * optimize and pull out duplcates.. but it does add more 		 * overhead. So for now... not! 		 */
name|at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt_of_skipped
condition|;
name|i
operator|++
control|)
block|{
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* We don't report these */
name|i
operator|--
expr_stmt|;
name|at
operator|=
name|tp1
expr_stmt|;
continue|continue;
block|}
name|strseq
operator|->
name|stream
operator|=
name|ntohs
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|)
expr_stmt|;
name|strseq
operator|->
name|sequence
operator|=
name|ntohs
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
name|strseq
operator|++
expr_stmt|;
name|at
operator|=
name|tp1
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/*- 	 * Queue up a SACK in the control queue. We must first check to see 	 * if a SACK is somehow on the control queue. If so, we will take 	 * and and remove the old one. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|a_chk
decl_stmt|;
name|struct
name|sctp_sack_chunk
modifier|*
name|sack
decl_stmt|;
name|struct
name|sctp_gap_ack_block
modifier|*
name|gap_descriptor
decl_stmt|;
name|struct
name|sack_track
modifier|*
name|selector
decl_stmt|;
name|int
name|mergeable
init|=
literal|0
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|caddr_t
name|limit
decl_stmt|;
name|uint32_t
modifier|*
name|dup
decl_stmt|;
name|int
name|limit_reached
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|jstart
decl_stmt|,
name|siz
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|num_gap_blocks
init|=
literal|0
decl_stmt|,
name|space
decl_stmt|;
name|int
name|num_dups
init|=
literal|0
decl_stmt|;
name|int
name|space_req
decl_stmt|;
name|a_chk
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|last_data_chunk_from
operator|==
name|NULL
condition|)
block|{
comment|/* Hmm we never received anything */
return|return;
block|}
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
condition|)
block|{
comment|/* Hmm, found a sack already on queue, remove it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|a_chk
operator|=
name|chk
expr_stmt|;
if|if
condition|(
name|a_chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|a_chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|a_chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|a_chk
operator|==
name|NULL
condition|)
block|{
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|a_chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_chk
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the idea, and set a timer */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
name|a_chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
comment|/* a_chk->rec.chunk_id.id = SCTP_SELECTIVE_ACK; */
name|a_chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_SELECTIVE_ACK
expr_stmt|;
name|a_chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Clear our pkt counts */
name|asoc
operator|->
name|data_pkts_seen
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|a_chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|send_size
operator|=
literal|0
expr_stmt|;
comment|/* fill in later */
name|a_chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|numduptsns
operator|)
operator|||
operator|(
name|asoc
operator|->
name|last_data_chunk_from
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
condition|)
block|{
comment|/*- 		 * Ok, we have some duplicates or the destination for the 		 * sack is unreachable, lets see if we can select an 		 * alternate than asoc->last_data_chunk_from 		 */
if|if
condition|(
operator|(
operator|!
operator|(
name|asoc
operator|->
name|last_data_chunk_from
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|used_alt_onsack
operator|>
name|asoc
operator|->
name|numnets
operator|)
condition|)
block|{
comment|/* We used an alt last time, don't this time */
name|a_chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|used_alt_onsack
operator|++
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|last_data_chunk_from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
comment|/* Nope, no alternate */
name|a_chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|last_data_chunk_from
expr_stmt|;
name|asoc
operator|->
name|used_alt_onsack
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * No duplicates so we use the last place we received data 		 * from. 		 */
name|asoc
operator|->
name|used_alt_onsack
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|last_data_chunk_from
expr_stmt|;
block|}
if|if
condition|(
name|a_chk
operator|->
name|whoTo
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|a_chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|==
name|asoc
operator|->
name|cumulative_tsn
condition|)
block|{
comment|/* no gaps */
name|space_req
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* gaps get a cluster */
name|space_req
operator|=
name|MCLBYTES
expr_stmt|;
block|}
comment|/* Ok now lets formulate a MBUF with our sack */
name|a_chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|space_req
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a_chk
operator|->
name|data
operator|==
name|NULL
operator|)
operator|||
operator|(
name|a_chk
operator|->
name|whoTo
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* rats, no mbuf memory */
if|if
condition|(
name|a_chk
operator|->
name|data
condition|)
block|{
comment|/* was a problem with the destination */
name|sctp_m_freem
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|a_chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|a_chk
operator|->
name|whoTo
condition|)
name|atomic_subtract_int
argument_list|(
operator|&
name|a_chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|a_chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* ok, lets go through and fill it in */
name|SCTP_BUF_RESV_UF
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
operator|(
name|a_chk
operator|->
name|whoTo
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
operator|)
condition|)
block|{
name|space
operator|=
operator|(
name|a_chk
operator|->
name|whoTo
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
operator|)
expr_stmt|;
block|}
name|limit
operator|=
name|mtod
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|limit
operator|+=
name|space
expr_stmt|;
name|sack
operator|=
name|mtod
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_sack_chunk
operator|*
argument_list|)
expr_stmt|;
name|sack
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SELECTIVE_ACK
expr_stmt|;
comment|/* 0x01 is used by nonce for ecn */
if|if
condition|(
operator|(
name|sctp_ecn_enable
operator|)
operator|&&
operator|(
name|sctp_ecn_nonce
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|peer_supports_ecn_nonce
operator|)
condition|)
name|sack
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
operator|(
name|asoc
operator|->
name|receiver_nonce_sum
operator|&
name|SCTP_SACK_NONCE_SUM
operator|)
expr_stmt|;
else|else
name|sack
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
operator|&&
name|sctp_cmt_use_dac
condition|)
block|{
comment|/*- 		 * CMT DAC algorithm: If 2 (i.e., 0x10) packets have been 		 * received, then set high bit to 1, else 0. Reset 		 * pkts_rcvd. 		 */
name|sack
operator|->
name|ch
operator|.
name|chunk_flags
operator||=
operator|(
name|asoc
operator|->
name|cmt_dac_pkts_rcvd
operator|<<
literal|6
operator|)
expr_stmt|;
name|asoc
operator|->
name|cmt_dac_pkts_rcvd
operator|=
literal|0
expr_stmt|;
block|}
name|sack
operator|->
name|sack
operator|.
name|cum_tsn_ack
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|my_rwnd
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_last_reported_rwnd
operator|=
name|asoc
operator|->
name|my_rwnd
expr_stmt|;
comment|/* reset the readers interpretation */
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
literal|0
expr_stmt|;
name|gap_descriptor
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sack
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|)
expr_stmt|;
name|siz
operator|=
operator|(
operator|(
operator|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|1
expr_stmt|;
comment|/*- 		 * cum-ack behind the mapping array, so we start and use all 		 * entries. 		 */
name|jstart
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|-
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
comment|/*- 		 * we skip the first one when the cum-ack is at or above the 		 * mapping array base. Note this only works if 		 */
name|jstart
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* we have a gap .. maybe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
block|{
name|selector
operator|=
operator|&
name|sack_array
index|[
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
index|]
expr_stmt|;
if|if
condition|(
name|mergeable
operator|&&
name|selector
operator|->
name|right_edge
condition|)
block|{
comment|/* 				 * Backup, left and right edges were ok to 				 * merge. 				 */
name|num_gap_blocks
operator|--
expr_stmt|;
name|gap_descriptor
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|selector
operator|->
name|num_entries
operator|==
literal|0
condition|)
name|mergeable
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|j
operator|=
name|jstart
init|;
name|j
operator|<
name|selector
operator|->
name|num_entries
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mergeable
operator|&&
name|selector
operator|->
name|right_edge
condition|)
block|{
comment|/* 						 * do a merge by NOT setting 						 * the left side 						 */
name|mergeable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 						 * no merge, set the left 						 * side 						 */
name|mergeable
operator|=
literal|0
expr_stmt|;
name|gap_descriptor
operator|->
name|start
operator|=
name|htons
argument_list|(
operator|(
name|selector
operator|->
name|gaps
index|[
name|j
index|]
operator|.
name|start
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
name|gap_descriptor
operator|->
name|end
operator|=
name|htons
argument_list|(
operator|(
name|selector
operator|->
name|gaps
index|[
name|j
index|]
operator|.
name|end
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
name|num_gap_blocks
operator|++
expr_stmt|;
name|gap_descriptor
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|gap_descriptor
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|>
name|limit
condition|)
block|{
comment|/* no more room */
name|limit_reached
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|selector
operator|->
name|left_edge
condition|)
block|{
name|mergeable
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|limit_reached
condition|)
block|{
comment|/* Reached the limit stop */
break|break;
block|}
name|jstart
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|num_gap_blocks
operator|==
literal|0
condition|)
block|{
comment|/* reneged all chunks */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
block|}
comment|/* now we must add any dups we are going to report. */
if|if
condition|(
operator|(
name|limit_reached
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|numduptsns
operator|)
condition|)
block|{
name|dup
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|gap_descriptor
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|numduptsns
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dup
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|dup_tsns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dup
operator|++
expr_stmt|;
name|num_dups
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|dup
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|>
name|limit
condition|)
block|{
comment|/* no more room */
break|break;
block|}
block|}
name|asoc
operator|->
name|numduptsns
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * now that the chunk is prepared queue it to the control chunk 	 * queue. 	 */
name|a_chk
operator|->
name|send_size
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|+
operator|(
name|num_gap_blocks
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|+
operator|(
name|num_dups
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
operator|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
operator|=
name|a_chk
operator|->
name|send_size
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|num_gap_ack_blks
operator|=
name|htons
argument_list|(
name|num_gap_blocks
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|num_dup_tsns
operator|=
name|htons
argument_list|(
name|num_dups
argument_list|)
expr_stmt|;
name|sack
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|a_chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|a_chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|asoc
operator|->
name|send_sack
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendsacks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_abort_tcb
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|operr
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_abort
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_out
init|=
name|NULL
decl_stmt|,
modifier|*
name|m_end
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_abort_chunk
modifier|*
name|abort
init|=
name|NULL
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|shdr
decl_stmt|;
comment|/*- 	 * Add an AUTH chunk, if chunk requires it and save the offset into 	 * the chain for AUTH 	 */
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_ABORT_ASSOCIATION
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|m_out
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m_out
argument_list|,
operator|&
name|m_end
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_ABORT_ASSOCIATION
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|m_abort
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_abort
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
if|if
condition|(
name|m_out
condition|)
name|sctp_m_freem
argument_list|(
name|m_out
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* link in any error */
name|SCTP_BUF_NEXT
argument_list|(
name|m_abort
argument_list|)
operator|=
name|operr
expr_stmt|;
name|sz
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|operr
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|operr
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
name|sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|n
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_abort
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|abort
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_out
operator|==
name|NULL
condition|)
block|{
comment|/* NO Auth chunk prepended, so reserve space in front */
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_abort
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|m_out
operator|=
name|m_abort
expr_stmt|;
block|}
else|else
block|{
comment|/* Put AUTH chunk at the front of the chain */
name|SCTP_BUF_NEXT
argument_list|(
name|m_end
argument_list|)
operator|=
name|m_abort
expr_stmt|;
block|}
comment|/* fill in the ABORT chunk */
name|abort
operator|=
name|mtod
argument_list|(
name|m_abort
argument_list|,
expr|struct
name|sctp_abort_chunk
operator|*
argument_list|)
expr_stmt|;
name|abort
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ABORT_ASSOCIATION
expr_stmt|;
name|abort
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|abort
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|abort
argument_list|)
operator|+
name|sz
argument_list|)
expr_stmt|;
comment|/* prepend and fill in the SCTP header */
name|SCTP_BUF_PREPEND
argument_list|(
name|m_out
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_out
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH: no memory */
return|return;
block|}
name|shdr
operator|=
name|mtod
argument_list|(
name|m_out
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|src_port
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
expr_stmt|;
name|shdr
operator|->
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|shdr
operator|->
name|v_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|shdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|auth_offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|sctp_lowlevel_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m_out
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_send_shutdown_complete
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* formulate and SEND a SHUTDOWN-COMPLETE */
name|struct
name|mbuf
modifier|*
name|m_shutdown_comp
decl_stmt|;
name|struct
name|sctp_shutdown_complete_msg
modifier|*
name|comp_cp
decl_stmt|;
name|m_shutdown_comp
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_msg
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_shutdown_comp
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|comp_cp
operator|=
name|mtod
argument_list|(
name|m_shutdown_comp
argument_list|,
expr|struct
name|sctp_shutdown_complete_msg
operator|*
argument_list|)
expr_stmt|;
name|comp_cp
operator|->
name|shut_cmp
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN_COMPLETE
expr_stmt|;
name|comp_cp
operator|->
name|shut_cmp
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|comp_cp
operator|->
name|shut_cmp
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|src_port
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|dest_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|v_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_shutdown_comp
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_msg
argument_list|)
expr_stmt|;
name|sctp_lowlevel_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m_shutdown_comp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_send_shutdown_complete2
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|)
block|{
comment|/* formulate and SEND a SHUTDOWN-COMPLETE */
name|struct
name|mbuf
modifier|*
name|o_pak
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mout
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|,
modifier|*
name|iph_out
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|,
modifier|*
name|ip6_out
decl_stmt|;
name|int
name|offset_out
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sctp_shutdown_complete_msg
modifier|*
name|comp_cp
decl_stmt|;
comment|/* Get room for the largest message */
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_msg
argument_list|)
operator|)
expr_stmt|;
name|o_pak
operator|=
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_pak
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mout
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|iph_out
operator|=
name|NULL
expr_stmt|;
name|ip6_out
operator|=
name|NULL
expr_stmt|;
name|offset_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_msg
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|mout
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|iph_out
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
comment|/* Fill in the IP header for the ABORT */
name|iph_out
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|iph_out
operator|->
name|ip_hl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|/
literal|4
operator|)
expr_stmt|;
name|iph_out
operator|->
name|ip_tos
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
name|iph_out
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
name|iph_out
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|iph_out
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
name|iph_out
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|iph_out
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|iph_out
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
comment|/* let IP layer calculate this */
name|iph_out
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|offset_out
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|iph_out
argument_list|)
expr_stmt|;
name|comp_cp
operator|=
operator|(
expr|struct
name|sctp_shutdown_complete_msg
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|iph_out
operator|+
name|offset_out
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|iph
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_msg
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|mout
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|ip6_out
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* Fill in the IPv6 header for the ABORT */
name|ip6_out
operator|->
name|ip6_flow
operator|=
name|ip6
operator|->
name|ip6_flow
expr_stmt|;
name|ip6_out
operator|->
name|ip6_hlim
operator|=
name|ip6_defhlim
expr_stmt|;
name|ip6_out
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|ip6_out
operator|->
name|ip6_src
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|ip6_out
operator|->
name|ip6_dst
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
comment|/* 		 * ?? The old code had both the iph len + payload, I think 		 * this is wrong and would never have worked 		 */
name|ip6_out
operator|->
name|ip6_plen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_msg
argument_list|)
expr_stmt|;
name|offset_out
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|ip6_out
argument_list|)
expr_stmt|;
name|comp_cp
operator|=
operator|(
expr|struct
name|sctp_shutdown_complete_msg
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6_out
operator|+
name|offset_out
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Currently not supported. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
expr_stmt|;
comment|/* Now copy in and fill in the ABORT tags etc. */
name|comp_cp
operator|->
name|sh
operator|.
name|src_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|dest_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
name|comp_cp
operator|->
name|sh
operator|.
name|v_tag
operator|=
name|sh
operator|->
name|v_tag
expr_stmt|;
name|comp_cp
operator|->
name|shut_cmp
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
name|SCTP_HAD_NO_TCB
expr_stmt|;
name|comp_cp
operator|->
name|shut_cmp
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN_COMPLETE
expr_stmt|;
name|comp_cp
operator|->
name|shut_cmp
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add checksum */
if|if
condition|(
operator|(
name|sctp_no_csum_on_loopback
operator|)
operator|&&
name|SCTP_IS_IT_LOOPBACK
argument_list|(
name|o_pak
argument_list|)
condition|)
block|{
name|comp_cp
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|comp_cp
operator|->
name|sh
operator|.
name|checksum
operator|=
name|sctp_calculate_sum
argument_list|(
name|mout
argument_list|,
name|NULL
argument_list|,
name|offset_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iph_out
operator|!=
name|NULL
condition|)
block|{
name|sctp_route_t
name|ro
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
name|ro
argument_list|)
expr_stmt|;
comment|/* set IPv4 length */
name|iph_out
operator|->
name|ip_len
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
comment|/* out it goes */
name|ip_output
argument_list|(
name|o_pak
argument_list|,
literal|0
argument_list|,
operator|&
name|ro
argument_list|,
name|IP_RAWOUTPUT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Free the route if we got one back */
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip6_out
operator|!=
name|NULL
condition|)
block|{
name|struct
name|route_in6
name|ro
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
argument_list|)
argument_list|)
expr_stmt|;
name|ip6_output
argument_list|(
name|o_pak
argument_list|,
name|NULL
argument_list|,
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Free the route if we got one back */
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_nets
modifier|*
name|sctp_select_hb_destination
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|hnet
decl_stmt|;
name|int
name|ms_goneby
decl_stmt|,
name|highest_ms
decl_stmt|,
name|state_overide
init|=
literal|0
decl_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
name|now
argument_list|)
expr_stmt|;
name|highest_ms
operator|=
literal|0
expr_stmt|;
name|hnet
operator|=
name|NULL
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
operator|)
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_OUT_OF_SCOPE
operator|)
condition|)
block|{
comment|/* 			 * Skip this guy from consideration if HB is off AND 			 * its confirmed 			 */
continue|continue;
block|}
if|if
condition|(
name|sctp_destination_is_reachable
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* skip this dest net from consideration */
continue|continue;
block|}
if|if
condition|(
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
condition|)
block|{
comment|/* Sent to so we subtract */
name|ms_goneby
operator|=
operator|(
name|now
operator|->
name|tv_sec
operator|-
name|net
operator|->
name|last_sent_time
operator|.
name|tv_sec
operator|)
operator|*
literal|1000
expr_stmt|;
block|}
else|else
comment|/* Never been sent to */
name|ms_goneby
operator|=
literal|0x7fffffff
expr_stmt|;
comment|/*- 		 * When the address state is unconfirmed but still 		 * considered reachable, we HB at a higher rate. Once it 		 * goes confirmed OR reaches the "unreachable" state, thenw 		 * we cut it back to HB at a more normal pace. 		 */
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
operator|(
name|SCTP_ADDR_UNCONFIRMED
operator||
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|)
operator|==
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|state_overide
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state_overide
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|ms_goneby
operator|>=
name|net
operator|->
name|RTO
operator|)
operator|||
operator|(
name|state_overide
operator|)
operator|)
operator|&&
operator|(
name|ms_goneby
operator|>
name|highest_ms
operator|)
condition|)
block|{
name|highest_ms
operator|=
name|ms_goneby
expr_stmt|;
name|hnet
operator|=
name|net
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hnet
operator|&&
operator|(
operator|(
name|hnet
operator|->
name|dest_state
operator|&
operator|(
name|SCTP_ADDR_UNCONFIRMED
operator||
name|SCTP_ADDR_NOT_REACHABLE
operator|)
operator|)
operator|==
name|SCTP_ADDR_UNCONFIRMED
operator|)
condition|)
block|{
name|state_overide
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|state_overide
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|highest_ms
operator|&&
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|highest_ms
operator|>=
name|hnet
operator|->
name|RTO
operator|)
operator|||
name|state_overide
operator|)
condition|)
block|{
comment|/*- 		 * Found the one with longest delay bounds OR it is 		 * unconfirmed and still not marked unreachable. 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT4
condition|)
block|{
name|printf
argument_list|(
literal|"net:%p is the hb winner -"
argument_list|,
name|hnet
argument_list|)
expr_stmt|;
if|if
condition|(
name|hnet
condition|)
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hnet
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" none\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* update the timer now */
name|hnet
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
return|return
operator|(
name|hnet
operator|)
return|;
block|}
comment|/* Nothing to HB */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_send_hb
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|user_req
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|u_net
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_heartbeat_chunk
modifier|*
name|hb
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|user_req
operator|==
literal|0
condition|)
block|{
name|net
operator|=
name|sctp_select_hb_destination
argument_list|(
name|stcb
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/*- 			 * All our busy none to send to, just start the 			 * timer again. 			 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|net
operator|=
name|u_net
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|!=
name|AF_INET6
condition|)
block|{
comment|/* huh */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT4
condition|)
block|{
name|printf
argument_list|(
literal|"Gak, can't get a chunk for hb\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_HEARTBEAT_REQUEST
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|chk
operator|->
name|send_size
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now we have a mbuf that we can fill in with the details */
name|hb
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_heartbeat_chunk
operator|*
argument_list|)
expr_stmt|;
comment|/* fill out chunk header */
name|hb
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_HEARTBEAT_REQUEST
expr_stmt|;
name|hb
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|hb
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
comment|/* Fill out hb parameter */
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HEARTBEAT_INFO
argument_list|)
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_info_param
argument_list|)
argument_list|)
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_1
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_2
operator|=
name|now
operator|.
name|tv_usec
expr_stmt|;
comment|/* Did our user request this one, put it in */
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|user_req
operator|=
name|user_req
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
operator|=
name|sin
operator|->
name|sin_family
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
operator|=
name|sin
operator|->
name|sin_len
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* 		 * we only take from the entropy pool if the address is not 		 * confirmed. 		 */
name|net
operator|->
name|heartbeat_random1
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value1
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|net
operator|->
name|heartbeat_random2
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value2
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|heartbeat_random1
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value1
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|heartbeat_random2
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|memcpy
argument_list|(
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sin
operator|->
name|sin_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* We leave the scope the way it is in our lookup table. */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|memcpy
argument_list|(
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* huh compiler bug */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ok we have a destination that needs a beat */
comment|/* lets do the theshold management Qiaobing style */
if|if
condition|(
name|sctp_threshold_management
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
argument_list|)
condition|)
block|{
comment|/*- 		 * we have lost the association, in a way this is 		 * quite bad since we really are one less time since 		 * we really did not send yet. This is the down side 		 * to the Q's style as defined in the RFC and not my 		 * alternate style defined in the RFC. 		 */
name|atomic_subtract_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|net
operator|->
name|hb_responded
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendheartbeat
argument_list|)
expr_stmt|;
comment|/*- 	 * Call directly med level routine to put out the chunk. It will 	 * always tumble out control chunks aka HB but it may even tumble 	 * out data too. 	 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_send_ecn_echo
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|high_tsn
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_ecne_chunk
modifier|*
name|ecne
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
condition|)
block|{
comment|/* found a previous ECN_ECHO update it if needed */
name|ecne
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_ecne_chunk
operator|*
argument_list|)
expr_stmt|;
name|ecne
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* nope could not find one to update so we must build one */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendecne
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ECN_ECHO
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|chk
operator|->
name|send_size
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
operator|++
expr_stmt|;
name|ecne
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_ecne_chunk
operator|*
argument_list|)
expr_stmt|;
name|ecne
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ECN_ECHO
expr_stmt|;
name|ecne
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ecne
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|ecne
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_packet_dropped
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|bad_crc
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_pktdrop_chunk
modifier|*
name|drp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint8_t
modifier|*
name|datap
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|small_one
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|long
name|spc
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peer_supports_pktdrop
operator|==
literal|0
condition|)
block|{
comment|/*- 		 * peer must declare support before I send one. 		 */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* IPv4 */
name|len
operator|=
name|chk
operator|->
name|send_size
operator|=
name|iph
operator|->
name|ip_len
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6h
decl_stmt|;
comment|/* IPv6 */
name|ip6h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|len
operator|=
name|chk
operator|->
name|send_size
operator|=
name|htons
argument_list|(
name|ip6h
operator|->
name|ip6_plen
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|jump_out
label|:
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|drp
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_pktdrop_chunk
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|drp
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
goto|goto
name|jump_out
goto|;
block|}
name|small_one
operator|=
name|asoc
operator|->
name|smallest_mtu
expr_stmt|;
if|if
condition|(
name|small_one
operator|>
name|MCLBYTES
condition|)
block|{
comment|/* Only one cluster worth of data MAX */
name|small_one
operator|=
name|MCLBYTES
expr_stmt|;
block|}
name|chk
operator|->
name|book_size
operator|=
name|SCTP_SIZE32
argument_list|(
operator|(
name|chk
operator|->
name|send_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
name|SCTP_MED_OVERHEAD
operator|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|book_size
operator|>
name|small_one
condition|)
block|{
name|drp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|SCTP_PACKET_TRUNCATED
expr_stmt|;
name|drp
operator|->
name|trunc_len
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|small_one
operator|-
operator|(
name|SCTP_MED_OVERHEAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
name|len
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
block|}
else|else
block|{
comment|/* no truncation needed */
name|drp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|drp
operator|->
name|trunc_len
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bad_crc
condition|)
block|{
name|drp
operator|->
name|ch
operator|.
name|chunk_flags
operator||=
name|SCTP_BADCRC
expr_stmt|;
block|}
name|chk
operator|->
name|send_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* we should hit here */
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|drp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
name|drp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|spc
operator|=
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|spc
operator|<
literal|0
condition|)
block|{
name|spc
operator|=
literal|0
expr_stmt|;
block|}
name|drp
operator|->
name|bottle_bw
operator|=
name|htonl
argument_list|(
name|spc
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|my_rwnd
condition|)
block|{
name|drp
operator|->
name|current_onq
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|size_on_reasm_queue
operator|+
name|asoc
operator|->
name|size_on_all_streams
operator|+
name|asoc
operator|->
name|my_rwnd_control_len
operator|+
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*- 		 * If my rwnd is 0, possibly from mbuf depletion as well as 		 * space used, tell the peer there is NO space aka onq == bw 		 */
name|drp
operator|->
name|current_onq
operator|=
name|htonl
argument_list|(
name|spc
argument_list|)
expr_stmt|;
block|}
name|drp
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|datap
operator|=
name|drp
operator|->
name|data
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|datap
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_cwr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|high_tsn
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_cwr_chunk
modifier|*
name|cwr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_CWR
condition|)
block|{
comment|/* found a previous ECN_CWR update it if needed */
name|cwr
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_cwr_chunk
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|high_tsn
argument_list|,
name|ntohl
argument_list|(
name|cwr
operator|->
name|tsn
argument_list|)
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|cwr
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
block|}
comment|/* nope could not find one to update so we must build one */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ECN_CWR
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cwr_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|chk
operator|->
name|send_size
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cwr
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_cwr_chunk
operator|*
argument_list|)
expr_stmt|;
name|cwr
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ECN_CWR
expr_stmt|;
name|cwr
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|cwr
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cwr_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|cwr
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_out
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint32_t
name|last_sent
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|old_len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req_out
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|req_out
operator|=
operator|(
expr|struct
name|sctp_stream_reset_out_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|number_entries
operator|)
operator|)
expr_stmt|;
name|req_out
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_OUT_REQUEST
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|response_seq
operator|=
name|htonl
argument_list|(
name|resp_seq
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|send_reset_at_tsn
operator|=
name|htonl
argument_list|(
name|last_sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|req_out
operator|->
name|list_of_streams
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|len
argument_list|)
operator|>
name|len
condition|)
block|{
comment|/*- 		 * Need to worry about the pad we may end up adding to the 		 * end. This is easy since the struct is either aligned to 4 		 * bytes or 2 bytes off. 		 */
name|req_out
operator|->
name|list_of_streams
index|[
name|number_entries
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_in
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|old_len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req_in
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|req_in
operator|=
operator|(
expr|struct
name|sctp_stream_reset_in_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_in_request
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|number_entries
operator|)
operator|)
expr_stmt|;
name|req_in
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_IN_REQUEST
argument_list|)
expr_stmt|;
name|req_in
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req_in
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|req_in
operator|->
name|list_of_streams
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|len
argument_list|)
operator|>
name|len
condition|)
block|{
comment|/*- 		 * Need to worry about the pad we may end up adding to the 		 * end. This is easy since the struct is either aligned to 4 		 * bytes or 2 bytes off. 		 */
name|req_in
operator|->
name|list_of_streams
index|[
name|number_entries
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_tsn
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_stream_reset_tsn_request
modifier|*
name|req_tsn
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|req_tsn
operator|=
operator|(
expr|struct
name|sctp_stream_reset_tsn_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_tsn_request
argument_list|)
expr_stmt|;
name|req_tsn
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_TSN_REQUEST
argument_list|)
expr_stmt|;
name|req_tsn
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req_tsn
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_result
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint32_t
name|result
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_stream_reset_response
modifier|*
name|resp
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_response
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_RESPONSE
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|resp
operator|->
name|response_seq
operator|=
name|htonl
argument_list|(
name|resp_seq
argument_list|)
expr_stmt|;
name|resp
operator|->
name|result
operator|=
name|ntohl
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_result_tsn
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint32_t
name|result
parameter_list|,
name|uint32_t
name|send_una
parameter_list|,
name|uint32_t
name|recv_next
parameter_list|)
block|{
name|int
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_stream_reset_response_tsn
modifier|*
name|resp
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response_tsn
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_response_tsn
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_RESPONSE
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|resp
operator|->
name|response_seq
operator|=
name|htonl
argument_list|(
name|resp_seq
argument_list|)
expr_stmt|;
name|resp
operator|->
name|result
operator|=
name|htonl
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|resp
operator|->
name|senders_next_tsn
operator|=
name|htonl
argument_list|(
name|send_una
argument_list|)
expr_stmt|;
name|resp
operator|->
name|receivers_next_tsn
operator|=
name|htonl
argument_list|(
name|recv_next
argument_list|)
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|sctp_send_str_reset_req
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|uint8_t
name|send_out_req
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint8_t
name|send_in_req
parameter_list|,
name|uint8_t
name|send_tsn_req
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
block|{
comment|/*- 		 * Already one pending, must get ACK back to clear the flag. 		 */
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|send_out_req
operator|==
literal|0
operator|)
operator|&&
operator|(
name|send_in_req
operator|==
literal|0
operator|)
operator|&&
operator|(
name|send_tsn_req
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing to do */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|send_tsn_req
operator|&&
operator|(
name|send_out_req
operator|||
name|send_in_req
operator|)
condition|)
block|{
comment|/* error, can't do that */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
comment|/* setup chunk parameters */
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|ch
operator|->
name|chunk_type
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|ch
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|seq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
expr_stmt|;
if|if
condition|(
name|send_out_req
condition|)
block|{
name|sctp_add_stream_reset_out
argument_list|(
name|chk
argument_list|,
name|number_entries
argument_list|,
name|list
argument_list|,
name|seq
argument_list|,
name|resp_seq
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_out_is_outstanding
operator|=
literal|1
expr_stmt|;
name|seq
operator|++
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|send_in_req
condition|)
block|{
name|sctp_add_stream_reset_in
argument_list|(
name|chk
argument_list|,
name|number_entries
argument_list|,
name|list
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|send_tsn_req
condition|)
block|{
name|sctp_add_stream_reset_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
name|asoc
operator|->
name|str_reset
operator|=
name|chk
expr_stmt|;
comment|/* insert the chunk for sending */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_send_abort
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|struct
name|mbuf
modifier|*
name|err_cause
parameter_list|)
block|{
comment|/*- 	 * Formulate the abort message, and send it back down. 	 */
name|struct
name|mbuf
modifier|*
name|o_pak
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mout
decl_stmt|;
name|struct
name|sctp_abort_msg
modifier|*
name|abm
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|,
modifier|*
name|iph_out
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|,
modifier|*
name|ip6_out
decl_stmt|;
name|int
name|iphlen_out
decl_stmt|;
comment|/* don't respond to ABORT with ABORT */
if|if
condition|(
name|sctp_is_there_an_abort_here
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|&
name|vtag
argument_list|)
condition|)
block|{
if|if
condition|(
name|err_cause
condition|)
name|sctp_m_freem
argument_list|(
name|err_cause
argument_list|)
expr_stmt|;
return|return;
block|}
name|o_pak
operator|=
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_msg
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_pak
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|err_cause
condition|)
name|sctp_m_freem
argument_list|(
name|err_cause
argument_list|)
expr_stmt|;
return|return;
block|}
name|mout
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|iph_out
operator|=
name|NULL
expr_stmt|;
name|ip6_out
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
name|iph_out
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|iph_out
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|abm
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|mout
argument_list|)
operator|=
name|err_cause
expr_stmt|;
comment|/* Fill in the IP header for the ABORT */
name|iph_out
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|iph_out
operator|->
name|ip_hl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|/
literal|4
operator|)
expr_stmt|;
name|iph_out
operator|->
name|ip_tos
operator|=
operator|(
name|u_char
operator|)
literal|0
expr_stmt|;
name|iph_out
operator|->
name|ip_id
operator|=
literal|0
expr_stmt|;
name|iph_out
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|iph_out
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
name|iph_out
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|iph_out
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|iph_out
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
comment|/* let IP layer calculate this */
name|iph_out
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|iphlen_out
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|iph_out
argument_list|)
expr_stmt|;
name|abm
operator|=
operator|(
expr|struct
name|sctp_abort_msg
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|iph_out
operator|+
name|iphlen_out
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|iph
expr_stmt|;
name|ip6_out
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6_out
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|abm
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|mout
argument_list|)
operator|=
name|err_cause
expr_stmt|;
comment|/* Fill in the IP6 header for the ABORT */
name|ip6_out
operator|->
name|ip6_flow
operator|=
name|ip6
operator|->
name|ip6_flow
expr_stmt|;
name|ip6_out
operator|->
name|ip6_hlim
operator|=
name|ip6_defhlim
expr_stmt|;
name|ip6_out
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|ip6_out
operator|->
name|ip6_src
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|ip6_out
operator|->
name|ip6_dst
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|iphlen_out
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ip6_out
argument_list|)
expr_stmt|;
name|abm
operator|=
operator|(
expr|struct
name|sctp_abort_msg
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6_out
operator|+
name|iphlen_out
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Currently not supported */
return|return;
block|}
name|abm
operator|->
name|sh
operator|.
name|src_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|abm
operator|->
name|sh
operator|.
name|dest_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|abm
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vtag
operator|==
literal|0
condition|)
block|{
name|abm
operator|->
name|sh
operator|.
name|v_tag
operator|=
name|sh
operator|->
name|v_tag
expr_stmt|;
name|abm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
name|SCTP_HAD_NO_TCB
expr_stmt|;
block|}
else|else
block|{
name|abm
operator|->
name|sh
operator|.
name|v_tag
operator|=
name|htonl
argument_list|(
name|vtag
argument_list|)
expr_stmt|;
name|abm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
block|}
name|abm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ABORT_ASSOCIATION
expr_stmt|;
if|if
condition|(
name|err_cause
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_tmp
init|=
name|err_cause
decl_stmt|;
name|int
name|err_len
init|=
literal|0
decl_stmt|;
comment|/* get length of the err_cause chain */
while|while
condition|(
name|m_tmp
operator|!=
name|NULL
condition|)
block|{
name|err_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
operator|+
name|err_len
expr_stmt|;
if|if
condition|(
name|err_len
operator|%
literal|4
condition|)
block|{
comment|/* need pad at end of chunk */
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|int
name|padlen
decl_stmt|;
name|padlen
operator|=
literal|4
operator|-
operator|(
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|mout
argument_list|,
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
argument_list|,
name|padlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
operator|+=
name|padlen
expr_stmt|;
block|}
name|abm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|abm
operator|->
name|msg
operator|.
name|ch
argument_list|)
operator|+
name|err_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_HEADER_LEN
argument_list|(
name|mout
argument_list|)
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
expr_stmt|;
name|abm
operator|->
name|msg
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|abm
operator|->
name|msg
operator|.
name|ch
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* add checksum */
if|if
condition|(
operator|(
name|sctp_no_csum_on_loopback
operator|)
operator|&&
name|SCTP_IS_IT_LOOPBACK
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|abm
operator|->
name|sh
operator|.
name|checksum
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|abm
operator|->
name|sh
operator|.
name|checksum
operator|=
name|sctp_calculate_sum
argument_list|(
name|mout
argument_list|,
name|NULL
argument_list|,
name|iphlen_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|iph_out
operator|!=
name|NULL
condition|)
block|{
name|sctp_route_t
name|ro
decl_stmt|;
comment|/* zap the stack pointer to the route */
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
name|ro
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_send_abort calling ip_output:\n"
argument_list|)
expr_stmt|;
name|sctp_print_address_pkt
argument_list|(
name|iph_out
argument_list|,
operator|&
name|abm
operator|->
name|sh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* set IPv4 length */
name|iph_out
operator|->
name|ip_len
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
comment|/* out it goes */
operator|(
name|void
operator|)
name|ip_output
argument_list|(
name|o_pak
argument_list|,
literal|0
argument_list|,
operator|&
name|ro
argument_list|,
name|IP_RAWOUTPUT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Free the route if we got one back */
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ip6_out
operator|!=
name|NULL
condition|)
block|{
name|struct
name|route_in6
name|ro
decl_stmt|;
comment|/* zap the stack pointer to the route */
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
name|ro
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_send_abort calling ip6_output:\n"
argument_list|)
expr_stmt|;
name|sctp_print_address_pkt
argument_list|(
operator|(
expr|struct
name|ip
operator|*
operator|)
name|ip6_out
argument_list|,
operator|&
name|abm
operator|->
name|sh
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ip6_out
operator|->
name|ip6_plen
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ip6_out
argument_list|)
expr_stmt|;
name|ip6_output
argument_list|(
name|o_pak
argument_list|,
name|NULL
argument_list|,
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Free the route if we got one back */
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_operr_to
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|struct
name|mbuf
modifier|*
name|scm
parameter_list|,
name|uint32_t
name|vtag
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|o_pak
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|ihdr
decl_stmt|;
name|int
name|retcode
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|ohdr
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ophdr
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|struct
name|sockaddr_in6
name|lsa6
decl_stmt|,
name|fsa6
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|val
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|at
decl_stmt|;
name|int
name|len
decl_stmt|;
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ihdr
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|iph
operator|+
name|iphlen
operator|)
expr_stmt|;
name|SCTP_BUF_PREPEND
argument_list|(
name|scm
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scm
operator|==
name|NULL
condition|)
block|{
comment|/* can't send because we can't add a mbuf */
return|return;
block|}
name|ohdr
operator|=
name|mtod
argument_list|(
name|scm
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
name|ohdr
operator|->
name|src_port
operator|=
name|ihdr
operator|->
name|dest_port
expr_stmt|;
name|ohdr
operator|->
name|dest_port
operator|=
name|ihdr
operator|->
name|src_port
expr_stmt|;
name|ohdr
operator|->
name|v_tag
operator|=
name|vtag
expr_stmt|;
name|ohdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|ophdr
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
name|ohdr
operator|+
literal|1
operator|)
expr_stmt|;
name|ophdr
operator|->
name|chunk_type
operator|=
name|SCTP_OPERATION_ERROR
expr_stmt|;
name|ophdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|at
operator|=
name|scm
expr_stmt|;
while|while
condition|(
name|at
condition|)
block|{
name|len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
name|ophdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|%
literal|4
condition|)
block|{
comment|/* need padding */
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|int
name|padlen
decl_stmt|;
name|padlen
operator|=
literal|4
operator|-
operator|(
name|len
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|scm
argument_list|,
name|len
argument_list|,
name|padlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|len
operator|+=
name|padlen
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sctp_no_csum_on_loopback
operator|)
operator|&&
name|SCTP_IS_IT_LOOPBACK
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|val
operator|=
name|sctp_calculate_sum
argument_list|(
name|scm
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ohdr
operator|->
name|checksum
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* V4 */
name|struct
name|ip
modifier|*
name|out
decl_stmt|;
name|sctp_route_t
name|ro
decl_stmt|;
name|o_pak
operator|=
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_pak
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|scm
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|scm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
name|ro
argument_list|)
expr_stmt|;
name|out
operator|=
name|mtod
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|out
operator|->
name|ip_v
operator|=
name|iph
operator|->
name|ip_v
expr_stmt|;
name|out
operator|->
name|ip_hl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|/
literal|4
operator|)
expr_stmt|;
name|out
operator|->
name|ip_tos
operator|=
name|iph
operator|->
name|ip_tos
expr_stmt|;
name|out
operator|->
name|ip_id
operator|=
name|iph
operator|->
name|ip_id
expr_stmt|;
name|out
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|ip_ttl
operator|=
name|MAXTTL
expr_stmt|;
name|out
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|out
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|out
operator|->
name|ip_src
operator|=
name|iph
operator|->
name|ip_dst
expr_stmt|;
name|out
operator|->
name|ip_dst
operator|=
name|iph
operator|->
name|ip_src
expr_stmt|;
name|out
operator|->
name|ip_len
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|ip_output
argument_list|(
name|o_pak
argument_list|,
literal|0
argument_list|,
operator|&
name|ro
argument_list|,
name|IP_RAWOUTPUT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
comment|/* Free the route if we got one back */
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* V6 */
name|struct
name|route_in6
name|ro
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|out6
decl_stmt|,
modifier|*
name|in6
decl_stmt|;
name|o_pak
operator|=
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|o_pak
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|scm
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|scm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ro
argument_list|,
sizeof|sizeof
name|ro
argument_list|)
expr_stmt|;
name|in6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|out6
operator|=
name|mtod
argument_list|(
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|o_pak
argument_list|)
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|out6
operator|->
name|ip6_flow
operator|=
name|in6
operator|->
name|ip6_flow
expr_stmt|;
name|out6
operator|->
name|ip6_hlim
operator|=
name|ip6_defhlim
expr_stmt|;
name|out6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_SCTP
expr_stmt|;
name|out6
operator|->
name|ip6_src
operator|=
name|in6
operator|->
name|ip6_dst
expr_stmt|;
name|out6
operator|->
name|ip6_dst
operator|=
name|in6
operator|->
name|ip6_src
expr_stmt|;
name|out6
operator|->
name|ip6_plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|bzero
argument_list|(
operator|&
name|lsa6
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa6
argument_list|)
argument_list|)
expr_stmt|;
name|lsa6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa6
argument_list|)
expr_stmt|;
name|lsa6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|lsa6
operator|.
name|sin6_addr
operator|=
name|out6
operator|->
name|ip6_src
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|fsa6
argument_list|,
sizeof|sizeof
argument_list|(
name|fsa6
argument_list|)
argument_list|)
expr_stmt|;
name|fsa6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|fsa6
argument_list|)
expr_stmt|;
name|fsa6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|fsa6
operator|.
name|sin6_addr
operator|=
name|out6
operator|->
name|ip6_dst
expr_stmt|;
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_operr_to calling ipv6 output:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"src: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|lsa6
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"dst "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|fsa6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|ip6_output
argument_list|(
name|o_pak
argument_list|,
name|NULL
argument_list|,
operator|&
name|ro
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
comment|/* Free the route if we got one back */
if|if
condition|(
name|ro
operator|.
name|ro_rt
condition|)
name|RTFREE
argument_list|(
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_copy_resume
parameter_list|(
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|int
name|max_send_len
parameter_list|,
name|int
name|user_marks_eor
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|uint32_t
modifier|*
name|sndout
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|new_tail
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|max_send_len
argument_list|,
literal|0
argument_list|,
operator|(
name|M_PKTHDR
operator||
operator|(
name|user_marks_eor
condition|?
name|M_EOR
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
operator|*
name|error
operator|=
name|ENOMEM
expr_stmt|;
else|else
operator|*
name|sndout
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|new_tail
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_copy_one
parameter_list|(
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|resv_upfront
parameter_list|)
block|{
name|int
name|left
decl_stmt|;
name|left
operator|=
name|sp
operator|->
name|length
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|resv_upfront
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|m_last
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sctp_copy_it_in
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|max_send_len
parameter_list|,
name|int
name|user_marks_eor
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|int
name|non_blocking
parameter_list|)
block|{
comment|/*- 	 * This routine must be very careful in its work. Protocol 	 * processing is up and running so care must be taken to spl...() 	 * when you need to do something that may effect the stcb/asoc. The 	 * sb is locked however. When data is copied the protocol processing 	 * should be enabled since this is a slower operation... 	 */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
name|int
name|resv_in_first
decl_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Unless E_EOR mode is on, we must make a send FIT in one call. */
if|if
condition|(
operator|(
operator|(
name|user_marks_eor
operator|==
literal|0
operator|)
operator|&&
name|non_blocking
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|>
name|SCTP_SB_LIMIT_SND
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
operator|)
condition|)
block|{
comment|/* It will NEVER fit */
operator|*
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
comment|/* Now can we send this? */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
comment|/* got data while shutting down */
operator|*
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sctp_alloc_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
operator|*
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sp
operator|->
name|act_flags
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sender_all_done
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sinfo_flags
operator|=
name|srcv
operator|->
name|sinfo_flags
expr_stmt|;
name|sp
operator|->
name|timetolive
operator|=
name|srcv
operator|->
name|sinfo_timetolive
expr_stmt|;
name|sp
operator|->
name|ppid
operator|=
name|srcv
operator|->
name|sinfo_ppid
expr_stmt|;
name|sp
operator|->
name|context
operator|=
name|srcv
operator|->
name|sinfo_context
expr_stmt|;
name|sp
operator|->
name|strseq
operator|=
literal|0
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
name|sp
operator|->
name|length
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|max_send_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
name|uio
operator|->
name|uio_resid
operator|)
operator|&&
operator|(
operator|(
name|user_marks_eor
operator|==
literal|0
operator|)
operator|||
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|||
operator|(
name|user_marks_eor
operator|&&
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOR
operator|)
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|sender_all_done
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|put_last_out
operator|=
literal|0
expr_stmt|;
name|resv_in_first
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
operator|*
name|error
operator|=
name|sctp_copy_one
argument_list|(
name|sp
argument_list|,
name|uio
argument_list|,
name|resv_in_first
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|error
condition|)
block|{
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
condition|)
block|{
name|sp
operator|->
name|net
operator|=
name|net
expr_stmt|;
name|sp
operator|->
name|addr_over
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|net
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
name|sp
operator|->
name|addr_over
operator|=
literal|0
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_set_prsctp_policy
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
block|}
name|out_now
label|:
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|use_rcvinfo
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_sndrcvinfo
name|srcv
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
comment|/* process cmsg snd/rcv info (maybe a assoc-id) */
if|if
condition|(
name|sctp_find_cmsg
argument_list|(
name|SCTP_SNDRCV
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|srcv
argument_list|,
name|control
argument_list|,
sizeof|sizeof
argument_list|(
name|srcv
argument_list|)
argument_list|)
condition|)
block|{
comment|/* got one */
name|use_rcvinfo
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|error
operator|=
name|sctp_lower_sosend
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|use_rcvinfo
argument_list|,
operator|&
name|srcv
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_lower_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|i_pak
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|use_rcvinfo
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|sndlen
decl_stmt|,
name|max_len
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__OpenBSD_
argument_list|)
name|int
name|s
decl_stmt|;
endif|#
directive|endif
name|int
name|queue_only
init|=
literal|0
decl_stmt|,
name|queue_only_for_init
init|=
literal|0
decl_stmt|;
name|int
name|free_cnt_applied
init|=
literal|0
decl_stmt|;
name|int
name|un_sent
init|=
literal|0
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_block_entry
name|be
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|t_inp
decl_stmt|;
name|int
name|create_lock_applied
init|=
literal|0
decl_stmt|;
name|int
name|nagle_applies
init|=
literal|0
decl_stmt|;
name|int
name|some_on_control
init|=
literal|0
decl_stmt|;
name|int
name|got_all_of_the_send
init|=
literal|0
decl_stmt|;
name|int
name|hold_tcblock
init|=
literal|0
decl_stmt|;
name|int
name|non_blocking
init|=
literal|0
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|=
name|NULL
expr_stmt|;
name|t_inp
operator|=
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|inp
operator|->
name|total_sends
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
condition|)
name|sndlen
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
else|else
block|{
name|sndlen
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
name|top
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
block|}
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* The listener can NOT send */
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
name|use_rcvinfo
operator|)
operator|&&
name|srcv
condition|)
block|{
if|if
condition|(
name|INVALID_SINFO_FLAG
argument_list|(
name|srcv
operator|->
name|sinfo_flags
argument_list|)
operator|||
name|PR_SCTP_INVALID_POLICY
argument_list|(
name|srcv
operator|->
name|sinfo_flags
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_SENDALL
condition|)
block|{
comment|/* its a sendall */
name|error
operator|=
name|sctp_sendall
argument_list|(
name|inp
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|srcv
argument_list|)
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
comment|/* now we must find the assoc */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
comment|/* Must locate the net structure if addr given */
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|use_rcvinfo
operator|&&
name|srcv
operator|&&
name|srcv
operator|->
name|sinfo_assoc_id
condition|)
block|{
name|stcb
operator|=
name|sctp_findassociation_ep_asocid
argument_list|(
name|inp
argument_list|,
name|srcv
operator|->
name|sinfo_assoc_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|addr
condition|)
comment|/* 				 * Must locate the net structure if addr 				 * given 				 */
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
condition|)
block|{
comment|/*- 		 * Since we did not use findep we must 		 * increment it, and if we don't find a tcb 		 * decrement it. 		 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|t_inp
argument_list|,
name|addr
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|addr
operator|)
condition|)
block|{
comment|/* Possible implicit send? */
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
comment|/* Should I really unlock ? */
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* With the lock applied look again */
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|t_inp
argument_list|,
name|addr
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
else|else
block|{
comment|/* 			 * UDP style, we must go ahead and start the INIT 			 * process 			 */
name|uint32_t
name|vrf_id
decl_stmt|;
if|if
condition|(
operator|(
name|use_rcvinfo
operator|)
operator|&&
operator|(
name|srcv
operator|)
operator|&&
operator|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ABORT
operator|)
operator|||
operator|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*- 				 * User asks to abort a non-existant assoc, 				 * or EOF a non-existant assoc with no data 				 */
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* get an asoc/stcb struct */
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Error is setup for us in the call */
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|create_lock_applied
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Huh-3? create lock should have been on??\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Turn on queue only flag to prevent data from 			 * being sent 			 */
name|queue_only
operator|=
literal|1
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
comment|/* initialize authentication params for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
comment|/* 				 * see if a init structure exists in cmsg 				 * headers 				 */
name|struct
name|sctp_initmsg
name|initm
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sctp_find_cmsg
argument_list|(
name|SCTP_INIT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|initm
argument_list|,
name|control
argument_list|,
sizeof|sizeof
argument_list|(
name|initm
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 					 * we have an INIT override of the 					 * default 					 */
if|if
condition|(
name|initm
operator|.
name|sinit_max_attempts
condition|)
name|asoc
operator|->
name|max_init_times
operator|=
name|initm
operator|.
name|sinit_max_attempts
expr_stmt|;
if|if
condition|(
name|initm
operator|.
name|sinit_num_ostreams
condition|)
name|asoc
operator|->
name|pre_open_streams
operator|=
name|initm
operator|.
name|sinit_num_ostreams
expr_stmt|;
if|if
condition|(
name|initm
operator|.
name|sinit_max_instreams
condition|)
name|asoc
operator|->
name|max_inbound_streams
operator|=
name|initm
operator|.
name|sinit_max_instreams
expr_stmt|;
if|if
condition|(
name|initm
operator|.
name|sinit_max_init_timeo
condition|)
name|asoc
operator|->
name|initial_init_rto_max
operator|=
name|initm
operator|.
name|sinit_max_init_timeo
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|streamoutcnt
operator|<
name|asoc
operator|->
name|pre_open_streams
condition|)
block|{
comment|/* Default is NOT correct */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Ok, defout:%d pre_open:%d\n"
argument_list|,
name|asoc
operator|->
name|streamoutcnt
argument_list|,
name|asoc
operator|->
name|pre_open_streams
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|->
name|streamoutcnt
operator|=
name|asoc
operator|->
name|pre_open_streams
expr_stmt|;
comment|/* 						 * What happens if this 						 * fails? .. we panic ... 						 */
block|{
name|struct
name|sctp_stream_out
modifier|*
name|tmp_str
decl_stmt|;
name|int
name|had_lock
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|had_lock
operator|=
literal|1
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_MALLOC
argument_list|(
name|tmp_str
argument_list|,
expr|struct
name|sctp_stream_out
operator|*
argument_list|,
name|asoc
operator|->
name|streamoutcnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_out
argument_list|)
argument_list|,
literal|"StreamsOut"
argument_list|)
expr_stmt|;
if|if
condition|(
name|had_lock
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|strmout
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|strmout
operator|=
name|tmp_str
expr_stmt|;
block|}
else|else
block|{
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmout
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
operator|=
name|tmp_str
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/*- 							 * inbound side must be set 							 * to 0xffff, also NOTE when 							 * we get the INIT-ACK back 							 * (for INIT sender) we MUST 							 * reduce the count 							 * (streamoutcnt) but first 							 * check if we sent to any 							 * of the upper streams that 							 * were dropped (if some 							 * were). Those that were 							 * dropped must be notified 							 * to the upper layer as 							 * failed to send. 							 */
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_sent
operator|=
literal|0x0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|next_spoke
operator|.
name|tqe_next
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|next_spoke
operator|.
name|tqe_prev
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
comment|/* out with the INIT */
name|queue_only_for_init
operator|=
literal|1
expr_stmt|;
comment|/*- 			 * we may want to dig in after this call and adjust the MTU 			 * value. It defaulted to 1500 (constant) but the ro 			 * structure may now have an update and thus we may need to 			 * change it BEFORE we append the message. 			 */
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|SCTP_SO_IS_NBIO
argument_list|(
name|so
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|MSG_NBIO
operator|)
operator|)
condition|)
block|{
name|non_blocking
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NO_FRAGMENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|sndlen
operator|>
name|asoc
operator|->
name|smallest_mtu
condition|)
block|{
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
comment|/* would we block? */
if|if
condition|(
name|non_blocking
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<
operator|(
name|sndlen
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|>
name|sctp_max_chunks_on_queue
operator|)
condition|)
block|{
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|total_nospaces
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
comment|/* Keep the stcb from being freed under our feet */
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_cnt_applied
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|create_lock_applied
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
block|{
comment|/* 		 * Can't queue any data while stream reset is underway. 		 */
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|use_rcvinfo
operator|==
literal|0
operator|)
operator|||
operator|(
name|srcv
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Grab the default stuff from the asoc */
name|srcv
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|def_send
expr_stmt|;
block|}
comment|/* we are now done with all control */
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|use_rcvinfo
operator|)
operator|&&
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ABORT
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
comment|/* Ok, we will attempt a msgsnd :> */
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|td_proc
operator|->
name|p_stats
operator|->
name|p_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|net
operator|&&
operator|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
operator|)
operator|)
condition|)
block|{
comment|/* we take the override or the unconfirmed */
empty_stmt|;
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|>
name|net
operator|->
name|cwnd
operator|)
operator|&&
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 		 * CMT: Added check for CMT above. net above is the primary 		 * dest. If CMT is ON, sender should always attempt to send 		 * with the output routine sctp_fill_outqueue() that loops 		 * through all destination addresses. Therefore, if CMT is 		 * ON, queue_only is NOT set to 1 here, so that 		 * sctp_chunk_output() can be called below. 		 */
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|ifp_had_enobuf
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
name|queue_only
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
comment|/* Are we aborting? */
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ABORT
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|int
name|tot_demand
decl_stmt|,
name|tot_out
decl_stmt|,
name|max
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_abort
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
comment|/* It has to be up before we abort */
comment|/* how big is the user initiated abort? */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|top
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|cntm
decl_stmt|;
name|mm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|M_WAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tot_out
operator|=
literal|0
expr_stmt|;
name|cntm
operator|=
name|top
expr_stmt|;
while|while
condition|(
name|cntm
condition|)
block|{
name|tot_out
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|cntm
argument_list|)
expr_stmt|;
name|cntm
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|cntm
argument_list|)
expr_stmt|;
block|}
name|tot_demand
operator|=
operator|(
name|tot_out
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Must fit in a MTU */
name|tot_out
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|tot_demand
operator|=
operator|(
name|tot_out
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
name|mm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|tot_demand
argument_list|,
literal|0
argument_list|,
name|M_WAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|max
operator|=
name|asoc
operator|->
name|smallest_mtu
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|max
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tot_out
operator|>
name|max
condition|)
block|{
name|tot_out
operator|=
name|max
expr_stmt|;
block|}
if|if
condition|(
name|mm
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
comment|/* now move forward the data pointer */
name|ph
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
name|tot_out
operator|)
argument_list|)
expr_stmt|;
name|ph
operator|++
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mm
argument_list|)
operator|=
name|tot_out
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|ph
argument_list|,
operator|(
name|int
operator|)
name|tot_out
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/*- 					 * Here if we can't get his data we 					 * still abort we just don't get to 					 * send the users note :-0 					 */
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
name|mm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|mm
argument_list|)
operator|=
name|top
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free_cnt_applied
operator|=
literal|0
expr_stmt|;
comment|/* release this lock, otherwise we hang on ourselves */
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|mm
argument_list|)
expr_stmt|;
comment|/* now relock the stcb so everything is sane */
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* Calculate the maximum we can send */
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
condition|)
block|{
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
block|}
else|else
block|{
name|max_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is the stream no. valid? */
if|if
condition|(
name|srcv
operator|->
name|sinfo_stream
operator|>=
name|asoc
operator|->
name|streamoutcnt
condition|)
block|{
comment|/* Invalid stream number */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|asoc
operator|->
name|strmout
operator|==
name|NULL
condition|)
block|{
comment|/* huh? software error */
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_len
operator|<
name|sctp_add_more_threshold
condition|)
block|{
comment|/* No room right no ! */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
while|while
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|+
name|sctp_add_more_threshold
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_BLK_LOGGING
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_INTO_BLKA
argument_list|,
name|so
argument_list|,
name|asoc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|be
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
operator|&
name|be
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|so
operator|->
name|so_error
operator|||
name|be
operator|.
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
name|be
operator|.
name|error
condition|)
block|{
name|error
operator|=
name|be
operator|.
name|error
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
ifdef|#
directive|ifdef
name|SCTP_BLK_LOGGING
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_OUTOF_BLK
argument_list|,
name|so
argument_list|,
name|asoc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
block|}
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
condition|)
block|{
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
block|}
else|else
block|{
name|max_len
operator|=
literal|0
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|total_sends
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|struct
name|sctp_stream_queue_pending
modifier|*
name|msp
decl_stmt|;
endif|#
directive|endif
name|struct
name|sctp_stream_out
modifier|*
name|strm
decl_stmt|;
name|uint32_t
name|sndout
decl_stmt|,
name|initial_out
decl_stmt|;
name|int
name|user_marks_eor
decl_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
condition|)
block|{
name|got_all_of_the_send
operator|=
literal|1
expr_stmt|;
goto|goto
name|dataless_eof
goto|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|initial_out
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_locked
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_locked_on
operator|!=
name|srcv
operator|->
name|sinfo_stream
operator|)
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|strm
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|srcv
operator|->
name|sinfo_stream
index|]
expr_stmt|;
name|user_marks_eor
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|last_msg_incomplete
operator|==
literal|0
condition|)
block|{
name|do_a_copy_in
label|:
name|sp
operator|=
name|sctp_copy_it_in
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|srcv
argument_list|,
name|uio
argument_list|,
name|net
argument_list|,
name|max_len
argument_list|,
name|user_marks_eor
argument_list|,
operator|&
name|error
argument_list|,
name|non_blocking
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|error
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|msp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|msp
operator|&&
operator|(
name|msp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|panic
argument_list|(
literal|"Huh, new mesg and old not done?"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Just got locked to this guy in case of an 				 * interupt. 				 */
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked_on
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
name|sp
operator|->
name|sender_all_done
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|sp
operator|->
name|strseq
operator|=
name|strm
operator|->
name|next_sequence_sent
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_SENDING_STR
name|sctp_misc_ints
argument_list|(
name|SCTP_STRMOUT_LOG_ASSIGN
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
operator|(
name|uintptr_t
operator|)
name|sp
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|srcv
operator|->
name|sinfo_stream
operator|<<
literal|16
operator|)
operator||
name|sp
operator|->
name|strseq
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strm
operator|->
name|next_sequence_sent
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_unord
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|strm
operator|->
name|next_spoke
operator|.
name|tqe_next
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|strm
operator|->
name|next_spoke
operator|.
name|tqe_prev
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* Not on wheel, insert */
name|sctp_insert_on_wheel
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* ???? Huh ??? last msg is gone */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Warning: Last msg marked incomplete, yet nothing left?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Warning: Last msg marked incomplete, yet nothing left?\n"
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
goto|goto
name|do_a_copy_in
goto|;
block|}
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* How much room do we have? */
name|struct
name|mbuf
modifier|*
name|new_tail
decl_stmt|,
modifier|*
name|mm
decl_stmt|;
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
condition|)
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
else|else
name|max_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|max_len
operator|>
name|sctp_add_more_threshold
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_resid
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|<
name|max_len
operator|)
operator|)
condition|)
block|{
name|sndout
operator|=
literal|0
expr_stmt|;
name|new_tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
name|mm
operator|=
name|sctp_copy_resume
argument_list|(
name|sp
argument_list|,
name|uio
argument_list|,
name|srcv
argument_list|,
name|max_len
argument_list|,
name|user_marks_eor
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|sndout
argument_list|,
operator|&
name|new_tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mm
operator|==
name|NULL
operator|)
operator|||
name|error
condition|)
block|{
if|if
condition|(
name|mm
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* Update the mbuf and count */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* 					 * we need to get out. Peer probably 					 * aborted. 					 */
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_PCB_FLAGS_WAS_ABORTED
condition|)
name|error
operator|=
name|ECONNRESET
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sp
operator|->
name|tail_mbuf
condition|)
block|{
comment|/* tack it to the end */
name|SCTP_BUF_NEXT
argument_list|(
name|sp
operator|->
name|tail_mbuf
argument_list|)
operator|=
name|mm
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|new_tail
expr_stmt|;
block|}
else|else
block|{
comment|/* A stolen mbuf */
name|sp
operator|->
name|data
operator|=
name|mm
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|new_tail
expr_stmt|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
name|sndout
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|length
argument_list|,
name|sndout
argument_list|)
expr_stmt|;
name|len
operator|+=
name|sndout
expr_stmt|;
comment|/* Did we reach EOR? */
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|user_marks_eor
operator|==
literal|0
operator|)
operator|||
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|||
operator|(
name|user_marks_eor
operator|&&
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOR
operator|)
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
comment|/* got it all? */
continue|continue;
block|}
comment|/* PR-SCTP? */
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_prsctp
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 				 * This is ugly but we must assure locking 				 * order 				 */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_prune_prsctp
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|srcv
argument_list|,
name|sndlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
condition|)
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
else|else
name|max_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_len
operator|>
literal|0
condition|)
block|{
continue|continue;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* wait for space now */
if|if
condition|(
name|non_blocking
condition|)
block|{
comment|/* Non-blocking io in place out */
goto|goto
name|skip_out_eof
goto|;
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|>
name|net
operator|->
name|cwnd
operator|)
operator|&&
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|ifp_had_enobuf
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
condition|)
block|{
comment|/*- 				 * Ok, Nagle is set on and we have data outstanding. 				 * Don't send anything and let SACKs drive out the 				 * data unless wen have a "full" segment to send. 				 */
ifdef|#
directive|ifdef
name|SCTP_NAGLE_LOGGING
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_APPLIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglequeued
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_NAGLE_LOGGING
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
condition|)
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_SKIPPED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglesent
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|0
expr_stmt|;
block|}
comment|/* What about the INIT, send it maybe */
ifdef|#
directive|ifdef
name|SCTP_BLK_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_CWNDLOG_PRESEND
argument_list|,
name|queue_only_for_init
argument_list|,
name|queue_only
argument_list|,
name|nagle_applies
argument_list|,
name|un_sent
argument_list|)
expr_stmt|;
name|sctp_misc_ints
argument_list|(
name|SCTP_CWNDLOG_PRESEND
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|queue_only_for_init
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
comment|/* a collision took us forward? */
name|queue_only_for_init
operator|=
literal|0
expr_stmt|;
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|queue_only_for_init
operator|=
literal|0
expr_stmt|;
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|queue_only
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nagle_applies
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 				 * need to start chunk output 				 * before blocking.. note that if 				 * a lock is already applied, then 				 * the input via the net is happening 				 * and I don't need to start output :-D 				 */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_TCB_TRYLOCK
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hold_tcblock
operator|==
literal|1
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/*- 			 * This is a bit strange, but I think it will 			 * work. The total_output_queue_size is locked and 			 * protected by the TCB_LOCK, which we just released. 			 * There is a race that can occur between releasing it 			 * above, and me getting the socket lock, where sacks 			 * come in but we have not put the SB_WAIT on the 			 * so_snd buffer to get the wakeup. After the LOCK 			 * is applied the sack_processing will also need to 			 * LOCK the so->so_snd to do the actual sowwakeup(). So 			 * once we have the socket buffer lock if we recheck the 			 * size we KNOW we will get to sleep safely with the 			 * wakeup flag in place. 			 */
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|+
name|sctp_add_more_threshold
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_BLK_LOGGING
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_INTO_BLK
argument_list|,
name|so
argument_list|,
name|asoc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|be
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
operator|&
name|be
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|so
operator|->
name|so_error
operator|||
name|be
operator|.
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
name|be
operator|.
name|error
condition|)
block|{
name|error
operator|=
name|be
operator|.
name|error
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
ifdef|#
directive|ifdef
name|SCTP_BLK_LOGGING
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_OUTOF_BLK
argument_list|,
name|so
argument_list|,
name|asoc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked_on
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|sender_all_done
operator|=
literal|1
expr_stmt|;
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Huh no sp TSNH?\n"
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|got_all_of_the_send
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|top
condition|)
block|{
comment|/* We send in a 0, since we do NOT have any locks */
name|error
operator|=
name|sctp_msg_append
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|top
argument_list|,
name|srcv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|dataless_eof
label|:
comment|/* EOF thing ? */
if|if
condition|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|&&
operator|(
name|got_all_of_the_send
operator|==
literal|1
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_eof
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
comment|/* there is nothing queued to send, so I'm done... */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* only send SHUTDOWN the first time through */
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*- 			 * we still got (or just got) data to send, so set 			 * SHUTDOWN_PENDING 			 */
comment|/*- 			 * XXX sockets draft says that SCTP_EOF should be 			 * sent with no data.  currently, we will allow user 			 * data to be sent first and move to 			 * SHUTDOWN-PENDING 			 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* Locked to send out the data */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|abort_anyway
label|:
if|if
condition|(
name|free_cnt_applied
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free_cnt_applied
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 					 * now relock the stcb so everything 					 * is sane 					 */
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|skip_out_eof
label|:
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
condition|)
block|{
name|some_on_control
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|>
name|net
operator|->
name|cwnd
operator|)
operator|&&
operator|(
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|ifp_had_enobuf
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>
operator|(
name|net
operator|->
name|mtu
operator|*
literal|2
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
condition|)
block|{
comment|/*- 		 * Ok, Nagle is set on and we have data outstanding. 		 * Don't send anything and let SACKs drive out the 		 * data unless wen have a "full" segment to send. 		 */
ifdef|#
directive|ifdef
name|SCTP_NAGLE_LOGGING
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_APPLIED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglequeued
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_NAGLE_LOGGING
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
condition|)
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_SKIPPED
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglesent
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|queue_only_for_init
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
comment|/* a collision took us forward? */
name|queue_only_for_init
operator|=
literal|0
expr_stmt|;
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
else|else
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|queue_only_for_init
operator|=
literal|0
expr_stmt|;
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|queue_only
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nagle_applies
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|&&
name|un_sent
operator|)
condition|)
block|{
comment|/* we can attempt to send too. */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If there is activity recv'ing sacks no need to 			 * send 			 */
if|if
condition|(
name|SCTP_TCB_TRYLOCK
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|queue_only
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We get to have a probe outstanding */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|some_on_control
condition|)
block|{
name|int
name|num_out
decl_stmt|,
name|reason
decl_stmt|,
name|cwnd_full
decl_stmt|,
name|frag_point
decl_stmt|;
comment|/* Here we do control only */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|frag_point
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason
argument_list|,
literal|1
argument_list|,
operator|&
name|cwnd_full
argument_list|,
literal|1
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"USR Send complete qo:%d prw:%d unsent:%d tf:%d cooq:%d toqs:%d \n"
argument_list|,
name|queue_only
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|un_sent
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|out
label|:
name|out_unlocked
label|:
if|if
condition|(
name|create_lock_applied
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|&&
name|free_cnt_applied
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|stcb
operator|->
name|tcb_mtx
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Leaving with tcb mtx owned?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|stcb
operator|->
name|tcb_send_mtx
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Leaving with tcb send mtx owned?"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|top
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate an AUTHentication chunk, if required  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_add_auth_chunk
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_end
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
modifier|*
name|auth_ret
parameter_list|,
name|uint32_t
modifier|*
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint8_t
name|chunk
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_auth
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
decl_stmt|;
name|int
name|chunk_len
decl_stmt|;
if|if
condition|(
operator|(
name|m_end
operator|==
name|NULL
operator|)
operator|||
operator|(
name|auth_ret
operator|==
name|NULL
operator|)
operator|||
operator|(
name|offset
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|m
operator|)
return|;
comment|/* sysctl disabled auth? */
if|if
condition|(
name|sctp_auth_disable
condition|)
return|return
operator|(
name|m
operator|)
return|;
comment|/* peer doesn't do auth... */
if|if
condition|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
condition|)
block|{
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* does the requested chunk require auth? */
if|if
condition|(
operator|!
name|sctp_auth_is_required_chunk
argument_list|(
name|chunk
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
return|return
operator|(
name|m
operator|)
return|;
block|}
name|m_auth
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_auth
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* reserve some space if this will be the first mbuf */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_auth
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
comment|/* fill in the AUTH chunk details */
name|auth
operator|=
name|mtod
argument_list|(
name|m_auth
argument_list|,
expr|struct
name|sctp_auth_chunk
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|auth
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
name|auth
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_AUTHENTICATION
expr_stmt|;
name|auth
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|chunk_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
operator|+
name|sctp_get_hmac_digest_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
name|auth
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chunk_len
argument_list|)
expr_stmt|;
name|auth
operator|->
name|hmac_id
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
comment|/* key id and hmac digest will be computed and filled in upon send */
comment|/* save the offset where the auth was inserted into the chain */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|cn
decl_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|cn
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|cn
condition|)
block|{
operator|*
name|offset
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|cn
argument_list|)
expr_stmt|;
name|cn
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
block|}
else|else
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
comment|/* update length and return pointer to the auth chunk */
name|SCTP_BUF_LEN
argument_list|(
name|m_auth
argument_list|)
operator|=
name|chunk_len
expr_stmt|;
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|m_auth
argument_list|,
name|m
argument_list|,
name|m_end
argument_list|,
literal|1
argument_list|,
name|chunk_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_ret
operator|!=
name|NULL
condition|)
operator|*
name|auth_ret
operator|=
name|auth
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

