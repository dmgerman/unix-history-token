begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/udp_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/in_cksum.h>
end_include

begin_define
define|#
directive|define
name|SCTP_MAX_GAPS_INARRAY
value|4
end_define

begin_struct
struct|struct
name|sack_track
block|{
name|uint8_t
name|right_edge
decl_stmt|;
comment|/* mergable on the right edge */
name|uint8_t
name|left_edge
decl_stmt|;
comment|/* mergable on the left edge */
name|uint8_t
name|num_entries
decl_stmt|;
name|uint8_t
name|spare
decl_stmt|;
name|struct
name|sctp_gap_ack_block
name|gaps
index|[
name|SCTP_MAX_GAPS_INARRAY
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|sack_track
name|sack_array
index|[
literal|256
index|]
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* 0x00 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x01 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x02 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x03 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x04 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x05 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x06 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x07 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x08 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x09 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x0a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x0b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x0c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x0d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x0e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x0f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x10 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x11 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x12 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x13 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x14 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x15 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x16 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x17 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x18 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x19 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x1a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x1b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x1c */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x1d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x1e */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x1f */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x20 */
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x21 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x22 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x23 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x24 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x25 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x26 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x27 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x28 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x29 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x2a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x2b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x2c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x2d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x2e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x2f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x30 */
block|{
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x31 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x32 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x33 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x34 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x35 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x36 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x37 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x38 */
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x39 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x3a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x3b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x3c */
block|{
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x3d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x3e */
block|{
block|{
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x3f */
block|{
block|{
literal|0
block|,
literal|5
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x40 */
block|{
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x41 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x42 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x43 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x44 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x45 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x46 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x47 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x48 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x49 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x4a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x4b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x4c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x4d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x4e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x4f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x50 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x51 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x52 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x53 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x54 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0x55 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x56 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x57 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x58 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x59 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x5a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x5b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x5c */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x5d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x5e */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x5f */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x60 */
block|{
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x61 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x62 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x63 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x64 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x65 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x66 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x67 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x68 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x69 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x6a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x6b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x6c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x6d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x6e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x6f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x70 */
block|{
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x71 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x72 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x73 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x74 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x75 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x76 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x77 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x78 */
block|{
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x79 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x7a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x7b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x7c */
block|{
block|{
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x7d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x7e */
block|{
block|{
literal|1
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x7f */
block|{
block|{
literal|0
block|,
literal|6
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0x80 */
block|{
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x81 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x82 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x83 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x84 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x85 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x86 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x87 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x88 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x89 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x8a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x8b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x8c */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x8d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x8e */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x8f */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x90 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x91 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x92 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x93 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x94 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0x95 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x96 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x97 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x98 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x99 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x9a */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x9b */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x9c */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0x9d */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x9e */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0x9f */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xa0 */
block|{
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xa5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xa8 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xa9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xaa */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xab */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xac */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xad */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xae */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xaf */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xb0 */
block|{
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xb5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xb8 */
block|{
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xb9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xba */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xbb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xbc */
block|{
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xbd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xbe */
block|{
block|{
literal|1
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xbf */
block|{
block|{
literal|0
block|,
literal|5
block|}
block|,
block|{
literal|7
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xc0 */
block|{
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xc5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xc8 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xc9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xca */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xcb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xcc */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xcd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xce */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xcf */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xd0 */
block|{
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|4
block|,
literal|0
block|,
comment|/* 0xd5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xd8 */
block|{
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xd9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xda */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xdb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xdc */
block|{
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xdd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xde */
block|{
block|{
literal|1
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xdf */
block|{
block|{
literal|0
block|,
literal|4
block|}
block|,
block|{
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xe0 */
block|{
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xe5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xe8 */
block|{
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xe9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xea */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xeb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xec */
block|{
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xed */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xee */
block|{
block|{
literal|1
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xef */
block|{
block|{
literal|0
block|,
literal|3
block|}
block|,
block|{
literal|5
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xf0 */
block|{
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf1 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf2 */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf3 */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf4 */
block|{
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
comment|/* 0xf5 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf6 */
block|{
block|{
literal|1
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf7 */
block|{
block|{
literal|0
block|,
literal|2
block|}
block|,
block|{
literal|4
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xf8 */
block|{
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xf9 */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xfa */
block|{
block|{
literal|1
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xfb */
block|{
block|{
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|3
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xfc */
block|{
block|{
literal|2
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
comment|/* 0xfd */
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|2
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xfe */
block|{
block|{
literal|1
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|,
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
comment|/* 0xff */
block|{
block|{
literal|0
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp_is_address_in_scope
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|struct
name|sctp_scoping
modifier|*
name|scope
parameter_list|,
name|int
name|do_update
parameter_list|)
block|{
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifn_p
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|ifa
operator|->
name|ifn_p
argument_list|)
condition|)
block|{
comment|/* 		 * skip loopback if not in scope * 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|scope
operator|->
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* not in scope , unspecified */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|scope
operator|->
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* private address not in scope */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|scope
operator|->
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
comment|/* 			 * Must update the flags,  bummer, which means any 			 * IFA locks must now be applied HERE<-> 			 */
if|if
condition|(
name|do_update
condition|)
block|{
name|sctp_gather_internal_ifa_flags
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* ok to use deprecated addresses? */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* skip unspecifed addresses */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
comment|/* (local_scope == 0)&& */
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|scope
operator|->
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_add_addr_to_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint16_t
modifier|*
name|len
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|sctp_paramhdr
modifier|*
name|parmh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mret
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|plen
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|plen
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
name|m
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
name|plen
condition|)
block|{
comment|/* easy side we just drop it on the end */
name|parmh
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|SCTP_BUF_AT
argument_list|(
name|m
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|mret
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* Need more space */
name|mret
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mret
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|plen
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* We are hosed, can't add more addresses */
return|return
operator|(
name|m
operator|)
return|;
block|}
name|mret
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
expr_stmt|;
name|parmh
operator|=
name|mtod
argument_list|(
name|mret
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* now add the parameter */
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|ipv4p
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|ipv4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|parmh
expr_stmt|;
name|parmh
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|parmh
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|ipv4p
operator|->
name|addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|+=
name|plen
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|ipv6p
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
name|ipv6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|parmh
expr_stmt|;
name|parmh
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
name|parmh
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ipv6p
operator|->
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ipv6p
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear embedded scope in the address */
name|in6_clearscope
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ipv6p
operator|->
name|addr
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|+=
name|plen
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
name|NULL
condition|)
block|{
operator|*
name|len
operator|+=
name|plen
expr_stmt|;
block|}
return|return
operator|(
name|mret
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_add_addresses_to_i_ia
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_scoping
modifier|*
name|scope
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_at
parameter_list|,
name|int
name|cnt_inits_to
parameter_list|,
name|uint16_t
modifier|*
name|padding_len
parameter_list|,
name|uint16_t
modifier|*
name|chunk_len
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|limit_out
init|=
literal|0
decl_stmt|,
name|total_count
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|m_at
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
if|if
condition|(
name|vrf
operator|->
name|total_ifa_count
operator|>
name|SCTP_COUNT_LIMIT
condition|)
block|{
name|limit_out
operator|=
literal|1
expr_stmt|;
name|cnt
operator|=
name|SCTP_ADDRESS_LIMIT
expr_stmt|;
goto|goto
name|skip_count
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifnp
argument_list|)
condition|)
block|{
comment|/* 				 * Skip loopback devices if loopback_scope 				 * not set 				 */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|&sctp_ifnp->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifap
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|sctp_ifap
argument_list|,
name|scope
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cnt
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
break|break;
block|}
block|}
name|skip_count
label|:
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|total_count
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
name|cnt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifnp
argument_list|)
condition|)
block|{
comment|/* 					 * Skip loopback devices if 					 * loopback_scope not set 					 */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|&sctp_ifnp->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifap
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|sctp_ifap
argument_list|,
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|chunk_len
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|padding_len
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|padding_len
operator|>
literal|0
operator|)
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m_at
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|*
name|chunk_len
argument_list|,
literal|0
argument_list|,
operator|*
name|padding_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
operator|+=
operator|*
name|padding_len
expr_stmt|;
operator|*
name|chunk_len
operator|+=
operator|*
name|padding_len
expr_stmt|;
operator|*
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|m_at
operator|=
name|sctp_add_addr_to_mbuf
argument_list|(
name|m_at
argument_list|,
name|sctp_ifap
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit_out
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|total_count
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
literal|2
condition|)
block|{
comment|/* 							 * two from each 							 * address 							 */
break|break;
block|}
if|if
condition|(
name|total_count
operator|>
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
comment|/* No more addresses */
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
comment|/* First, how many ? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
comment|/* 				 * Address being deleted by the system, dont 				 * list. 				 */
continue|continue;
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* 				 * Address being deleted on this ep don't 				 * list. 				 */
continue|continue;
block|}
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|scope
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * To get through a NAT we only list addresses if we have 		 * more than one. That way if you just bind a single address 		 * we let the source of the init dictate our address. 		 */
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|chunk_len
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|padding_len
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|padding_len
operator|>
literal|0
operator|)
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m_at
argument_list|,
name|caddr_t
argument_list|)
operator|+
operator|*
name|chunk_len
argument_list|,
literal|0
argument_list|,
operator|*
name|padding_len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
operator|+=
operator|*
name|padding_len
expr_stmt|;
operator|*
name|chunk_len
operator|+=
operator|*
name|padding_len
expr_stmt|;
operator|*
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|m_at
operator|=
name|sctp_add_addr_to_mbuf
argument_list|(
name|m_at
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
name|cnt
operator|>=
name|SCTP_ADDRESS_LIMIT
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|m_at
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_is_ifa_addr_preferred
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|uint8_t
name|dest_is_global
init|=
literal|0
decl_stmt|;
comment|/* dest_is_priv is true if destination is a private address */
comment|/* dest_is_loop is true if destination is a loopback addresses */
comment|/** 	 * Here we determine if its a preferred address. A preferred address 	 * means it is the same scope or higher scope then the destination. 	 * L = loopback, P = private, G = global 	 * ----------------------------------------- 	 *    src    |  dest | result 	 *  ---------------------------------------- 	 *     L     |    L  |    yes 	 *  ----------------------------------------- 	 *     P     |    L  |    yes-v4 no-v6 	 *  ----------------------------------------- 	 *     G     |    L  |    yes-v4 no-v6 	 *  ----------------------------------------- 	 *     L     |    P  |    no 	 *  ----------------------------------------- 	 *     P     |    P  |    yes 	 *  ----------------------------------------- 	 *     G     |    P  |    no 	 *   ----------------------------------------- 	 *     L     |    G  |    no 	 *   ----------------------------------------- 	 *     P     |    G  |    no 	 *    ----------------------------------------- 	 *     G     |    G  |    yes 	 *    ----------------------------------------- 	 */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|fam
condition|)
block|{
comment|/* forget mis-matched family */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dest_is_priv
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dest_is_loop
operator|==
literal|0
operator|)
condition|)
block|{
name|dest_is_global
operator|=
literal|1
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Is destination preferred:"
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
comment|/* Ok the address may be ok */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
comment|/* ok to use deprecated addresses? no lets not! */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:1\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ifa
operator|->
name|src_is_priv
operator|&&
operator|!
name|ifa
operator|->
name|src_is_loop
condition|)
block|{
if|if
condition|(
name|dest_is_loop
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:2\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ifa
operator|->
name|src_is_glob
condition|)
block|{
if|if
condition|(
name|dest_is_loop
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:3\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Now that we know what is what, implement or table this could in 	 * theory be done slicker (it used to be), but this is 	 * straightforward and easier to validate :-) 	 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"src_loop:%d src_priv:%d src_glob:%d\n"
argument_list|,
name|ifa
operator|->
name|src_is_loop
argument_list|,
name|ifa
operator|->
name|src_is_priv
argument_list|,
name|ifa
operator|->
name|src_is_glob
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"dest_loop:%d dest_priv:%d dest_glob:%d\n"
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_global
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:4\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_glob
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:5\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|)
operator|&&
operator|(
name|dest_is_global
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:6\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_priv
operator|)
operator|&&
operator|(
name|dest_is_global
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"NO:7\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"YES\n"
argument_list|)
expr_stmt|;
comment|/* its a preferred address */
return|return
operator|(
name|ifa
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_is_ifa_addr_acceptable
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|uint8_t
name|dest_is_global
init|=
literal|0
decl_stmt|;
comment|/** 	 * Here we determine if its a acceptable address. A acceptable 	 * address means it is the same scope or higher scope but we can 	 * allow for NAT which means its ok to have a global dest and a 	 * private src. 	 * 	 * L = loopback, P = private, G = global 	 * ----------------------------------------- 	 *  src    |  dest | result 	 * ----------------------------------------- 	 *   L     |   L   |    yes 	 *  ----------------------------------------- 	 *   P     |   L   |    yes-v4 no-v6 	 *  ----------------------------------------- 	 *   G     |   L   |    yes 	 * ----------------------------------------- 	 *   L     |   P   |    no 	 * ----------------------------------------- 	 *   P     |   P   |    yes 	 * ----------------------------------------- 	 *   G     |   P   |    yes - May not work 	 * ----------------------------------------- 	 *   L     |   G   |    no 	 * ----------------------------------------- 	 *   P     |   G   |    yes - May not work 	 * ----------------------------------------- 	 *   G     |   G   |    yes 	 * ----------------------------------------- 	 */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|fam
condition|)
block|{
comment|/* forget non matching family */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"ifa_fam:%d fam:%d\n"
argument_list|,
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|fam
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Ok the address may be ok */
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"dst_is_loop:%d dest_is_priv:%d\n"
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dest_is_loop
operator|==
literal|0
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|==
literal|0
operator|)
condition|)
block|{
name|dest_is_global
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
comment|/* ok to use deprecated addresses? */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ifa
operator|->
name|src_is_priv
condition|)
block|{
comment|/* Special case, linklocal to loop */
if|if
condition|(
name|dest_is_loop
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Now that we know what is what, implement our table. This could in 	 * theory be done slicker (it used to be), but this is 	 * straightforward and easier to validate :-) 	 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"ifa->src_is_loop:%d dest_is_priv:%d\n"
argument_list|,
name|ifa
operator|->
name|src_is_loop
argument_list|,
name|dest_is_priv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|==
literal|1
operator|)
operator|&&
operator|(
name|dest_is_priv
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"ifa->src_is_loop:%d dest_is_glob:%d\n"
argument_list|,
name|ifa
operator|->
name|src_is_loop
argument_list|,
name|dest_is_global
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|->
name|src_is_loop
operator|==
literal|1
operator|)
operator|&&
operator|(
name|dest_is_global
operator|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"address is acceptable\n"
argument_list|)
expr_stmt|;
comment|/* its an acceptable address */
return|return
operator|(
name|ifa
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_is_addr_restricted
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* There are no restrictions, no TCB :-) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_restricted_addrs
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"%s: NULL ifa\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
comment|/* Yes it is on the list */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_is_addr_in_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"%s: NULL ifa\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
operator|)
operator|&&
name|laddr
operator|->
name|action
operator|==
literal|0
condition|)
comment|/* same pointer */
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_choose_boundspecific_inp
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|starting_point
decl_stmt|;
name|void
modifier|*
name|ifn
decl_stmt|;
name|int
name|resettotop
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|uint32_t
name|ifn_index
decl_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ifn
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|ifn_index
operator|=
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|sctp_ifn
operator|=
name|sctp_find_ifn
argument_list|(
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want such an address. Note that we first looked for a preferred 	 * address. 	 */
if|if
condition|(
name|sctp_ifn
condition|)
block|{
comment|/* is a preferred one on the interface we route out? */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|sifa
argument_list|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * ok, now we now need to find one on the list of the addresses. We 	 * can't get one on the emitting interface so let's find first a 	 * preferred one. If not that an acceptable one otherwise... we 	 * return NULL. 	 */
name|starting_point
operator|=
name|inp
operator|->
name|next_addr_touse
expr_stmt|;
name|once_again
label|:
if|if
condition|(
name|inp
operator|->
name|next_addr_touse
operator|==
name|NULL
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
name|resettotop
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|laddr
operator|=
name|inp
operator|->
name|next_addr_touse
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* address is being deleted */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|resettotop
operator|==
literal|0
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|NULL
expr_stmt|;
goto|goto
name|once_again
goto|;
block|}
name|inp
operator|->
name|next_addr_touse
operator|=
name|starting_point
expr_stmt|;
name|resettotop
operator|=
literal|0
expr_stmt|;
name|once_again_too
label|:
if|if
condition|(
name|inp
operator|->
name|next_addr_touse
operator|==
name|NULL
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
name|resettotop
operator|=
literal|1
expr_stmt|;
block|}
comment|/* ok, what about an acceptable address in the inp */
for|for
control|(
name|laddr
operator|=
name|inp
operator|->
name|next_addr_touse
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* address is being deleted */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|resettotop
operator|==
literal|0
condition|)
block|{
name|inp
operator|->
name|next_addr_touse
operator|=
name|NULL
expr_stmt|;
goto|goto
name|once_again_too
goto|;
block|}
comment|/* 	 * no address bound can be a source for the destination we are in 	 * trouble 	 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_choose_boundspecific_stcb
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|starting_point
decl_stmt|;
name|void
modifier|*
name|ifn
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|uint8_t
name|start_at_beginning
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|uint32_t
name|ifn_index
decl_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want that one. 	 */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ifn
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|ifn_index
operator|=
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|sctp_ifn
operator|=
name|sctp_find_ifn
argument_list|(
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list?  If so, 	 * we want that one. First we look for a preferred. Second, we go 	 * for an acceptable. 	 */
if|if
condition|(
name|sctp_ifn
condition|)
block|{
comment|/* first try for a preferred address on the ep */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
block|{
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
comment|/* next try for an acceptable address on the ep */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
block|{
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
block|}
block|}
comment|/* 	 * if we can't find one like that then we must look at all addresses 	 * bound to pick one at first preferable then secondly acceptable. 	 */
name|starting_point
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
expr_stmt|;
name|sctp_from_the_top
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* address is being deleted */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|laddr
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctp_from_the_top
goto|;
block|}
comment|/* now try for any higher scope than the destination */
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|starting_point
expr_stmt|;
name|start_at_beginning
operator|=
literal|0
expr_stmt|;
name|sctp_from_the_top2
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* address is being deleted */
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|laddr
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctp_from_the_top2
goto|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_select_nth_preferred_addr_from_ifn_boundall
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|int
name|addr_wanted
parameter_list|,
name|sa_family_t
name|fam
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|,
name|lsa6
decl_stmt|;
if|if
condition|(
name|fam
operator|==
name|AF_INET6
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|sin6
argument_list|,
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
operator|&
name|sin6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|LIST_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|fam
operator|==
name|AF_INET6
operator|&&
name|dest_is_loop
operator|&&
name|sifa
operator|->
name|src_is_loop
operator|&&
name|sifa
operator|->
name|src_is_priv
condition|)
block|{
comment|/* 			 * don't allow fe80::1 to be a src on loop ::1, we 			 * don't list it to the peer so we will get an 			 * abort. 			 */
continue|continue;
block|}
if|if
condition|(
name|fam
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 			 * link-local<-> link-local must belong to the same 			 * scope. 			 */
name|memcpy
argument_list|(
operator|&
name|lsa6
argument_list|,
operator|&
name|sifa
operator|->
name|address
operator|.
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
operator|&
name|lsa6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|.
name|sin6_scope_id
operator|!=
name|lsa6
operator|.
name|sin6_scope_id
condition|)
block|{
continue|continue;
block|}
block|}
endif|#
directive|endif
comment|/* INET6 */
comment|/* 		 * Check if the IPv6 address matches to next-hop. In the 		 * mobile case, old IPv6 address may be not deleted from the 		 * interface. Then, the interface has previous and new 		 * addresses.  We should use one corresponding to the 		 * next-hop.  (by micchie) 		 */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|stcb
operator|&&
name|fam
operator|==
name|AF_INET6
operator|&&
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sctp_v6src_match_nexthop
argument_list|(
operator|&
name|sifa
operator|->
name|address
operator|.
name|sin6
argument_list|,
name|ro
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
comment|/* Avoid topologically incorrect IPv4 address */
if|if
condition|(
name|stcb
operator|&&
name|fam
operator|==
name|AF_INET
operator|&&
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sctp_v4src_match_nexthop
argument_list|(
name|sifa
argument_list|,
name|ro
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|ifa
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
if|if
condition|(
name|num_eligible_addr
operator|>=
name|addr_wanted
condition|)
block|{
return|return
operator|(
name|sifa
operator|)
return|;
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_num_preferred_boundall
parameter_list|(
name|struct
name|sctp_ifn
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_preferred
argument_list|(
name|ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|ifa
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num_eligible_addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_ifa
modifier|*
name|sctp_choose_boundall
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint8_t
name|dest_is_priv
parameter_list|,
name|uint8_t
name|dest_is_loop
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|sa_family_t
name|fam
parameter_list|)
block|{
name|int
name|cur_addr_num
init|=
literal|0
decl_stmt|,
name|num_preferred
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|ifn
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|,
modifier|*
name|looked_at
init|=
name|NULL
decl_stmt|,
modifier|*
name|emit_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|,
modifier|*
name|sifa
decl_stmt|;
name|uint32_t
name|ifn_index
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|int
name|retried
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/*- 	 * For boundall we can use any address in the association. 	 * If non_asoc_addr_ok is set we can use any address (at least in 	 * theory). So we look for preferred addresses first. If we find one, 	 * we use it. Otherwise we next try to get an address on the 	 * interface, which we should be able to do (unless non_asoc_addr_ok 	 * is false and we are routed out that way). In these cases where we 	 * can't use the address of the interface we go through all the 	 * ifn's looking for an address we can use and fill that in. Punting 	 * means we send back address 0, which will probably cause problems 	 * actually since then IP will fill in the address of the route ifn, 	 * which means we probably already rejected it.. i.e. here comes an 	 * abort :-<. 	 */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ifn
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|ifn_index
operator|=
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"ifn from route:%p ifn_index:%d\n"
argument_list|,
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
name|emit_ifn
operator|=
name|looked_at
operator|=
name|sctp_ifn
operator|=
name|sctp_find_ifn
argument_list|(
name|ifn
argument_list|,
name|ifn_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifn
operator|==
name|NULL
condition|)
block|{
comment|/* ?? We don't have this guy ?? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"No ifn emit interface?\n"
argument_list|)
expr_stmt|;
goto|goto
name|bound_all_plan_b
goto|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"ifn_index:%d name:%s is emit interface\n"
argument_list|,
name|ifn_index
argument_list|,
name|sctp_ifn
operator|->
name|ifn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|cur_addr_num
operator|=
name|net
operator|->
name|indx_of_eligible_next_to_use
expr_stmt|;
block|}
name|num_preferred
operator|=
name|sctp_count_num_preferred_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Found %d preferred source addresses for intf:%s\n"
argument_list|,
name|num_preferred
argument_list|,
name|sctp_ifn
operator|->
name|ifn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_preferred
operator|==
literal|0
condition|)
block|{
comment|/* 		 * no eligible addresses, we must use some other interface 		 * address if we can find one. 		 */
goto|goto
name|bound_all_plan_b
goto|;
block|}
comment|/* 	 * Ok we have num_eligible_addr set with how many we can use, this 	 * may vary from call to call due to addresses being deprecated 	 * etc.. 	 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_preferred
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * select the nth address from the list (where cur_addr_num is the 	 * nth) and 0 is the first one, 1 is the second one etc... 	 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"cur_addr_num:%d\n"
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
name|sctp_ifa
operator|=
name|sctp_select_nth_preferred_addr_from_ifn_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|cur_addr_num
argument_list|,
name|fam
argument_list|,
name|ro
argument_list|)
expr_stmt|;
comment|/* if sctp_ifa is NULL something changed??, fall to plan b. */
if|if
condition|(
name|sctp_ifa
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|sctp_ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* save off where the next one we will want */
name|net
operator|->
name|indx_of_eligible_next_to_use
operator|=
name|cur_addr_num
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|sctp_ifa
operator|)
return|;
block|}
comment|/* 	 * plan_b: Look at all interfaces and find a preferred address. If 	 * no preferred fall through to plan_c. 	 */
name|bound_all_plan_b
label|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Trying Plan B\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Examine interface %s\n"
argument_list|,
name|sctp_ifn
operator|->
name|ifn_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dest_is_loop
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* wrong base scope */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"skip\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|sctp_ifn
operator|==
name|looked_at
operator|)
operator|&&
name|looked_at
condition|)
block|{
comment|/* already looked at this guy */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"already seen\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|num_preferred
operator|=
name|sctp_count_num_preferred_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Found ifn:%p %d preferred source addresses\n"
argument_list|,
name|ifn
argument_list|,
name|num_preferred
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_preferred
operator|==
literal|0
condition|)
block|{
comment|/* None on this interface. */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"No prefered -- skipping to next\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"num preferred:%d on interface:%p cur_addr_num:%d\n"
argument_list|,
name|num_preferred
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sctp_ifn
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
comment|/* 		 * Ok we have num_eligible_addr set with how many we can 		 * use, this may vary from call to call due to addresses 		 * being deprecated etc.. 		 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_preferred
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
name|sifa
operator|=
name|sctp_select_nth_preferred_addr_from_ifn_boundall
argument_list|(
name|sctp_ifn
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|cur_addr_num
argument_list|,
name|fam
argument_list|,
name|ro
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|net
condition|)
block|{
name|net
operator|->
name|indx_of_eligible_next_to_use
operator|=
name|cur_addr_num
operator|+
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"we selected %d\n"
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Source:"
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|&
name|sifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Dest:"
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sifa
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
name|again_with_private_addresses_allowed
label|:
endif|#
directive|endif
comment|/* plan_c: do we have an acceptable address on the emit interface */
name|sifa
operator|=
name|NULL
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Trying Plan C: find acceptable on interface\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|emit_ifn
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Jump to Plan D - no emit_ifn\n"
argument_list|)
expr_stmt|;
goto|goto
name|plan_d
goto|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&emit_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"ifa:%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sctp_ifa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Jailed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Jailed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Defer\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"IFA not acceptable\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|sifa
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"NOT in scope\n"
argument_list|)
expr_stmt|;
name|sifa
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Its resticted\n"
argument_list|)
expr_stmt|;
name|sifa
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Stcb is null - no print\n"
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|plan_d
label|:
comment|/* 	 * plan_d: We are in trouble. No preferred address on the emit 	 * interface. And not even a preferred address on all interfaces. Go 	 * out and see if we can find an acceptable address somewhere 	 * amongst all interfaces. 	 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Trying Plan D looked_at is %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|looked_at
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
name|dest_is_loop
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|sifa
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|sifa
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sifa
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 					 * It is restricted for some 					 * reason.. probably not yet added. 					 */
name|sifa
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
block|}
goto|goto
name|out
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|retried
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
operator|=
literal|1
expr_stmt|;
name|retried
operator|=
literal|1
expr_stmt|;
goto|goto
name|again_with_private_addresses_allowed
goto|;
block|}
elseif|else
if|if
condition|(
name|retried
operator|==
literal|1
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|out
label|:
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sifa
condition|)
block|{
if|if
condition|(
name|retried
operator|==
literal|1
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
name|dest_is_loop
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|tmp_sifa
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_DEFER_USE
operator|)
operator|&&
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
condition|)
continue|continue;
name|tmp_sifa
operator|=
name|sctp_is_ifa_addr_acceptable
argument_list|(
name|sctp_ifa
argument_list|,
name|dest_is_loop
argument_list|,
name|dest_is_priv
argument_list|,
name|fam
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_sifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|tmp_sifa
operator|==
name|sifa
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|tmp_sifa
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|tmp_sifa
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|non_asoc_addr_ok
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|tmp_sifa
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|tmp_sifa
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 							 * It is restricted 							 * for some reason.. 							 * probably not yet 							 * added. 							 */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|tmp_sifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
operator|(
name|tmp_sifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|)
argument_list|)
operator|)
condition|)
block|{
name|sctp_add_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|tmp_sifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|atomic_add_int
argument_list|(
operator|&
name|sifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|sifa
operator|)
return|;
block|}
end_function

begin_comment
comment|/* tcb may be NULL */
end_comment

begin_function
name|struct
name|sctp_ifa
modifier|*
name|sctp_source_address_selection
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|answer
decl_stmt|;
name|uint8_t
name|dest_is_priv
decl_stmt|,
name|dest_is_loop
decl_stmt|;
name|sa_family_t
name|fam
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|to6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
endif|#
directive|endif
comment|/** 	 * Rules: - Find the route if needed, cache if I can. - Look at 	 * interface address in route, Is it in the bound list. If so we 	 * have the best source. - If not we must rotate amongst the 	 * addresses. 	 * 	 * Cavets and issues 	 * 	 * Do we need to pay attention to scope. We can have a private address 	 * or a global address we are sourcing or sending to. So if we draw 	 * it out 	 * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 	 * For V4 	 * ------------------------------------------ 	 *      source     *      dest  *  result 	 * ----------------------------------------- 	 *<a>  Private    *    Global  *  NAT 	 * ----------------------------------------- 	 *<b>  Private    *    Private *  No problem 	 * ----------------------------------------- 	 *<c>  Global     *    Private *  Huh, How will this work? 	 * ----------------------------------------- 	 *<d>  Global     *    Global  *  No Problem 	 *------------------------------------------ 	 * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 	 * For V6 	 *------------------------------------------ 	 *      source     *      dest  *  result 	 * ----------------------------------------- 	 *<a>  Linklocal  *    Global  * 	 * ----------------------------------------- 	 *<b>  Linklocal  * Linklocal  *  No problem 	 * ----------------------------------------- 	 *<c>  Global     * Linklocal  *  Huh, How will this work? 	 * ----------------------------------------- 	 *<d>  Global     *    Global  *  No Problem 	 *------------------------------------------ 	 * zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz 	 * 	 * And then we add to that what happens if there are multiple addresses 	 * assigned to an interface. Remember the ifa on a ifn is a linked 	 * list of addresses. So one interface can have more than one IP 	 * address. What happens if we have both a private and a global 	 * address? Do we then use context of destination to sort out which 	 * one is best? And what about NAT's sending P->G may get you a NAT 	 * translation, or should you select the G thats on the interface in 	 * preference. 	 * 	 * Decisions: 	 * 	 * - count the number of addresses on the interface. 	 * - if it is one, no problem except case<c>. 	 *   For<a> we will assume a NAT out there. 	 * - if there are more than one, then we need to worry about scope P 	 *   or G. We should prefer G -> G and P -> P if possible. 	 *   Then as a secondary fall back to mixed types G->P being a last 	 *   ditch one. 	 * - The above all works for bound all, but bound specific we need to 	 *   use the same concept but instead only consider the bound 	 *   addresses. If the bound set is NOT assigned to the interface then 	 *   we must use rotation amongst the bound addresses.. 	 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Need a route to cache. 		 */
name|SCTP_RTALLOC
argument_list|(
name|ro
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fam
operator|=
name|ro
operator|->
name|ro_dst
operator|.
name|sa_family
expr_stmt|;
name|dest_is_priv
operator|=
name|dest_is_loop
operator|=
literal|0
expr_stmt|;
comment|/* Setup our scopes for the destination */
switch|switch
condition|(
name|fam
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* Scope based on outbound address */
if|if
condition|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|dest_is_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* mark it as local */
name|net
operator|->
name|addr_is_local
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|dest_is_priv
operator|=
literal|1
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* Scope based on outbound address */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
operator|||
name|SCTP_ROUTE_IS_REAL_LOOP
argument_list|(
name|ro
argument_list|)
condition|)
block|{
comment|/* 			 * If the address is a loopback address, which 			 * consists of "::1" OR "fe80::1%lo0", we are 			 * loopback scope. But we don't use dest_is_priv 			 * (link local addresses). 			 */
name|dest_is_loop
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* mark it as local */
name|net
operator|->
name|addr_is_local
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|dest_is_priv
operator|=
literal|1
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"Select source addr for:"
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* 		 * Bound all case 		 */
name|answer
operator|=
name|sctp_choose_boundall
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|vrf_id
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_loop
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|fam
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
comment|/* 	 * Subset bound case 	 */
if|if
condition|(
name|stcb
condition|)
block|{
name|answer
operator|=
name|sctp_choose_boundspecific_stcb
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|vrf_id
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_loop
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|fam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|answer
operator|=
name|sctp_choose_boundspecific_inp
argument_list|(
name|inp
argument_list|,
name|ro
argument_list|,
name|vrf_id
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|dest_is_priv
argument_list|,
name|dest_is_loop
argument_list|,
name|fam
argument_list|)
expr_stmt|;
block|}
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|answer
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_find_cmsg
parameter_list|(
name|int
name|c_type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|size_t
name|cpsize
parameter_list|)
block|{
name|struct
name|cmsghdr
name|cmh
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|at
decl_stmt|,
name|found
decl_stmt|;
name|struct
name|sctp_sndinfo
name|sndinfo
decl_stmt|;
name|struct
name|sctp_prinfo
name|prinfo
decl_stmt|;
name|struct
name|sctp_authinfo
name|authinfo
decl_stmt|;
name|tlen
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Independent of how many mbufs, find the c_type inside the control 	 * structure and copy out the data. 	 */
while|while
condition|(
name|at
operator|<
name|tlen
condition|)
block|{
if|if
condition|(
operator|(
name|tlen
operator|-
name|at
operator|)
operator|<
operator|(
name|int
operator|)
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* There is not enough room for one more. */
return|return
operator|(
name|found
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cmh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmh
operator|.
name|cmsg_len
operator|<
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We dont't have a complete CMSG header. */
return|return
operator|(
name|found
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cmh
operator|.
name|cmsg_len
operator|+
name|at
operator|)
operator|>
name|tlen
condition|)
block|{
comment|/* We don't have the complete CMSG. */
return|return
operator|(
name|found
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cmh
operator|.
name|cmsg_level
operator|==
name|IPPROTO_SCTP
operator|)
operator|&&
operator|(
operator|(
name|c_type
operator|==
name|cmh
operator|.
name|cmsg_type
operator|)
operator|||
operator|(
operator|(
name|c_type
operator|==
name|SCTP_SNDRCV
operator|)
operator|&&
operator|(
operator|(
name|cmh
operator|.
name|cmsg_type
operator|==
name|SCTP_SNDINFO
operator|)
operator|||
operator|(
name|cmh
operator|.
name|cmsg_type
operator|==
name|SCTP_PRINFO
operator|)
operator|||
operator|(
name|cmh
operator|.
name|cmsg_type
operator|==
name|SCTP_AUTHINFO
operator|)
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|c_type
operator|==
name|cmh
operator|.
name|cmsg_type
condition|)
block|{
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
name|cpsize
condition|)
block|{
return|return
operator|(
name|found
operator|)
return|;
block|}
comment|/* It is exactly what we want. Copy it out. */
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
name|cpsize
argument_list|,
operator|(
name|caddr_t
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|sndrcvinfo
decl_stmt|;
name|sndrcvinfo
operator|=
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cpsize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
condition|)
block|{
return|return
operator|(
name|found
operator|)
return|;
block|}
name|memset
argument_list|(
name|sndrcvinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|cmh
operator|.
name|cmsg_type
condition|)
block|{
case|case
name|SCTP_SNDINFO
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndinfo
argument_list|)
condition|)
block|{
return|return
operator|(
name|found
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndinfo
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sndinfo
argument_list|)
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_stream
operator|=
name|sndinfo
operator|.
name|snd_sid
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_flags
operator|=
name|sndinfo
operator|.
name|snd_flags
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_ppid
operator|=
name|sndinfo
operator|.
name|snd_ppid
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_context
operator|=
name|sndinfo
operator|.
name|snd_context
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_assoc_id
operator|=
name|sndinfo
operator|.
name|snd_assoc_id
expr_stmt|;
break|break;
case|case
name|SCTP_PRINFO
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_prinfo
argument_list|)
condition|)
block|{
return|return
operator|(
name|found
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_prinfo
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|prinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|prinfo
operator|.
name|pr_policy
operator|!=
name|SCTP_PR_SCTP_NONE
condition|)
block|{
name|sndrcvinfo
operator|->
name|sinfo_timetolive
operator|=
name|prinfo
operator|.
name|pr_value
expr_stmt|;
block|}
else|else
block|{
name|sndrcvinfo
operator|->
name|sinfo_timetolive
operator|=
literal|0
expr_stmt|;
block|}
name|sndrcvinfo
operator|->
name|sinfo_flags
operator||=
name|prinfo
operator|.
name|pr_policy
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHINFO
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authinfo
argument_list|)
condition|)
block|{
return|return
operator|(
name|found
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authinfo
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|authinfo
argument_list|)
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_keynumber_valid
operator|=
literal|1
expr_stmt|;
name|sndrcvinfo
operator|->
name|sinfo_keynumber
operator|=
name|authinfo
operator|.
name|auth_keynumber
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|found
operator|)
return|;
block|}
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|at
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cmh
operator|.
name|cmsg_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_process_cmsgs_for_init
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|cmsghdr
name|cmh
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|at
decl_stmt|;
name|struct
name|sctp_initmsg
name|initmsg
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
name|tlen
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|at
operator|<
name|tlen
condition|)
block|{
if|if
condition|(
operator|(
name|tlen
operator|-
name|at
operator|)
operator|<
operator|(
name|int
operator|)
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* There is not enough room for one more. */
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cmh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmh
operator|.
name|cmsg_len
operator|<
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We dont't have a complete CMSG header. */
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cmh
operator|.
name|cmsg_len
operator|+
name|at
operator|)
operator|>
name|tlen
condition|)
block|{
comment|/* We don't have the complete CMSG. */
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cmh
operator|.
name|cmsg_level
operator|==
name|IPPROTO_SCTP
condition|)
block|{
switch|switch
condition|(
name|cmh
operator|.
name|cmsg_type
condition|)
block|{
case|case
name|SCTP_INIT
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_initmsg
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_initmsg
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|initmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|initmsg
operator|.
name|sinit_max_attempts
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|max_init_times
operator|=
name|initmsg
operator|.
name|sinit_max_attempts
expr_stmt|;
if|if
condition|(
name|initmsg
operator|.
name|sinit_num_ostreams
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
operator|=
name|initmsg
operator|.
name|sinit_num_ostreams
expr_stmt|;
if|if
condition|(
name|initmsg
operator|.
name|sinit_max_instreams
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|max_inbound_streams
operator|=
name|initmsg
operator|.
name|sinit_max_instreams
expr_stmt|;
if|if
condition|(
name|initmsg
operator|.
name|sinit_max_init_timeo
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|initial_init_rto_max
operator|=
name|initmsg
operator|.
name|sinit_max_init_timeo
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
condition|)
block|{
name|struct
name|sctp_stream_out
modifier|*
name|tmp_str
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Default is NOT correct */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Ok, default:%d pre_open:%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|tmp_str
argument_list|,
expr|struct
name|sctp_stream_out
operator|*
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_out
argument_list|)
operator|)
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp_str
operator|!=
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
operator|=
name|tmp_str
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|chunks_on_queues
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_send
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_DSTADDRV4
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_DSTADDRV6
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
operator|)
operator|||
operator|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|NULL
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
name|at
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cmh
operator|.
name|cmsg_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_findassociation_cmsgs
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|uint16_t
name|port
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|net_p
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
name|struct
name|cmsghdr
name|cmh
decl_stmt|;
name|int
name|tlen
decl_stmt|,
name|at
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
name|tlen
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|at
operator|<
name|tlen
condition|)
block|{
if|if
condition|(
operator|(
name|tlen
operator|-
name|at
operator|)
operator|<
operator|(
name|int
operator|)
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* There is not enough room for one more. */
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
argument_list|,
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cmh
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmh
operator|.
name|cmsg_len
operator|<
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
condition|)
block|{
comment|/* We dont't have a complete CMSG header. */
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|cmh
operator|.
name|cmsg_len
operator|+
name|at
operator|)
operator|>
name|tlen
condition|)
block|{
comment|/* We don't have the complete CMSG. */
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|cmh
operator|.
name|cmsg_level
operator|==
name|IPPROTO_SCTP
condition|)
block|{
switch|switch
condition|(
name|cmh
operator|.
name|cmsg_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_DSTADDRV4
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_DSTADDRV6
case|:
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|cmh
operator|.
name|cmsg_len
operator|-
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|)
block|{
operator|*
name|error
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|port
expr_stmt|;
name|m_copydata
argument_list|(
name|control
argument_list|,
name|at
operator|+
name|CMSG_ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
name|cmh
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|addr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|addr
condition|)
block|{
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
name|addr
argument_list|,
name|net_p
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|stcb
operator|)
return|;
block|}
block|}
block|}
name|at
operator|+=
name|CMSG_ALIGN
argument_list|(
name|cmh
operator|.
name|cmsg_len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_add_cookie
parameter_list|(
name|struct
name|mbuf
modifier|*
name|init
parameter_list|,
name|int
name|init_offset
parameter_list|,
name|struct
name|mbuf
modifier|*
name|initack
parameter_list|,
name|int
name|initack_offset
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|stc_in
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|signature
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|copy_init
decl_stmt|,
modifier|*
name|copy_initack
decl_stmt|,
modifier|*
name|m_at
decl_stmt|,
modifier|*
name|sig
decl_stmt|,
modifier|*
name|mret
decl_stmt|;
name|struct
name|sctp_state_cookie
modifier|*
name|stc
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint8_t
modifier|*
name|foo
decl_stmt|;
name|int
name|sig_offset
decl_stmt|;
name|uint16_t
name|cookie_sz
decl_stmt|;
name|mret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mret
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|copy_init
operator|=
name|SCTP_M_COPYM
argument_list|(
name|init
argument_list|,
name|init_offset
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_init
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|copy_init
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|copy_initack
operator|=
name|SCTP_M_COPYM
argument_list|(
name|initack
argument_list|,
name|initack_offset
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_initack
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mret
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|copy_init
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|copy_initack
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* easy side we just drop it on the end */
name|ph
operator|=
name|mtod
argument_list|(
name|mret
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|stc
operator|=
operator|(
expr|struct
name|sctp_state_cookie
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ph
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STATE_COOKIE
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
literal|0
expr_stmt|;
comment|/* fill in at the end */
comment|/* Fill in the stc cookie data */
name|memcpy
argument_list|(
name|stc
argument_list|,
name|stc_in
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
argument_list|)
expr_stmt|;
comment|/* tack the INIT and then the INIT-ACK onto the chain */
name|cookie_sz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_at
operator|=
name|mret
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
name|cookie_sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|copy_init
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|m_at
operator|=
name|copy_init
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
name|cookie_sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|copy_initack
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|m_at
operator|=
name|copy_initack
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
name|cookie_sz
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
name|sig
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|SCTP_SECRET_SIZE
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|NULL
condition|)
block|{
comment|/* no space, so free the entire chain */
name|sctp_m_freem
argument_list|(
name|mret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|sig
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|sig
expr_stmt|;
name|sig_offset
operator|=
literal|0
expr_stmt|;
name|foo
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|sig
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|sig_offset
operator|)
expr_stmt|;
name|memset
argument_list|(
name|foo
argument_list|,
literal|0
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|)
expr_stmt|;
operator|*
name|signature
operator|=
name|foo
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|sig
argument_list|)
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|cookie_sz
operator|+=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|cookie_sz
argument_list|)
expr_stmt|;
return|return
operator|(
name|mret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|sctp_get_ect
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_supported
operator|==
literal|1
operator|)
condition|)
block|{
return|return
operator|(
name|SCTP_ECT0_BIT
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_function
specifier|static
name|void
name|sctp_handle_no_route
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|so_locked
parameter_list|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"dropped packet - no valid source addr\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Destination was "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_CONFIRMED
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|&&
name|stcb
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"no route takes interface %p down\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* need a new primary */
name|struct
name|sctp_nets
modifier|*
name|alt
decl_stmt|;
name|alt
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|alt
operator|!=
name|net
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|alt
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sctp_lowlevel_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
comment|/* may be NULL */
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
parameter_list|,
name|uint16_t
name|auth_keyid
parameter_list|,
name|int
name|nofragment_flag
parameter_list|,
name|int
name|ecn_ok
parameter_list|,
name|int
name|out_of_asoc_ok
parameter_list|,
name|uint16_t
name|src_port
parameter_list|,
name|uint16_t
name|dest_port
parameter_list|,
name|uint32_t
name|v_tag
parameter_list|,
name|uint16_t
name|port
parameter_list|,
name|union
name|sctp_sockstore
modifier|*
name|over_addr
parameter_list|,
name|uint8_t
name|use_mflowid
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|int
name|so_locked
name|SCTP_UNUSED
else|#
directive|else
name|int
name|so_locked
endif|#
directive|endif
parameter_list|)
comment|/* nofragment_flag to tell if IP_DF should be set (IPv4 only) */
block|{
comment|/** 	 * Given a mbuf chain (via SCTP_BUF_NEXT()) that holds a packet header 	 * WITH an SCTPHDR but no IP header, endpoint inp and sa structure: 	 * - fill in the HMAC digest of any AUTH chunk in the packet. 	 * - calculate and fill in the SCTP checksum. 	 * - prepend an IP address header. 	 * - if boundall use INADDR_ANY. 	 * - if boundspecific do source address selection. 	 * - set fragmentation option for ipV4. 	 * - On return from IP output, check/adjust mtu size of output 	 *   interface and smallest_mtu size as well. 	 */
comment|/* Will need ifdefs around this */
name|struct
name|mbuf
modifier|*
name|newm
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sctphdr
decl_stmt|;
name|int
name|packet_length
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|uint32_t
name|vrf_id
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|mbuf
modifier|*
name|o_pak
decl_stmt|;
name|sctp_route_t
modifier|*
name|ro
init|=
name|NULL
decl_stmt|;
name|struct
name|udphdr
modifier|*
name|udp
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
name|uint8_t
name|tos_value
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
init|=
name|NULL
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|net
operator|)
operator|&&
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_OUT_OF_SCOPE
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|stcb
condition|)
block|{
name|vrf_id
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
block|}
else|else
block|{
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* fill in the HMAC digest for any AUTH chunk in the packet */
if|if
condition|(
operator|(
name|auth
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|sctp_fill_hmac_digest_m
argument_list|(
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|stcb
argument_list|,
name|auth_keyid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
condition|)
block|{
name|tos_value
operator|=
name|net
operator|->
name|dscp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb
condition|)
block|{
name|tos_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_dscp
expr_stmt|;
block|}
else|else
block|{
name|tos_value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_dscp
expr_stmt|;
block|}
switch|switch
condition|(
name|to
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
name|sctp_route_t
name|iproute
decl_stmt|;
name|int
name|len
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
name|newm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|1
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|newm
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_ALIGN_TO_END
argument_list|(
name|newm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|newm
argument_list|)
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|newm
argument_list|)
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|newm
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|net
operator|->
name|flowidset
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Flow ID not set"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|net
operator|->
name|flowid
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|use_mflowid
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|mflowid
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
block|}
name|packet_length
operator|=
name|sctp_calculate_len
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|tos_value
operator|==
literal|0
condition|)
block|{
comment|/* 				 * This means especially, that it is not set 				 * at the SCTP layer. So use the value from 				 * the IP layer. 				 */
name|tos_value
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_tos
expr_stmt|;
block|}
name|tos_value
operator|&=
literal|0xfc
expr_stmt|;
if|if
condition|(
name|ecn_ok
condition|)
block|{
name|tos_value
operator||=
name|sctp_get_ect
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nofragment_flag
operator|)
operator|&&
operator|(
name|port
operator|==
literal|0
operator|)
condition|)
block|{
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
name|IP_DF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|ip_off
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* FreeBSD has a function for ip_id's */
name|ip
operator|->
name|ip_id
operator|=
name|ip_newid
argument_list|()
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_ttl
expr_stmt|;
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|packet_length
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
name|tos_value
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
block|}
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|ro
operator|=
operator|&
name|iproute
expr_stmt|;
name|memset
argument_list|(
operator|&
name|iproute
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iproute
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|to
argument_list|,
name|to
operator|->
name|sa_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
expr_stmt|;
block|}
comment|/* Now the address selection part */
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
comment|/* call the routine to select the src address */
if|if
condition|(
name|net
operator|&&
name|out_of_asoc_ok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|localifa_flags
operator|&
operator|(
name|SCTP_BEING_DELETED
operator||
name|SCTP_ADDR_IFA_UNUSEABLE
operator|)
operator|)
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* Cache the source address */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
block|{
comment|/* No route to host */
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|ip
operator|->
name|ip_src
operator|=
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|over_addr
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|_lsrc
decl_stmt|;
name|_lsrc
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
name|out_of_asoc_ok
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lsrc
operator|==
name|NULL
condition|)
block|{
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|ip
operator|->
name|ip_src
operator|=
name|_lsrc
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|_lsrc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|ip_src
operator|=
name|over_addr
operator|->
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|SCTP_RTALLOC
argument_list|(
name|ro
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|port
condition|)
block|{
if|if
condition|(
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|udp
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|port
expr_stmt|;
name|udp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
name|packet_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_udp_cksum
condition|)
block|{
name|udp
operator|->
name|uh_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|udp
operator|->
name|uh_ulen
operator|+
name|htons
argument_list|(
name|IPPROTO_UDP
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|udp
operator|->
name|uh_sum
operator|=
literal|0
expr_stmt|;
block|}
name|sctphdr
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|udp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sctphdr
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
expr_stmt|;
block|}
name|sctphdr
operator|->
name|src_port
operator|=
name|src_port
expr_stmt|;
name|sctphdr
operator|->
name|dest_port
operator|=
name|dest_port
expr_stmt|;
name|sctphdr
operator|->
name|v_tag
operator|=
name|v_tag
expr_stmt|;
name|sctphdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If source address selection fails and we find no 			 * route then the ip_output should fail as well with 			 * a NO_ROUTE_TO_HOST type error. We probably should 			 * catch that somewhere and abort the association 			 * right away (assuming this is an INIT being sent). 			 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * src addr selection failed to find a route 				 * (or valid source addr), so we can't get 				 * there from here (yet)! 				 */
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
if|if
condition|(
name|ro
operator|!=
operator|&
name|iproute
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|iproute
argument_list|,
name|ro
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ro
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"Calling ipv4 output routine from low level src addr:%x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"Destination is %x\n"
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"RTP route is %p through\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
name|o_pak
argument_list|)
condition|)
block|{
comment|/* failed to prepend data, give up */
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|m
argument_list|,
name|packet_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctphdr
operator|->
name|checksum
operator|=
name|sctp_calculate_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendswcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|V_udp_cksum
condition|)
block|{
name|SCTP_ENABLE_UDP_CSUM
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_SCTP
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendhwcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LAST_PACKET_TRACING
condition|)
name|sctp_packet_log
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* send it out.  table id is taken from stcb */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_output_unlocked
argument_list|)
operator|)
operator|&&
operator|(
name|so_locked
operator|)
condition|)
block|{
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_IP_OUTPUT
argument_list|(
name|ret
argument_list|,
name|o_pak
argument_list|,
name|ro
argument_list|,
name|stcb
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_output_unlocked
argument_list|)
operator|)
operator|&&
operator|(
name|so_locked
operator|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_senderrors
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"IP output returns %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* free tempy routes */
name|RO_RTFREE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * PMTU check versus smallest asoc MTU goes 				 * here 				 */
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|)
condition|)
block|{
name|uint32_t
name|mtu
decl_stmt|;
name|mtu
operator|=
name|SCTP_GATHER_MTU_FROM_ROUTE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|port
condition|)
block|{
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtu
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|mtu
operator|)
condition|)
block|{
name|sctp_mtu_size_reset
argument_list|(
name|inp
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|net
operator|->
name|mtu
operator|=
name|mtu
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* route was freed */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|uint32_t
name|flowlabel
decl_stmt|,
name|flowinfo
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6h
decl_stmt|;
name|struct
name|route_in6
name|ip6route
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
name|tmp
decl_stmt|,
modifier|*
name|lsa6
decl_stmt|,
name|lsa6_tmp
decl_stmt|;
name|int
name|prev_scope
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in6
name|lsa6_storage
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_short
name|prev_port
init|=
literal|0
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|flowlabel
operator|=
name|net
operator|->
name|flowlabel
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb
condition|)
block|{
name|flowlabel
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
expr_stmt|;
block|}
else|else
block|{
name|flowlabel
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
expr_stmt|;
block|}
if|if
condition|(
name|flowlabel
operator|==
literal|0
condition|)
block|{
comment|/* 				 * This means especially, that it is not set 				 * at the SCTP layer. So use the value from 				 * the IP layer. 				 */
name|flowlabel
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
argument_list|)
expr_stmt|;
block|}
name|flowlabel
operator|&=
literal|0x000fffff
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
name|newm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|1
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|newm
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_ALIGN_TO_END
argument_list|(
name|newm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|newm
argument_list|)
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|newm
argument_list|)
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|newm
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|net
operator|->
name|flowidset
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Flow ID not set"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|net
operator|->
name|flowid
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|use_mflowid
operator|!=
literal|0
condition|)
block|{
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|mflowid
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
block|}
name|packet_length
operator|=
name|sctp_calculate_len
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ip6h
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
comment|/* protect *sin6 from overwrite */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|tmp
operator|=
operator|*
name|sin6
expr_stmt|;
name|sin6
operator|=
operator|&
name|tmp
expr_stmt|;
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|memset
argument_list|(
operator|&
name|ip6route
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ip6route
argument_list|)
argument_list|)
expr_stmt|;
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|ip6route
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ro
operator|->
name|ro_dst
argument_list|,
name|sin6
argument_list|,
name|sin6
operator|->
name|sin6_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ro
operator|=
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
expr_stmt|;
block|}
comment|/* 			 * We assume here that inp_flow is in host byte 			 * order within the TCB! 			 */
if|if
condition|(
name|tos_value
operator|==
literal|0
condition|)
block|{
comment|/* 				 * This means especially, that it is not set 				 * at the SCTP layer. So use the value from 				 * the IP layer. 				 */
name|tos_value
operator|=
operator|(
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
name|tos_value
operator|&=
literal|0xfc
expr_stmt|;
if|if
condition|(
name|ecn_ok
condition|)
block|{
name|tos_value
operator||=
name|sctp_get_ect
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|flowinfo
operator|=
literal|0x06
expr_stmt|;
name|flowinfo
operator|<<=
literal|8
expr_stmt|;
name|flowinfo
operator||=
name|tos_value
expr_stmt|;
name|flowinfo
operator|<<=
literal|20
expr_stmt|;
name|flowinfo
operator||=
name|flowlabel
expr_stmt|;
name|ip6h
operator|->
name|ip6_flow
operator|=
name|htonl
argument_list|(
name|flowinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|ip6h
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
else|else
block|{
name|ip6h
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_SCTP
expr_stmt|;
block|}
name|ip6h
operator|->
name|ip6_plen
operator|=
operator|(
name|packet_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
name|ip6h
operator|->
name|ip6_dst
operator|=
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
comment|/* 			 * Add SRC address selection here: we can only reuse 			 * to a limited degree the kame src-addr-sel, since 			 * we can try their selection but it may not be 			 * bound. 			 */
name|bzero
argument_list|(
operator|&
name|lsa6_tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa6_tmp
argument_list|)
argument_list|)
expr_stmt|;
name|lsa6_tmp
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|lsa6_tmp
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa6_tmp
argument_list|)
expr_stmt|;
name|lsa6
operator|=
operator|&
name|lsa6_tmp
expr_stmt|;
if|if
condition|(
name|net
operator|&&
name|out_of_asoc_ok
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|localifa_flags
operator|&
operator|(
name|SCTP_BEING_DELETED
operator||
name|SCTP_ADDR_IFA_UNUSEABLE
operator|)
operator|)
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* Cache the source address */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"V6:No route to host\n"
argument_list|)
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|lsa6
operator|->
name|sin6_addr
operator|=
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
block|}
else|else
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
expr_stmt|;
comment|/* KAME hack: embed scopeid */
if|if
condition|(
name|sa6_embedscope
argument_list|(
name|sin6
argument_list|,
name|MODULE_GLOBAL
argument_list|(
name|ip6_use_defzone
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|over_addr
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|_lsrc
decl_stmt|;
name|_lsrc
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ro
argument_list|,
name|net
argument_list|,
name|out_of_asoc_ok
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lsrc
operator|==
name|NULL
condition|)
block|{
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|lsa6
operator|->
name|sin6_addr
operator|=
name|_lsrc
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|_lsrc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lsa6
operator|->
name|sin6_addr
operator|=
name|over_addr
operator|->
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
name|SCTP_RTALLOC
argument_list|(
name|ro
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
block|}
name|lsa6
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * src addr selection failed to find a route 				 * (or valid source addr), so we can't get 				 * there from here! 				 */
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
comment|/* 			 * XXX: sa6 may not have a valid sin6_scope_id in 			 * the non-SCOPEDROUTING case. 			 */
name|bzero
argument_list|(
operator|&
name|lsa6_storage
argument_list|,
sizeof|sizeof
argument_list|(
name|lsa6_storage
argument_list|)
argument_list|)
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|lsa6_storage
argument_list|)
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_addr
operator|=
name|lsa6
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
operator|&
name|lsa6_storage
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"recover scope fails error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* XXX */
name|lsa6_storage
operator|.
name|sin6_addr
operator|=
name|lsa6
operator|->
name|sin6_addr
expr_stmt|;
name|lsa6_storage
operator|.
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|lsa6
operator|=
operator|&
name|lsa6_storage
expr_stmt|;
name|ip6h
operator|->
name|ip6_src
operator|=
name|lsa6
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
if|if
condition|(
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_handle_no_route
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|EHOSTUNREACH
operator|)
return|;
block|}
name|udp
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6h
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|port
expr_stmt|;
name|udp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
name|packet_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_sum
operator|=
literal|0
expr_stmt|;
name|sctphdr
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|udp
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|sctphdr
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6h
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
block|}
name|sctphdr
operator|->
name|src_port
operator|=
name|src_port
expr_stmt|;
name|sctphdr
operator|->
name|dest_port
operator|=
name|dest_port
expr_stmt|;
name|sctphdr
operator|->
name|v_tag
operator|=
name|v_tag
expr_stmt|;
name|sctphdr
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* 			 * We set the hop limit now since there is a good 			 * chance that our ro pointer is now filled 			 */
name|ip6h
operator|->
name|ip6_hlim
operator|=
name|SCTP_GET_HLIM
argument_list|(
name|inp
argument_list|,
name|ro
argument_list|)
expr_stmt|;
name|ifp
operator|=
name|SCTP_GET_IFN_VOID_FROM_ROUTE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
comment|/* Copy to be sure something bad is not happening */
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6h
operator|->
name|ip6_dst
expr_stmt|;
name|lsa6
operator|->
name|sin6_addr
operator|=
name|ip6h
operator|->
name|ip6_src
expr_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"Calling ipv6 output routine from low level\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"src: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|lsa6
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"dst: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
comment|/* 				 * preserve the port and scope for link 				 * local send 				 */
name|prev_scope
operator|=
name|sin6
operator|->
name|sin6_scope_id
expr_stmt|;
name|prev_port
operator|=
name|sin6
operator|->
name|sin6_port
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
name|o_pak
argument_list|)
condition|)
block|{
comment|/* failed to prepend data, give up */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|m
argument_list|,
name|packet_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctphdr
operator|->
name|checksum
operator|=
name|sctp_calculate_cksum
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendswcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|udp
operator|->
name|uh_sum
operator|=
name|in6_cksum
argument_list|(
name|o_pak
argument_list|,
name|IPPROTO_UDP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|packet_length
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|udp
operator|->
name|uh_sum
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_SCTP_IPV6
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendhwcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* send it out. table id is taken from stcb */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_output_unlocked
argument_list|)
operator|)
operator|&&
operator|(
name|so_locked
operator|)
condition|)
block|{
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LAST_PACKET_TRACING
condition|)
name|sctp_packet_log
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_IP6_OUTPUT
argument_list|(
name|ret
argument_list|,
name|o_pak
argument_list|,
operator|(
expr|struct
name|route_in6
operator|*
operator|)
name|ro
argument_list|,
operator|&
name|ifp
argument_list|,
name|stcb
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_output_unlocked
argument_list|)
operator|)
operator|&&
operator|(
name|so_locked
operator|)
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
condition|)
block|{
comment|/* for link local this must be done */
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|prev_scope
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|prev_port
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"return from send is %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_senderrors
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* Now if we had a temp route free it */
name|RO_RTFREE
argument_list|(
name|ro
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * PMTU check versus smallest asoc MTU goes 				 * here 				 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* Route was freed */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|&&
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
block|}
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ro
operator|->
name|ro_rt
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|)
condition|)
block|{
name|uint32_t
name|mtu
decl_stmt|;
name|mtu
operator|=
name|SCTP_GATHER_MTU_FROM_ROUTE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|,
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtu
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|mtu
operator|)
condition|)
block|{
name|sctp_mtu_size_reset
argument_list|(
name|inp
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|net
operator|->
name|mtu
operator|=
name|mtu
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|port
condition|)
block|{
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|ifp
condition|)
block|{
if|if
condition|(
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
operator|)
condition|)
block|{
name|sctp_mtu_size_reset
argument_list|(
name|inp
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|ND_IFINFO
argument_list|(
name|ifp
argument_list|)
operator|->
name|linkmtu
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Unknown protocol (TSNH) type %d\n"
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|to
operator|)
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_send_initiate
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_last
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init
decl_stmt|;
name|struct
name|sctp_supported_addr_param
modifier|*
name|sup_addr
decl_stmt|;
name|struct
name|sctp_adaptation_layer_indication
modifier|*
name|ali
decl_stmt|;
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|int
name|cnt_inits_to
init|=
literal|0
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|uint16_t
name|num_ext
decl_stmt|,
name|chunk_len
decl_stmt|,
name|padding_len
decl_stmt|,
name|parameter_len
decl_stmt|;
comment|/* INIT's always go to the primary (and usually ONLY address) */
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
return|return;
block|}
comment|/* we confirm any address we send an INIT to */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* we confirm any address we send an INIT to */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT4
argument_list|,
literal|"Sending INIT\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* 		 * special hook, if we are sending to link local it will not 		 * show up in our private address count. 		 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
name|cnt_inits_to
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* This case should not happen */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT4
argument_list|,
literal|"Sending INIT - failed timer?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* start the INIT timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|1
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No memory, INIT timer will re-attempt. */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT4
argument_list|,
literal|"Sending INIT - mbuf?\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|chunk_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * assume peer supports asconf in order to be able to queue local 	 * address changes while an INIT is in flight and before the assoc 	 * is established. 	 */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
comment|/* Now lets put the chunk header in place */
name|init
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_init_chunk
operator|*
argument_list|)
expr_stmt|;
comment|/* now the chunk header */
name|init
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_INITIATION
expr_stmt|;
name|init
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
comment|/* fill in later from mbuf we build */
name|init
operator|->
name|ch
operator|.
name|chunk_length
operator|=
literal|0
expr_stmt|;
comment|/* place in my tag */
name|init
operator|->
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|)
expr_stmt|;
comment|/* set up some of the credits. */
name|init
operator|->
name|init
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|max
argument_list|(
name|inp
operator|->
name|sctp_socket
condition|?
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
else|:
literal|0
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
argument_list|)
expr_stmt|;
name|init
operator|->
name|init
operator|.
name|num_outbound_streams
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|pre_open_streams
argument_list|)
expr_stmt|;
name|init
operator|->
name|init
operator|.
name|num_inbound_streams
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|max_inbound_streams
argument_list|)
expr_stmt|;
name|init
operator|->
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|init_seq_number
argument_list|)
expr_stmt|;
comment|/* Adaptation layer indication parameter */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator_provided
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_layer_indication
argument_list|)
expr_stmt|;
name|ali
operator|=
operator|(
expr|struct
name|sctp_adaptation_layer_indication
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ULP_ADAPTATION
argument_list|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|ali
operator|->
name|indication
operator|=
name|htonl
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* ECN parameter */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_supported
operator|==
literal|1
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ECN_CAPABLE
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* PR-SCTP supported parameter */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|==
literal|1
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_PRSCTP_SUPPORTED
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* Add NAT friendly parameter. */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_inits_include_nat_friendly
argument_list|)
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HAS_NAT_SUPPORT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* And now tell the peer which extensions we support */
name|num_ext
operator|=
literal|0
expr_stmt|;
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUPPORTED_CHUNK_EXT
argument_list|)
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|==
literal|1
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|pktdrop_supported
operator|==
literal|1
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
block|}
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auth_disable
argument_list|)
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_AUTHENTICATION
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|nrsack_supported
operator|==
literal|1
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_NR_SELECTIVE_ACK
expr_stmt|;
block|}
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_supported_chunk_types_param
argument_list|)
operator|+
name|num_ext
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
comment|/* add authentication parameters */
if|if
condition|(
operator|!
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auth_disable
argument_list|)
condition|)
block|{
comment|/* attach RANDOM parameter, if available */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sctp_auth_random
modifier|*
name|randp
decl_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|randp
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_random
argument_list|)
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random_len
expr_stmt|;
comment|/* random key already contains the header */
name|memcpy
argument_list|(
name|randp
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|random
operator|->
name|key
argument_list|,
name|parameter_len
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* add HMAC_ALGO parameter */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|->
name|num_algo
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
decl_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|parameter_len
operator|=
call|(
name|uint16_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_hmac_algo
argument_list|)
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HMAC_LIST
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|sctp_serialize_hmaclist
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|hmacs
operator|->
name|hmac_ids
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* add CHUNKS parameter */
if|if
condition|(
name|sctp_auth_get_chklist_size
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
decl_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|parameter_len
operator|=
call|(
name|uint16_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk_list
argument_list|)
operator|+
name|sctp_auth_get_chklist_size
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CHUNK_LIST
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|sctp_serialize_auth_chunks
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|,
name|chunks
operator|->
name|chunk_types
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
block|}
comment|/* now any cookie time extensions */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cookie_preserve_req
condition|)
block|{
name|struct
name|sctp_cookie_perserve_param
modifier|*
name|cookie_preserve
decl_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_perserve_param
argument_list|)
expr_stmt|;
name|cookie_preserve
operator|=
operator|(
expr|struct
name|sctp_cookie_perserve_param
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|cookie_preserve
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_COOKIE_PRESERVE
argument_list|)
expr_stmt|;
name|cookie_preserve
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|cookie_preserve
operator|->
name|time
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cookie_preserve_req
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cookie_preserve_req
operator|=
literal|0
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_addr_legal
operator|||
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv6_addr_legal
condition|)
block|{
name|uint8_t
name|i
decl_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_addr_legal
condition|)
block|{
name|parameter_len
operator|+=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv6_addr_legal
condition|)
block|{
name|parameter_len
operator|+=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
block|}
name|sup_addr
operator|=
operator|(
expr|struct
name|sctp_supported_addr_param
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|sup_addr
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUPPORTED_ADDRTYPE
argument_list|)
expr_stmt|;
name|sup_addr
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_addr_legal
condition|)
block|{
name|sup_addr
operator|->
name|addr_type
index|[
name|i
operator|++
index|]
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv6_addr_legal
condition|)
block|{
name|sup_addr
operator|->
name|addr_type
index|[
name|i
operator|++
index|]
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
block|}
name|padding_len
operator|=
literal|4
operator|-
literal|2
operator|*
name|i
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|chunk_len
expr_stmt|;
comment|/* now the addresses */
comment|/* 	 * To optimize this we could put the scoping stuff into a structure 	 * and remove the individual uint8's from the assoc structure. Then 	 * we could just sifa in the address within the stcb. But for now 	 * this is a quick hack to get the address stuff teased apart. 	 */
name|m_last
operator|=
name|sctp_add_addresses_to_i_ia
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
name|m
argument_list|,
name|cnt_inits_to
argument_list|,
operator|&
name|padding_len
argument_list|,
operator|&
name|chunk_len
argument_list|)
expr_stmt|;
name|init
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chunk_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_add_pad_tombuf
argument_list|(
name|m_last
argument_list|,
name|padding_len
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT4
argument_list|,
literal|"Sending INIT - calls lowlevel_output\n"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
literal|0
argument_list|)
argument_list|,
name|net
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT4
argument_list|,
literal|"lowlevel_output - %d\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_arethere_unrecognized_parameters
parameter_list|(
name|struct
name|mbuf
modifier|*
name|in_initpkt
parameter_list|,
name|int
name|param_offset
parameter_list|,
name|int
modifier|*
name|abort_processing
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|nat_friendly
parameter_list|)
block|{
comment|/* 	 * Given a mbuf containing an INIT or INIT-ACK with the param_offset 	 * being equal to the beginning of the params i.e. (iphlen + 	 * sizeof(struct sctp_init_msg) parse through the parameters to the 	 * end of the mbuf verifying that all parameters are known. 	 *  	 * For unknown parameters build and return a mbuf with 	 * UNRECOGNIZED_PARAMETER errors. If the flags indicate to stop 	 * processing this chunk stop, and set *abort_processing to 1. 	 *  	 * By having param_offset be pre-set to where parameters begin it is 	 * hoped that this routine may be reused in the future by new 	 * features. 	 */
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|params
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|,
modifier|*
name|op_err
decl_stmt|;
name|char
name|tempbuf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|int
name|at
decl_stmt|,
name|limit
decl_stmt|,
name|pad_needed
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|,
name|padded_size
decl_stmt|;
name|int
name|err_at
decl_stmt|;
operator|*
name|abort_processing
operator|=
literal|0
expr_stmt|;
name|mat
operator|=
name|in_initpkt
expr_stmt|;
name|err_at
operator|=
literal|0
expr_stmt|;
name|limit
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|at
operator|=
name|param_offset
expr_stmt|;
name|op_err
operator|=
name|NULL
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Check for unrecognized param's\n"
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|phdr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|limit
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plen
operator|>
name|limit
operator|)
operator|||
operator|(
name|plen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
condition|)
block|{
comment|/* wacked parameter */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|limit
operator|-=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
comment|/*- 		 * All parameters for all chunks that we know/understand are 		 * listed here. We process them other places and make 		 * appropriate stop actions per the upper bits. However this 		 * is the generic routine processor's can call to get back 		 * an operr.. to either incorporate (init-ack) or send. 		 */
name|padded_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
comment|/* Param's with variable size */
case|case
name|SCTP_HEARTBEAT_INFO
case|:
case|case
name|SCTP_STATE_COOKIE
case|:
case|case
name|SCTP_UNRECOG_PARAM
case|:
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
comment|/* ok skip fwd */
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
comment|/* Param's with variable size within a range */
case|case
name|SCTP_CHUNK_LIST
case|:
case|case
name|SCTP_SUPPORTED_CHUNK_EXT
case|:
if|if
condition|(
name|padded_size
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_supported_chunk_types_param
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
operator|*
name|SCTP_MAX_SUPPORTED_EXT
operator|)
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error chklist %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_SUPPORTED_ADDRTYPE
case|:
if|if
condition|(
name|padded_size
operator|>
name|SCTP_MAX_ADDR_PARAMS_SIZE
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error supaddrtype %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_RANDOM
case|:
if|if
condition|(
name|padded_size
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_random
argument_list|)
operator|+
name|SCTP_RANDOM_MAX_SIZE
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error random %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
if|if
condition|(
operator|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
operator|)
operator|&&
operator|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error setprim %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
comment|/* Param's with a fixed size */
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error ipv4 addr %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error ipv6 addr %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_COOKIE_PRESERVE
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_perserve_param
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error cookie-preserve %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_HAS_NAT_SUPPORT
case|:
operator|*
name|nat_friendly
operator|=
literal|1
expr_stmt|;
comment|/* fall through */
case|case
name|SCTP_PRSCTP_SUPPORTED
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error prsctp/nat support %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_ECN_CAPABLE
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error ecn %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_ULP_ADAPTATION
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_layer_indication
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error adapatation %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
if|if
condition|(
name|padded_size
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Invalid size - error success %d\n"
argument_list|,
name|plen
argument_list|)
expr_stmt|;
goto|goto
name|invalid_size
goto|;
block|}
name|at
operator|+=
name|padded_size
expr_stmt|;
break|break;
case|case
name|SCTP_HOSTNAME_ADDRESS
case|:
block|{
comment|/* We can NOT handle HOST NAME addresses!! */
name|int
name|l_len
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Can't handle hostname addresses.. abort processing\n"
argument_list|)
expr_stmt|;
operator|*
name|abort_processing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
comment|/* Ok need to try to get a mbuf */
ifdef|#
directive|ifdef
name|INET6
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
else|#
directive|else
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l_len
operator|+=
name|plen
expr_stmt|;
name|l_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|l_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* 						 * pre-reserve space for ip 						 * and sctp header  and 						 * chunk hdr 						 */
ifdef|#
directive|ifdef
name|INET6
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* If we have space */
name|struct
name|sctp_paramhdr
name|s
decl_stmt|;
if|if
condition|(
name|err_at
operator|%
literal|4
condition|)
block|{
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|pad_needed
operator|=
literal|4
operator|-
operator|(
name|err_at
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|pad_needed
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|pad_needed
expr_stmt|;
block|}
name|s
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|)
expr_stmt|;
name|s
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|+
name|plen
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|err_at
operator|+=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|tempbuf
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
comment|/* 						 * we are out of memory but 						 * we still need to have a 						 * look at what to do (the 						 * system is in trouble 						 * though). 						 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|plen
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|op_err
operator|)
return|;
break|break;
block|}
default|default:
comment|/* 			 * we do not recognize the parameter figure out what 			 * we do. 			 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Hit default param %x\n"
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ptype
operator|&
literal|0x4000
operator|)
operator|==
literal|0x4000
condition|)
block|{
comment|/* Report bit is set?? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"report op err\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
name|int
name|l_len
decl_stmt|;
comment|/* Ok need to try to get an mbuf */
ifdef|#
directive|ifdef
name|INET6
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
else|#
directive|else
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l_len
operator|+=
name|plen
expr_stmt|;
name|l_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|l_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* If we have space */
name|struct
name|sctp_paramhdr
name|s
decl_stmt|;
if|if
condition|(
name|err_at
operator|%
literal|4
condition|)
block|{
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|pad_needed
operator|=
literal|4
operator|-
operator|(
name|err_at
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|pad_needed
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|pad_needed
expr_stmt|;
block|}
name|s
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_UNRECOG_PARAM
argument_list|)
expr_stmt|;
name|s
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|+
name|plen
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|err_at
operator|+=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
condition|)
block|{
name|plen
operator|=
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
expr_stmt|;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|tempbuf
argument_list|,
name|min
argument_list|(
sizeof|sizeof
argument_list|(
name|tempbuf
argument_list|)
argument_list|,
name|plen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
comment|/* 						 * we are out of memory but 						 * we still need to have a 						 * look at what to do (the 						 * system is in trouble 						 * though). 						 */
name|op_err
operator|=
name|NULL
expr_stmt|;
goto|goto
name|more_processing
goto|;
block|}
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|plen
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|plen
expr_stmt|;
block|}
block|}
name|more_processing
label|:
if|if
condition|(
operator|(
name|ptype
operator|&
literal|0x8000
operator|)
operator|==
literal|0x0000
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"stop proc\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|op_err
operator|)
return|;
block|}
else|else
block|{
comment|/* skip this chunk and continue processing */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"move on\n"
argument_list|)
expr_stmt|;
name|at
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|mat
argument_list|,
name|at
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|op_err
operator|)
return|;
name|invalid_size
label|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"abort flag set\n"
argument_list|)
expr_stmt|;
operator|*
name|abort_processing
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|op_err
operator|==
name|NULL
operator|)
operator|&&
name|phdr
condition|)
block|{
name|int
name|l_len
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
else|#
directive|else
name|l_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l_len
operator|+=
operator|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|l_len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|op_err
operator|)
operator|&&
name|phdr
condition|)
block|{
name|struct
name|sctp_paramhdr
name|s
decl_stmt|;
if|if
condition|(
name|err_at
operator|%
literal|4
condition|)
block|{
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|pad_needed
operator|=
literal|4
operator|-
operator|(
name|err_at
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
name|pad_needed
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
name|err_at
operator|+=
name|pad_needed
expr_stmt|;
block|}
name|s
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|)
expr_stmt|;
name|s
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
name|s
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
name|s
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|s
argument_list|)
expr_stmt|;
name|err_at
operator|+=
sizeof|sizeof
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Only copy back the p-hdr that caused the issue */
name|m_copyback
argument_list|(
name|op_err
argument_list|,
name|err_at
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
name|phdr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|op_err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_are_there_new_addresses
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|in_initpkt
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
comment|/* 	 * Given a INIT packet, look through the packet to verify that there 	 * are NO new addresses. As we go through the parameters add reports 	 * of any un-understood parameters that require an error.  Also we 	 * must return (1) to drop the packet if we see a un-understood 	 * parameter that tells us to drop the chunk. 	 */
name|struct
name|sockaddr
modifier|*
name|sa_touse
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|,
name|params
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
name|uint8_t
name|fnd
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin4
decl_stmt|,
modifier|*
name|sa4
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|,
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|memset
argument_list|(
operator|&
name|sin4
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
argument_list|)
expr_stmt|;
name|sin4
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin4
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin4
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* First what about the src address of the pkt ? */
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|src
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|src4
decl_stmt|;
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
name|src4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
expr_stmt|;
if|if
condition|(
name|sa4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|src4
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|src6
decl_stmt|;
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|src6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sa6
argument_list|,
name|src6
argument_list|)
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|fnd
operator|==
literal|0
condition|)
block|{
comment|/* New address added! no need to look futher. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Ok so far lets munge through the rest of the packet */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|in_initpkt
argument_list|,
name|offset
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|phdr
condition|)
block|{
name|sa_touse
operator|=
name|NULL
expr_stmt|;
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|p4
decl_stmt|,
name|p4_buf
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|in_initpkt
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p4_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p4_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p4
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|sin4
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|p4
operator|->
name|addr
expr_stmt|;
name|sa_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin4
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p6
decl_stmt|,
name|p6_buf
decl_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|in_initpkt
argument_list|,
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|p6_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|p6_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p6
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|phdr
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|p6
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|p6
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|sa_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
name|sa_touse
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sa_touse
condition|)
block|{
comment|/* ok, sa_touse points to one to check */
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|sa_touse
operator|->
name|sa_family
condition|)
block|{
continue|continue;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sa4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|sin4
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|SCTP6_ARE_ADDR_EQUAL
argument_list|(
name|sa6
argument_list|,
operator|&
name|sin6
argument_list|)
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
comment|/* New addr added! no need to look further */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|in_initpkt
argument_list|,
name|offset
argument_list|,
operator|&
name|params
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a MBUF chain that was sent into us containing an INIT. Build a  * INIT-ACK with COOKIE and send back. We assume that the in_initpkt has done  * a pullup to include IPv6/4header, SCTP header and initial part of INIT  * message (i.e. the struct sctp_init_msg).  */
end_comment

begin_function
name|void
name|sctp_send_initiate_ack
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|init_pkt
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_chunk
modifier|*
name|init_chk
parameter_list|,
name|uint8_t
name|use_mflowid
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|,
name|int
name|hold_inp_lock
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_tmp
decl_stmt|,
modifier|*
name|m_last
decl_stmt|,
modifier|*
name|m_cookie
decl_stmt|,
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_init_ack_chunk
modifier|*
name|initack
decl_stmt|;
name|struct
name|sctp_adaptation_layer_indication
modifier|*
name|ali
decl_stmt|;
name|struct
name|sctp_supported_chunk_types_param
modifier|*
name|pr_supported
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|union
name|sctp_sockstore
modifier|*
name|over_addr
decl_stmt|;
name|struct
name|sctp_scoping
name|scp
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|dst4
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|src4
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|dst6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|src6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr
modifier|*
name|to
decl_stmt|;
name|struct
name|sctp_state_cookie
name|stc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|uint8_t
modifier|*
name|signature
init|=
name|NULL
decl_stmt|;
name|int
name|cnt_inits_to
init|=
literal|0
decl_stmt|;
name|uint16_t
name|his_limit
decl_stmt|,
name|i_want
decl_stmt|;
name|int
name|abort_flag
decl_stmt|;
name|int
name|nat_friendly
init|=
literal|0
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|uint16_t
name|num_ext
decl_stmt|,
name|chunk_len
decl_stmt|,
name|padding_len
decl_stmt|,
name|parameter_len
decl_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|&&
operator|(
name|sctp_are_there_new_addresses
argument_list|(
name|asoc
argument_list|,
name|init_pkt
argument_list|,
name|offset
argument_list|,
name|src
argument_list|)
operator|)
condition|)
block|{
comment|/* new addresses, out of here in non-cookie-wait states */
comment|/* 		 * Send a ABORT, we don't add the new address error clause 		 * though we even set the T bit and copy in the 0 tag.. this 		 * looks no different than if no listener was present. 		 */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Address added"
argument_list|)
expr_stmt|;
name|sctp_send_abort
argument_list|(
name|init_pkt
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
name|abort_flag
operator|=
literal|0
expr_stmt|;
name|op_err
operator|=
name|sctp_arethere_unrecognized_parameters
argument_list|(
name|init_pkt
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|)
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|init_chk
argument_list|,
operator|&
name|nat_friendly
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
name|do_a_abort
label|:
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"%s:%d at %s\n"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|sctp_send_abort
argument_list|(
name|init_pkt
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
argument_list|,
name|op_err
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* No memory, INIT timer will re-attempt. */
if|if
condition|(
name|op_err
condition|)
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
return|return;
block|}
name|chunk_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We might not overwrite the identification[] completely and on 	 * some platforms time_entered will contain some padding. Therefore 	 * zero out the cookie to avoid putting uninitialized memory on the 	 * wire. 	 */
name|memset
argument_list|(
operator|&
name|stc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_state_cookie
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the time I built cookie */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* populate any tie tags */
if|if
condition|(
name|asoc
operator|!=
name|NULL
condition|)
block|{
comment|/* unlock before tag selections */
name|stc
operator|.
name|tie_tag_my_vtag
operator|=
name|asoc
operator|->
name|my_vtag_nonce
expr_stmt|;
name|stc
operator|.
name|tie_tag_peer_vtag
operator|=
name|asoc
operator|->
name|peer_vtag_nonce
expr_stmt|;
name|stc
operator|.
name|cookie_life
operator|=
name|asoc
operator|->
name|cookie_life
expr_stmt|;
name|net
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
else|else
block|{
name|stc
operator|.
name|tie_tag_my_vtag
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|tie_tag_peer_vtag
operator|=
literal|0
expr_stmt|;
comment|/* life I will award this cookie */
name|stc
operator|.
name|cookie_life
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
expr_stmt|;
block|}
comment|/* copy in the ports for later check */
name|stc
operator|.
name|myport
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|stc
operator|.
name|peerport
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
comment|/* 	 * If we wanted to honor cookie life extentions, we would add to 	 * stc.cookie_life. For now we should NOT honor any extension 	 */
name|stc
operator|.
name|site_scope
operator|=
name|stc
operator|.
name|local_scope
operator|=
name|stc
operator|.
name|loopback_scope
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|stc
operator|.
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
condition|)
block|{
name|stc
operator|.
name|ipv4_addr_legal
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|stc
operator|.
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|stc
operator|.
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DONT_DO_PRIVADDR_SCOPE
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|stc
operator|.
name|ipv4_scope
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|to
operator|=
name|src
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
comment|/* lookup address */
name|stc
operator|.
name|address
index|[
literal|0
index|]
operator|=
name|src4
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
comment|/* local from address */
name|stc
operator|.
name|laddress
index|[
literal|0
index|]
operator|=
name|dst4
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
comment|/* scope_id is only for v6 */
name|stc
operator|.
name|scope_id
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|SCTP_DONT_DO_PRIVADDR_SCOPE
if|if
condition|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|src4
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
block|}
else|#
directive|else
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DONT_DO_PRIVADDR_SCOPE */
comment|/* Must use the address in this case */
if|if
condition|(
name|sctp_is_address_on_local_host
argument_list|(
name|src
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
name|stc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|address
argument_list|,
operator|&
name|src6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|scope_id
operator|=
name|in6_getscope
argument_list|(
operator|&
name|src6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_address_on_local_host
argument_list|(
name|src
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
name|stc
operator|.
name|loopback_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|src6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * If the new destination is a 					 * LINK_LOCAL we must have common 					 * both site and local scope. Don't 					 * set local scope though since we 					 * must depend on the source to be 					 * added implicitly. We cannot 					 * assure just because we share one 					 * link that all links are common. 					 */
name|stc
operator|.
name|local_scope
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
comment|/* 					 * we start counting for the private 					 * address stuff at 1. since the 					 * link local we source from won't 					 * show up in our scoped count. 					 */
name|cnt_inits_to
operator|=
literal|1
expr_stmt|;
comment|/* 					 * pull out the scope_id from 					 * incoming pkt 					 */
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|src6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * If the new destination is 					 * SITE_LOCAL then we must have site 					 * scope in common. 					 */
name|stc
operator|.
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|laddress
argument_list|,
operator|&
name|dst6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
goto|goto
name|do_a_abort
goto|;
break|break;
block|}
block|}
else|else
block|{
comment|/* set the scope per the existing tcb */
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
endif|#
directive|endif
name|stc
operator|.
name|loopback_scope
operator|=
name|asoc
operator|->
name|scope
operator|.
name|loopback_scope
expr_stmt|;
name|stc
operator|.
name|ipv4_scope
operator|=
name|asoc
operator|->
name|scope
operator|.
name|ipv4_local_scope
expr_stmt|;
name|stc
operator|.
name|site_scope
operator|=
name|asoc
operator|->
name|scope
operator|.
name|site_scope
expr_stmt|;
name|stc
operator|.
name|local_scope
operator|=
name|asoc
operator|->
name|scope
operator|.
name|local_scope
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
comment|/* Why do we not consider IPv4 LL addresses? */
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|lnet
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|lnet
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 					 * if we have a LL address, start 					 * counting at 1. 					 */
name|cnt_inits_to
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* use the net pointer */
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
switch|switch
condition|(
name|to
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|to
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|0
index|]
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|address
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* 				 * strange case here, the INIT should have 				 * did the selection. 				 */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
return|return;
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
name|stc
operator|.
name|laddress
index|[
literal|0
index|]
operator|=
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddress
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
comment|/* scope_id is only for v6 */
name|stc
operator|.
name|scope_id
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|to
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|address
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|addr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|stc
operator|.
name|scope_id
operator|=
name|sin6
operator|->
name|sin6_scope_id
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|src_addr_selected
operator|==
literal|0
condition|)
block|{
comment|/* 				 * strange case here, the INIT should have 				 * done the selection. 				 */
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|NULL
condition|)
return|return;
name|net
operator|->
name|src_addr_selected
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|stc
operator|.
name|laddress
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|stc
operator|.
name|laddr_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
comment|/* Now lets put the SCTP header in place */
name|initack
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_init_ack_chunk
operator|*
argument_list|)
expr_stmt|;
comment|/* Save it off for quick ref */
name|stc
operator|.
name|peers_vtag
operator|=
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
expr_stmt|;
comment|/* who are we */
name|memcpy
argument_list|(
name|stc
operator|.
name|identification
argument_list|,
name|SCTP_VERSION_STRING
argument_list|,
name|min
argument_list|(
name|strlen
argument_list|(
name|SCTP_VERSION_STRING
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|stc
operator|.
name|identification
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stc
operator|.
name|reserved
argument_list|,
literal|0
argument_list|,
name|SCTP_RESERVE_SPACE
argument_list|)
expr_stmt|;
comment|/* now the chunk header */
name|initack
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_INITIATION_ACK
expr_stmt|;
name|initack
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
comment|/* fill in later from mbuf we build */
name|initack
operator|->
name|ch
operator|.
name|chunk_length
operator|=
literal|0
expr_stmt|;
comment|/* place in my tag */
if|if
condition|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_INUSE
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|)
condition|)
block|{
comment|/* re-use the v-tags and init-seq here */
name|initack
operator|->
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|my_vtag
argument_list|)
expr_stmt|;
name|initack
operator|->
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|init_seq_number
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint32_t
name|vtag
decl_stmt|,
name|itsn
decl_stmt|;
if|if
condition|(
name|hold_inp_lock
condition|)
block|{
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|new_tag
label|:
name|vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|peer_supports_nat
operator|)
operator|&&
operator|(
name|vtag
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
condition|)
block|{
comment|/* 				 * Got a duplicate vtag on some guy behind a 				 * nat make sure we don't use it. 				 */
goto|goto
name|new_tag
goto|;
block|}
name|initack
operator|->
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|vtag
argument_list|)
expr_stmt|;
comment|/* get a TSN to use too */
name|itsn
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|initack
operator|->
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|itsn
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|initack
operator|->
name|init
operator|.
name|initiate_tag
operator|=
name|htonl
argument_list|(
name|vtag
argument_list|)
expr_stmt|;
comment|/* get a TSN to use too */
name|initack
operator|->
name|init
operator|.
name|initial_tsn
operator|=
name|htonl
argument_list|(
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|inp
operator|->
name|sctp_ep
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hold_inp_lock
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* save away my tag to */
name|stc
operator|.
name|my_vtag
operator|=
name|initack
operator|->
name|init
operator|.
name|initiate_tag
expr_stmt|;
comment|/* set up some of the credits. */
name|so
operator|=
name|inp
operator|->
name|sctp_socket
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
comment|/* memory problem */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|initack
operator|->
name|init
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|max
argument_list|(
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
argument_list|,
name|SCTP_MINIMAL_RWND
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set what I want */
name|his_limit
operator|=
name|ntohs
argument_list|(
name|init_chk
operator|->
name|init
operator|.
name|num_inbound_streams
argument_list|)
expr_stmt|;
comment|/* choose what I want */
if|if
condition|(
name|asoc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|streamoutcnt
operator|>
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
condition|)
block|{
name|i_want
operator|=
name|asoc
operator|->
name|streamoutcnt
expr_stmt|;
block|}
else|else
block|{
name|i_want
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
block|}
block|}
else|else
block|{
name|i_want
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
block|}
if|if
condition|(
name|his_limit
operator|<
name|i_want
condition|)
block|{
comment|/* I Want more :< */
name|initack
operator|->
name|init
operator|.
name|num_outbound_streams
operator|=
name|init_chk
operator|->
name|init
operator|.
name|num_inbound_streams
expr_stmt|;
block|}
else|else
block|{
comment|/* I can have what I want :> */
name|initack
operator|->
name|init
operator|.
name|num_outbound_streams
operator|=
name|htons
argument_list|(
name|i_want
argument_list|)
expr_stmt|;
block|}
comment|/* tell him his limit. */
name|initack
operator|->
name|init
operator|.
name|num_inbound_streams
operator|=
name|htons
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
argument_list|)
expr_stmt|;
comment|/* adaptation layer indication parameter */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator_provided
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_adaptation_layer_indication
argument_list|)
expr_stmt|;
name|ali
operator|=
operator|(
expr|struct
name|sctp_adaptation_layer_indication
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ULP_ADAPTATION
argument_list|)
expr_stmt|;
name|ali
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|ali
operator|->
name|indication
operator|=
name|htonl
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* ECN parameter */
if|if
condition|(
operator|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|ecn_supported
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|ecn_supported
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ECN_CAPABLE
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* PR-SCTP supported parameter */
if|if
condition|(
operator|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|prsctp_supported
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|prsctp_supported
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_PRSCTP_SUPPORTED
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
comment|/* Add NAT friendly parameter */
if|if
condition|(
name|nat_friendly
condition|)
block|{
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HAS_NAT_SUPPORT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
block|}
comment|/* And now tell the peer which extensions we support */
name|num_ext
operator|=
literal|0
expr_stmt|;
name|pr_supported
operator|=
operator|(
expr|struct
name|sctp_supported_chunk_types_param
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUPPORTED_CHUNK_EXT
argument_list|)
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|prsctp_supported
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|prsctp_supported
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|pktdrop_supported
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|pktdrop_supported
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
block|}
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auth_disable
argument_list|)
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_AUTHENTICATION
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|asoc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|nrsack_supported
operator|==
literal|1
operator|)
operator|)
operator|||
operator|(
operator|(
name|asoc
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|nrsack_supported
operator|==
literal|1
operator|)
operator|)
condition|)
block|{
name|pr_supported
operator|->
name|chunk_types
index|[
name|num_ext
operator|++
index|]
operator|=
name|SCTP_NR_SELECTIVE_ACK
expr_stmt|;
block|}
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_supported_chunk_types_param
argument_list|)
operator|+
name|num_ext
expr_stmt|;
name|pr_supported
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
comment|/* add authentication parameters */
if|if
condition|(
operator|!
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auth_disable
argument_list|)
condition|)
block|{
name|struct
name|sctp_auth_random
modifier|*
name|randp
decl_stmt|;
name|struct
name|sctp_auth_hmac_algo
modifier|*
name|hmacs
decl_stmt|;
name|struct
name|sctp_auth_chunk_list
modifier|*
name|chunks
decl_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* generate and add RANDOM parameter */
name|randp
operator|=
operator|(
expr|struct
name|sctp_auth_random
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_random
argument_list|)
operator|+
name|SCTP_AUTH_RANDOM_SIZE_DEFAULT
expr_stmt|;
name|randp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_RANDOM
argument_list|)
expr_stmt|;
name|randp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|SCTP_READ_RANDOM
argument_list|(
name|randp
operator|->
name|random_data
argument_list|,
name|SCTP_AUTH_RANDOM_SIZE_DEFAULT
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* add HMAC_ALGO parameter */
name|hmacs
operator|=
operator|(
expr|struct
name|sctp_auth_hmac_algo
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_hmac_algo
argument_list|)
operator|+
name|sctp_serialize_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|hmacs
operator|->
name|hmac_ids
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HMAC_LIST
argument_list|)
expr_stmt|;
name|hmacs
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* add CHUNKS parameter */
name|chunks
operator|=
operator|(
expr|struct
name|sctp_auth_chunk_list
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
operator|)
expr_stmt|;
name|parameter_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk_list
argument_list|)
operator|+
name|sctp_serialize_auth_chunks
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|,
name|chunks
operator|->
name|chunk_types
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CHUNK_LIST
argument_list|)
expr_stmt|;
name|chunks
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|parameter_len
argument_list|)
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
name|chunk_len
expr_stmt|;
name|m_last
operator|=
name|m
expr_stmt|;
comment|/* now the addresses */
comment|/* 	 * To optimize this we could put the scoping stuff into a structure 	 * and remove the individual uint8's from the stc structure. Then we 	 * could just sifa in the address within the stc.. but for now this 	 * is a quick hack to get the address stuff teased apart. 	 */
name|scp
operator|.
name|ipv4_addr_legal
operator|=
name|stc
operator|.
name|ipv4_addr_legal
expr_stmt|;
name|scp
operator|.
name|ipv6_addr_legal
operator|=
name|stc
operator|.
name|ipv6_addr_legal
expr_stmt|;
name|scp
operator|.
name|loopback_scope
operator|=
name|stc
operator|.
name|loopback_scope
expr_stmt|;
name|scp
operator|.
name|ipv4_local_scope
operator|=
name|stc
operator|.
name|ipv4_scope
expr_stmt|;
name|scp
operator|.
name|local_scope
operator|=
name|stc
operator|.
name|local_scope
expr_stmt|;
name|scp
operator|.
name|site_scope
operator|=
name|stc
operator|.
name|site_scope
expr_stmt|;
name|m_last
operator|=
name|sctp_add_addresses_to_i_ia
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|scp
argument_list|,
name|m_last
argument_list|,
name|cnt_inits_to
argument_list|,
operator|&
name|padding_len
argument_list|,
operator|&
name|chunk_len
argument_list|)
expr_stmt|;
comment|/* padding_len can only be positive, if no addresses have been added */
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|memset
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|chunk_len
argument_list|,
literal|0
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* tack on the operational error if present */
if|if
condition|(
name|op_err
condition|)
block|{
name|parameter_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_tmp
operator|=
name|op_err
init|;
name|m_tmp
operator|!=
name|NULL
condition|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
control|)
block|{
name|parameter_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
block|}
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m_last
argument_list|)
operator|=
name|op_err
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_last
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m_last
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_last
argument_list|)
expr_stmt|;
block|}
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
block|}
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
name|m_last
operator|=
name|sctp_add_pad_tombuf
argument_list|(
name|m_last
argument_list|,
name|padding_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_last
operator|==
name|NULL
condition|)
block|{
comment|/* Houston we have a problem, no space */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
name|chunk_len
operator|+=
name|padding_len
expr_stmt|;
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Now we must build a cookie */
name|m_cookie
operator|=
name|sctp_add_cookie
argument_list|(
name|init_pkt
argument_list|,
name|offset
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
operator|&
name|stc
argument_list|,
operator|&
name|signature
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_cookie
operator|==
name|NULL
condition|)
block|{
comment|/* memory problem */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now append the cookie to the end and update the space/size */
name|SCTP_BUF_NEXT
argument_list|(
name|m_last
argument_list|)
operator|=
name|m_cookie
expr_stmt|;
name|parameter_len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|m_tmp
operator|=
name|m_cookie
init|;
name|m_tmp
operator|!=
name|NULL
condition|;
name|m_tmp
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
control|)
block|{
name|parameter_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_tmp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|m_last
operator|=
name|m_tmp
expr_stmt|;
block|}
block|}
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|parameter_len
argument_list|)
operator|-
name|parameter_len
expr_stmt|;
name|chunk_len
operator|+=
name|parameter_len
expr_stmt|;
comment|/* 	 * Place in the size, but we don't include the last pad (if any) in 	 * the INIT-ACK. 	 */
name|initack
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chunk_len
argument_list|)
expr_stmt|;
comment|/* 	 * Time to sign the cookie, we don't sign over the cookie signature 	 * though thus we set trailer. 	 */
operator|(
name|void
operator|)
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|inp
operator|->
name|sctp_ep
operator|.
name|secret_key
index|[
call|(
name|int
call|)
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|current_secret_number
argument_list|)
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m_cookie
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|signature
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * We sifa 0 here to NOT set IP_DF if its IPv4, we ignore the return 	 * here since the timer will drive a retranmission. 	 */
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_add_pad_tombuf
argument_list|(
name|m_last
argument_list|,
name|padding_len
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|stc
operator|.
name|loopback_scope
condition|)
block|{
name|over_addr
operator|=
operator|(
expr|union
name|sctp_sockstore
operator|*
operator|)
name|dst
expr_stmt|;
block|}
else|else
block|{
name|over_addr
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|to
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|sh
operator|->
name|src_port
argument_list|,
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
argument_list|,
name|port
argument_list|,
name|over_addr
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_prune_prsctp
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|int
name|dataout
parameter_list|)
block|{
name|int
name|freed_spc
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|prsctp_supported
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|>
literal|0
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 			 * Look for chunks marked with the PR_SCTP flag AND 			 * the buffer space flag. If the one being sent is 			 * equal or greater priority then purge the old one 			 * and free some space. 			 */
if|if
condition|(
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
comment|/* 				 * This one is PR-SCTP AND buffer space 				 * limited type 				 */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
operator|>=
operator|(
name|long
operator|)
name|srcv
operator|->
name|sinfo_timetolive
condition|)
block|{
comment|/* 					 * Lower numbers equates to higher 					 * priority so if the one we are 					 * looking at has a larger or equal 					 * priority we want to drop the data 					 * and NOT retransmit it. 					 */
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
comment|/* 						 * We release the book_size 						 * if the mbuf is here 						 */
name|int
name|ret_spc
decl_stmt|;
name|uint8_t
name|sent
decl_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|>
name|SCTP_DATAGRAM_UNSENT
condition|)
name|sent
operator|=
literal|1
expr_stmt|;
else|else
name|sent
operator|=
literal|0
expr_stmt|;
name|ret_spc
operator|=
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|sent
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|freed_spc
operator|+=
name|ret_spc
expr_stmt|;
if|if
condition|(
name|freed_spc
operator|>=
name|dataout
condition|)
block|{
return|return;
block|}
block|}
comment|/* if chunk was present */
block|}
comment|/* if of sufficent priority */
block|}
comment|/* if chunk has enabled */
block|}
comment|/* tailqforeach */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
comment|/* Here we must move to the sent queue and mark */
if|if
condition|(
name|PR_SCTP_BUF_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|.
name|tv_sec
operator|>=
operator|(
name|long
operator|)
name|srcv
operator|->
name|sinfo_timetolive
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
comment|/* 						 * We release the book_size 						 * if the mbuf is here 						 */
name|int
name|ret_spc
decl_stmt|;
name|ret_spc
operator|=
name|sctp_release_pr_sctp_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
literal|0
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|freed_spc
operator|+=
name|ret_spc
expr_stmt|;
if|if
condition|(
name|freed_spc
operator|>=
name|dataout
condition|)
block|{
return|return;
block|}
block|}
comment|/* end if chk->data */
block|}
comment|/* end if right class */
block|}
comment|/* end if chk pr-sctp */
block|}
comment|/* tailqforeachsafe (chk) */
block|}
comment|/* if enabled in asoc */
block|}
end_function

begin_function
name|int
name|sctp_get_frag_point
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|int
name|siz
decl_stmt|,
name|ovh
decl_stmt|;
comment|/* 	 * For endpoints that have both v6 and v4 addresses we must reserve 	 * room for the ipv6 header, for those that are only dealing with V4 	 * we use a larger frag point. 	 */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_frag_point
operator|>
name|asoc
operator|->
name|smallest_mtu
condition|)
name|siz
operator|=
name|asoc
operator|->
name|smallest_mtu
operator|-
name|ovh
expr_stmt|;
else|else
name|siz
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_frag_point
operator|-
name|ovh
operator|)
expr_stmt|;
comment|/* 	 * if (siz> (MCLBYTES-sizeof(struct sctp_data_chunk))) { 	 */
comment|/* A data chunk MUST fit in a cluster */
comment|/* siz = (MCLBYTES - sizeof(struct sctp_data_chunk)); */
comment|/* } */
comment|/* adjust for an AUTH chunk if DATA requires auth */
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
name|siz
operator|-=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|siz
operator|%
literal|4
condition|)
block|{
comment|/* make it an even word boundary please */
name|siz
operator|-=
operator|(
name|siz
operator|%
literal|4
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|siz
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_set_prsctp_policy
parameter_list|(
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|)
block|{
comment|/* 	 * We assume that the user wants PR_SCTP_TTL if the user provides a 	 * positive lifetime but does not specify any PR_SCTP policy. 	 */
if|if
condition|(
name|PR_SCTP_ENABLED
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
condition|)
block|{
name|sp
operator|->
name|act_flags
operator||=
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|timetolive
operator|>
literal|0
condition|)
block|{
name|sp
operator|->
name|sinfo_flags
operator||=
name|SCTP_PR_SCTP_TTL
expr_stmt|;
name|sp
operator|->
name|act_flags
operator||=
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
switch|switch
condition|(
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
condition|)
block|{
case|case
name|CHUNK_FLAGS_PR_SCTP_BUF
case|:
comment|/* 		 * Time to live is a priority stored in tv_sec when doing 		 * the buffer drop thing. 		 */
name|sp
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|timetolive
expr_stmt|;
name|sp
operator|->
name|ts
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CHUNK_FLAGS_PR_SCTP_TTL
case|:
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|)
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|timetolive
operator|/
literal|1000
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
operator|(
name|sp
operator|->
name|timetolive
operator|*
literal|1000
operator|)
operator|%
literal|1000000
expr_stmt|;
comment|/* 			 * TODO sctp_constants.h needs alternative time 			 * macros when _KERNEL is undefined. 			 */
name|timevaladd
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CHUNK_FLAGS_PR_SCTP_RTX
case|:
comment|/* 		 * Time to live is a the number or retransmissions stored in 		 * tv_sec. 		 */
name|sp
operator|->
name|ts
operator|.
name|tv_sec
operator|=
name|sp
operator|->
name|timetolive
expr_stmt|;
name|sp
operator|->
name|ts
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_USRREQ1
argument_list|,
literal|"Unknown PR_SCTP policy %u.\n"
argument_list|,
name|PR_SCTP_POLICY
argument_list|(
name|sp
operator|->
name|sinfo_flags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_msg_append
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|int
name|hold_stcb_lock
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|at
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|strm
decl_stmt|;
comment|/* 	 * Given an mbuf chain, put it into the association send queue and 	 * place it on the wheel 	 */
if|if
condition|(
name|srcv
operator|->
name|sinfo_stream
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
comment|/* Invalid stream number */
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_locked
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_locked_on
operator|!=
name|srcv
operator|->
name|sinfo_stream
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|strm
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|srcv
operator|->
name|sinfo_stream
index|]
expr_stmt|;
comment|/* Now can we send this? */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
comment|/* got data while shutting down */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sctp_alloc_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sp
operator|->
name|sinfo_flags
operator|=
name|srcv
operator|->
name|sinfo_flags
expr_stmt|;
name|sp
operator|->
name|timetolive
operator|=
name|srcv
operator|->
name|sinfo_timetolive
expr_stmt|;
name|sp
operator|->
name|ppid
operator|=
name|srcv
operator|->
name|sinfo_ppid
expr_stmt|;
name|sp
operator|->
name|context
operator|=
name|srcv
operator|->
name|sinfo_context
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
condition|)
block|{
name|sp
operator|->
name|net
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|sender_all_done
operator|=
literal|1
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
name|sctp_set_prsctp_policy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
comment|/* 	 * We could in theory (for sendall) sifa the length in, but we would 	 * still have to hunt through the chain since we need to setup the 	 * tail_mbuf 	 */
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|at
operator|=
name|m
init|;
name|at
condition|;
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|==
name|NULL
condition|)
name|sp
operator|->
name|tail_mbuf
operator|=
name|at
expr_stmt|;
name|sp
operator|->
name|length
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|srcv
operator|->
name|sinfo_keynumber_valid
condition|)
block|{
name|sp
operator|->
name|auth_keyid
operator|=
name|srcv
operator|->
name|sinfo_keynumber
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|auth_keyid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
expr_stmt|;
block|}
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|sctp_auth_key_acquire
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|auth_keyid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|holds_key_ref
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|hold_stcb_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_add_to_stream
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|strm
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hold_stcb_lock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|out_now
label|:
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_copy_mbufchain
parameter_list|(
name|struct
name|mbuf
modifier|*
name|clonechain
parameter_list|,
name|struct
name|mbuf
modifier|*
name|outchain
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|endofchain
parameter_list|,
name|int
name|can_take_mbuf
parameter_list|,
name|int
name|sizeofcpy
parameter_list|,
name|uint8_t
name|copy_by_ref
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|appendchain
decl_stmt|;
name|caddr_t
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|endofchain
operator|==
name|NULL
condition|)
block|{
comment|/* error */
name|error_out
label|:
if|if
condition|(
name|outchain
condition|)
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|can_take_mbuf
condition|)
block|{
name|appendchain
operator|=
name|clonechain
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|copy_by_ref
operator|&&
operator|(
name|sizeofcpy
operator|<=
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_mbuf_threshold_count
argument_list|)
operator|-
literal|1
operator|)
operator|*
name|MLEN
operator|)
operator|+
name|MHLEN
operator|)
argument_list|)
operator|)
condition|)
block|{
comment|/* Its not in a cluster */
if|if
condition|(
operator|*
name|endofchain
operator|==
name|NULL
condition|)
block|{
comment|/* lets get a mbuf cluster */
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
comment|/* This is the general case */
name|new_mbuf
label|:
name|outchain
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
goto|goto
name|error_out
goto|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|outchain
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|endofchain
operator|=
name|outchain
expr_stmt|;
comment|/* get the prepend space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|outchain
argument_list|,
operator|(
name|SCTP_FIRST_MBUF_RESV
operator|+
literal|4
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * We really should not get a NULL 					 * in endofchain 					 */
comment|/* find end */
name|m
operator|=
name|outchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* sanity */
if|if
condition|(
operator|*
name|endofchain
operator|==
name|NULL
condition|)
block|{
comment|/* 						 * huh, TSNH XXX maybe we 						 * should panic 						 */
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
goto|goto
name|new_mbuf
goto|;
block|}
block|}
comment|/* get the new end of length */
name|len
operator|=
name|M_TRAILINGSPACE
argument_list|(
operator|*
name|endofchain
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* how much is left at the end? */
name|len
operator|=
name|M_TRAILINGSPACE
argument_list|(
operator|*
name|endofchain
argument_list|)
expr_stmt|;
block|}
comment|/* Find the end of the data, for appending */
name|cp
operator|=
operator|(
name|mtod
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|)
expr_stmt|;
comment|/* Now lets copy it out */
if|if
condition|(
name|len
operator|>=
name|sizeofcpy
condition|)
block|{
comment|/* It all fits, copy it in */
name|m_copydata
argument_list|(
name|clonechain
argument_list|,
literal|0
argument_list|,
name|sizeofcpy
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|+=
name|sizeofcpy
expr_stmt|;
block|}
else|else
block|{
comment|/* fill up the end of the chain */
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|m_copydata
argument_list|(
name|clonechain
argument_list|,
literal|0
argument_list|,
name|len
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|+=
name|len
expr_stmt|;
comment|/* now we need another one */
name|sizeofcpy
operator|-=
name|len
expr_stmt|;
block|}
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* We failed */
goto|goto
name|error_out
goto|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|=
name|m
expr_stmt|;
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
name|cp
operator|=
name|mtod
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|clonechain
argument_list|,
name|len
argument_list|,
name|sizeofcpy
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
operator|(
operator|*
name|endofchain
operator|)
argument_list|)
operator|+=
name|sizeofcpy
expr_stmt|;
block|}
return|return
operator|(
name|outchain
operator|)
return|;
block|}
else|else
block|{
comment|/* copy the old fashion way */
name|appendchain
operator|=
name|SCTP_M_COPYM
argument_list|(
name|clonechain
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|appendchain
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|appendchain
operator|==
name|NULL
condition|)
block|{
comment|/* error */
if|if
condition|(
name|outchain
condition|)
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|outchain
condition|)
block|{
comment|/* tack on to the end */
if|if
condition|(
operator|*
name|endofchain
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
operator|(
operator|(
operator|*
name|endofchain
operator|)
operator|)
argument_list|)
operator|=
name|appendchain
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|outchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|appendchain
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * save off the end and update the end-chain postion 		 */
name|m
operator|=
name|appendchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|outchain
operator|)
return|;
block|}
else|else
block|{
comment|/* save off the end and update the end-chain postion */
name|m
operator|=
name|appendchain
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|endofchain
operator|=
name|m
expr_stmt|;
break|break;
block|}
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|appendchain
operator|)
return|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|int
name|sctp_med_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
modifier|*
name|num_out
parameter_list|,
name|int
modifier|*
name|reason_code
parameter_list|,
name|int
name|control_only
parameter_list|,
name|int
name|from_where
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
modifier|*
name|now_filled
parameter_list|,
name|int
name|frag_point
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|sctp_sendall_iterator
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_copy_all
modifier|*
name|ca
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|added_control
init|=
literal|0
decl_stmt|;
name|int
name|un_sent
decl_stmt|,
name|do_chunk_output
init|=
literal|1
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|ca
operator|=
operator|(
expr|struct
name|sctp_copy_all
operator|*
operator|)
name|ptr
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ca
operator|->
name|inp
operator|!=
name|inp
condition|)
block|{
comment|/* TSNH */
return|return;
block|}
if|if
condition|(
name|ca
operator|->
name|sndlen
operator|>
literal|0
condition|)
block|{
name|m
operator|=
name|SCTP_M_COPYM
argument_list|(
name|ca
operator|->
name|m
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* can't copy so we are done */
name|ca
operator|->
name|cnt_failed
operator|++
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|m
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|m
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
if|if
condition|(
name|ca
operator|->
name|sndrcv
operator|.
name|sinfo_flags
operator|&
name|SCTP_ABORT
condition|)
block|{
comment|/* Abort this assoc with m as the user defined reason */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
name|ca
operator|->
name|sndlen
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * We add one here to keep the assoc from dis-appearing on 		 * us. 		 */
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* 		 * sctp_abort_an_association calls sctp_free_asoc() free 		 * association will NOT free it since we incremented the 		 * refcnt .. we do this to prevent it being freed and things 		 * getting tricky since we could end up (from free_asoc) 		 * calling inpcb_free which would get a recursive lock call 		 * to the iterator lock.. But as a consequence of that the 		 * stcb will return to us un-locked.. since free_asoc 		 * returns with either no TCB or the TCB unlocked, we must 		 * relock.. to unlock in the iterator timer :-0 		 */
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|no_chunk_output
goto|;
block|}
else|else
block|{
if|if
condition|(
name|m
condition|)
block|{
name|ret
operator|=
name|sctp_msg_append
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|m
argument_list|,
operator|&
name|ca
operator|->
name|sndrcv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|sndrcv
operator|.
name|sinfo_flags
operator|&
name|SCTP_EOF
condition|)
block|{
comment|/* shutdown this assoc */
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|sctp_is_there_unsent_data
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
comment|/* 				 * there is nothing queued to send, so I'm 				 * done... 				 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* 					 * only send SHUTDOWN the first time 					 * through 					 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|added_control
operator|=
literal|1
expr_stmt|;
name|do_chunk_output
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * we still got (or just got) data to send, 				 * so set SHUTDOWN_PENDING 				 */
comment|/* 				 * XXX sockets draft says that SCTP_EOF 				 * should be sent with no data.  currently, 				 * we will allow user data to be sent first 				 * and move to SHUTDOWN-PENDING 				 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* 						 * Locked to send out the 						 * data 						 */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|abort_anyway
label|:
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|no_chunk_output
goto|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
condition|)
block|{
name|do_chunk_output
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|do_chunk_output
condition|)
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|added_control
condition|)
block|{
name|int
name|num_out
init|=
literal|0
decl_stmt|,
name|reason
init|=
literal|0
decl_stmt|,
name|now_filled
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|frag_point
decl_stmt|;
name|frag_point
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|no_chunk_output
label|:
if|if
condition|(
name|ret
condition|)
block|{
name|ca
operator|->
name|cnt_failed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ca
operator|->
name|cnt_sent
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_sendall_completes
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_copy_all
modifier|*
name|ca
decl_stmt|;
name|ca
operator|=
operator|(
expr|struct
name|sctp_copy_all
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* 	 * Do a notify here? Kacheong suggests that the notify be done at 	 * the send time.. so you would push up a notification if any send 	 * failed. Don't know if this is feasable since the only failures we 	 * have is "memory" related and if you cannot get an mbuf to send 	 * the data you surely can't get an mbuf to send up to notify the 	 * user you can't send the data :-> 	 */
comment|/* now free everything */
name|sctp_m_freem
argument_list|(
name|ca
operator|->
name|m
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|ca
argument_list|,
name|SCTP_M_COPYAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MC_ALIGN
parameter_list|(
name|m
parameter_list|,
name|len
parameter_list|)
value|do {						\ 	SCTP_BUF_RESV_UF(m, ((MCLBYTES - (len))& ~(sizeof(long) - 1));	\ } while (0)
end_define

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_copy_out_all
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|ret
decl_stmt|,
modifier|*
name|at
decl_stmt|;
name|int
name|left
decl_stmt|,
name|willcpy
decl_stmt|,
name|cancpy
decl_stmt|,
name|error
decl_stmt|;
name|ret
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_WAITOK
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|left
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|ret
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* save space for the data chunk header */
name|cancpy
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|willcpy
operator|=
name|min
argument_list|(
name|cancpy
argument_list|,
name|left
argument_list|)
expr_stmt|;
name|at
operator|=
name|ret
expr_stmt|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
comment|/* Align data to the end */
name|error
operator|=
name|uiomove
argument_list|(
name|mtod
argument_list|(
name|at
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|willcpy
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|err_out_now
label|:
name|sctp_m_freem
argument_list|(
name|at
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
operator|=
name|willcpy
expr_stmt|;
name|SCTP_BUF_NEXT_PKT
argument_list|(
name|at
argument_list|)
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|=
literal|0
expr_stmt|;
name|left
operator|-=
name|willcpy
expr_stmt|;
if|if
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|left
argument_list|,
literal|0
argument_list|,
name|M_WAITOK
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
operator|==
name|NULL
condition|)
block|{
goto|goto
name|err_out_now
goto|;
block|}
name|at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|at
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cancpy
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|willcpy
operator|=
name|min
argument_list|(
name|cancpy
argument_list|,
name|left
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_sendall
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|struct
name|sctp_copy_all
modifier|*
name|ca
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|ca
argument_list|,
expr|struct
name|sctp_copy_all
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_copy_all
argument_list|)
argument_list|,
name|SCTP_M_COPYAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|memset
argument_list|(
name|ca
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_copy_all
argument_list|)
argument_list|)
expr_stmt|;
name|ca
operator|->
name|inp
operator|=
name|inp
expr_stmt|;
if|if
condition|(
name|srcv
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|ca
operator|->
name|sndrcv
argument_list|,
name|srcv
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nonpad_sndrcvinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * take off the sendall flag, it would be bad if we failed to do 	 * this :-0 	 */
name|ca
operator|->
name|sndrcv
operator|.
name|sinfo_flags
operator|&=
operator|~
name|SCTP_SENDALL
expr_stmt|;
comment|/* get length and mbuf chain */
if|if
condition|(
name|uio
condition|)
block|{
name|ca
operator|->
name|sndlen
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|ca
operator|->
name|m
operator|=
name|sctp_copy_out_all
argument_list|(
name|uio
argument_list|,
name|ca
operator|->
name|sndlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ca
operator|->
name|m
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|ca
argument_list|,
name|SCTP_M_COPYAL
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* Gather the length of the send */
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|ca
operator|->
name|sndlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mat
operator|=
name|m
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
name|ca
operator|->
name|sndlen
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|sctp_initiate_iterator
argument_list|(
name|NULL
argument_list|,
name|sctp_sendall_iterator
argument_list|,
name|NULL
argument_list|,
name|SCTP_PCB_ANY_FLAGS
argument_list|,
name|SCTP_PCB_ANY_FEATURES
argument_list|,
name|SCTP_ASOC_ANY_STATE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ca
argument_list|,
literal|0
argument_list|,
name|sctp_sendall_completes
argument_list|,
name|inp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Failed to initiate iterator for sendall\n"
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|ca
argument_list|,
name|SCTP_M_COPYAL
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_toss_old_cookies
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_toss_old_asconf
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|struct
name|sctp_asconf_chunk
modifier|*
name|acp
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->asconf_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
comment|/* find SCTP_ASCONF chunk in queue */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|acp
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_asconf_chunk
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|ntohl
argument_list|(
name|acp
operator|->
name|serial_number
argument_list|)
argument_list|,
name|asoc
operator|->
name|asconf_seq_out_acked
argument_list|)
condition|)
block|{
comment|/* Not Acked yet */
break|break;
block|}
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_clean_up_datalist
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
modifier|*
name|data_list
parameter_list|,
name|int
name|bundle_at
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bundle_at
condition|;
name|i
operator|++
control|)
block|{
comment|/* off of the send queue */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Any chunk NOT 0 you zap the time chunk 0 gets 			 * zapped or set based on if a RTO measurment is 			 * needed. 			 */
name|data_list
index|[
name|i
index|]
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
comment|/* record time */
name|data_list
index|[
name|i
index|]
operator|->
name|sent_rcv_time
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|cwnd_at_send
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
if|if
condition|(
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* on to the sent queue */
name|tp1
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp1
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|tpp
decl_stmt|;
comment|/* need to move back */
name|back_up_more
label|:
name|tpp
operator|=
name|TAILQ_PREV
argument_list|(
name|tp1
argument_list|,
name|sctpchunk_listhead
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpp
operator|==
name|NULL
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|tp1
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
goto|goto
name|all_done
goto|;
block|}
name|tp1
operator|=
name|tpp
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
condition|)
block|{
goto|goto
name|back_up_more
goto|;
block|}
name|TAILQ_INSERT_AFTER
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|tp1
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
name|all_done
label|:
comment|/* This does not lower until the cum-ack passes it */
name|asoc
operator|->
name|sent_queue_cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|==
literal|0
operator|)
operator|&&
operator|(
name|bundle_at
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* Mark the chunk as being a window probe */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_windowprobed
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC2
argument_list|,
literal|3
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_list
index|[
name|i
index|]
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|snd_count
operator|=
literal|1
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd
argument_list|(
name|SCTP_DECREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|peers_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
operator|+
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_packet_transmitted
condition|)
block|{
call|(
modifier|*
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_packet_transmitted
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_clean_up_ctl
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
operator|||
comment|/* EY */
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_REQUEST
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_OPERATION_ERROR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_PACKET_DROPPED
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_CWR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF_ACK
operator|)
condition|)
block|{
comment|/* Stray chunks must be cleaned up */
name|clean_up_anyway
label|:
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
condition|)
name|asoc
operator|->
name|fwd_tsn_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_STREAM_RESET
condition|)
block|{
comment|/* special handling, we must look into the param */
if|if
condition|(
name|chk
operator|!=
name|asoc
operator|->
name|str_reset
condition|)
block|{
goto|goto
name|clean_up_anyway
goto|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_can_we_split_this
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|uint32_t
name|goal_mtu
parameter_list|,
name|uint32_t
name|frag_point
parameter_list|,
name|int
name|eeor_on
parameter_list|)
block|{
comment|/* 	 * Make a decision on if I should split a msg into multiple parts. 	 * This is only asked of incomplete messages. 	 */
if|if
condition|(
name|eeor_on
condition|)
block|{
comment|/* 		 * If we are doing EEOR we need to always send it if its the 		 * entire thing, since it might be all the guy is putting in 		 * the hopper. 		 */
if|if
condition|(
name|goal_mtu
operator|>=
name|length
condition|)
block|{
comment|/*- 			 * If we have data outstanding, 			 * we get another chance when the sack 			 * arrives to transmit - wait for more data 			 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If nothing is in flight, we zero the 				 * packet counter. 				 */
return|return
operator|(
name|length
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* You can fill the rest */
return|return
operator|(
name|goal_mtu
operator|)
return|;
block|}
block|}
comment|/*- 	 * For those strange folk that make the send buffer 	 * smaller than our fragmentation point, we can't 	 * get a full msg in so we have to allow splitting. 	 */
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
operator|<
name|frag_point
condition|)
block|{
return|return
operator|(
name|length
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|length
operator|<=
name|goal_mtu
operator|)
operator|||
operator|(
operator|(
name|length
operator|-
name|goal_mtu
operator|)
operator|<
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_min_residual
argument_list|)
operator|)
condition|)
block|{
comment|/* Sub-optimial residual don't split in non-eeor mode. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we reach here length is larger than the goal_mtu. Do we wish 	 * to split it for the sake of packet putting together? 	 */
if|if
condition|(
name|goal_mtu
operator|>=
name|min
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_min_split_point
argument_list|)
argument_list|,
name|frag_point
argument_list|)
condition|)
block|{
comment|/* Its ok to split it */
return|return
operator|(
name|min
argument_list|(
name|goal_mtu
argument_list|,
name|frag_point
argument_list|)
operator|)
return|;
block|}
comment|/* Nope, can't split */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|sctp_move_to_outqueue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_out
modifier|*
name|strq
parameter_list|,
name|uint32_t
name|goal_mtu
parameter_list|,
name|uint32_t
name|frag_point
parameter_list|,
name|int
modifier|*
name|locked
parameter_list|,
name|int
modifier|*
name|giveup
parameter_list|,
name|int
name|eeor_mode
parameter_list|,
name|int
modifier|*
name|bail
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/* Move from the stream to the send_queue keeping track of the total */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_data_chunk
modifier|*
name|dchkh
decl_stmt|;
name|uint32_t
name|to_move
decl_stmt|,
name|length
decl_stmt|;
name|uint8_t
name|rcv_flags
init|=
literal|0
decl_stmt|;
name|uint8_t
name|some_taken
decl_stmt|;
name|uint8_t
name|send_lock_up
init|=
literal|0
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|one_more_time
label|:
comment|/* sa_ignore FREED_MEMORY */
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
operator|*
name|locked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|send_lock_up
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
goto|goto
name|one_more_time
goto|;
block|}
if|if
condition|(
name|strq
operator|->
name|last_msg_incomplete
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Huh? Stream:%d lm_in_c=%d but queue is NULL\n"
argument_list|,
name|strq
operator|->
name|stream_no
argument_list|,
name|strq
operator|->
name|last_msg_incomplete
argument_list|)
expr_stmt|;
name|strq
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
block|}
name|to_move
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|send_lock_up
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|0
expr_stmt|;
block|}
goto|goto
name|out_of
goto|;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|msg_is_complete
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|sender_all_done
condition|)
block|{
comment|/* 			 * We are doing differed cleanup. Last time through 			 * when we took all the data the sender_all_done was 			 * not set. 			 */
if|if
condition|(
operator|(
name|sp
operator|->
name|put_last_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|discard_rest
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Gak, put out entire msg with NO end!-1\n"
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"sender_done:%d len:%d msg_comp:%d put_last_out:%d send_lock:%d\n"
argument_list|,
name|sp
operator|->
name|sender_all_done
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|sp
operator|->
name|msg_is_complete
argument_list|,
name|sp
operator|->
name|put_last_out
argument_list|,
name|send_lock_up
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|send_lock_up
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_remove_from_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strq
argument_list|,
name|sp
argument_list|,
name|send_lock_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* we can't be locked to it */
operator|*
name|locked
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|send_lock_up
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|0
expr_stmt|;
block|}
comment|/* back to get the next msg */
goto|goto
name|one_more_time
goto|;
block|}
else|else
block|{
comment|/* 			 * sender just finished this but still holds a 			 * reference 			 */
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
block|}
else|else
block|{
comment|/* is there some to get */
if|if
condition|(
name|sp
operator|->
name|length
operator|==
literal|0
condition|)
block|{
comment|/* no */
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
elseif|else
if|if
condition|(
name|sp
operator|->
name|discard_rest
condition|)
block|{
if|if
condition|(
name|send_lock_up
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Whack down the size */
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|,
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_socket
operator|!=
name|NULL
operator|)
operator|&&
expr|\
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
argument_list|,
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
block|}
name|some_taken
operator|=
name|sp
operator|->
name|some_taken
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
block|}
name|re_look
label|:
name|length
operator|=
name|sp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
comment|/* The message is complete */
name|to_move
operator|=
name|min
argument_list|(
name|length
argument_list|,
name|frag_point
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_move
operator|==
name|length
condition|)
block|{
comment|/* All of it fits in the MTU */
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_LAST_FRAG
expr_stmt|;
name|sp
operator|->
name|put_last_out
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_NOT_FRAG
expr_stmt|;
name|sp
operator|->
name|put_last_out
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Not all of it fits, we fragment */
if|if
condition|(
name|sp
operator|->
name|some_taken
operator|==
literal|0
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_FIRST_FRAG
expr_stmt|;
block|}
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|to_move
operator|=
name|sctp_can_we_split_this
argument_list|(
name|stcb
argument_list|,
name|length
argument_list|,
name|goal_mtu
argument_list|,
name|frag_point
argument_list|,
name|eeor_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|to_move
condition|)
block|{
comment|/*- 			 * We use a snapshot of length in case it 			 * is expanding during the compare. 			 */
name|uint32_t
name|llen
decl_stmt|;
name|llen
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|to_move
operator|>=
name|llen
condition|)
block|{
name|to_move
operator|=
name|llen
expr_stmt|;
if|if
condition|(
name|send_lock_up
operator|==
literal|0
condition|)
block|{
comment|/*- 					 * We are taking all of an incomplete msg 					 * thus we need a send lock. 					 */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
comment|/* 						 * the sender finished the 						 * msg 						 */
goto|goto
name|re_look
goto|;
block|}
block|}
block|}
if|if
condition|(
name|sp
operator|->
name|some_taken
operator|==
literal|0
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_FIRST_FRAG
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Nothing to take. */
if|if
condition|(
name|sp
operator|->
name|some_taken
condition|)
block|{
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
block|}
comment|/* If we reach here, we can copy out a chunk */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* No chunk memory */
operator|*
name|giveup
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
comment|/* 	 * Setup for unordered if needed by looking at the user sent info 	 * flags. 	 */
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_UNORDERED
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_enable_sack_immediately
argument_list|)
operator|&&
operator|(
operator|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|==
name|SCTP_EOF
operator|)
operator|)
operator|||
operator|(
operator|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_SACK_IMMEDIATELY
operator|)
operator|==
name|SCTP_SACK_IMMEDIATELY
operator|)
condition|)
block|{
name|rcv_flags
operator||=
name|SCTP_DATA_SACK_IMMEDIATELY
expr_stmt|;
block|}
comment|/* clear out the chunk before setting up */
name|memset
argument_list|(
name|chk
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chk
argument_list|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|=
name|rcv_flags
expr_stmt|;
if|if
condition|(
name|to_move
operator|>=
name|length
condition|)
block|{
comment|/* we think we can steal the whole thing */
if|if
condition|(
operator|(
name|sp
operator|->
name|sender_all_done
operator|==
literal|0
operator|)
operator|&&
operator|(
name|send_lock_up
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|to_move
operator|<
name|sp
operator|->
name|length
condition|)
block|{
comment|/* bail, it changed */
goto|goto
name|dont_do_it
goto|;
block|}
name|chk
operator|->
name|data
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|chk
operator|->
name|last_mbuf
operator|=
name|sp
operator|->
name|tail_mbuf
expr_stmt|;
comment|/* register the stealing */
name|sp
operator|->
name|data
operator|=
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|dont_do_it
label|:
name|chk
operator|->
name|data
operator|=
name|SCTP_M_COPYM
argument_list|(
name|sp
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|to_move
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|chk
operator|->
name|last_mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|some_taken
operator|=
name|some_taken
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
operator|*
name|bail
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|chk
operator|->
name|data
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* Pull off the data */
name|m_adj
argument_list|(
name|sp
operator|->
name|data
argument_list|,
name|to_move
argument_list|)
expr_stmt|;
comment|/* Now lets work our way down and compact it */
name|m
operator|=
name|sp
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|m
operator|&&
operator|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|sp
operator|->
name|data
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tail_mbuf
operator|==
name|m
condition|)
block|{
comment|/*- 				 * Freeing tail? TSNH since 				 * we supposedly were taking less 				 * than the sp->length. 				 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh, freing tail? - TSNH"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Huh, freeing tail? - TSNH\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|sctp_m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|sp
operator|->
name|data
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|chk
operator|->
name|data
argument_list|)
condition|)
block|{
name|chk
operator|->
name|copy_by_ref
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * get last_mbuf and counts of mb useage This is ugly but hopefully 	 * its only one mbuf. 	 */
if|if
condition|(
name|chk
operator|->
name|last_mbuf
operator|==
name|NULL
condition|)
block|{
name|chk
operator|->
name|last_mbuf
operator|=
name|chk
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|chk
operator|->
name|last_mbuf
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|last_mbuf
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|chk
operator|->
name|last_mbuf
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|to_move
operator|>
name|length
condition|)
block|{
comment|/*- This should not happen either 		 * since we always lower to_move to the size 		 * of sp->length if its larger. 		 */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Huh, how can to_move be larger?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Huh, how can to_move be larger?\n"
argument_list|)
expr_stmt|;
name|sp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|sp
operator|->
name|length
argument_list|,
name|to_move
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
condition|)
block|{
comment|/* Not enough room for a chunk header, get some */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * we're in trouble here. _PREPEND below will free 			 * all the data if there is no leading space, so we 			 * must put the data back and restore. 			 */
if|if
condition|(
name|send_lock_up
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* unsteal the data */
name|sp
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|chk
operator|->
name|last_mbuf
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m_tmp
decl_stmt|;
comment|/* reassemble the data */
name|m_tmp
operator|=
name|sp
operator|->
name|data
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|chk
operator|->
name|last_mbuf
argument_list|)
operator|=
name|m_tmp
expr_stmt|;
block|}
name|sp
operator|->
name|some_taken
operator|=
name|some_taken
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|length
argument_list|,
name|to_move
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
operator|*
name|bail
operator|=
literal|1
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
else|else
block|{
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|=
name|chk
operator|->
name|data
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m
expr_stmt|;
name|M_ALIGN
argument_list|(
name|chk
operator|->
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_BUF_PREPEND
argument_list|(
name|chk
operator|->
name|data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
comment|/* HELP, TSNH since we assured it would not above? */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"prepend failes HELP?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"prepend fails HELP?\n"
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|bail
operator|=
literal|1
expr_stmt|;
name|to_move
operator|=
literal|0
expr_stmt|;
goto|goto
name|out_of
goto|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|chk
operator|->
name|send_size
operator|=
operator|(
name|to_move
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|pad_inplace
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
operator|=
name|strq
operator|->
name|next_sequence_send
expr_stmt|;
if|if
condition|(
operator|(
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
operator|)
operator|&&
operator|!
operator|(
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
condition|)
block|{
name|strq
operator|->
name|next_sequence_send
operator|++
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|=
name|sp
operator|->
name|stream
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
operator|=
name|sp
operator|->
name|ppid
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|context
operator|=
name|sp
operator|->
name|context
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|timetodrop
operator|=
name|sp
operator|->
name|ts
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
name|sp
operator|->
name|act_flags
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|sp
operator|->
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|holds_key_ref
condition|)
block|{
name|chk
operator|->
name|auth_keyid
operator|=
name|sp
operator|->
name|auth_keyid
expr_stmt|;
name|sctp_auth_key_acquire
argument_list|(
name|stcb
argument_list|,
name|chk
operator|->
name|auth_keyid
argument_list|)
expr_stmt|;
name|chk
operator|->
name|holds_key_ref
operator|=
literal|1
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|asoc
operator|->
name|sending_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_AT_SEND_2_OUTQ
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_STRMOUT_LOG_SEND
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|sp
operator|->
name|length
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
operator|<<
literal|16
operator|)
operator||
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|dchkh
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_data_chunk
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Put the rest of the things in place now. Size was done earlier in 	 * previous loop prior to padding. 	 */
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|tsn_out_at
operator|>=
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|asoc
operator|->
name|tsn_out_at
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|tsn_out_wrapped
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|tsn
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|strm
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|seq
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|sz
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|flgs
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|stcb
operator|=
operator|(
name|void
operator|*
operator|)
name|stcb
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|in_pos
operator|=
name|asoc
operator|->
name|tsn_out_at
expr_stmt|;
name|asoc
operator|->
name|out_tsnlog
index|[
name|asoc
operator|->
name|tsn_out_at
index|]
operator|.
name|in_out
operator|=
literal|2
expr_stmt|;
name|asoc
operator|->
name|tsn_out_at
operator|++
expr_stmt|;
endif|#
directive|endif
name|dchkh
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_DATA
expr_stmt|;
name|dchkh
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|tsn
operator|=
name|htonl
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|stream_id
operator|=
name|htons
argument_list|(
name|strq
operator|->
name|stream_no
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|stream_sequence
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|dp
operator|.
name|protocol_id
operator|=
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|payloadtype
expr_stmt|;
name|dchkh
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
comment|/* Now advance the chk->send_size by the actual pad needed. */
if|if
condition|(
name|chk
operator|->
name|send_size
operator|<
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
condition|)
block|{
comment|/* need a pad */
name|struct
name|mbuf
modifier|*
name|lm
decl_stmt|;
name|int
name|pads
decl_stmt|;
name|pads
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
operator|-
name|chk
operator|->
name|send_size
expr_stmt|;
name|lm
operator|=
name|sctp_pad_lastmbuf
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|pads
argument_list|,
name|chk
operator|->
name|last_mbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|last_mbuf
operator|=
name|lm
expr_stmt|;
name|chk
operator|->
name|pad_inplace
operator|=
literal|1
expr_stmt|;
block|}
name|chk
operator|->
name|send_size
operator|+=
name|pads
expr_stmt|;
block|}
if|if
condition|(
name|PR_SCTP_ENABLED
argument_list|(
name|chk
operator|->
name|flags
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|pr_sctp_cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|sender_all_done
operator|)
condition|)
block|{
comment|/* All done pull and kill the message */
name|atomic_subtract_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|put_last_out
operator|==
literal|0
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Gak, put out entire msg with NO end!-2\n"
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"sender_done:%d len:%d msg_comp:%d put_last_out:%d send_lock:%d\n"
argument_list|,
name|sp
operator|->
name|sender_all_done
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|sp
operator|->
name|msg_is_complete
argument_list|,
name|sp
operator|->
name|put_last_out
argument_list|,
name|send_lock_up
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|send_lock_up
operator|==
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_NEXT
argument_list|(
name|sp
argument_list|,
name|next
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|send_lock_up
operator|=
literal|1
expr_stmt|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strq
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_remove_from_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strq
argument_list|,
name|sp
argument_list|,
name|send_lock_up
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* we can't be locked to it */
operator|*
name|locked
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* more to go, we are locked */
operator|*
name|locked
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|chunks_on_out_queue
operator|++
expr_stmt|;
name|strq
operator|->
name|chunks_on_queues
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|++
expr_stmt|;
name|out_of
label|:
if|if
condition|(
name|send_lock_up
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|to_move
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_fill_outqueue
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|frag_point
parameter_list|,
name|int
name|eeor_mode
parameter_list|,
name|int
modifier|*
name|quit_now
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|strq
decl_stmt|;
name|int
name|goal_mtu
decl_stmt|,
name|moved_how_much
decl_stmt|,
name|total_moved
init|=
literal|0
decl_stmt|,
name|bail
init|=
literal|0
decl_stmt|;
name|int
name|locked
decl_stmt|,
name|giveup
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|goal_mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|goal_mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
name|goal_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
break|break;
block|}
comment|/* Need an allowance for the data chunk header too */
name|goal_mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
comment|/* must make even word boundary */
name|goal_mtu
operator|&=
literal|0xfffffffc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* We are stuck on one stream until the message completes. */
name|strq
operator|=
name|asoc
operator|->
name|locked_on_sending
expr_stmt|;
name|locked
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|strq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_select_stream
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|locked
operator|=
literal|0
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|goal_mtu
operator|>
literal|0
operator|)
operator|&&
name|strq
condition|)
block|{
name|giveup
operator|=
literal|0
expr_stmt|;
name|bail
operator|=
literal|0
expr_stmt|;
name|moved_how_much
operator|=
name|sctp_move_to_outqueue
argument_list|(
name|stcb
argument_list|,
name|strq
argument_list|,
name|goal_mtu
argument_list|,
name|frag_point
argument_list|,
operator|&
name|locked
argument_list|,
operator|&
name|giveup
argument_list|,
name|eeor_mode
argument_list|,
operator|&
name|bail
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_how_much
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_scheduled
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|asoc
argument_list|,
name|strq
argument_list|,
name|moved_how_much
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
block|{
name|asoc
operator|->
name|locked_on_sending
operator|=
name|strq
expr_stmt|;
if|if
condition|(
operator|(
name|moved_how_much
operator|==
literal|0
operator|)
operator|||
operator|(
name|giveup
operator|)
operator|||
name|bail
condition|)
comment|/* no more to move for now */
break|break;
block|}
else|else
block|{
name|asoc
operator|->
name|locked_on_sending
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|giveup
operator|)
operator|||
name|bail
condition|)
block|{
break|break;
block|}
name|strq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_select_stream
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|strq
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
block|}
name|total_moved
operator|+=
name|moved_how_much
expr_stmt|;
name|goal_mtu
operator|-=
operator|(
name|moved_how_much
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
name|goal_mtu
operator|&=
literal|0xfffffffc
expr_stmt|;
block|}
if|if
condition|(
name|bail
condition|)
operator|*
name|quit_now
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_packet_done
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_moved
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
operator|&&
operator|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
condition|)
block|{
comment|/* ran dry for primary network net */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_primary_randry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|>
literal|0
condition|)
block|{
comment|/* ran dry with CMT on */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_cmt_randry
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_fix_ecn_echo
parameter_list|(
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_move_chunks_from_net
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|sp
argument_list|,
argument|&stcb->asoc.strmout[i].outqueue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|sp
operator|->
name|net
operator|==
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_med_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
modifier|*
name|num_out
parameter_list|,
name|int
modifier|*
name|reason_code
parameter_list|,
name|int
name|control_only
parameter_list|,
name|int
name|from_where
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
modifier|*
name|now_filled
parameter_list|,
name|int
name|frag_point
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/** 	 * Ok this is the generic chunk service queue. we must do the 	 * following: - Service the stream queue that is next, moving any 	 * message (note I must get a complete message i.e. FIRST/MIDDLE and 	 * LAST to the out queue in one pass) and assigning TSN's - Check to 	 * see if the cwnd/rwnd allows any output, if so we go ahead and 	 * fomulate and send the low level chunks. Making sure to combine 	 * any control in the control chunk queue also. 	 */
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|start_at
decl_stmt|,
modifier|*
name|sack_goes_to
init|=
name|NULL
decl_stmt|,
modifier|*
name|old_start_at
init|=
name|NULL
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|outchain
decl_stmt|,
modifier|*
name|endoutchain
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
comment|/* temp arrays for unlinking */
name|struct
name|sctp_tmit_chunk
modifier|*
name|data_list
index|[
name|SCTP_MAX_DATA_BUNDLING
index|]
decl_stmt|;
name|int
name|no_fragmentflg
decl_stmt|,
name|error
decl_stmt|;
name|unsigned
name|int
name|max_rwnd_per_dest
decl_stmt|,
name|max_send_per_dest
decl_stmt|;
name|int
name|one_chunk
decl_stmt|,
name|hbflag
decl_stmt|,
name|skip_data_for_this_net
decl_stmt|;
name|int
name|asconf
decl_stmt|,
name|cookie
decl_stmt|,
name|no_out_cnt
decl_stmt|;
name|int
name|bundle_at
decl_stmt|,
name|ctl_cnt
decl_stmt|,
name|no_data_chunks
decl_stmt|,
name|eeor_mode
decl_stmt|;
name|unsigned
name|int
name|mtu
decl_stmt|,
name|r_mtu
decl_stmt|,
name|omtu
decl_stmt|,
name|mx_mtu
decl_stmt|,
name|to_out
decl_stmt|;
name|int
name|tsns_sent
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
name|uint16_t
name|auth_keyid
decl_stmt|;
name|int
name|override_ok
init|=
literal|1
decl_stmt|;
name|int
name|skip_fill_up
init|=
literal|0
decl_stmt|;
name|int
name|data_auth_reqd
init|=
literal|0
decl_stmt|;
comment|/* 	 * JRS 5/14/07 - Add flag for whether a heartbeat is sent to the 	 * destination. 	 */
name|int
name|quit_now
init|=
literal|0
decl_stmt|;
operator|*
name|num_out
operator|=
literal|0
expr_stmt|;
name|auth_keyid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
operator|)
condition|)
block|{
name|eeor_mode
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|eeor_mode
operator|=
literal|0
expr_stmt|;
block|}
name|ctl_cnt
operator|=
name|no_out_cnt
operator|=
name|asconf
operator|=
name|cookie
operator|=
literal|0
expr_stmt|;
comment|/* 	 * First lets prime the pump. For each destination, if there is room 	 * in the flight size, attempt to pull an MTU's worth out of the 	 * stream queues into the general send_queue 	 */
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hbflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|control_only
operator|)
operator|||
operator|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|)
condition|)
name|no_data_chunks
operator|=
literal|1
expr_stmt|;
else|else
name|no_data_chunks
operator|=
literal|0
expr_stmt|;
comment|/* Nothing to possible to send? */
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|||
operator|(
name|asoc
operator|->
name|ctrl_queue_cnt
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
operator|)
operator|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_is_empty
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
condition|)
block|{
name|nothing_to_send
label|:
operator|*
name|reason_code
operator|=
literal|9
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|==
literal|0
condition|)
block|{
comment|/* No room in peers rwnd */
operator|*
name|reason_code
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
condition|)
block|{
comment|/* we are allowed one chunk in flight */
name|no_data_chunks
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
condition|)
block|{
comment|/* Record where a sack goes, if any */
if|if
condition|(
name|no_data_chunks
operator|&&
operator|(
name|asoc
operator|->
name|ctrl_queue_cnt
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
operator|)
condition|)
block|{
comment|/* Nothing but ECNe to send - we don't do that */
goto|goto
name|nothing_to_send
goto|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
condition|)
block|{
name|sack_goes_to
operator|=
name|chk
operator|->
name|whoTo
expr_stmt|;
break|break;
block|}
block|}
block|}
name|max_rwnd_per_dest
operator|=
operator|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|+
name|asoc
operator|->
name|total_flight
operator|)
operator|/
name|asoc
operator|->
name|numnets
operator|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
name|max_send_per_dest
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
operator|/
name|asoc
operator|->
name|numnets
expr_stmt|;
else|else
name|max_send_per_dest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|no_data_chunks
operator|==
literal|0
condition|)
block|{
comment|/* How many non-directed chunks are there? */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * We already have non-directed chunks on 				 * the queue, no need to do a fill-up. 				 */
name|skip_fill_up
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|no_data_chunks
operator|==
literal|0
operator|)
operator|&&
operator|(
name|skip_fill_up
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_is_empty
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 			 * This for loop we are in takes in each net, if 			 * its's got space in cwnd and has data sent to it 			 * (when CMT is off) then it calls 			 * sctp_fill_outqueue for the net. This gets data on 			 * the send queue for that network. 			 *  			 * In sctp_fill_outqueue TSN's are assigned and data is 			 * copied out of the stream buffers. Note mostly 			 * copy by reference (we hope). 			 */
name|net
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|)
operator|&&
operator|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|||
operator|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|)
operator|||
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|,
name|SCTP_CWND_LOG_FILL_OUTQ_CALLED
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_new_transmission_begins
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|==
literal|0
operator|)
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_new_transmission_begins
call|)
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* skip this network, no room - can't fill */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|3
argument_list|,
name|SCTP_CWND_LOG_FILL_OUTQ_CALLED
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|4
argument_list|,
name|SCTP_CWND_LOG_FILL_OUTQ_CALLED
argument_list|)
expr_stmt|;
block|}
name|sctp_fill_outqueue
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|frag_point
argument_list|,
name|eeor_mode
argument_list|,
operator|&
name|quit_now
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|quit_now
condition|)
block|{
comment|/* memory alloc failure */
name|no_data_chunks
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* now service each destination and send out what we can for it */
comment|/* Nothing to send? */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|8
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
condition|)
block|{
comment|/* get the last start point */
name|start_at
operator|=
name|asoc
operator|->
name|last_net_cmt_send_started
expr_stmt|;
if|if
condition|(
name|start_at
operator|==
name|NULL
condition|)
block|{
comment|/* null so to beginning */
name|start_at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|start_at
operator|=
name|TAILQ_NEXT
argument_list|(
name|asoc
operator|->
name|last_net_cmt_send_started
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_at
operator|==
name|NULL
condition|)
block|{
name|start_at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|last_net_cmt_send_started
operator|=
name|start_at
expr_stmt|;
block|}
else|else
block|{
name|start_at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|alternate
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|primary_destination
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|old_start_at
operator|=
name|NULL
expr_stmt|;
name|again_one_more_time
label|:
for|for
control|(
name|net
operator|=
name|start_at
init|;
name|net
operator|!=
name|NULL
condition|;
name|net
operator|=
name|TAILQ_NEXT
argument_list|(
name|net
argument_list|,
name|sctp_next
argument_list|)
control|)
block|{
comment|/* how much can we send? */
comment|/* SCTPDBG("Examine for sending net:%x\n", (uint32_t)net); */
if|if
condition|(
name|old_start_at
operator|&&
operator|(
name|old_start_at
operator|==
name|net
operator|)
condition|)
block|{
comment|/* through list ocmpletely. */
break|break;
block|}
name|tsns_sent
operator|=
literal|0xa
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
operator|)
condition|)
block|{
comment|/* 			 * Nothing on control or asconf and flight is full, 			 * we can skip even in the CMT case. 			 */
continue|continue;
block|}
name|bundle_at
operator|=
literal|0
expr_stmt|;
name|endoutchain
operator|=
name|outchain
operator|=
name|NULL
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
name|one_chunk
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|skip_data_for_this_net
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|skip_data_for_this_net
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|)
operator|&&
operator|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
operator|)
condition|)
block|{
comment|/* 			 * if we have a route and an ifp check to see if we 			 * have room to send to this guy 			 */
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
operator|+
literal|2
operator|)
operator|>=
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_MAXBURST_ENABLE
condition|)
block|{
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_len
argument_list|,
name|ifp
operator|->
name|if_snd
operator|.
name|ifq_maxlen
argument_list|,
name|SCTP_MAX_IFP_APPLIED
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
name|mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
break|break;
block|}
name|mx_mtu
operator|=
name|mtu
expr_stmt|;
name|to_out
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mtu
operator|>
name|asoc
operator|->
name|peers_rwnd
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
condition|)
block|{
comment|/* We have a packet in flight somewhere */
name|r_mtu
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
block|}
else|else
block|{
comment|/* We are always allowed to send one MTU out */
name|one_chunk
operator|=
literal|1
expr_stmt|;
name|r_mtu
operator|=
name|mtu
expr_stmt|;
block|}
block|}
else|else
block|{
name|r_mtu
operator|=
name|mtu
expr_stmt|;
block|}
comment|/************************/
comment|/* ASCONF transmission */
comment|/************************/
comment|/* Now first lets go through the asconf queue */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->asconf_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|!=
name|SCTP_ASCONF
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|alternate
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|primary_destination
operator|!=
name|net
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|asoc
operator|->
name|alternate
operator|!=
name|net
condition|)
block|{
break|break;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
operator|&&
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
break|break;
block|}
comment|/* 			 * if no AUTH is yet included and this chunk 			 * requires it, make sure to account for it.  We 			 * don't apply the size until the AUTH chunk is 			 * actually added below in case there is no room for 			 * this chunk. NOTE: we overload the use of "omtu" 			 * here 			 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|omtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
comment|/* Here we do NOT factor the r_mtu */
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|<
call|(
name|int
call|)
argument_list|(
name|mtu
operator|-
name|omtu
argument_list|)
operator|)
operator|||
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
condition|)
block|{
comment|/* 				 * We probably should glom the mbuf chain 				 * from the chk->data for control but the 				 * problem is it becomes yet one more level 				 * of tracking to do if for some reason 				 * output fails. Then I have got to 				 * reconstruct the merged control chain.. el 				 * yucko.. for now we take the easy way and 				 * do the copy 				 */
comment|/* 				 * Add an AUTH chunk, if chunk requires it 				 * save the offset into the chain for AUTH 				 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|outchain
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
name|outchain
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|(
name|int
operator|)
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|8
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
comment|/* update our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|to_out
operator|+=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
expr_stmt|;
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
condition|)
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* 				 * set hb flag since we can use these for 				 * RTO 				 */
name|hbflag
operator|=
literal|1
expr_stmt|;
name|asconf
operator|=
literal|1
expr_stmt|;
comment|/* 				 * should sysctl this: don't bundle data 				 * with ASCONF since it requires AUTH 				 */
name|no_data_chunks
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|snd_count
operator|++
expr_stmt|;
if|if
condition|(
name|mtu
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Ok we are out of room but we can 					 * output without effecting the 					 * flight size since this little guy 					 * is a control only packet. 					 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 					 * do NOT clear the asconf flag as 					 * it is used to do appropriate 					 * source address selection. 					 */
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|outchain
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
name|asconf
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
argument_list|,
name|net
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
block|{
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|1
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_where
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerrusr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
comment|/* error, could not output */
if|if
condition|(
name|error
operator|==
name|EHOSTUNREACH
condition|)
block|{
comment|/* 							 * Destination went 							 * unreachable 							 * during this send 							 */
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|7
expr_stmt|;
continue|continue;
block|}
else|else
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
comment|/* 					 * increase the number we sent, if a 					 * cookie is sent we don't tell them 					 * any was sent out. 					 */
name|outchain
operator|=
name|endoutchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_out_cnt
condition|)
operator|*
name|num_out
operator|+=
name|ctl_cnt
expr_stmt|;
comment|/* recalc a clean slate and setup */
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
name|mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
break|break;
block|}
name|to_out
operator|=
literal|0
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/************************/
comment|/* Control transmission */
comment|/************************/
comment|/* Now first lets go through the control queue */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
operator|(
name|sack_goes_to
operator|)
operator|&&
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
operator|&&
operator|(
name|chk
operator|->
name|whoTo
operator|!=
name|sack_goes_to
operator|)
condition|)
block|{
comment|/* 				 * if we have a sack in queue, and we are 				 * looking at an ecn echo that is NOT queued 				 * to where the sack is going.. 				 */
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|net
condition|)
block|{
comment|/* 					 * Don't transmit it to where its 					 * going (current net) 					 */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|sack_goes_to
operator|==
name|net
condition|)
block|{
comment|/* 					 * But do transmit it to this 					 * address 					 */
goto|goto
name|skip_net_check
goto|;
block|}
block|}
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|alternate
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|primary_destination
operator|!=
name|net
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|asoc
operator|->
name|alternate
operator|!=
name|net
condition|)
block|{
continue|continue;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
continue|continue;
block|}
block|}
name|skip_net_check
label|:
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
comment|/* 				 * It must be unsent. Cookies and ASCONF's 				 * hang around but there timers will force 				 * when marked for resend. 				 */
continue|continue;
block|}
comment|/* 			 * if no AUTH is yet included and this chunk 			 * requires it, make sure to account for it.  We 			 * don't apply the size until the AUTH chunk is 			 * actually added below in case there is no room for 			 * this chunk. NOTE: we overload the use of "omtu" 			 * here 			 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|omtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
comment|/* Here we do NOT factor the r_mtu */
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|<=
call|(
name|int
call|)
argument_list|(
name|mtu
operator|-
name|omtu
argument_list|)
operator|)
operator|||
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
condition|)
block|{
comment|/* 				 * We probably should glom the mbuf chain 				 * from the chk->data for control but the 				 * problem is it becomes yet one more level 				 * of tracking to do if for some reason 				 * output fails. Then I have got to 				 * reconstruct the merged control chain.. el 				 * yucko.. for now we take the easy way and 				 * do the copy 				 */
comment|/* 				 * Add an AUTH chunk, if chunk requires it 				 * save the offset into the chain for AUTH 				 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|outchain
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
name|outchain
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|(
name|int
operator|)
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|8
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
comment|/* update our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|to_out
operator|+=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|omtu
operator|)
expr_stmt|;
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
condition|)
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
comment|/* Mark things to be removed, if needed */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
operator|||
comment|/* EY */
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_REQUEST
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SHUTDOWN_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_OPERATION_ERROR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_CWR
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_PACKET_DROPPED
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF_ACK
operator|)
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_HEARTBEAT_REQUEST
condition|)
block|{
name|hbflag
operator|=
literal|1
expr_stmt|;
block|}
comment|/* remove these chunks at the end */
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
condition|)
block|{
comment|/* turn off the timer */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
block|}
name|ctl_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Other chunks, since they have 					 * timers running (i.e. COOKIE) we 					 * just "trust" that it gets sent or 					 * retransmitted. 					 */
name|ctl_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
name|cookie
operator|=
literal|1
expr_stmt|;
name|no_out_cnt
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
condition|)
block|{
comment|/* 						 * Increment ecne send count 						 * here this means we may be 						 * over-zealous in our 						 * counting if the send 						 * fails, but its the best 						 * place to do it (we used 						 * to do it in the queue of 						 * the chunk, but that did 						 * not tell how many times 						 * it was sent. 						 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendecne
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|snd_count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|mtu
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Ok we are out of room but we can 					 * output without effecting the 					 * flight size since this little guy 					 * is a control only packet. 					 */
if|if
condition|(
name|asconf
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 						 * do NOT clear the asconf 						 * flag as it is used to do 						 * appropriate source 						 * address selection. 						 */
block|}
if|if
condition|(
name|cookie
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|outchain
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
name|asconf
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
argument_list|,
name|net
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
block|{
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|1
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|from_where
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerrusr
argument_list|)
expr_stmt|;
block|}
comment|/* error, could not output */
if|if
condition|(
name|hbflag
condition|)
block|{
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EHOSTUNREACH
condition|)
block|{
comment|/* 							 * Destination went 							 * unreachable 							 * during this send 							 */
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|7
expr_stmt|;
continue|continue;
block|}
else|else
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
comment|/* Only HB or ASCONF advances time */
if|if
condition|(
name|hbflag
condition|)
block|{
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * increase the number we sent, if a 					 * cookie is sent we don't tell them 					 * any was sent out. 					 */
name|outchain
operator|=
name|endoutchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|no_out_cnt
condition|)
operator|*
name|num_out
operator|+=
name|ctl_cnt
expr_stmt|;
comment|/* recalc a clean slate and setup */
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
name|mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
break|break;
block|}
name|to_out
operator|=
literal|0
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* JRI: if dest is in PF state, do not send data to it */
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
operator|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|)
operator|&&
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
condition|)
block|{
goto|goto
name|no_data_fill
goto|;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
goto|goto
name|no_data_fill
goto|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_buffer_splitting
argument_list|)
operator|&
name|SCTP_RECV_BUFFER_SPLITTING
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|>
name|max_rwnd_per_dest
operator|)
condition|)
block|{
goto|goto
name|no_data_fill
goto|;
block|}
comment|/* 		 * We need a specific accounting for the usage of the send 		 * buffer. We also need to check the number of messages per 		 * net. For now, this is better than nothing and it disabled 		 * by default... 		 */
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_buffer_splitting
argument_list|)
operator|&
name|SCTP_SEND_BUFFER_SPLITTING
operator|)
operator|&&
operator|(
name|max_send_per_dest
operator|>
literal|0
operator|)
operator|&&
operator|(
name|net
operator|->
name|flight_size
operator|>
name|max_send_per_dest
operator|)
condition|)
block|{
goto|goto
name|no_data_fill
goto|;
block|}
comment|/*********************/
comment|/* Data transmission */
comment|/*********************/
comment|/* 		 * if AUTH for DATA is required and no AUTH has been added 		 * yet, account for this in the mtu now... if no data can be 		 * bundled, this adjustment won't matter anyways since the 		 * packet will be going out... 		 */
name|data_auth_reqd
operator|=
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_auth_reqd
operator|&&
operator|(
name|auth
operator|==
name|NULL
operator|)
condition|)
block|{
name|mtu
operator|-=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
comment|/* now lets add any data within the MTU constraints */
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
condition|)
name|omtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
condition|)
name|omtu
operator|=
name|net
operator|->
name|mtu
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
else|else
name|omtu
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
name|omtu
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_OPEN
operator|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|&&
operator|(
name|skip_data_for_this_net
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|cookie
operator|)
condition|)
block|{
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|no_data_chunks
condition|)
block|{
comment|/* let only control go out */
operator|*
name|reason_code
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* skip this net, no room for data */
operator|*
name|reason_code
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|whoTo
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
operator|)
condition|)
block|{
comment|/* Don't send the chunk on this net */
continue|continue;
block|}
if|if
condition|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|alternate
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|alternate
operator|!=
name|net
operator|)
operator|&&
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
operator|)
condition|)
block|{
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|net
operator|!=
name|asoc
operator|->
name|primary_destination
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|alternate
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|chk
operator|->
name|whoTo
operator|==
name|NULL
operator|)
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|>
name|omtu
operator|)
operator|&&
operator|(
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 					 * strange, we have a chunk that is 					 * to big for its destination and 					 * yet no fragment ok flag. 					 * Something went wrong when the 					 * PMTU changed...we did not mark 					 * this chunk for some reason?? I 					 * will fix it here by letting IP 					 * fragment it for now and printing 					 * a warning. This really should not 					 * happen ... 					 */
name|SCTP_PRINTF
argument_list|(
literal|"Warning chunk of %d bytes> mtu:%d and yet PMTU disc missed\n"
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|mtu
argument_list|)
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_enable_sack_immediately
argument_list|)
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
operator|==
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
name|struct
name|sctp_data_chunk
modifier|*
name|dchkh
decl_stmt|;
name|dchkh
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_data_chunk
operator|*
argument_list|)
expr_stmt|;
name|dchkh
operator|->
name|ch
operator|.
name|chunk_flags
operator||=
name|SCTP_DATA_SACK_IMMEDIATELY
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|chk
operator|->
name|send_size
operator|<=
name|mtu
operator|)
operator|&&
operator|(
name|chk
operator|->
name|send_size
operator|<=
name|r_mtu
operator|)
operator|)
operator|||
operator|(
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
operator|&&
operator|(
name|chk
operator|->
name|send_size
operator|<=
name|asoc
operator|->
name|peers_rwnd
operator|)
operator|)
condition|)
block|{
comment|/* ok we will add this one */
comment|/* 					 * Add an AUTH chunk, if chunk 					 * requires it, save the offset into 					 * the chain for AUTH 					 */
if|if
condition|(
name|data_auth_reqd
condition|)
block|{
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|outchain
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_DATA
argument_list|)
expr_stmt|;
name|auth_keyid
operator|=
name|chk
operator|->
name|auth_keyid
expr_stmt|;
name|override_ok
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|override_ok
condition|)
block|{
comment|/* 							 * use this data's 							 * keyid 							 */
name|auth_keyid
operator|=
name|chk
operator|->
name|auth_keyid
expr_stmt|;
name|override_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|auth_keyid
operator|!=
name|chk
operator|->
name|auth_keyid
condition|)
block|{
comment|/* 							 * different keyid, 							 * so done bundling 							 */
break|break;
block|}
block|}
name|outchain
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|outchain
argument_list|,
operator|&
name|endoutchain
argument_list|,
literal|0
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"No memory?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|3
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* upate our MTU size */
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* unsigned subtraction of mtu */
if|if
condition|(
name|mtu
operator|>
name|chk
operator|->
name|send_size
condition|)
name|mtu
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
comment|/* unsigned subtraction of r_mtu */
if|if
condition|(
name|r_mtu
operator|>
name|chk
operator|->
name|send_size
condition|)
name|r_mtu
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
else|else
name|r_mtu
operator|=
literal|0
expr_stmt|;
name|to_out
operator|+=
name|chk
operator|->
name|send_size
expr_stmt|;
if|if
condition|(
operator|(
name|to_out
operator|>
name|mx_mtu
operator|)
operator|&&
name|no_fragmentflg
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Exceeding mtu of %d out size is %d"
argument_list|,
name|mx_mtu
argument_list|,
name|to_out
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Exceeding mtu of %d out size is %d\n"
argument_list|,
name|mx_mtu
argument_list|,
name|to_out
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|chk
operator|->
name|window_probe
operator|=
literal|0
expr_stmt|;
name|data_list
index|[
name|bundle_at
operator|++
index|]
operator|=
name|chk
expr_stmt|;
if|if
condition|(
name|bundle_at
operator|>=
name|SCTP_MAX_DATA_BUNDLING
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_UNSENT
condition|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outorderchunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outunorderchunks
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_LAST_FRAG
operator|)
operator|==
name|SCTP_DATA_LAST_FRAG
operator|)
operator|&&
operator|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_FIRST_FRAG
operator|)
operator|==
literal|0
operator|)
condition|)
comment|/* 							 * Count number of 							 * user msg's that 							 * were fragmented 							 * we do this by 							 * counting when we 							 * see a LAST 							 * fragment only. 							 */
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_fragusrmsgs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtu
operator|==
literal|0
operator|)
operator|||
operator|(
name|r_mtu
operator|==
literal|0
operator|)
operator|||
operator|(
name|one_chunk
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|one_chunk
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
operator|)
condition|)
block|{
name|data_list
index|[
literal|0
index|]
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* 					 * Must be sent in order of the 					 * TSN's (on a network) 					 */
break|break;
block|}
block|}
comment|/* for (chunk gather loop for this net) */
block|}
comment|/* if asoc.state OPEN */
name|no_data_fill
label|:
comment|/* Is there something to send for this destination? */
if|if
condition|(
name|outchain
condition|)
block|{
comment|/* We may need to start a control timer or two */
if|if
condition|(
name|asconf
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 				 * do NOT clear the asconf flag as it is 				 * used to do appropriate source address 				 * selection. 				 */
block|}
if|if
condition|(
name|cookie
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|cookie
operator|=
literal|0
expr_stmt|;
block|}
comment|/* must start a send timer if data is being sent */
if|if
condition|(
name|bundle_at
operator|&&
operator|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * no timer running on this destination 				 * restart it. 				 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* Now send it, if there is anything to send :> */
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|outchain
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|auth_keyid
argument_list|,
name|no_fragmentflg
argument_list|,
name|bundle_at
argument_list|,
name|asconf
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
argument_list|,
name|net
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
operator|)
condition|)
block|{
comment|/* error, we could not output */
if|if
condition|(
name|error
operator|==
name|ENOBUFS
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|from_where
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerrusr
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"Gak send error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|hbflag
condition|)
block|{
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
name|hbflag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|EHOSTUNREACH
condition|)
block|{
comment|/* 					 * Destination went unreachable 					 * during this send 					 */
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
operator|*
name|reason_code
operator|=
literal|6
expr_stmt|;
comment|/*- 				 * I add this line to be paranoid. As far as 				 * I can tell the continue, takes us back to 				 * the top of the for, but just to make sure 				 * I will reset these again here. 				 */
name|ctl_cnt
operator|=
name|bundle_at
operator|=
literal|0
expr_stmt|;
continue|continue;
comment|/* This takes us back to the 						 * for() for the nets. */
block|}
else|else
block|{
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
block|}
name|endoutchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bundle_at
operator|||
name|hbflag
condition|)
block|{
comment|/* For data/asconf and hb set time */
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|net
operator|->
name|last_sent_time
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|net
operator|->
name|last_sent_time
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|last_sent_time
operator|=
operator|*
name|now
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|no_out_cnt
condition|)
block|{
operator|*
name|num_out
operator|+=
operator|(
name|ctl_cnt
operator|+
name|bundle_at
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|bundle_at
condition|)
block|{
comment|/* setup for a RTO measurement */
name|tsns_sent
operator|=
name|data_list
index|[
literal|0
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
comment|/* fill time if not already filled */
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_last_sent
argument_list|)
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
operator|*
name|now
operator|=
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|time_last_sent
operator|=
operator|*
name|now
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|rto_needed
condition|)
block|{
name|data_list
index|[
literal|0
index|]
operator|->
name|do_rtt
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|rto_needed
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_STAT_INCR_BY
argument_list|(
name|sctps_senddata
argument_list|,
name|bundle_at
argument_list|)
expr_stmt|;
name|sctp_clean_up_datalist
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|data_list
argument_list|,
name|bundle_at
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|one_chunk
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|tsns_sent
argument_list|,
name|SCTP_CWND_LOG_FROM_SEND
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|old_start_at
operator|==
name|NULL
condition|)
block|{
name|old_start_at
operator|=
name|start_at
expr_stmt|;
name|start_at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_start_at
condition|)
goto|goto
name|again_one_more_time
goto|;
block|}
comment|/* 	 * At the end there should be no NON timed chunks hanging on this 	 * queue. 	 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|*
name|num_out
argument_list|,
name|SCTP_CWND_LOG_FROM_SEND
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|num_out
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|reason_code
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|reason_code
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
operator|*
name|reason_code
operator|=
literal|5
expr_stmt|;
block|}
name|sctp_clean_up_ctl
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_queue_op_err
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|op_err
parameter_list|)
block|{
comment|/*- 	 * Prepend a OPERATIONAL_ERROR chunk header and put on the end of 	 * the control chunk queue. 	 */
name|struct
name|sctp_chunkhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_PREPEND
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|send_size
operator|=
literal|0
expr_stmt|;
name|mat
operator|=
name|op_err
expr_stmt|;
while|while
condition|(
name|mat
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|send_size
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|mat
argument_list|)
expr_stmt|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_OPERATION_ERROR
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|op_err
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
name|hdr
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|chunk_type
operator|=
name|SCTP_OPERATION_ERROR
expr_stmt|;
name|hdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|int
name|sctp_send_cookie_echo
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/*- 	 * pull out the cookie and put it at the front of the control chunk 	 * queue. 	 */
name|int
name|at
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|cookie
decl_stmt|;
name|struct
name|sctp_paramhdr
name|parm
decl_stmt|,
modifier|*
name|phdr
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint16_t
name|ptype
decl_stmt|,
name|plen
decl_stmt|;
comment|/* First find the cookie in the param area */
name|cookie
operator|=
name|NULL
expr_stmt|;
name|at
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
do|do
block|{
name|phdr
operator|=
name|sctp_get_next_param
argument_list|(
name|m
argument_list|,
name|at
argument_list|,
operator|&
name|parm
argument_list|,
sizeof|sizeof
argument_list|(
name|parm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phdr
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
name|ptype
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptype
operator|==
name|SCTP_STATE_COOKIE
condition|)
block|{
name|int
name|pad
decl_stmt|;
comment|/* found the cookie */
if|if
condition|(
operator|(
name|pad
operator|=
operator|(
name|plen
operator|%
literal|4
operator|)
operator|)
condition|)
block|{
name|plen
operator|+=
literal|4
operator|-
name|pad
expr_stmt|;
block|}
name|cookie
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
name|at
argument_list|,
name|plen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie
operator|==
name|NULL
condition|)
block|{
comment|/* No memory */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|cookie
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
break|break;
block|}
name|at
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|phdr
condition|)
do|;
if|if
condition|(
name|cookie
operator|==
name|NULL
condition|)
block|{
comment|/* Did not find the cookie */
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
comment|/* ok, we got the cookie lets change it into a cookie echo chunk */
comment|/* first the change from param to cookie */
name|hdr
operator|=
name|mtod
argument_list|(
name|cookie
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|chunk_type
operator|=
name|SCTP_COOKIE_ECHO
expr_stmt|;
name|hdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
comment|/* get the chunk stuff now and place it in the FRONT of the queue */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|5
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|plen
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_COOKIE_ECHO
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|cookie
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_send_heartbeat_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|chk_length
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * take a HB request and make it into a HB ack and send it. 	 */
name|struct
name|mbuf
modifier|*
name|outchain
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|chdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
comment|/* must have a net pointer */
return|return;
name|outchain
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|chk_length
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|outchain
operator|==
name|NULL
condition|)
block|{
comment|/* gak out of memory */
return|return;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|outchain
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|chdr
operator|=
name|mtod
argument_list|(
name|outchain
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|chdr
operator|->
name|chunk_type
operator|=
name|SCTP_HEARTBEAT_ACK
expr_stmt|;
name|chdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk_length
operator|%
literal|4
condition|)
block|{
comment|/* need pad */
name|uint32_t
name|cpthis
init|=
literal|0
decl_stmt|;
name|int
name|padlen
decl_stmt|;
name|padlen
operator|=
literal|4
operator|-
operator|(
name|chk_length
operator|%
literal|4
operator|)
expr_stmt|;
name|m_copyback
argument_list|(
name|outchain
argument_list|,
name|chk_length
argument_list|,
name|padlen
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cpthis
argument_list|)
expr_stmt|;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|outchain
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|chk_length
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_HEARTBEAT_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|outchain
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_cookie_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* formulate and queue a cookie-ack back to sender */
name|struct
name|mbuf
modifier|*
name|cookie_ack
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|hdr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|cookie_ack
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie_ack
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|cookie_ack
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|cookie_ack
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_COOKIE_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|cookie_ack
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|asoc
operator|->
name|last_control_chunk_from
operator|!=
name|NULL
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|chk
operator|->
name|asoc
operator|->
name|last_control_chunk_from
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
name|hdr
operator|=
name|mtod
argument_list|(
name|cookie_ack
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|hdr
operator|->
name|chunk_type
operator|=
name|SCTP_COOKIE_ACK
expr_stmt|;
name|hdr
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|hdr
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|cookie_ack
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_shutdown_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* formulate and queue a SHUTDOWN-ACK back to the sender */
name|struct
name|mbuf
modifier|*
name|m_shutdown_ack
decl_stmt|;
name|struct
name|sctp_shutdown_ack_chunk
modifier|*
name|ack_cp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|m_shutdown_ack
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_ack_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_shutdown_ack
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_shutdown_ack
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_shutdown_ack
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_SHUTDOWN_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m_shutdown_ack
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ack_cp
operator|=
name|mtod
argument_list|(
name|m_shutdown_ack
argument_list|,
expr|struct
name|sctp_shutdown_ack_chunk
operator|*
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN_ACK
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_shutdown_ack
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_shutdown
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* formulate and queue a SHUTDOWN to the sender */
name|struct
name|mbuf
modifier|*
name|m_shutdown
decl_stmt|;
name|struct
name|sctp_shutdown_chunk
modifier|*
name|shutdown_cp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|m_shutdown
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_shutdown
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_shutdown
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_shutdown
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_SHUTDOWN
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m_shutdown
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|shutdown_cp
operator|=
name|mtod
argument_list|(
name|m_shutdown
argument_list|,
expr|struct
name|sctp_shutdown_chunk
operator|*
argument_list|)
expr_stmt|;
name|shutdown_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN
expr_stmt|;
name|shutdown_cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|shutdown_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|shutdown_cp
operator|->
name|cumulative_tsn_ack
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_shutdown
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_asconf
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|addr_locked
parameter_list|)
block|{
comment|/* 	 * formulate and queue an ASCONF to the peer. ASCONF parameters 	 * should be queued on the assoc queue. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_asconf
decl_stmt|;
name|int
name|len
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_send_queue
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_MULTIPLE_ASCONFS
argument_list|)
operator|)
condition|)
block|{
comment|/* can't send a new one if there is one in flight already */
return|return;
block|}
comment|/* compose an ASCONF chunk, maximum length is PMTU */
name|m_asconf
operator|=
name|sctp_compose_asconf
argument_list|(
name|stcb
argument_list|,
operator|&
name|len
argument_list|,
name|addr_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_asconf
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
name|sctp_m_freem
argument_list|(
name|m_asconf
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|m_asconf
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|asconf_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_asconf_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* 	 * formulate and queue a asconf-ack back to sender. the asconf-ack 	 * must be stored in the tcb. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_asconf_ack
modifier|*
name|ack
decl_stmt|,
modifier|*
name|latest_ack
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_ack
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* Get the latest ASCONF-ACK */
name|latest_ack
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_ack_sent
argument_list|,
name|sctp_asconf_ackhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest_ack
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|latest_ack
operator|->
name|last_sent_to
operator|!=
name|NULL
operator|&&
name|latest_ack
operator|->
name|last_sent_to
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
condition|)
block|{
comment|/* we're doing a retransmission */
name|net
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* no alternate */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* normal case */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
expr_stmt|;
block|}
block|}
name|latest_ack
operator|->
name|last_sent_to
operator|=
name|net
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ack
argument_list|,
argument|&stcb->asoc.asconf_ack_sent
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|ack
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* copy the asconf_ack */
name|m_ack
operator|=
name|SCTP_M_COPYM
argument_list|(
name|ack
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|M_COPYALL
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_ack
operator|==
name|NULL
condition|)
block|{
comment|/* couldn't copy it */
return|return;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|m_ack
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
comment|/* no memory */
if|if
condition|(
name|m_ack
condition|)
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|data
operator|=
name|m_ack
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
literal|0
expr_stmt|;
comment|/* Get size */
name|chk
operator|->
name|send_size
operator|=
name|ack
operator|->
name|len
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
comment|/* XXX */
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|chk
operator|->
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|chk
operator|->
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_chunk_retransmission
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|int
modifier|*
name|cnt_out
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|,
name|int
modifier|*
name|now_filled
parameter_list|,
name|int
modifier|*
name|fr_done
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/*- 	 * send out one MTU of retransmission. If fast_retransmit is 	 * happening we ignore the cwnd. Otherwise we obey the cwnd and 	 * rwnd. For a Cookie or Asconf in the control chunk queue we 	 * retransmit them by themselves. 	 * 	 * For data chunks we will pick out the lowest TSN's in the sent_queue 	 * marked for resend and bundle them all together (up to a MTU of 	 * destination). The address to send to should have been 	 * selected/changed where the retransmission was marked (i.e. in FR 	 * or t3-timeout routines). 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|data_list
index|[
name|SCTP_MAX_DATA_BUNDLING
index|]
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|fwd
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|endofchain
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|tsns_sent
init|=
literal|0
decl_stmt|;
name|int
name|no_fragmentflg
decl_stmt|,
name|bundle_at
decl_stmt|,
name|cnt_thru
decl_stmt|;
name|unsigned
name|int
name|mtu
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|,
name|one_chunk
decl_stmt|,
name|fwd_tsn
decl_stmt|,
name|ctl_cnt
decl_stmt|,
name|tmr_started
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|;
name|uint16_t
name|auth_keyid
decl_stmt|;
name|int
name|override_ok
init|=
literal|1
decl_stmt|;
name|int
name|data_auth_reqd
init|=
literal|0
decl_stmt|;
name|uint32_t
name|dmtu
init|=
literal|0
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|tmr_started
operator|=
name|ctl_cnt
operator|=
name|bundle_at
operator|=
name|error
operator|=
literal|0
expr_stmt|;
name|no_fragmentflg
operator|=
literal|1
expr_stmt|;
name|fwd_tsn
operator|=
literal|0
expr_stmt|;
operator|*
name|cnt_out
operator|=
literal|0
expr_stmt|;
name|fwd
operator|=
name|NULL
expr_stmt|;
name|endofchain
operator|=
name|m
operator|=
name|NULL
expr_stmt|;
name|auth_keyid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"SCTP hits empty queue with cnt set to %d?\n"
argument_list|,
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|=
literal|0
expr_stmt|;
comment|/* send back 0/0 so we enter normal transmission */
operator|*
name|cnt_out
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_STREAM_RESET
operator|)
operator|||
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
operator|)
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_STREAM_RESET
condition|)
block|{
if|if
condition|(
name|chk
operator|!=
name|asoc
operator|->
name|str_reset
condition|)
block|{
comment|/* 					 * not eligible for retran if its 					 * not ours 					 */
continue|continue;
block|}
block|}
name|ctl_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
condition|)
block|{
name|fwd_tsn
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 			 * Add an AUTH chunk, if chunk requires it save the 			 * offset into the chain for AUTH 			 */
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_auth_is_required_chunk
argument_list|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
operator|)
condition|)
block|{
name|m
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
literal|0
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|one_chunk
operator|=
literal|0
expr_stmt|;
name|cnt_thru
operator|=
literal|0
expr_stmt|;
comment|/* do we have control chunks to retransmit? */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* Start a timer no matter if we suceed or fail */
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|++
expr_stmt|;
comment|/* update our count */
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|endofchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
comment|/* 		 * We don't want to mark the net->sent time here since this 		 * we use this for HB and retrans cannot measure RTT 		 */
comment|/* (void)SCTP_GETTIME_TIMEVAL(&chk->whoTo->last_sent_time); */
operator|*
name|cnt_out
operator|+=
literal|1
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwd_tsn
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* Clean up the fwd-tsn list */
name|sctp_clean_up_ctl
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * Ok, it is just data retransmission we need to do or that and a 	 * fwd-tsn with it all. 	 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
return|return
operator|(
name|SCTP_RETRAN_DONE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
condition|)
block|{
comment|/* not yet open, resend the cookie and that is it */
return|return
operator|(
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|20
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|data_auth_reqd
operator|=
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* No, not sent to this net or not ready for rtx */
continue|continue;
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"TSN:%x chk->snd_count:%d chk->sent:%d can't retran - no data\n"
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|,
name|chk
operator|->
name|sent
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_retran_chunk
argument_list|)
operator|)
operator|&&
operator|(
name|chk
operator|->
name|snd_count
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_retran_chunk
argument_list|)
operator|)
condition|)
block|{
comment|/* Gak, we have exceeded max unlucky retran, abort! */
name|SCTP_PRINTF
argument_list|(
literal|"Gak, chk->snd_count:%d>= max:%d - send abort\n"
argument_list|,
name|chk
operator|->
name|snd_count
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_retran_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|SCTP_RETRAN_EXIT
operator|)
return|;
block|}
comment|/* pick up the net */
name|net
operator|=
name|chk
operator|->
name|whoTo
expr_stmt|;
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|mtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
name|mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|mtu
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* No room in peers rwnd */
name|uint32_t
name|tsn
decl_stmt|;
name|tsn
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tsn
operator|==
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
condition|)
block|{
comment|/* 				 * we make a special exception for this 				 * case. The peer has no rwnd but is missing 				 * the lowest chunk.. which is probably what 				 * is holding up the rwnd. 				 */
goto|goto
name|one_chunk_around
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|one_chunk_around
label|:
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|mtu
condition|)
block|{
name|one_chunk
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|==
literal|0
operator|)
condition|)
block|{
name|chk
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|->
name|window_probe
operator|=
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC3
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bundle_at
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|fast_retran_ip
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|==
literal|0
condition|)
block|{
comment|/* 			 * if no FR in progress skip destination that have 			 * flight_size> cwnd. 			 */
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>=
name|net
operator|->
name|cwnd
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
comment|/* 			 * Mark the destination net to have FR recovery 			 * limits put on it. 			 */
operator|*
name|fr_done
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|fast_retran_ip
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * if no AUTH is yet included and this chunk requires it, 		 * make sure to account for it.  We don't apply the size 		 * until the AUTH chunk is actually added below in case 		 * there is no room for this chunk. 		 */
if|if
condition|(
name|data_auth_reqd
operator|&&
operator|(
name|auth
operator|==
name|NULL
operator|)
condition|)
block|{
name|dmtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|dmtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|<=
operator|(
name|mtu
operator|-
name|dmtu
operator|)
operator|)
operator|||
operator|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
operator|)
condition|)
block|{
comment|/* ok we will add this one */
if|if
condition|(
name|data_auth_reqd
condition|)
block|{
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_DATA
argument_list|)
expr_stmt|;
name|auth_keyid
operator|=
name|chk
operator|->
name|auth_keyid
expr_stmt|;
name|override_ok
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|override_ok
condition|)
block|{
name|auth_keyid
operator|=
name|chk
operator|->
name|auth_keyid
expr_stmt|;
name|override_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chk
operator|->
name|auth_keyid
operator|!=
name|auth_keyid
condition|)
block|{
comment|/* different keyid, so done bundling */
break|break;
block|}
block|}
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
literal|0
argument_list|,
name|chk
operator|->
name|send_size
argument_list|,
name|chk
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|chk
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* upate our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|chk
operator|->
name|send_size
operator|+
name|dmtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|chk
operator|->
name|send_size
operator|+
name|dmtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|data_list
index|[
name|bundle_at
operator|++
index|]
operator|=
name|chk
expr_stmt|;
if|if
condition|(
name|one_chunk
operator|&&
operator|(
name|asoc
operator|->
name|total_flight
operator|<=
literal|0
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_windowprobed
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|one_chunk
operator|==
literal|0
condition|)
block|{
comment|/* 			 * now are there anymore forward from chk to pick 			 * up? 			 */
for|for
control|(
name|fwd
operator|=
name|TAILQ_NEXT
argument_list|(
name|chk
argument_list|,
name|sctp_next
argument_list|)
init|;
name|fwd
operator|!=
name|NULL
condition|;
name|fwd
operator|=
name|TAILQ_NEXT
argument_list|(
name|fwd
argument_list|,
name|sctp_next
argument_list|)
control|)
block|{
if|if
condition|(
name|fwd
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
comment|/* Nope, not for retran */
continue|continue;
block|}
if|if
condition|(
name|fwd
operator|->
name|whoTo
operator|!=
name|net
condition|)
block|{
comment|/* Nope, not the net in question */
continue|continue;
block|}
if|if
condition|(
name|data_auth_reqd
operator|&&
operator|(
name|auth
operator|==
name|NULL
operator|)
condition|)
block|{
name|dmtu
operator|=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
else|else
name|dmtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwd
operator|->
name|send_size
operator|<=
operator|(
name|mtu
operator|-
name|dmtu
operator|)
condition|)
block|{
if|if
condition|(
name|data_auth_reqd
condition|)
block|{
if|if
condition|(
name|auth
operator|==
name|NULL
condition|)
block|{
name|m
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_DATA
argument_list|)
expr_stmt|;
name|auth_keyid
operator|=
name|fwd
operator|->
name|auth_keyid
expr_stmt|;
name|override_ok
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|override_ok
condition|)
block|{
name|auth_keyid
operator|=
name|fwd
operator|->
name|auth_keyid
expr_stmt|;
name|override_ok
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fwd
operator|->
name|auth_keyid
operator|!=
name|auth_keyid
condition|)
block|{
comment|/* 							 * different keyid, 							 * so done bundling 							 */
break|break;
block|}
block|}
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|fwd
operator|->
name|data
argument_list|,
name|m
argument_list|,
operator|&
name|endofchain
argument_list|,
literal|0
argument_list|,
name|fwd
operator|->
name|send_size
argument_list|,
name|fwd
operator|->
name|copy_by_ref
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
comment|/* Do clear IP_DF ? */
if|if
condition|(
name|fwd
operator|->
name|flags
operator|&
name|CHUNK_FLAGS_FRAGMENT_OK
condition|)
block|{
name|no_fragmentflg
operator|=
literal|0
expr_stmt|;
block|}
comment|/* upate our MTU size */
if|if
condition|(
name|mtu
operator|>
operator|(
name|fwd
operator|->
name|send_size
operator|+
name|dmtu
operator|)
condition|)
name|mtu
operator|-=
operator|(
name|fwd
operator|->
name|send_size
operator|+
name|dmtu
operator|)
expr_stmt|;
else|else
name|mtu
operator|=
literal|0
expr_stmt|;
name|data_list
index|[
name|bundle_at
operator|++
index|]
operator|=
name|fwd
expr_stmt|;
if|if
condition|(
name|bundle_at
operator|>=
name|SCTP_MAX_DATA_BUNDLING
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
comment|/* can't fit so we are done */
break|break;
block|}
block|}
block|}
comment|/* Is there something to send for this destination? */
if|if
condition|(
name|m
condition|)
block|{
comment|/* 			 * No matter if we fail/or suceed we should start a 			 * timer. A failure is like a lost IP packet :-) 			 */
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* 				 * no timer running on this destination 				 * restart it. 				 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|tmr_started
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Now lets send it, if there is anything to send :> */
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_lowlevel_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|auth_keyid
argument_list|,
name|no_fragmentflg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
argument_list|,
name|net
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
operator|)
condition|)
block|{
comment|/* error, we could not output */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_lowlevelerr
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|endofchain
operator|=
name|NULL
expr_stmt|;
name|auth
operator|=
name|NULL
expr_stmt|;
name|auth_offset
operator|=
literal|0
expr_stmt|;
comment|/* For HB's */
comment|/* 			 * We don't want to mark the net->sent time here 			 * since this we use this for HB and retrans cannot 			 * measure RTT 			 */
comment|/* (void)SCTP_GETTIME_TIMEVAL(&net->last_sent_time); */
comment|/* For auto-close */
name|cnt_thru
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|now_filled
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_last_sent
argument_list|)
expr_stmt|;
operator|*
name|now
operator|=
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
operator|*
name|now_filled
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|time_last_sent
operator|=
operator|*
name|now
expr_stmt|;
block|}
operator|*
name|cnt_out
operator|+=
name|bundle_at
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xC4
argument_list|,
name|bundle_at
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bundle_at
condition|)
block|{
name|tsns_sent
operator|=
name|data_list
index|[
literal|0
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bundle_at
condition|;
name|i
operator|++
control|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendretransdata
argument_list|)
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_SENT
expr_stmt|;
comment|/* 				 * When we have a revoked data, and we 				 * retransmit it, then we clear the revoked 				 * flag since this flag dictates if we 				 * subtracted from the fs 				 */
if|if
condition|(
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
condition|)
block|{
comment|/* Deflate the cwnd */
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|->
name|cwnd
operator|-=
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|chunk_was_revoked
operator|=
literal|0
expr_stmt|;
block|}
name|data_list
index|[
name|i
index|]
operator|->
name|snd_count
operator|++
expr_stmt|;
name|sctp_ucount_decr
argument_list|(
name|asoc
operator|->
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
comment|/* record the time */
name|data_list
index|[
name|i
index|]
operator|->
name|sent_rcv_time
operator|=
name|asoc
operator|->
name|time_last_sent
expr_stmt|;
if|if
condition|(
name|data_list
index|[
name|i
index|]
operator|->
name|book_size_scale
condition|)
block|{
comment|/* 					 * need to double the book size on 					 * this one 					 */
name|data_list
index|[
name|i
index|]
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
comment|/* 					 * Since we double the booksize, we 					 * must also double the output queue 					 * size, since this get shrunk when 					 * we free by this amount. 					 */
name|atomic_add_int
argument_list|(
operator|&
operator|(
operator|(
name|asoc
operator|)
operator|->
name|total_output_queue_size
operator|)
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
operator|*=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_RWND_ENABLE
condition|)
block|{
name|sctp_log_rwnd
argument_list|(
name|SCTP_DECREASE_PEER_RWND
argument_list|,
name|asoc
operator|->
name|peers_rwnd
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|peers_rwnd
operator|=
name|sctp_sbspace_sub
argument_list|(
name|asoc
operator|->
name|peers_rwnd
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|data_list
index|[
name|i
index|]
operator|->
name|send_size
operator|+
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_peer_chunk_oh
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_UP_RSND
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|data_list
index|[
name|i
index|]
operator|->
name|whoTo
argument_list|,
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
name|sctp_flight_size_increase
argument_list|(
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|sctp_total_flight_increase
argument_list|(
name|stcb
argument_list|,
name|data_list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|asoc
operator|->
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|&&
operator|(
name|data_list
index|[
name|i
index|]
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendfastretrans
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data_list
index|[
name|i
index|]
operator|==
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|)
operator|&&
operator|(
name|tmr_started
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 						 * ok we just fast-retrans'd 						 * the lowest TSN, i.e the 						 * first on the list. In 						 * this case we want to give 						 * some more time to get a 						 * SACK back without a 						 * t3-expiring. 						 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|tsns_sent
argument_list|,
name|SCTP_CWND_LOG_FROM_RESEND
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|21
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* None will fit */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|<=
literal|0
condition|)
block|{
comment|/* all done we have no more to retran */
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|one_chunk
condition|)
block|{
comment|/* No more room in rwnd */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* stop the for loop here. we sent out a packet */
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_timer_validation
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* Validate that a timer is running somewhere */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|rxt_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
comment|/* Here is a timer */
return|return;
block|}
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* Gak, we did not have a timer somewhere */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"Deadlock avoided starting timer on a dest at retran\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|alternate
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|alternate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|sctp_chunk_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|from_where
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/*- 	 * Ok this is the generic chunk service queue. we must do the 	 * following: 	 * - See if there are retransmits pending, if so we must 	 *   do these first. 	 * - Service the stream queue that is next, moving any 	 *   message (note I must get a complete message i.e. 	 *   FIRST/MIDDLE and LAST to the out queue in one pass) and assigning 	 *   TSN's 	 * - Check to see if the cwnd/rwnd allows any output, if so we 	 *   go ahead and fomulate and send the low level chunks. Making sure 	 *   to combine any control in the control chunk queue also. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|num_out
init|=
literal|0
decl_stmt|,
name|tot_out
init|=
literal|0
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|,
name|reason_code
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|burst_cnt
init|=
literal|0
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
name|int
name|nagle_on
decl_stmt|;
name|int
name|frag_point
init|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
decl_stmt|;
name|int
name|un_sent
init|=
literal|0
decl_stmt|;
name|int
name|fr_done
decl_stmt|;
name|unsigned
name|int
name|tot_frs
init|=
literal|0
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* The Nagle algorithm is only applied when handling a send call. */
if|if
condition|(
name|from_where
operator|==
name|SCTP_OUTPUT_FROM_USR_SEND
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
condition|)
block|{
name|nagle_on
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|nagle_on
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|nagle_on
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|un_sent
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|un_sent
operator|<=
literal|0
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_send_queue
argument_list|)
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_retran_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Nothing to do unless there is something to be sent left */
return|return;
block|}
comment|/* 	 * Do we have something to send, data or control AND a sack timer 	 * running, if so piggy-back the sack. 	 */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_OS_TIMER_STOP
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|dack_timer
operator|.
name|timer
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|asoc
operator|->
name|sent_queue_retran_cnt
condition|)
block|{
comment|/*- 		 * Ok, it is retransmission time only, we send out only ONE 		 * packet with a single call off to the retran code. 		 */
if|if
condition|(
name|from_where
operator|==
name|SCTP_OUTPUT_FROM_COOKIE_ACK
condition|)
block|{
comment|/*- 			 * Special hook for handling cookiess discarded 			 * by peer that carried data. Send cookie-ack only 			 * and then the next call with get the retran's. 			 */
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|1
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|from_where
operator|!=
name|SCTP_OUTPUT_FROM_HB_TMR
condition|)
block|{
comment|/* if its not from a HB then do it */
name|fr_done
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|sctp_chunk_retransmission
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
operator|&
name|fr_done
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr_done
condition|)
block|{
name|tot_frs
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * its from any other place, we don't allow retran 			 * output (only control) 			 */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
comment|/* Can't send anymore */
comment|/*- 			 * now lets push out control by calling med-level 			 * output once. this assures that we WILL send HB's 			 * if queued too. 			 */
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|1
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|8
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_timer_validation
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
comment|/*- 			 * The count was off.. retran is not happening so do 			 * the normal retransmission. 			 */
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|9
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
name|SCTP_RETRAN_EXIT
condition|)
block|{
return|return;
block|}
break|break;
block|}
if|if
condition|(
name|from_where
operator|==
name|SCTP_OUTPUT_FROM_T3
condition|)
block|{
comment|/* Only one transmission allowed out of a timeout */
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|10
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Push out any control */
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|1
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|fr_max_burst
operator|>
literal|0
operator|)
operator|&&
operator|(
name|tot_frs
operator|>=
name|asoc
operator|->
name|fr_max_burst
operator|)
condition|)
block|{
comment|/* Hit FR burst limit */
return|return;
block|}
if|if
condition|(
operator|(
name|num_out
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ret
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* No more retrans to send */
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|12
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check for bad destinations, if they exist move chunks around. */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
comment|/*- 			 * if possible move things off of this address we 			 * still may send below due to the dormant state but 			 * we try to find an alternate address to send to 			 * and if we have one we move all queued data on the 			 * out wheel to this alternate address. 			 */
if|if
condition|(
name|net
operator|->
name|ref_count
operator|>
literal|1
condition|)
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*- 			 * if ((asoc->sat_network) || (net->addr_is_local)) 			 * { burst_limit = asoc->max_burst * 			 * SCTP_SAT_NETWORK_BURST_INCR; } 			 */
if|if
condition|(
name|asoc
operator|->
name|max_burst
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_use_cwnd_based_maxburst
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|+
operator|(
name|asoc
operator|->
name|max_burst
operator|*
name|net
operator|->
name|mtu
operator|)
operator|)
operator|<
name|net
operator|->
name|cwnd
condition|)
block|{
comment|/* 						 * JRS - Use the congestion 						 * control given in the 						 * congestion control module 						 */
name|asoc
operator|->
name|cc_functions
operator|.
name|sctp_cwnd_update_after_output
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|asoc
operator|->
name|max_burst
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_MAXBURST_ENABLE
condition|)
block|{
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|max_burst
argument_list|,
name|SCTP_MAX_BURST_APPLIED
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_maxburstqueued
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|fast_retran_ip
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|flight_size
operator|==
literal|0
condition|)
block|{
comment|/* 						 * Should be decaying the 						 * cwnd here 						 */
empty_stmt|;
block|}
block|}
block|}
block|}
block|}
name|burst_cnt
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|error
operator|=
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason_code
argument_list|,
literal|0
argument_list|,
name|from_where
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Error %d was returned from med-c-op\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_MAXBURST_ENABLE
condition|)
block|{
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|,
name|error
argument_list|,
name|burst_cnt
argument_list|,
name|SCTP_MAX_BURST_ERROR_STOP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|error
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
literal|0xdeadbeef
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT3
argument_list|,
literal|"m-c-o put out %d\n"
argument_list|,
name|num_out
argument_list|)
expr_stmt|;
name|tot_out
operator|+=
name|num_out
expr_stmt|;
name|burst_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|num_out
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_out
operator|==
literal|0
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|reason_code
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nagle_on
condition|)
block|{
comment|/* 			 * When the Nagle algorithm is used, look at how 			 * much is unsent, then if its smaller than an MTU 			 * and we have data in flight we stop, except if we 			 * are handling a fragmented user message. 			 */
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|==
name|NULL
operator|)
operator|||
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_is_empty
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
condition|)
block|{
comment|/* Nothing left to send */
break|break;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* Nothing left to send */
break|break;
block|}
block|}
do|while
condition|(
name|num_out
operator|&&
operator|(
operator|(
name|asoc
operator|->
name|max_burst
operator|==
literal|0
operator|)
operator|||
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_use_cwnd_based_maxburst
argument_list|)
operator|||
operator|(
name|burst_cnt
operator|<
name|asoc
operator|->
name|max_burst
operator|)
operator|)
condition|)
do|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_use_cwnd_based_maxburst
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|asoc
operator|->
name|max_burst
operator|>
literal|0
operator|)
operator|&&
operator|(
name|burst_cnt
operator|>=
name|asoc
operator|->
name|max_burst
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_maxburstqueued
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|burst_limit_applied
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_MAXBURST_ENABLE
condition|)
block|{
name|sctp_log_maxburst
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|,
literal|0
argument_list|,
name|burst_cnt
argument_list|,
name|SCTP_MAX_BURST_APPLIED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|asoc
operator|->
name|burst_limit_applied
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_CWND_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|tot_out
argument_list|,
name|SCTP_SEND_NOW_COMPLETES
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Ok, we have put out %d chunks\n"
argument_list|,
name|tot_out
argument_list|)
expr_stmt|;
comment|/*- 	 * Now we need to clean up the control chunk chain if a ECNE is on 	 * it. It must be marked as UNSENT again so next call will continue 	 * to send it until such time that we get a CWR, to remove it. 	 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
condition|)
name|sctp_fix_ecn_echo
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|sctp_output
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|sctp_sosend
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|,
name|addr
argument_list|,
operator|(
expr|struct
name|uio
operator|*
operator|)
name|NULL
argument_list|,
name|m
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|send_forward_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_forward_tsn_chunk
modifier|*
name|fwdtsn
decl_stmt|;
name|uint32_t
name|advance_peer_ack_point
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_FORWARD_CUM_TSN
condition|)
block|{
comment|/* mark it to unsent */
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
comment|/* Do we correct its output location? */
if|if
condition|(
name|chk
operator|->
name|whoTo
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|sctp_fill_in_rest
goto|;
block|}
block|}
comment|/* Ok if we reach here we must build one */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|->
name|fwd_tsn_cnt
operator|++
expr_stmt|;
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|sctp_fill_in_rest
label|:
comment|/*- 	 * Here we go through and fill out the part that deals with 	 * stream/seq of the ones we skip. 	 */
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
literal|0
expr_stmt|;
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|at
decl_stmt|,
modifier|*
name|tp1
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|sctp_strseq
modifier|*
name|strseq
decl_stmt|;
name|unsigned
name|int
name|cnt_of_space
decl_stmt|,
name|i
decl_stmt|,
name|ovh
decl_stmt|;
name|unsigned
name|int
name|space_needed
decl_stmt|;
name|unsigned
name|int
name|cnt_of_skipped
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|at
argument_list|,
argument|&asoc->sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|at
operator|->
name|sent
operator|!=
name|SCTP_FORWARD_TSN_SKIP
operator|)
operator|&&
operator|(
name|at
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_NR_ACKED
operator|)
condition|)
block|{
comment|/* no more to look at */
break|break;
block|}
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* We don't report these */
continue|continue;
block|}
name|cnt_of_skipped
operator|++
expr_stmt|;
block|}
name|space_needed
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
operator|+
operator|(
name|cnt_of_skipped
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
operator|)
operator|)
expr_stmt|;
name|cnt_of_space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MIN_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MIN_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
name|cnt_of_space
operator|>
operator|(
name|asoc
operator|->
name|smallest_mtu
operator|-
name|ovh
operator|)
condition|)
block|{
comment|/* trim to a mtu size */
name|cnt_of_space
operator|=
name|asoc
operator|->
name|smallest_mtu
operator|-
name|ovh
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
literal|0xff
argument_list|,
literal|0
argument_list|,
name|cnt_of_skipped
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|)
expr_stmt|;
block|}
name|advance_peer_ack_point
operator|=
name|asoc
operator|->
name|advanced_peer_ack_point
expr_stmt|;
if|if
condition|(
name|cnt_of_space
operator|<
name|space_needed
condition|)
block|{
comment|/*- 			 * ok we must trim down the chunk by lowering the 			 * advance peer ack point. 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
literal|0xff
argument_list|,
literal|0xff
argument_list|,
name|cnt_of_space
argument_list|,
name|space_needed
argument_list|)
expr_stmt|;
block|}
name|cnt_of_skipped
operator|=
name|cnt_of_space
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
expr_stmt|;
name|cnt_of_skipped
operator|/=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
comment|/*- 			 * Go through and find the TSN that will be the one 			 * we report. 			 */
name|at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt_of_skipped
condition|;
name|i
operator|++
control|)
block|{
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
break|break;
block|}
name|at
operator|=
name|tp1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|at
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOG_TRY_ADVANCE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FWD_TSN_CHECK
argument_list|,
literal|0xff
argument_list|,
name|cnt_of_skipped
argument_list|,
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|asoc
operator|->
name|advanced_peer_ack_point
argument_list|)
expr_stmt|;
block|}
name|last
operator|=
name|at
expr_stmt|;
comment|/*- 			 * last now points to last one I can report, update 			 * peer ack point 			 */
if|if
condition|(
name|last
condition|)
name|advance_peer_ack_point
operator|=
name|last
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
name|space_needed
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
operator|+
name|cnt_of_skipped
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_strseq
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|send_size
operator|=
name|space_needed
expr_stmt|;
comment|/* Setup the chunk */
name|fwdtsn
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_forward_tsn_chunk
operator|*
argument_list|)
expr_stmt|;
name|fwdtsn
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|fwdtsn
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|fwdtsn
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|fwdtsn
operator|->
name|new_cumulative_tsn
operator|=
name|htonl
argument_list|(
name|advance_peer_ack_point
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|fwdtsn
operator|++
expr_stmt|;
comment|/*- 		 * Move pointer to after the fwdtsn and transfer to the 		 * strseq pointer. 		 */
name|strseq
operator|=
operator|(
expr|struct
name|sctp_strseq
operator|*
operator|)
name|fwdtsn
expr_stmt|;
comment|/*- 		 * Now populate the strseq list. This is done blindly 		 * without pulling out duplicate stream info. This is 		 * inefficent but won't harm the process since the peer will 		 * look at these in sequence and will thus release anything. 		 * It could mean we exceed the PMTU and chop off some that 		 * we could have included.. but this is unlikely (aka 1432/4 		 * would mean 300+ stream seq's would have to be reported in 		 * one FWD-TSN. With a bit of work we can later FIX this to 		 * optimize and pull out duplcates.. but it does add more 		 * overhead. So for now... not! 		 */
name|at
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt_of_skipped
condition|;
name|i
operator|++
control|)
block|{
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|at
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|rcv_flags
operator|&
name|SCTP_DATA_UNORDERED
condition|)
block|{
comment|/* We don't report these */
name|i
operator|--
expr_stmt|;
name|at
operator|=
name|tp1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|advance_peer_ack_point
condition|)
block|{
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|fwd_tsn_cnt
operator|=
literal|0
expr_stmt|;
block|}
name|strseq
operator|->
name|stream
operator|=
name|ntohs
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_number
argument_list|)
expr_stmt|;
name|strseq
operator|->
name|sequence
operator|=
name|ntohs
argument_list|(
name|at
operator|->
name|rec
operator|.
name|data
operator|.
name|stream_seq
argument_list|)
expr_stmt|;
name|strseq
operator|++
expr_stmt|;
name|at
operator|=
name|tp1
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_sack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
comment|/*- 	 * Queue up a SACK or NR-SACK in the control queue. 	 * We must first check to see if a SACK or NR-SACK is 	 * somehow on the control queue. 	 * If so, we will take and and remove the old one. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|a_chk
decl_stmt|;
name|struct
name|sctp_sack_chunk
modifier|*
name|sack
decl_stmt|;
name|struct
name|sctp_nr_sack_chunk
modifier|*
name|nr_sack
decl_stmt|;
name|struct
name|sctp_gap_ack_block
modifier|*
name|gap_descriptor
decl_stmt|;
name|struct
name|sack_track
modifier|*
name|selector
decl_stmt|;
name|int
name|mergeable
init|=
literal|0
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|caddr_t
name|limit
decl_stmt|;
name|uint32_t
modifier|*
name|dup
decl_stmt|;
name|int
name|limit_reached
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|,
name|siz
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|int
name|num_gap_blocks
init|=
literal|0
decl_stmt|,
name|num_nr_gap_blocks
init|=
literal|0
decl_stmt|,
name|space
decl_stmt|;
name|int
name|num_dups
init|=
literal|0
decl_stmt|;
name|int
name|space_req
decl_stmt|;
name|uint32_t
name|highest_tsn
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|uint8_t
name|type
decl_stmt|;
name|uint8_t
name|tsn_map
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|nrsack_supported
operator|==
literal|1
condition|)
block|{
name|type
operator|=
name|SCTP_NR_SELECTIVE_ACK
expr_stmt|;
block|}
else|else
block|{
name|type
operator|=
name|SCTP_SELECTIVE_ACK
expr_stmt|;
block|}
name|a_chk
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|last_data_chunk_from
operator|==
name|NULL
condition|)
block|{
comment|/* Hmm we never received anything */
return|return;
block|}
name|sctp_slide_mapping_arrays
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_set_rwnd
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|type
condition|)
block|{
comment|/* Hmm, found a sack already on queue, remove it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|a_chk
operator|=
name|chk
expr_stmt|;
if|if
condition|(
name|a_chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|a_chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|a_chk
operator|->
name|whoTo
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|a_chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|a_chk
operator|==
name|NULL
condition|)
block|{
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|a_chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_chk
operator|==
name|NULL
condition|)
block|{
comment|/* No memory so we drop the idea, and set a timer */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
name|a_chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|type
expr_stmt|;
name|a_chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Clear our pkt counts */
name|asoc
operator|->
name|data_pkts_seen
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|asoc
operator|=
name|asoc
expr_stmt|;
name|a_chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|send_size
operator|=
literal|0
expr_stmt|;
comment|/* fill in later */
name|a_chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|numduptsns
operator|)
operator|||
operator|(
operator|!
operator|(
name|asoc
operator|->
name|last_data_chunk_from
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|)
condition|)
block|{
comment|/*- 		 * Ok, we have some duplicates or the destination for the 		 * sack is unreachable, lets see if we can select an 		 * alternate than asoc->last_data_chunk_from 		 */
if|if
condition|(
operator|(
name|asoc
operator|->
name|last_data_chunk_from
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|used_alt_onsack
operator|>
name|asoc
operator|->
name|numnets
operator|)
condition|)
block|{
comment|/* We used an alt last time, don't this time */
name|a_chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|used_alt_onsack
operator|++
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|sctp_find_alternate_net
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|last_data_chunk_from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|a_chk
operator|->
name|whoTo
operator|==
name|NULL
condition|)
block|{
comment|/* Nope, no alternate */
name|a_chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|last_data_chunk_from
expr_stmt|;
name|asoc
operator|->
name|used_alt_onsack
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * No duplicates so we use the last place we received data 		 * from. 		 */
name|asoc
operator|->
name|used_alt_onsack
operator|=
literal|0
expr_stmt|;
name|a_chk
operator|->
name|whoTo
operator|=
name|asoc
operator|->
name|last_data_chunk_from
expr_stmt|;
block|}
if|if
condition|(
name|a_chk
operator|->
name|whoTo
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|a_chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|)
condition|)
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
block|}
else|else
block|{
name|highest_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_nr_map
expr_stmt|;
block|}
if|if
condition|(
name|highest_tsn
operator|==
name|asoc
operator|->
name|cumulative_tsn
condition|)
block|{
comment|/* no gaps */
if|if
condition|(
name|type
operator|==
name|SCTP_SELECTIVE_ACK
condition|)
block|{
name|space_req
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|space_req
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* gaps get a cluster */
name|space_req
operator|=
name|MCLBYTES
expr_stmt|;
block|}
comment|/* Ok now lets formulate a MBUF with our sack */
name|a_chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|space_req
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a_chk
operator|->
name|data
operator|==
name|NULL
operator|)
operator|||
operator|(
name|a_chk
operator|->
name|whoTo
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* rats, no mbuf memory */
if|if
condition|(
name|a_chk
operator|->
name|data
condition|)
block|{
comment|/* was a problem with the destination */
name|sctp_m_freem
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|a_chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|a_chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
return|return;
block|}
comment|/* ok, lets go through and fill it in */
name|SCTP_BUF_RESV_UF
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|space
operator|=
name|M_TRAILINGSPACE
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|>
operator|(
name|a_chk
operator|->
name|whoTo
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
operator|)
condition|)
block|{
name|space
operator|=
operator|(
name|a_chk
operator|->
name|whoTo
operator|->
name|mtu
operator|-
name|SCTP_MIN_OVERHEAD
operator|)
expr_stmt|;
block|}
name|limit
operator|=
name|mtod
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
name|limit
operator|+=
name|space
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|>
literal|0
operator|)
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_use_dac
argument_list|)
condition|)
block|{
comment|/*- 		 * CMT DAC algorithm: If 2 (i.e., 0x10) packets have been 		 * received, then set high bit to 1, else 0. Reset 		 * pkts_rcvd. 		 */
name|flags
operator||=
operator|(
name|asoc
operator|->
name|cmt_dac_pkts_rcvd
operator|<<
literal|6
operator|)
expr_stmt|;
name|asoc
operator|->
name|cmt_dac_pkts_rcvd
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|stcb
operator|->
name|asoc
operator|.
name|cumack_logsnt
index|[
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_atsnt
index|]
operator|=
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_atsnt
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_atsnt
operator|>=
name|SCTP_TSN_LOG_SIZE
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cumack_log_atsnt
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* reset the readers interpretation */
name|stcb
operator|->
name|freed_by_sorcv_sincelast
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SCTP_SELECTIVE_ACK
condition|)
block|{
name|sack
operator|=
name|mtod
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_sack_chunk
operator|*
argument_list|)
expr_stmt|;
name|nr_sack
operator|=
name|NULL
expr_stmt|;
name|gap_descriptor
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sack
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|highest_tsn
operator|>
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|siz
operator|=
operator|(
operator|(
operator|(
name|highest_tsn
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|siz
operator|=
operator|(
operator|(
operator|(
name|MAX_TSN
operator|-
name|highest_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
name|highest_tsn
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
name|sack
operator|=
name|NULL
expr_stmt|;
name|nr_sack
operator|=
name|mtod
argument_list|(
name|a_chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_nr_sack_chunk
operator|*
argument_list|)
expr_stmt|;
name|gap_descriptor
operator|=
operator|(
expr|struct
name|sctp_gap_ack_block
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nr_sack
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|>
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|siz
operator|=
operator|(
operator|(
operator|(
name|asoc
operator|->
name|highest_tsn_inside_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|siz
operator|=
operator|(
operator|(
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|-
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|highest_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|type
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
operator|&&
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
operator|)
condition|)
block|{
comment|/* we have a gap .. maybe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
block|{
name|tsn_map
operator|=
name|asoc
operator|->
name|mapping_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SCTP_SELECTIVE_ACK
condition|)
block|{
name|tsn_map
operator||=
name|asoc
operator|->
name|nr_mapping_array
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Clear all bits corresponding to TSNs 				 * smaller or equal to the cumulative TSN. 				 */
name|tsn_map
operator|&=
operator|(
operator|~
literal|0
operator|<<
operator|(
literal|1
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
block|}
name|selector
operator|=
operator|&
name|sack_array
index|[
name|tsn_map
index|]
expr_stmt|;
if|if
condition|(
name|mergeable
operator|&&
name|selector
operator|->
name|right_edge
condition|)
block|{
comment|/* 				 * Backup, left and right edges were ok to 				 * merge. 				 */
name|num_gap_blocks
operator|--
expr_stmt|;
name|gap_descriptor
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|selector
operator|->
name|num_entries
operator|==
literal|0
condition|)
name|mergeable
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|selector
operator|->
name|num_entries
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mergeable
operator|&&
name|selector
operator|->
name|right_edge
condition|)
block|{
comment|/* 						 * do a merge by NOT setting 						 * the left side 						 */
name|mergeable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 						 * no merge, set the left 						 * side 						 */
name|mergeable
operator|=
literal|0
expr_stmt|;
name|gap_descriptor
operator|->
name|start
operator|=
name|htons
argument_list|(
operator|(
name|selector
operator|->
name|gaps
index|[
name|j
index|]
operator|.
name|start
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
name|gap_descriptor
operator|->
name|end
operator|=
name|htons
argument_list|(
operator|(
name|selector
operator|->
name|gaps
index|[
name|j
index|]
operator|.
name|end
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
name|num_gap_blocks
operator|++
expr_stmt|;
name|gap_descriptor
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|gap_descriptor
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|>
name|limit
condition|)
block|{
comment|/* no more room */
name|limit_reached
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|selector
operator|->
name|left_edge
condition|)
block|{
name|mergeable
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|limit_reached
condition|)
block|{
comment|/* Reached the limit stop */
break|break;
block|}
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|type
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
operator|&&
operator|(
name|limit_reached
operator|==
literal|0
operator|)
condition|)
block|{
name|mergeable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|>
name|asoc
operator|->
name|mapping_array_base_tsn
condition|)
block|{
name|siz
operator|=
operator|(
operator|(
operator|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
else|else
block|{
name|siz
operator|=
operator|(
operator|(
operator|(
name|MAX_TSN
operator|-
name|asoc
operator|->
name|mapping_array_base_tsn
operator|)
operator|+
literal|1
operator|)
operator|+
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|+
literal|7
operator|)
operator|/
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|mapping_array_base_tsn
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
condition|)
block|{
name|offset
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
operator|-
name|asoc
operator|->
name|cumulative_tsn
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|asoc
operator|->
name|highest_tsn_inside_nr_map
argument_list|,
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
condition|)
block|{
comment|/* we have a gap .. maybe */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|siz
condition|;
name|i
operator|++
control|)
block|{
name|tsn_map
operator|=
name|asoc
operator|->
name|nr_mapping_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Clear all bits corresponding to 					 * TSNs smaller or equal to the 					 * cumulative TSN. 					 */
name|tsn_map
operator|&=
operator|(
operator|~
literal|0
operator|<<
operator|(
literal|1
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
block|}
name|selector
operator|=
operator|&
name|sack_array
index|[
name|tsn_map
index|]
expr_stmt|;
if|if
condition|(
name|mergeable
operator|&&
name|selector
operator|->
name|right_edge
condition|)
block|{
comment|/* 					 * Backup, left and right edges were 					 * ok to merge. 					 */
name|num_nr_gap_blocks
operator|--
expr_stmt|;
name|gap_descriptor
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|selector
operator|->
name|num_entries
operator|==
literal|0
condition|)
name|mergeable
operator|=
literal|0
expr_stmt|;
else|else
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|selector
operator|->
name|num_entries
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|mergeable
operator|&&
name|selector
operator|->
name|right_edge
condition|)
block|{
comment|/* 							 * do a merge by NOT 							 * setting the left 							 * side 							 */
name|mergeable
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 							 * no merge, set the 							 * left side 							 */
name|mergeable
operator|=
literal|0
expr_stmt|;
name|gap_descriptor
operator|->
name|start
operator|=
name|htons
argument_list|(
operator|(
name|selector
operator|->
name|gaps
index|[
name|j
index|]
operator|.
name|start
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
block|}
name|gap_descriptor
operator|->
name|end
operator|=
name|htons
argument_list|(
operator|(
name|selector
operator|->
name|gaps
index|[
name|j
index|]
operator|.
name|end
operator|+
name|offset
operator|)
argument_list|)
expr_stmt|;
name|num_nr_gap_blocks
operator|++
expr_stmt|;
name|gap_descriptor
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|gap_descriptor
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|)
operator|>
name|limit
condition|)
block|{
comment|/* no more room */
name|limit_reached
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|selector
operator|->
name|left_edge
condition|)
block|{
name|mergeable
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|limit_reached
condition|)
block|{
comment|/* Reached the limit stop */
break|break;
block|}
name|offset
operator|+=
literal|8
expr_stmt|;
block|}
block|}
block|}
comment|/* now we must add any dups we are going to report. */
if|if
condition|(
operator|(
name|limit_reached
operator|==
literal|0
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|numduptsns
operator|)
condition|)
block|{
name|dup
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|gap_descriptor
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|numduptsns
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|dup
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|dup_tsns
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dup
operator|++
expr_stmt|;
name|num_dups
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|dup
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|>
name|limit
condition|)
block|{
comment|/* no more room */
break|break;
block|}
block|}
name|asoc
operator|->
name|numduptsns
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * now that the chunk is prepared queue it to the control chunk 	 * queue. 	 */
if|if
condition|(
name|type
operator|==
name|SCTP_SELECTIVE_ACK
condition|)
block|{
name|a_chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|+
operator|(
name|num_gap_blocks
operator|+
name|num_nr_gap_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|+
name|num_dups
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
operator|=
name|a_chk
operator|->
name|send_size
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|cum_tsn_ack
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|my_rwnd
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|num_gap_ack_blks
operator|=
name|htons
argument_list|(
name|num_gap_blocks
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack
operator|.
name|num_dup_tsns
operator|=
name|htons
argument_list|(
name|num_dups
argument_list|)
expr_stmt|;
name|sack
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|type
expr_stmt|;
name|sack
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|flags
expr_stmt|;
name|sack
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|a_chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a_chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
operator|+
operator|(
name|num_gap_blocks
operator|+
name|num_nr_gap_blocks
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|+
name|num_dups
operator|*
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|a_chk
operator|->
name|data
argument_list|)
operator|=
name|a_chk
operator|->
name|send_size
expr_stmt|;
name|nr_sack
operator|->
name|nr_sack
operator|.
name|cum_tsn_ack
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|)
expr_stmt|;
name|nr_sack
operator|->
name|nr_sack
operator|.
name|a_rwnd
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|my_rwnd
argument_list|)
expr_stmt|;
name|nr_sack
operator|->
name|nr_sack
operator|.
name|num_gap_ack_blks
operator|=
name|htons
argument_list|(
name|num_gap_blocks
argument_list|)
expr_stmt|;
name|nr_sack
operator|->
name|nr_sack
operator|.
name|num_nr_gap_ack_blks
operator|=
name|htons
argument_list|(
name|num_nr_gap_blocks
argument_list|)
expr_stmt|;
name|nr_sack
operator|->
name|nr_sack
operator|.
name|num_dup_tsns
operator|=
name|htons
argument_list|(
name|num_dups
argument_list|)
expr_stmt|;
name|nr_sack
operator|->
name|nr_sack
operator|.
name|reserved
operator|=
literal|0
expr_stmt|;
name|nr_sack
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|type
expr_stmt|;
name|nr_sack
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|flags
expr_stmt|;
name|nr_sack
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|a_chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|a_chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_last_reported_rwnd
operator|=
name|asoc
operator|->
name|my_rwnd
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|asoc
operator|->
name|send_sack
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendsacks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_abort_tcb
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|operr
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_abort
decl_stmt|,
modifier|*
name|m
decl_stmt|,
modifier|*
name|m_last
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_out
decl_stmt|,
modifier|*
name|m_end
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_abort_chunk
modifier|*
name|abort
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|uint32_t
name|vtag
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|;
name|uint16_t
name|cause_len
decl_stmt|,
name|chunk_len
decl_stmt|,
name|padding_len
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/*- 	 * Add an AUTH chunk, if chunk requires it and save the offset into 	 * the chain for AUTH 	 */
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_ABORT_ASSOCIATION
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|m_out
operator|=
name|sctp_add_auth_chunk
argument_list|(
name|NULL
argument_list|,
operator|&
name|m_end
argument_list|,
operator|&
name|auth
argument_list|,
operator|&
name|auth_offset
argument_list|,
name|stcb
argument_list|,
name|SCTP_ABORT_ASSOCIATION
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m_out
operator|=
name|NULL
expr_stmt|;
block|}
name|m_abort
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_abort
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|m_out
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|operr
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|operr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* link in any error */
name|SCTP_BUF_NEXT
argument_list|(
name|m_abort
argument_list|)
operator|=
name|operr
expr_stmt|;
name|cause_len
operator|=
literal|0
expr_stmt|;
name|m_last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|m
operator|=
name|operr
init|;
name|m
condition|;
name|m
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
control|)
block|{
name|cause_len
operator|+=
operator|(
name|uint16_t
operator|)
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|m_last
operator|=
name|m
expr_stmt|;
block|}
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_abort
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_chunk
argument_list|)
expr_stmt|;
name|chunk_len
operator|=
operator|(
name|uint16_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_chunk
argument_list|)
operator|+
name|cause_len
expr_stmt|;
name|padding_len
operator|=
name|SCTP_SIZE32
argument_list|(
name|chunk_len
argument_list|)
operator|-
name|chunk_len
expr_stmt|;
if|if
condition|(
name|m_out
operator|==
name|NULL
condition|)
block|{
comment|/* NO Auth chunk prepended, so reserve space in front */
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_abort
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|m_out
operator|=
name|m_abort
expr_stmt|;
block|}
else|else
block|{
comment|/* Put AUTH chunk at the front of the chain */
name|SCTP_BUF_NEXT
argument_list|(
name|m_end
argument_list|)
operator|=
name|m_abort
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
comment|/* Fill in the ABORT chunk header. */
name|abort
operator|=
name|mtod
argument_list|(
name|m_abort
argument_list|,
expr|struct
name|sctp_abort_chunk
operator|*
argument_list|)
expr_stmt|;
name|abort
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ABORT_ASSOCIATION
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|==
literal|0
condition|)
block|{
comment|/* This happens iff the assoc is in COOKIE-WAIT state. */
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
expr_stmt|;
name|abort
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|SCTP_HAD_NO_TCB
expr_stmt|;
block|}
else|else
block|{
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
name|abort
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
block|}
name|abort
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chunk_len
argument_list|)
expr_stmt|;
comment|/* Add padding, if necessary. */
if|if
condition|(
name|padding_len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m_last
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sctp_add_pad_tombuf
argument_list|(
name|m_last
argument_list|,
name|padding_len
argument_list|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_out
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
operator|(
name|void
operator|)
name|sctp_lowlevel_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m_out
argument_list|,
name|auth_offset
argument_list|,
name|auth
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|vtag
argument_list|)
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_shutdown_complete
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|reflect_vtag
parameter_list|)
block|{
comment|/* formulate and SEND a SHUTDOWN-COMPLETE */
name|struct
name|mbuf
modifier|*
name|m_shutdown_comp
decl_stmt|;
name|struct
name|sctp_shutdown_complete_chunk
modifier|*
name|shutdown_complete
decl_stmt|;
name|uint32_t
name|vtag
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|m_shutdown_comp
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_shutdown_comp
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return;
block|}
if|if
condition|(
name|reflect_vtag
condition|)
block|{
name|flags
operator|=
name|SCTP_HAD_NO_TCB
expr_stmt|;
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
literal|0
expr_stmt|;
name|vtag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
block|}
name|shutdown_complete
operator|=
name|mtod
argument_list|(
name|m_shutdown_comp
argument_list|,
expr|struct
name|sctp_shutdown_complete_chunk
operator|*
argument_list|)
expr_stmt|;
name|shutdown_complete
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_SHUTDOWN_COMPLETE
expr_stmt|;
name|shutdown_complete
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|flags
expr_stmt|;
name|shutdown_complete
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_shutdown_comp
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_complete_chunk
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_lowlevel_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|m_shutdown_comp
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
name|htonl
argument_list|(
name|vtag
argument_list|)
argument_list|,
name|net
operator|->
name|port
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_send_resp_msg
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|uint8_t
name|type
parameter_list|,
name|struct
name|mbuf
modifier|*
name|cause
parameter_list|,
name|uint8_t
name|use_mflowid
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|o_pak
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mout
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|shout
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|udphdr
modifier|*
name|udp
decl_stmt|;
name|int
name|ret
decl_stmt|;
endif|#
directive|endif
name|int
name|len
decl_stmt|,
name|cause_len
decl_stmt|,
name|padding_len
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|src_sin
decl_stmt|,
modifier|*
name|dst_sin
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|src_sin6
decl_stmt|,
modifier|*
name|dst_sin6
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
comment|/* Compute the length of the cause and add final padding. */
name|cause_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cause
operator|!=
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m_at
decl_stmt|,
modifier|*
name|m_last
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|m_at
operator|=
name|cause
init|;
name|m_at
condition|;
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|==
name|NULL
condition|)
name|m_last
operator|=
name|m_at
expr_stmt|;
name|cause_len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
name|padding_len
operator|=
name|cause_len
operator|%
literal|4
expr_stmt|;
if|if
condition|(
name|padding_len
operator|!=
literal|0
condition|)
block|{
name|padding_len
operator|=
literal|4
operator|-
name|padding_len
expr_stmt|;
block|}
if|if
condition|(
name|padding_len
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sctp_add_pad_tombuf
argument_list|(
name|m_last
argument_list|,
name|padding_len
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|cause
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
else|else
block|{
name|padding_len
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Get an mbuf for the header. */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|port
condition|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|mout
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
operator|+
name|max_linkhdr
argument_list|,
literal|1
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mout
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cause
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|cause
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|mout
argument_list|,
name|max_linkhdr
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mout
argument_list|)
operator|=
name|len
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|mout
argument_list|)
operator|=
name|cause
expr_stmt|;
if|if
condition|(
name|use_mflowid
operator|!=
literal|0
condition|)
block|{
name|mout
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|mflowid
expr_stmt|;
name|mout
operator|->
name|m_flags
operator||=
name|M_FLOWID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
name|ip
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|ip6
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|src_sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
expr_stmt|;
name|dst_sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
expr_stmt|;
name|ip
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|ip
operator|->
name|ip_v
operator|=
name|IPVERSION
expr_stmt|;
name|ip
operator|->
name|ip_hl
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_id
operator|=
name|ip_newid
argument_list|()
expr_stmt|;
name|ip
operator|->
name|ip_off
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|ip_ttl
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ip_defttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|->
name|ip_p
operator|=
name|IPPROTO_SCTP
expr_stmt|;
block|}
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|=
name|dst_sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
operator|=
name|src_sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|ip
operator|->
name|ip_sum
operator|=
literal|0
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
expr_stmt|;
name|shout
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|len
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|src_sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
expr_stmt|;
name|dst_sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|ip6
operator|->
name|ip6_flow
operator|=
name|htonl
argument_list|(
literal|0x60000000
argument_list|)
expr_stmt|;
if|if
condition|(
name|V_ip6_auto_flowlabel
condition|)
block|{
name|ip6
operator|->
name|ip6_flow
operator||=
operator|(
name|htonl
argument_list|(
name|ip6_randomflowlabel
argument_list|()
argument_list|)
operator|&
name|IPV6_FLOWLABEL_MASK
operator|)
expr_stmt|;
block|}
name|ip6
operator|->
name|ip6_hlim
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ip6_defhlim
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_UDP
expr_stmt|;
block|}
else|else
block|{
name|ip6
operator|->
name|ip6_nxt
operator|=
name|IPPROTO_SCTP
expr_stmt|;
block|}
name|ip6
operator|->
name|ip6_src
operator|=
name|dst_sin6
operator|->
name|sin6_addr
expr_stmt|;
name|ip6
operator|->
name|ip6_dst
operator|=
name|src_sin6
operator|->
name|sin6_addr
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
name|shout
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|len
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|len
operator|=
literal|0
expr_stmt|;
name|shout
operator|=
name|mtod
argument_list|(
name|mout
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|port
condition|)
block|{
if|if
condition|(
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mout
argument_list|)
expr_stmt|;
return|return;
block|}
name|udp
operator|=
operator|(
expr|struct
name|udphdr
operator|*
operator|)
name|shout
expr_stmt|;
name|udp
operator|->
name|uh_sport
operator|=
name|htons
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_udp_tunneling_port
argument_list|)
argument_list|)
expr_stmt|;
name|udp
operator|->
name|uh_dport
operator|=
name|port
expr_stmt|;
name|udp
operator|->
name|uh_sum
operator|=
literal|0
expr_stmt|;
name|udp
operator|->
name|uh_ulen
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|+
name|cause_len
operator|+
name|padding_len
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
name|shout
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|shout
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|udp
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
name|shout
operator|->
name|src_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|shout
operator|->
name|dest_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|shout
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
block|{
name|shout
operator|->
name|v_tag
operator|=
name|htonl
argument_list|(
name|vtag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shout
operator|->
name|v_tag
operator|=
name|sh
operator|->
name|v_tag
expr_stmt|;
block|}
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|shout
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
name|ch
operator|->
name|chunk_type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|vtag
condition|)
block|{
name|ch
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|->
name|chunk_flags
operator|=
name|SCTP_HAD_NO_TCB
expr_stmt|;
block|}
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|+
name|cause_len
argument_list|)
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|len
operator|+=
name|cause_len
operator|+
name|padding_len
expr_stmt|;
if|if
condition|(
name|SCTP_GET_HEADER_FOR_OUTPUT
argument_list|(
name|o_pak
argument_list|)
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mout
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_ATTACH_CHAIN
argument_list|(
name|o_pak
argument_list|,
name|mout
argument_list|,
name|len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|dst
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|port
condition|)
block|{
if|if
condition|(
name|V_udp_cksum
condition|)
block|{
name|udp
operator|->
name|uh_sum
operator|=
name|in_pseudo
argument_list|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
argument_list|,
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|,
name|udp
operator|->
name|uh_ulen
operator|+
name|htons
argument_list|(
name|IPPROTO_UDP
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|udp
operator|->
name|uh_sum
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ip
operator|->
name|ip_len
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|shout
operator|->
name|checksum
operator|=
name|sctp_calculate_cksum
argument_list|(
name|mout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendswcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|V_udp_cksum
condition|)
block|{
name|SCTP_ENABLE_UDP_CSUM
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|mout
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_SCTP
expr_stmt|;
name|mout
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendhwcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LAST_PACKET_TRACING
condition|)
block|{
name|sctp_packet_log
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_IP_OUTPUT
argument_list|(
name|ret
argument_list|,
name|o_pak
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ip6
operator|->
name|ip6_plen
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|shout
operator|->
name|checksum
operator|=
name|sctp_calculate_cksum
argument_list|(
name|mout
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendswcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|udp
operator|->
name|uh_sum
operator|=
name|in6_cksum
argument_list|(
name|o_pak
argument_list|,
name|IPPROTO_UDP
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|,
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|udp
operator|->
name|uh_sum
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
name|mout
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|=
name|CSUM_SCTP_IPV6
expr_stmt|;
name|mout
operator|->
name|m_pkthdr
operator|.
name|csum_data
operator|=
name|offsetof
argument_list|(
expr|struct
name|sctphdr
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendhwcrc
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LAST_PACKET_TRACING
condition|)
block|{
name|sctp_packet_log
argument_list|(
name|o_pak
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTP_IP6_OUTPUT
argument_list|(
name|ret
argument_list|,
name|o_pak
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Unknown protocol (TSNH) type %d\n"
argument_list|,
name|dst
operator|->
name|sa_family
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|mout
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|mout
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_outcontrolchunks
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_shutdown_complete2
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|uint8_t
name|use_mflowid
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|sctp_send_resp_msg
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|SCTP_SHUTDOWN_COMPLETE
argument_list|,
name|NULL
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_hb
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_heartbeat_chunk
modifier|*
name|hb
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
break|break;
endif|#
directive|endif
default|default:
return|return;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT4
argument_list|,
literal|"Gak, can't get a chunk for hb\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_HEARTBEAT_REQUEST
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|chk
operator|->
name|send_size
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Now we have a mbuf that we can fill in with the details */
name|hb
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_heartbeat_chunk
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hb
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill out chunk header */
name|hb
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_HEARTBEAT_REQUEST
expr_stmt|;
name|hb
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|hb
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
comment|/* Fill out hb parameter */
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_HEARTBEAT_INFO
argument_list|)
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_info_param
argument_list|)
argument_list|)
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_1
operator|=
name|now
operator|.
name|tv_sec
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_2
operator|=
name|now
operator|.
name|tv_usec
expr_stmt|;
comment|/* Did our user request this one, put it in */
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
operator|=
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
operator|=
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* 		 * we only take from the entropy pool if the address is not 		 * confirmed. 		 */
name|net
operator|->
name|heartbeat_random1
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value1
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|net
operator|->
name|heartbeat_random2
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value2
operator|=
name|sctp_select_initial_TSN
argument_list|(
operator|&
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|net
operator|->
name|heartbeat_random1
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value1
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|heartbeat_random2
operator|=
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value2
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|memcpy
argument_list|(
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|memcpy
argument_list|(
name|hb
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
return|return;
break|break;
block|}
name|net
operator|->
name|hb_responded
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sendheartbeat
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_ecn_echo
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|high_tsn
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_ecne_chunk
modifier|*
name|ecne
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_ECHO
operator|)
operator|&&
operator|(
name|net
operator|==
name|chk
operator|->
name|whoTo
operator|)
condition|)
block|{
comment|/* found a previous ECN_ECHO update it if needed */
name|uint32_t
name|cnt
decl_stmt|,
name|ctsn
decl_stmt|;
name|ecne
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_ecne_chunk
operator|*
argument_list|)
expr_stmt|;
name|ctsn
operator|=
name|ntohl
argument_list|(
name|ecne
operator|->
name|tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|high_tsn
argument_list|,
name|ctsn
argument_list|)
condition|)
block|{
name|ecne
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_queue_upd_ecne
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|=
name|ntohl
argument_list|(
name|ecne
operator|->
name|num_pkts_since_cwr
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
name|ecne
operator|->
name|num_pkts_since_cwr
operator|=
name|htonl
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* nope could not find one to update so we must build one */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_queue_upd_ecne
argument_list|)
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ECN_ECHO
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|chk
operator|->
name|send_size
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
operator|++
expr_stmt|;
name|ecne
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_ecne_chunk
operator|*
argument_list|)
expr_stmt|;
name|ecne
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ECN_ECHO
expr_stmt|;
name|ecne
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ecne
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|ecne
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
name|ecne
operator|->
name|num_pkts_since_cwr
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_packet_dropped
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|bad_crc
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_pktdrop_chunk
modifier|*
name|drp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint8_t
modifier|*
name|datap
decl_stmt|;
name|int
name|was_trunc
init|=
literal|0
decl_stmt|;
name|int
name|fullsz
init|=
literal|0
decl_stmt|;
name|long
name|spc
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|unsigned
name|int
name|chk_length
decl_stmt|;
if|if
condition|(
operator|!
name|stcb
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|pktdrop_supported
operator|==
literal|0
condition|)
block|{
comment|/*- 		 * peer must declare support before I send one. 		 */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|len
operator|-=
name|iphlen
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
expr_stmt|;
comment|/* Validate that we do not have an ABORT in here. */
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|ch
operator|!=
name|NULL
condition|)
block|{
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
comment|/* break to abort land */
break|break;
block|}
switch|switch
condition|(
name|ch
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_PACKET_DROPPED
case|:
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
case|case
name|SCTP_INITIATION_ACK
case|:
comment|/** 			 * We don't respond with an PKT-DROP to an ABORT 			 * or PKT-DROP. We also do not respond to an 			 * INIT-ACK, because we can't know if the initiation 			 * tag is correct or not. 			 */
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
default|default:
break|break;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|len
operator|+
name|SCTP_MAX_OVERHEAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
operator|)
operator|>
name|min
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
argument_list|,
name|MCLBYTES
argument_list|)
condition|)
block|{
comment|/* 		 * only send 1 mtu worth, trim off the excess on the end. 		 */
name|fullsz
operator|=
name|len
expr_stmt|;
name|len
operator|=
name|min
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
argument_list|,
name|MCLBYTES
argument_list|)
operator|-
name|SCTP_MAX_OVERHEAD
expr_stmt|;
name|was_trunc
operator|=
literal|1
expr_stmt|;
block|}
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|jump_out
label|:
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|drp
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_pktdrop_chunk
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|drp
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
goto|goto
name|jump_out
goto|;
block|}
name|chk
operator|->
name|book_size
operator|=
name|SCTP_SIZE32
argument_list|(
operator|(
name|chk
operator|->
name|send_size
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
name|SCTP_MED_OVERHEAD
operator|)
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|was_trunc
condition|)
block|{
name|drp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|SCTP_PACKET_TRUNCATED
expr_stmt|;
name|drp
operator|->
name|trunc_len
operator|=
name|htons
argument_list|(
name|fullsz
argument_list|)
expr_stmt|;
comment|/* 		 * Len is already adjusted to size minus overhead above take 		 * out the pkt_drop chunk itself from it. 		 */
name|chk
operator|->
name|send_size
operator|=
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
expr_stmt|;
name|len
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
block|}
else|else
block|{
comment|/* no truncation needed */
name|drp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|drp
operator|->
name|trunc_len
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bad_crc
condition|)
block|{
name|drp
operator|->
name|ch
operator|.
name|chunk_flags
operator||=
name|SCTP_BADCRC
expr_stmt|;
block|}
name|chk
operator|->
name|send_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
comment|/* we should hit here */
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
block|}
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|drp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_PACKET_DROPPED
expr_stmt|;
name|drp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|spc
operator|=
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|spc
operator|<
literal|0
condition|)
block|{
name|spc
operator|=
literal|0
expr_stmt|;
block|}
name|drp
operator|->
name|bottle_bw
operator|=
name|htonl
argument_list|(
name|spc
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|my_rwnd
condition|)
block|{
name|drp
operator|->
name|current_onq
operator|=
name|htonl
argument_list|(
name|asoc
operator|->
name|size_on_reasm_queue
operator|+
name|asoc
operator|->
name|size_on_all_streams
operator|+
name|asoc
operator|->
name|my_rwnd_control_len
operator|+
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_rcv
operator|.
name|sb_cc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*- 		 * If my rwnd is 0, possibly from mbuf depletion as well as 		 * space used, tell the peer there is NO space aka onq == bw 		 */
name|drp
operator|->
name|current_onq
operator|=
name|htonl
argument_list|(
name|spc
argument_list|)
expr_stmt|;
block|}
name|drp
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|datap
operator|=
name|drp
operator|->
name|data
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|len
argument_list|,
operator|(
name|caddr_t
operator|)
name|datap
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_send_cwr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|high_tsn
parameter_list|,
name|uint8_t
name|override
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_cwr_chunk
modifier|*
name|cwr
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&asoc->control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ECN_CWR
operator|)
operator|&&
operator|(
name|net
operator|==
name|chk
operator|->
name|whoTo
operator|)
condition|)
block|{
comment|/* 			 * found a previous CWR queued to same destination 			 * update it if needed 			 */
name|uint32_t
name|ctsn
decl_stmt|;
name|cwr
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_cwr_chunk
operator|*
argument_list|)
expr_stmt|;
name|ctsn
operator|=
name|ntohl
argument_list|(
name|cwr
operator|->
name|tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|high_tsn
argument_list|,
name|ctsn
argument_list|)
condition|)
block|{
name|cwr
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|override
operator|&
name|SCTP_CWR_REDUCE_OVERRIDE
condition|)
block|{
comment|/* Make sure override is carried */
name|cwr
operator|->
name|ch
operator|.
name|chunk_flags
operator||=
name|SCTP_CWR_REDUCE_OVERRIDE
expr_stmt|;
block|}
return|return;
block|}
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_ECN_CWR
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|1
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cwr_chunk
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|chk
operator|->
name|send_size
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cwr
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_cwr_chunk
operator|*
argument_list|)
expr_stmt|;
name|cwr
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ECN_CWR
expr_stmt|;
name|cwr
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
name|override
expr_stmt|;
name|cwr
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cwr_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|cwr
operator|->
name|tsn
operator|=
name|htonl
argument_list|(
name|high_tsn
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_out
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint32_t
name|last_sent
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req_out
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|req_out
operator|=
operator|(
expr|struct
name|sctp_stream_reset_out_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|number_entries
operator|)
operator|)
expr_stmt|;
name|req_out
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_OUT_REQUEST
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|response_seq
operator|=
name|htonl
argument_list|(
name|resp_seq
argument_list|)
expr_stmt|;
name|req_out
operator|->
name|send_reset_at_tsn
operator|=
name|htonl
argument_list|(
name|last_sent
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|req_out
operator|->
name|list_of_streams
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|len
argument_list|)
operator|>
name|len
condition|)
block|{
comment|/*- 		 * Need to worry about the pad we may end up adding to the 		 * end. This is easy since the struct is either aligned to 4 		 * bytes or 2 bytes off. 		 */
name|req_out
operator|->
name|list_of_streams
index|[
name|number_entries
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_add_stream_reset_in
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req_in
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|req_in
operator|=
operator|(
expr|struct
name|sctp_stream_reset_in_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_in_request
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|*
name|number_entries
operator|)
operator|)
expr_stmt|;
name|req_in
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_IN_REQUEST
argument_list|)
expr_stmt|;
name|req_in
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req_in
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|req_in
operator|->
name|list_of_streams
index|[
name|i
index|]
operator|=
name|htons
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|len
argument_list|)
operator|>
name|len
condition|)
block|{
comment|/*- 		 * Need to worry about the pad we may end up adding to the 		 * end. This is easy since the struct is either aligned to 4 		 * bytes or 2 bytes off. 		 */
name|req_in
operator|->
name|list_of_streams
index|[
name|number_entries
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_add_stream_reset_tsn
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_stream_reset_tsn_request
modifier|*
name|req_tsn
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|req_tsn
operator|=
operator|(
expr|struct
name|sctp_stream_reset_tsn_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_tsn_request
argument_list|)
expr_stmt|;
name|req_tsn
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_TSN_REQUEST
argument_list|)
expr_stmt|;
name|req_tsn
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|req_tsn
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_result
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint32_t
name|result
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_stream_reset_response
modifier|*
name|resp
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_response
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_RESPONSE
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|resp
operator|->
name|response_seq
operator|=
name|htonl
argument_list|(
name|resp_seq
argument_list|)
expr_stmt|;
name|resp
operator|->
name|result
operator|=
name|ntohl
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_add_stream_reset_result_tsn
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|resp_seq
parameter_list|,
name|uint32_t
name|result
parameter_list|,
name|uint32_t
name|send_una
parameter_list|,
name|uint32_t
name|recv_next
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_stream_reset_response_tsn
modifier|*
name|resp
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response_tsn
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_response_tsn
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_RESPONSE
argument_list|)
expr_stmt|;
name|resp
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|resp
operator|->
name|response_seq
operator|=
name|htonl
argument_list|(
name|resp_seq
argument_list|)
expr_stmt|;
name|resp
operator|->
name|result
operator|=
name|htonl
argument_list|(
name|result
argument_list|)
expr_stmt|;
name|resp
operator|->
name|senders_next_tsn
operator|=
name|htonl
argument_list|(
name|send_una
argument_list|)
expr_stmt|;
name|resp
operator|->
name|receivers_next_tsn
operator|=
name|htonl
argument_list|(
name|recv_next
argument_list|)
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_add_an_out_stream
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint16_t
name|adding
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_stream_reset_add_strm
modifier|*
name|addstr
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|addstr
operator|=
operator|(
expr|struct
name|sctp_stream_reset_add_strm
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_add_strm
argument_list|)
expr_stmt|;
comment|/* Fill it out. */
name|addstr
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_ADD_OUT_STREAMS
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|number_of_streams
operator|=
name|htons
argument_list|(
name|adding
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_add_an_in_stream
parameter_list|(
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint16_t
name|adding
parameter_list|)
block|{
name|uint16_t
name|len
decl_stmt|,
name|old_len
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_stream_reset_add_strm
modifier|*
name|addstr
decl_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|old_len
operator|=
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get to new offset for the param. */
name|addstr
operator|=
operator|(
expr|struct
name|sctp_stream_reset_add_strm
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|len
operator|)
expr_stmt|;
comment|/* now how long will this param be? */
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_add_strm
argument_list|)
expr_stmt|;
comment|/* Fill it out. */
name|addstr
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_STR_RESET_ADD_IN_STREAMS
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|request_seq
operator|=
name|htonl
argument_list|(
name|seq
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|number_of_streams
operator|=
name|htons
argument_list|(
name|adding
argument_list|)
expr_stmt|;
name|addstr
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
comment|/* now fix the chunk length */
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|len
operator|+
name|old_len
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|len
operator|+
name|old_len
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|int
name|sctp_send_str_reset_req
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|,
name|uint8_t
name|send_out_req
parameter_list|,
name|uint8_t
name|send_in_req
parameter_list|,
name|uint8_t
name|send_tsn_req
parameter_list|,
name|uint8_t
name|add_stream
parameter_list|,
name|uint16_t
name|adding_o
parameter_list|,
name|uint16_t
name|adding_i
parameter_list|,
name|uint8_t
name|peer_asked
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
block|{
comment|/*- 		 * Already one pending, must get ACK back to clear the flag. 		 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EBUSY
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|send_out_req
operator|==
literal|0
operator|)
operator|&&
operator|(
name|send_in_req
operator|==
literal|0
operator|)
operator|&&
operator|(
name|send_tsn_req
operator|==
literal|0
operator|)
operator|&&
operator|(
name|add_stream
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing to do */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|send_tsn_req
operator|&&
operator|(
name|send_out_req
operator|||
name|send_in_req
operator|)
condition|)
block|{
comment|/* error, can't do that */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|send_size
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
comment|/* setup chunk parameters */
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|ch
operator|->
name|chunk_type
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|ch
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|book_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|seq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
expr_stmt|;
if|if
condition|(
name|send_out_req
condition|)
block|{
name|sctp_add_stream_reset_out
argument_list|(
name|chk
argument_list|,
name|number_entries
argument_list|,
name|list
argument_list|,
name|seq
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_in
operator|-
literal|1
operator|)
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_out_is_outstanding
operator|=
literal|1
expr_stmt|;
name|seq
operator|++
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|add_stream
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|)
operator|<
name|adding_o
operator|)
condition|)
block|{
comment|/* Need to allocate more */
name|struct
name|sctp_stream_out
modifier|*
name|oldstream
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|oldstream
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|strmout
expr_stmt|;
comment|/* get some more */
name|SCTP_MALLOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
argument_list|,
expr|struct
name|sctp_stream_out
operator|*
argument_list|,
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|+
name|adding_o
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_out
argument_list|)
operator|)
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
operator|==
name|NULL
condition|)
block|{
name|uint8_t
name|x
decl_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
operator|=
name|oldstream
expr_stmt|;
comment|/* Turn off the bit */
name|x
operator|=
name|add_stream
operator|&
literal|0xfe
expr_stmt|;
name|add_stream
operator|=
name|x
expr_stmt|;
goto|goto
name|skip_stuff
goto|;
block|}
comment|/* 		 * Ok now we proceed with copying the old out stuff and 		 * initializing the new stuff. 		 */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_clear
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|chunks_on_queues
operator|=
name|oldstream
index|[
name|i
index|]
operator|.
name|chunks_on_queues
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_send
operator|=
name|oldstream
index|[
name|i
index|]
operator|.
name|next_sequence_send
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
name|oldstream
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
argument_list|,
operator|&
name|oldstream
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* now anything on those queues? */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&oldstream[i].outqueue
argument_list|,
argument|next
argument_list|,
argument|nsp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|oldstream
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* Now move assoc pointers too */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_out_stream
operator|==
operator|&
name|oldstream
index|[
name|i
index|]
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_out_stream
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|==
operator|&
name|oldstream
index|[
name|i
index|]
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* now the new streams */
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
init|;
name|i
operator|<
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|+
name|adding_o
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|chunks_on_queues
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_send
operator|=
literal|0x0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|+
name|adding_o
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|oldstream
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|skip_stuff
label|:
if|if
condition|(
operator|(
name|add_stream
operator|&
literal|1
operator|)
operator|&&
operator|(
name|adding_o
operator|>
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|strm_pending_add_size
operator|=
name|adding_o
expr_stmt|;
name|asoc
operator|->
name|peer_req_out
operator|=
name|peer_asked
expr_stmt|;
name|sctp_add_an_out_stream
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|adding_o
argument_list|)
expr_stmt|;
name|seq
operator|++
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|add_stream
operator|&
literal|2
operator|)
operator|&&
operator|(
name|adding_i
operator|>
literal|0
operator|)
condition|)
block|{
name|sctp_add_an_in_stream
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|adding_i
argument_list|)
expr_stmt|;
name|seq
operator|++
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|send_in_req
condition|)
block|{
name|sctp_add_stream_reset_in
argument_list|(
name|chk
argument_list|,
name|number_entries
argument_list|,
name|list
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|seq
operator|++
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|send_tsn_req
condition|)
block|{
name|sctp_add_stream_reset_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
name|asoc
operator|->
name|str_reset
operator|=
name|chk
expr_stmt|;
comment|/* insert the chunk for sending */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|ctrl_queue_cnt
operator|++
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_send_abort
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|struct
name|mbuf
modifier|*
name|cause
parameter_list|,
name|uint8_t
name|use_mflowid
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
comment|/* Don't respond to an ABORT with an ABORT. */
if|if
condition|(
name|sctp_is_there_an_abort_here
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|&
name|vtag
argument_list|)
condition|)
block|{
if|if
condition|(
name|cause
condition|)
name|sctp_m_freem
argument_list|(
name|cause
argument_list|)
expr_stmt|;
return|return;
block|}
name|sctp_send_resp_msg
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|vtag
argument_list|,
name|SCTP_ABORT_ASSOCIATION
argument_list|,
name|cause
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|sctp_send_operr_to
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|uint32_t
name|vtag
parameter_list|,
name|struct
name|mbuf
modifier|*
name|cause
parameter_list|,
name|uint8_t
name|use_mflowid
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|sctp_send_resp_msg
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|vtag
argument_list|,
name|SCTP_OPERATION_ERROR
argument_list|,
name|cause
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_copy_resume
parameter_list|(
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|max_send_len
parameter_list|,
name|int
name|user_marks_eor
parameter_list|,
name|int
modifier|*
name|error
parameter_list|,
name|uint32_t
modifier|*
name|sndout
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|new_tail
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|m
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|max_send_len
argument_list|,
literal|0
argument_list|,
operator|(
name|M_PKTHDR
operator||
operator|(
name|user_marks_eor
condition|?
name|M_EOR
else|:
literal|0
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOBUFS
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sndout
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|new_tail
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_copy_one
parameter_list|(
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|int
name|resv_upfront
parameter_list|)
block|{
name|int
name|left
decl_stmt|;
name|left
operator|=
name|sp
operator|->
name|length
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|m_uiotombuf
argument_list|(
name|uio
argument_list|,
name|M_WAITOK
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|resv_upfront
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|sp
operator|->
name|tail_mbuf
operator|=
name|m_last
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sctp_copy_it_in
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_association
modifier|*
name|asoc
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|max_send_len
parameter_list|,
name|int
name|user_marks_eor
parameter_list|,
name|int
modifier|*
name|error
parameter_list|)
block|{
comment|/*- 	 * This routine must be very careful in its work. Protocol 	 * processing is up and running so care must be taken to spl...() 	 * when you need to do something that may effect the stcb/asoc. The 	 * sb is locked however. When data is copied the protocol processing 	 * should be enabled since this is a slower operation... 	 */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
init|=
name|NULL
decl_stmt|;
name|int
name|resv_in_first
decl_stmt|;
operator|*
name|error
operator|=
literal|0
expr_stmt|;
comment|/* Now can we send this? */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
comment|/* got data while shutting down */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sctp_alloc_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
operator|*
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|sp
operator|->
name|act_flags
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sender_all_done
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|sinfo_flags
operator|=
name|srcv
operator|->
name|sinfo_flags
expr_stmt|;
name|sp
operator|->
name|timetolive
operator|=
name|srcv
operator|->
name|sinfo_timetolive
expr_stmt|;
name|sp
operator|->
name|ppid
operator|=
name|srcv
operator|->
name|sinfo_ppid
expr_stmt|;
name|sp
operator|->
name|context
operator|=
name|srcv
operator|->
name|sinfo_context
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|sp
operator|->
name|ts
argument_list|)
expr_stmt|;
name|sp
operator|->
name|stream
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
name|sp
operator|->
name|length
operator|=
name|min
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|max_send_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
operator|(
name|uint32_t
operator|)
name|uio
operator|->
name|uio_resid
operator|)
operator|&&
operator|(
operator|(
name|user_marks_eor
operator|==
literal|0
operator|)
operator|||
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|||
operator|(
name|user_marks_eor
operator|&&
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOR
operator|)
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|sender_all_done
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|some_taken
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|put_last_out
operator|=
literal|0
expr_stmt|;
name|resv_in_first
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|sp
operator|->
name|tail_mbuf
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|length
operator|==
literal|0
condition|)
block|{
operator|*
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|skip_copy
goto|;
block|}
if|if
condition|(
name|srcv
operator|->
name|sinfo_keynumber_valid
condition|)
block|{
name|sp
operator|->
name|auth_keyid
operator|=
name|srcv
operator|->
name|sinfo_keynumber
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|auth_keyid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
expr_stmt|;
block|}
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|sctp_auth_key_acquire
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|auth_keyid
argument_list|)
expr_stmt|;
name|sp
operator|->
name|holds_key_ref
operator|=
literal|1
expr_stmt|;
block|}
operator|*
name|error
operator|=
name|sctp_copy_one
argument_list|(
name|sp
argument_list|,
name|uio
argument_list|,
name|resv_in_first
argument_list|)
expr_stmt|;
name|skip_copy
label|:
if|if
condition|(
operator|*
name|error
condition|)
block|{
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sp
operator|->
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
condition|)
block|{
name|sp
operator|->
name|net
operator|=
name|net
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|net
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_set_prsctp_policy
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|out_now
label|:
return|return
operator|(
name|sp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|top
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|use_sndinfo
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_sndrcvinfo
name|sndrcvninfo
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr_to_use
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|control
condition|)
block|{
comment|/* process cmsg snd/rcv info (maybe a assoc-id) */
if|if
condition|(
name|sctp_find_cmsg
argument_list|(
name|SCTP_SNDRCV
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sndrcvninfo
argument_list|,
name|control
argument_list|,
sizeof|sizeof
argument_list|(
name|sndrcvninfo
argument_list|)
argument_list|)
condition|)
block|{
comment|/* got one */
name|use_sndinfo
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|addr_to_use
operator|=
name|addr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
operator|(
name|addr
operator|)
operator|&&
operator|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_to_use
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|error
operator|=
name|sctp_lower_sosend
argument_list|(
name|so
argument_list|,
name|addr_to_use
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|control
argument_list|,
name|flags
argument_list|,
name|use_sndinfo
condition|?
operator|&
name|sndrcvninfo
else|:
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_lower_sosend
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|struct
name|mbuf
modifier|*
name|i_pak
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|sctp_sndrcvinfo
modifier|*
name|srcv
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|sndlen
init|=
literal|0
decl_stmt|,
name|max_len
decl_stmt|;
name|int
name|error
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|top
init|=
name|NULL
decl_stmt|;
name|int
name|queue_only
init|=
literal|0
decl_stmt|,
name|queue_only_for_init
init|=
literal|0
decl_stmt|;
name|int
name|free_cnt_applied
init|=
literal|0
decl_stmt|;
name|int
name|un_sent
decl_stmt|;
name|int
name|now_filled
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|inqueue_bytes
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_block_entry
name|be
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|t_inp
decl_stmt|;
name|int
name|user_marks_eor
decl_stmt|;
name|int
name|create_lock_applied
init|=
literal|0
decl_stmt|;
name|int
name|nagle_applies
init|=
literal|0
decl_stmt|;
name|int
name|some_on_control
init|=
literal|0
decl_stmt|;
name|int
name|got_all_of_the_send
init|=
literal|0
decl_stmt|;
name|int
name|hold_tcblock
init|=
literal|0
decl_stmt|;
name|int
name|non_blocking
init|=
literal|0
decl_stmt|;
name|uint32_t
name|local_add_more
decl_stmt|,
name|local_soresv
init|=
literal|0
decl_stmt|;
name|uint16_t
name|port
decl_stmt|;
name|uint16_t
name|sinfo_flags
decl_stmt|;
name|sctp_assoc_t
name|sinfo_assoc_id
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
name|asoc
operator|=
name|NULL
expr_stmt|;
name|t_inp
operator|=
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|i_pak
condition|)
block|{
name|SCTP_RELEASE_PKT
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|uio
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|i_pak
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|user_marks_eor
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|inp
operator|->
name|total_sends
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
condition|)
block|{
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|<
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sndlen
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
else|else
block|{
name|top
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
name|sndlen
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"Send called addr:%p send length %d\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|sndlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* The listener can NOT send */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
comment|/** 	 * Pre-screen address, if one is given the sin-len 	 * must be set correctly! 	 */
if|if
condition|(
name|addr
condition|)
block|{
name|union
name|sctp_sockstore
modifier|*
name|raddr
init|=
operator|(
expr|union
name|sctp_sockstore
operator|*
operator|)
name|addr
decl_stmt|;
switch|switch
condition|(
name|raddr
operator|->
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|raddr
operator|->
name|sin
operator|.
name|sin_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|port
operator|=
name|raddr
operator|->
name|sin
operator|.
name|sin_port
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|raddr
operator|->
name|sin6
operator|.
name|sin6_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|port
operator|=
name|raddr
operator|->
name|sin6
operator|.
name|sin6_port
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
else|else
name|port
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|srcv
condition|)
block|{
name|sinfo_flags
operator|=
name|srcv
operator|->
name|sinfo_flags
expr_stmt|;
name|sinfo_assoc_id
operator|=
name|srcv
operator|->
name|sinfo_assoc_id
expr_stmt|;
if|if
condition|(
name|INVALID_SINFO_FLAG
argument_list|(
name|sinfo_flags
argument_list|)
operator|||
name|PR_SCTP_INVALID_POLICY
argument_list|(
name|sinfo_flags
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sinfo_flags
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
expr_stmt|;
name|sinfo_assoc_id
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_assoc_id
expr_stmt|;
block|}
if|if
condition|(
name|sinfo_flags
operator|&
name|SCTP_SENDALL
condition|)
block|{
comment|/* its a sendall */
name|error
operator|=
name|sctp_sendall
argument_list|(
name|inp
argument_list|,
name|uio
argument_list|,
name|top
argument_list|,
name|srcv
argument_list|)
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
operator|)
operator|&&
operator|(
name|addr
operator|==
name|NULL
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* now we must find the assoc */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sinfo_assoc_id
condition|)
block|{
name|stcb
operator|=
name|sctp_findassociation_ep_asocid
argument_list|(
name|inp
argument_list|,
name|sinfo_assoc_id
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|addr
condition|)
block|{
comment|/*- 		 * Since we did not use findep we must 		 * increment it, and if we don't find a tcb 		 * decrement it. 		 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|t_inp
argument_list|,
name|addr
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|addr
operator|)
condition|)
block|{
comment|/* Possible implicit send? */
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
comment|/* Should I really unlock ? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* With the lock applied look again */
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|t_inp
argument_list|,
name|addr
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|control
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|port
operator|>
literal|0
operator|)
condition|)
block|{
name|stcb
operator|=
name|sctp_findassociation_cmsgs
argument_list|(
operator|&
name|t_inp
argument_list|,
name|port
argument_list|,
name|control
argument_list|,
operator|&
name|net
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|t_inp
operator|!=
name|inp
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
else|else
block|{
comment|/* We must go ahead and start the INIT process */
name|uint32_t
name|vrf_id
decl_stmt|;
if|if
condition|(
operator|(
name|sinfo_flags
operator|&
name|SCTP_ABORT
operator|)
operator|||
operator|(
operator|(
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|&&
operator|(
name|sndlen
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/*- 				 * User asks to abort a non-existant assoc, 				 * or EOF a non-existant assoc with no data 				 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* get an asoc/stcb struct */
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|create_lock_applied
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"Error, should hold create lock and I don't?"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Error is setup for us in the call */
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* 				 * Set the connected flag so we can queue 				 * data 				 */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|create_lock_applied
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Huh-3? create lock should have been on??\n"
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Turn on queue only flag to prevent data from 			 * being sent 			 */
name|queue_only
operator|=
literal|1
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_COOKIE_WAIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
comment|/* initialize authentication params for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|sctp_process_cmsgs_for_init
argument_list|(
name|stcb
argument_list|,
name|control
argument_list|,
operator|&
name|error
argument_list|)
condition|)
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCBFREE_FORCE
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
comment|/* out with the INIT */
name|queue_only_for_init
operator|=
literal|1
expr_stmt|;
comment|/*- 			 * we may want to dig in after this call and adjust the MTU 			 * value. It defaulted to 1500 (constant) but the ro 			 * structure may now have an update and thus we may need to 			 * change it BEFORE we append the message. 			 */
block|}
block|}
else|else
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|srcv
operator|==
name|NULL
condition|)
name|srcv
operator|=
operator|(
expr|struct
name|sctp_sndrcvinfo
operator|*
operator|)
operator|&
name|asoc
operator|->
name|def_send
expr_stmt|;
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ADDR_OVER
condition|)
block|{
if|if
condition|(
name|addr
condition|)
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
else|else
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|port
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|port
operator|!=
name|stcb
operator|->
name|rport
operator|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|total_sends
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Keep the stcb from being freed under our feet */
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free_cnt_applied
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NO_FRAGMENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|sndlen
operator|>
name|asoc
operator|->
name|smallest_mtu
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EMSGSIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
if|if
condition|(
name|SCTP_SO_IS_NBIO
argument_list|(
name|so
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|MSG_NBIO
operator|)
condition|)
block|{
name|non_blocking
operator|=
literal|1
expr_stmt|;
block|}
comment|/* would we block? */
if|if
condition|(
name|non_blocking
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
name|inqueue_bytes
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<
operator|(
name|sndlen
operator|+
name|inqueue_bytes
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|sb_send_resv
operator|)
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EWOULDBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndlen
operator|>
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
condition|)
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
else|else
name|error
operator|=
name|EWOULDBLOCK
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|sb_send_resv
operator|+=
name|sndlen
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sb_send_resv
argument_list|,
name|sndlen
argument_list|)
expr_stmt|;
block|}
name|local_soresv
operator|=
name|sndlen
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|create_lock_applied
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_applied
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
block|{
comment|/* 		 * Can't queue any data while stream reset is underway. 		 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EAGAIN
argument_list|)
expr_stmt|;
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
comment|/* we are now done with all control */
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
operator|)
condition|)
block|{
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ABORT
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
block|}
comment|/* Ok, we will attempt a msgsnd :> */
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|td_ru
operator|.
name|ru_msgsnd
operator|++
expr_stmt|;
block|}
comment|/* Are we aborting? */
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_ABORT
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|int
name|tot_demand
decl_stmt|,
name|tot_out
init|=
literal|0
decl_stmt|,
name|max_out
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_abort
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
comment|/* It has to be up before we abort */
comment|/* how big is the user initiated abort? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|top
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|cntm
init|=
name|NULL
decl_stmt|;
name|mm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_WAITOK
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sndlen
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|cntm
operator|=
name|top
init|;
name|cntm
condition|;
name|cntm
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|cntm
argument_list|)
control|)
block|{
name|tot_out
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|cntm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Must fit in a MTU */
name|tot_out
operator|=
name|sndlen
expr_stmt|;
name|tot_demand
operator|=
operator|(
name|tot_out
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|tot_demand
operator|>
name|SCTP_DEFAULT_ADD_MORE
condition|)
block|{
comment|/* To big */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EMSGSIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|tot_demand
argument_list|,
literal|0
argument_list|,
name|M_WAITOK
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mm
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|max_out
operator|=
name|asoc
operator|->
name|smallest_mtu
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|max_out
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_abort_msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|tot_out
operator|>
name|max_out
condition|)
block|{
name|tot_out
operator|=
name|max_out
expr_stmt|;
block|}
if|if
condition|(
name|mm
condition|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
comment|/* now move forward the data pointer */
name|ph
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
name|tot_out
argument_list|)
expr_stmt|;
name|ph
operator|++
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mm
argument_list|)
operator|=
name|tot_out
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|ph
argument_list|,
operator|(
name|int
operator|)
name|tot_out
argument_list|,
name|uio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/*- 					 * Here if we can't get his data we 					 * still abort we just don't get to 					 * send the users note :-0 					 */
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
name|mm
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sndlen
operator|!=
literal|0
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|mm
argument_list|)
operator|=
name|top
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free_cnt_applied
operator|=
literal|0
expr_stmt|;
comment|/* release this lock, otherwise we hang on ourselves */
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|mm
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
comment|/* now relock the stcb so everything is sane */
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * In this case top is already chained to mm avoid double 		 * free, since we free it below if top != NULL and driver 		 * would free it after sending the packet out 		 */
if|if
condition|(
name|sndlen
operator|!=
literal|0
condition|)
block|{
name|top
operator|=
name|NULL
expr_stmt|;
block|}
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* Calculate the maximum we can send */
name|inqueue_bytes
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|inqueue_bytes
condition|)
block|{
if|if
condition|(
name|non_blocking
condition|)
block|{
comment|/* we already checked for non-blocking above. */
name|max_len
operator|=
name|sndlen
expr_stmt|;
block|}
else|else
block|{
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|inqueue_bytes
expr_stmt|;
block|}
block|}
else|else
block|{
name|max_len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Is the stream no. valid? */
if|if
condition|(
name|srcv
operator|->
name|sinfo_stream
operator|>=
name|asoc
operator|->
name|streamoutcnt
condition|)
block|{
comment|/* Invalid stream number */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|asoc
operator|->
name|strmout
operator|==
name|NULL
condition|)
block|{
comment|/* huh? software error */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* Unless E_EOR mode is on, we must make a send FIT in one call. */
if|if
condition|(
operator|(
name|user_marks_eor
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sndlen
operator|>
name|SCTP_SB_LIMIT_SND
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
operator|)
condition|)
block|{
comment|/* It will NEVER fit */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EMSGSIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EMSGSIZE
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
operator|(
name|uio
operator|==
name|NULL
operator|)
operator|&&
name|user_marks_eor
condition|)
block|{
comment|/*- 		 * We do not support eeor mode for 		 * sending with mbuf chains (like sendfile). 		 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|user_marks_eor
condition|)
block|{
name|local_add_more
operator|=
name|min
argument_list|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_add_more_threshold
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/*- 		 * For non-eeor the whole message must fit in 		 * the socket send buffer. 		 */
name|local_add_more
operator|=
name|sndlen
expr_stmt|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|non_blocking
condition|)
block|{
goto|goto
name|skip_preblock
goto|;
block|}
if|if
condition|(
operator|(
operator|(
name|max_len
operator|<=
name|local_add_more
operator|)
operator|&&
operator|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>=
name|local_add_more
operator|)
operator|)
operator|||
operator|(
name|max_len
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|)
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
operator|)
condition|)
block|{
comment|/* No room right now ! */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|inqueue_bytes
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<
operator|(
name|inqueue_bytes
operator|+
name|local_add_more
operator|)
operator|)
operator|||
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|)
operator|>=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"pre_block limit:%u<(inq:%d + %d) || (%d+%d> %d)\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
argument_list|,
name|inqueue_bytes
argument_list|,
name|local_add_more
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_BLK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_INTO_BLKA
argument_list|,
name|asoc
argument_list|,
name|sndlen
argument_list|)
expr_stmt|;
block|}
name|be
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
operator|&
name|be
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|so
operator|->
name|so_error
operator|||
name|be
operator|.
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
name|be
operator|.
name|error
condition|)
block|{
name|error
operator|=
name|be
operator|.
name|error
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_BLK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_OUTOF_BLK
argument_list|,
name|asoc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
name|inqueue_bytes
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|inqueue_bytes
condition|)
block|{
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|inqueue_bytes
expr_stmt|;
block|}
else|else
block|{
name|max_len
operator|=
literal|0
expr_stmt|;
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
name|skip_preblock
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
comment|/* 	 * sndlen covers for mbuf case uio_resid covers for the non-mbuf 	 * case NOTE: uio will be null when top/mbuf is passed 	 */
if|if
condition|(
name|sndlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
condition|)
block|{
name|got_all_of_the_send
operator|=
literal|1
expr_stmt|;
goto|goto
name|dataless_eof
goto|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|top
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|strm
decl_stmt|;
name|uint32_t
name|sndout
decl_stmt|;
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|stream_locked
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_locked_on
operator|!=
name|srcv
operator|->
name|sinfo_stream
operator|)
condition|)
block|{
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|strm
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|srcv
operator|->
name|sinfo_stream
index|]
expr_stmt|;
if|if
condition|(
name|strm
operator|->
name|last_msg_incomplete
operator|==
literal|0
condition|)
block|{
name|do_a_copy_in
label|:
name|sp
operator|=
name|sctp_copy_it_in
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|srcv
argument_list|,
name|uio
argument_list|,
name|net
argument_list|,
name|max_len
argument_list|,
name|user_marks_eor
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|error
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
condition|)
block|{
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Just got locked to this guy in case of an 				 * interrupt. 				 */
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked_on
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
name|sp
operator|->
name|sender_all_done
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
name|sp
operator|->
name|length
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_UNORDERED
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_unord
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_add_to_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|strm
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|strm
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
comment|/* ???? Huh ??? last msg is gone */
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Warning: Last msg marked incomplete, yet nothing left?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|SCTP_PRINTF
argument_list|(
literal|"Warning: Last msg marked incomplete, yet nothing left?\n"
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
goto|goto
name|do_a_copy_in
goto|;
block|}
block|}
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
condition|)
block|{
comment|/* How much room do we have? */
name|struct
name|mbuf
modifier|*
name|new_tail
decl_stmt|,
modifier|*
name|mm
decl_stmt|;
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
condition|)
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
else|else
name|max_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|max_len
operator|>
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_add_more_threshold
argument_list|)
operator|)
operator|||
operator|(
name|max_len
operator|&&
operator|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_add_more_threshold
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|uio
operator|->
name|uio_resid
operator|&&
operator|(
name|uio
operator|->
name|uio_resid
operator|<=
operator|(
name|int
operator|)
name|max_len
operator|)
operator|)
condition|)
block|{
name|sndout
operator|=
literal|0
expr_stmt|;
name|new_tail
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
name|mm
operator|=
name|sctp_copy_resume
argument_list|(
name|uio
argument_list|,
name|max_len
argument_list|,
name|user_marks_eor
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|sndout
argument_list|,
operator|&
name|new_tail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mm
operator|==
name|NULL
operator|)
operator|||
name|error
condition|)
block|{
if|if
condition|(
name|mm
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
goto|goto
name|out
goto|;
block|}
comment|/* Update the mbuf and count */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* 					 * we need to get out. Peer probably 					 * aborted. 					 */
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_PCB_FLAGS_WAS_ABORTED
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_OUTPUT
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
name|error
operator|=
name|ECONNRESET
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|sp
operator|->
name|tail_mbuf
condition|)
block|{
comment|/* tack it to the end */
name|SCTP_BUF_NEXT
argument_list|(
name|sp
operator|->
name|tail_mbuf
argument_list|)
operator|=
name|mm
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|new_tail
expr_stmt|;
block|}
else|else
block|{
comment|/* A stolen mbuf */
name|sp
operator|->
name|data
operator|=
name|mm
expr_stmt|;
name|sp
operator|->
name|tail_mbuf
operator|=
name|new_tail
expr_stmt|;
block|}
name|sctp_snd_sb_alloc
argument_list|(
name|stcb
argument_list|,
name|sndout
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|sp
operator|->
name|length
argument_list|,
name|sndout
argument_list|)
expr_stmt|;
name|len
operator|+=
name|sndout
expr_stmt|;
comment|/* Did we reach EOR? */
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|user_marks_eor
operator|==
literal|0
operator|)
operator|||
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|||
operator|(
name|user_marks_eor
operator|&&
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOR
operator|)
operator|)
operator|)
condition|)
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|msg_is_complete
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
comment|/* got it all? */
continue|continue;
block|}
comment|/* PR-SCTP? */
if|if
condition|(
operator|(
name|asoc
operator|->
name|prsctp_supported
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sent_queue_cnt_removeable
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* 				 * This is ugly but we must assure locking 				 * order 				 */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_prune_prsctp
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|srcv
argument_list|,
name|sndlen
argument_list|)
expr_stmt|;
name|inqueue_bytes
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
condition|)
name|max_len
operator|=
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|-
name|inqueue_bytes
expr_stmt|;
else|else
name|max_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_len
operator|>
literal|0
condition|)
block|{
continue|continue;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
comment|/* wait for space now */
if|if
condition|(
name|non_blocking
condition|)
block|{
comment|/* Non-blocking io in place out */
goto|goto
name|skip_out_eof
goto|;
block|}
comment|/* What about the INIT, send it maybe */
if|if
condition|(
name|queue_only_for_init
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
comment|/* a collision took us forward? */
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_COOKIE_WAIT
argument_list|)
expr_stmt|;
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|>
name|net
operator|->
name|cwnd
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_send_cwnd_avoid
argument_list|)
expr_stmt|;
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|ifp_had_enobuf
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
block|}
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|<
name|SCTP_MAX_DATA_BUNDLING
operator|)
operator|&&
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
condition|)
block|{
comment|/*- 				 * Ok, Nagle is set on and we have data outstanding. 				 * Don't send anything and let SACKs drive out the 				 * data unless wen have a "full" segment to send. 				 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_NAGLE_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_APPLIED
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglequeued
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_NAGLE_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
condition|)
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_SKIPPED
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglesent
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_BLK_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_CWNDLOG_PRESEND
argument_list|,
name|queue_only_for_init
argument_list|,
name|queue_only
argument_list|,
name|nagle_applies
argument_list|,
name|un_sent
argument_list|)
expr_stmt|;
name|sctp_misc_ints
argument_list|(
name|SCTP_CWNDLOG_PRESEND
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|queue_only_for_init
condition|)
name|queue_only_for_init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|queue_only
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nagle_applies
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*- 				 * need to start chunk output 				 * before blocking.. note that if 				 * a lock is already applied, then 				 * the input via the net is happening 				 * and I don't need to start output :-D 				 */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|SCTP_TCB_TRYLOCK
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hold_tcblock
operator|==
literal|1
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/*- 			 * This is a bit strange, but I think it will 			 * work. The total_output_queue_size is locked and 			 * protected by the TCB_LOCK, which we just released. 			 * There is a race that can occur between releasing it 			 * above, and me getting the socket lock, where sacks 			 * come in but we have not put the SB_WAIT on the 			 * so_snd buffer to get the wakeup. After the LOCK 			 * is applied the sack_processing will also need to 			 * LOCK the so->so_snd to do the actual sowwakeup(). So 			 * once we have the socket buffer lock if we recheck the 			 * size we KNOW we will get to sleep safely with the 			 * wakeup flag in place. 			 */
if|if
condition|(
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
operator|<=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|+
name|min
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_add_more_threshold
argument_list|)
argument_list|,
name|SCTP_SB_LIMIT_SND
argument_list|(
name|so
argument_list|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_BLK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_INTO_BLK
argument_list|,
name|asoc
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
block|}
name|be
operator|.
name|error
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
operator|&
name|be
expr_stmt|;
name|error
operator|=
name|sbwait
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|block_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|so
operator|->
name|so_error
operator|||
name|be
operator|.
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|so
operator|->
name|so_error
condition|)
name|error
operator|=
name|so
operator|->
name|so_error
expr_stmt|;
if|if
condition|(
name|be
operator|.
name|error
condition|)
block|{
name|error
operator|=
name|be
operator|.
name|error
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
goto|goto
name|out_unlocked
goto|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_BLK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_block
argument_list|(
name|SCTP_BLOCK_LOG_OUTOF_BLK
argument_list|,
name|asoc
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|)
expr_stmt|;
block|}
block|}
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
goto|goto
name|out_unlocked
goto|;
block|}
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
condition|)
block|{
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|stream_locked_on
operator|=
name|srcv
operator|->
name|sinfo_stream
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|sender_all_done
operator|=
literal|1
expr_stmt|;
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Huh no sp TSNH?\n"
argument_list|)
expr_stmt|;
name|strm
operator|->
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|stream_locked
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|got_all_of_the_send
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We send in a 0, since we do NOT have any locks */
name|error
operator|=
name|sctp_msg_append
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|top
argument_list|,
name|srcv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|top
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
condition|)
block|{
comment|/* 			 * This should only happen for Panda for the mbuf 			 * send case, which does NOT yet support EEOR mode. 			 * Thus, we can just set this flag to do the proper 			 * EOF handling. 			 */
name|got_all_of_the_send
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|dataless_eof
label|:
comment|/* EOF thing ? */
if|if
condition|(
operator|(
name|srcv
operator|->
name|sinfo_flags
operator|&
name|SCTP_EOF
operator|)
operator|&&
operator|(
name|got_all_of_the_send
operator|==
literal|1
operator|)
condition|)
block|{
name|int
name|cnt
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_sends_with_eof
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
name|cnt
operator|=
name|sctp_is_there_unsent_data
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
comment|/* there is nothing queued to send, so I'm done... */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
comment|/* only send SHUTDOWN the first time through */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/*- 			 * we still got (or just got) data to send, so set 			 * SHUTDOWN_PENDING 			 */
comment|/*- 			 * XXX sockets draft says that SCTP_EOF should be 			 * sent with no data.  currently, we will allow user 			 * data to be sent first and move to 			 * SHUTDOWN-PENDING 			 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* Locked to send out the data */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|abort_anyway
label|:
if|if
condition|(
name|free_cnt_applied
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|free_cnt_applied
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
comment|/* 					 * now relock the stcb so everything 					 * is sane 					 */
name|hold_tcblock
operator|=
literal|0
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|skip_out_eof
label|:
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
condition|)
block|{
name|some_on_control
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|queue_only_for_init
condition|)
block|{
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
comment|/* a collision took us forward? */
name|queue_only
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_COOKIE_WAIT
argument_list|)
expr_stmt|;
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|net
operator|->
name|flight_size
operator|>
name|net
operator|->
name|cwnd
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_send_cwnd_avoid
argument_list|)
expr_stmt|;
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|ifp_had_enobuf
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ifnomemqueued
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|flight_size
operator|>
operator|(
literal|2
operator|*
name|net
operator|->
name|mtu
operator|)
condition|)
block|{
name|queue_only
operator|=
literal|1
expr_stmt|;
block|}
name|asoc
operator|->
name|ifp_had_enobuf
operator|=
literal|0
expr_stmt|;
block|}
name|un_sent
operator|=
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
operator|+
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|>
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|<
name|SCTP_MAX_DATA_BUNDLING
operator|)
operator|&&
operator|(
name|un_sent
operator|<
call|(
name|int
call|)
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|-
name|SCTP_MIN_OVERHEAD
argument_list|)
operator|)
condition|)
block|{
comment|/*- 		 * Ok, Nagle is set on and we have data outstanding. 		 * Don't send anything and let SACKs drive out the 		 * data unless wen have a "full" segment to send. 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_NAGLE_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_APPLIED
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglequeued
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_NAGLE_LOGGING_ENABLE
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
condition|)
name|sctp_log_nagle_event
argument_list|(
name|stcb
argument_list|,
name|SCTP_NAGLE_SKIPPED
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_naglesent
argument_list|)
expr_stmt|;
name|nagle_applies
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_BLK_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_CWNDLOG_PRESEND
argument_list|,
name|queue_only_for_init
argument_list|,
name|queue_only
argument_list|,
name|nagle_applies
argument_list|,
name|un_sent
argument_list|)
expr_stmt|;
name|sctp_misc_ints
argument_list|(
name|SCTP_CWNDLOG_PRESEND
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight_count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|queue_only
operator|==
literal|0
operator|)
operator|&&
operator|(
name|nagle_applies
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|&&
name|un_sent
operator|)
condition|)
block|{
comment|/* we can attempt to send too. */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
comment|/* 			 * If there is activity recv'ing sacks no need to 			 * send 			 */
if|if
condition|(
name|SCTP_TCB_TRYLOCK
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|queue_only
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* We get to have a probe outstanding */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_USR_SEND
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|some_on_control
condition|)
block|{
name|int
name|num_out
decl_stmt|,
name|reason
decl_stmt|,
name|frag_point
decl_stmt|;
comment|/* Here we do control only */
if|if
condition|(
name|hold_tcblock
operator|==
literal|0
condition|)
block|{
name|hold_tcblock
operator|=
literal|1
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|frag_point
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_med_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|num_out
argument_list|,
operator|&
name|reason
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
operator|&
name|now
argument_list|,
operator|&
name|now_filled
argument_list|,
name|frag_point
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"USR Send complete qo:%d prw:%d unsent:%d tf:%d cooq:%d toqs:%d err:%d\n"
argument_list|,
name|queue_only
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|un_sent
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|chunks_on_out_queue
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|out
label|:
name|out_unlocked
label|:
if|if
condition|(
name|local_soresv
operator|&&
name|stcb
condition|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sb_send_resv
argument_list|,
name|sndlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|create_lock_applied
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|hold_tcblock
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|&&
name|free_cnt_applied
condition|)
block|{
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|stcb
operator|->
name|tcb_mtx
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Leaving with tcb mtx owned?"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtx_owned
argument_list|(
operator|&
name|stcb
operator|->
name|tcb_send_mtx
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Leaving with tcb send mtx owned?"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
name|inp
condition|)
block|{
name|sctp_validate_no_locks
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Warning - inp is NULL so cant validate locks\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|top
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|top
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * generate an AUTHentication chunk, if required  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_add_auth_chunk
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|m_end
parameter_list|,
name|struct
name|sctp_auth_chunk
modifier|*
modifier|*
name|auth_ret
parameter_list|,
name|uint32_t
modifier|*
name|offset
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint8_t
name|chunk
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_auth
decl_stmt|;
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
decl_stmt|;
name|int
name|chunk_len
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|cn
decl_stmt|;
if|if
condition|(
operator|(
name|m_end
operator|==
name|NULL
operator|)
operator|||
operator|(
name|auth_ret
operator|==
name|NULL
operator|)
operator|||
operator|(
name|offset
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
name|m
operator|)
return|;
comment|/* sysctl disabled auth? */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auth_disable
argument_list|)
condition|)
return|return
operator|(
name|m
operator|)
return|;
comment|/* peer doesn't do auth... */
if|if
condition|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_auth
condition|)
block|{
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* does the requested chunk require auth? */
if|if
condition|(
operator|!
name|sctp_auth_is_required_chunk
argument_list|(
name|chunk
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
return|return
operator|(
name|m
operator|)
return|;
block|}
name|m_auth
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_auth
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
return|return
operator|(
name|m
operator|)
return|;
block|}
comment|/* reserve some space if this will be the first mbuf */
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|SCTP_BUF_RESV_UF
argument_list|(
name|m_auth
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
comment|/* fill in the AUTH chunk details */
name|auth
operator|=
name|mtod
argument_list|(
name|m_auth
argument_list|,
expr|struct
name|sctp_auth_chunk
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|auth
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
argument_list|)
expr_stmt|;
name|auth
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_AUTHENTICATION
expr_stmt|;
name|auth
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|chunk_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|auth
argument_list|)
operator|+
name|sctp_get_hmac_digest_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
name|auth
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|chunk_len
argument_list|)
expr_stmt|;
name|auth
operator|->
name|hmac_id
operator|=
name|htons
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
comment|/* key id and hmac digest will be computed and filled in upon send */
comment|/* save the offset where the auth was inserted into the chain */
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cn
operator|=
name|m
init|;
name|cn
condition|;
name|cn
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|cn
argument_list|)
control|)
block|{
operator|*
name|offset
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|cn
argument_list|)
expr_stmt|;
block|}
comment|/* update length and return pointer to the auth chunk */
name|SCTP_BUF_LEN
argument_list|(
name|m_auth
argument_list|)
operator|=
name|chunk_len
expr_stmt|;
name|m
operator|=
name|sctp_copy_mbufchain
argument_list|(
name|m_auth
argument_list|,
name|m
argument_list|,
name|m_end
argument_list|,
literal|1
argument_list|,
name|chunk_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_ret
operator|!=
name|NULL
condition|)
operator|*
name|auth_ret
operator|=
name|auth
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
name|int
name|sctp_v6src_match_nexthop
parameter_list|(
name|struct
name|sockaddr_in6
modifier|*
name|src6
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|)
block|{
name|struct
name|nd_prefix
modifier|*
name|pfx
init|=
name|NULL
decl_stmt|;
name|struct
name|nd_pfxrouter
modifier|*
name|pfxrtr
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in6
name|gw6
decl_stmt|;
if|if
condition|(
name|ro
operator|==
name|NULL
operator|||
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
operator|||
name|src6
operator|->
name|sin6_family
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* get prefix entry of address */
name|LIST_FOREACH
argument_list|(
argument|pfx
argument_list|,
argument|&MODULE_GLOBAL(nd_prefix)
argument_list|,
argument|ndpr_entry
argument_list|)
block|{
if|if
condition|(
name|pfx
operator|->
name|ndpr_stateflags
operator|&
name|NDPRF_DETACHED
condition|)
continue|continue;
if|if
condition|(
name|IN6_ARE_MASKED_ADDR_EQUAL
argument_list|(
operator|&
name|pfx
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
argument_list|,
operator|&
name|src6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|pfx
operator|->
name|ndpr_mask
argument_list|)
condition|)
break|break;
block|}
comment|/* no prefix entry in the prefix list */
if|if
condition|(
name|pfx
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"No prefix entry for "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src6
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"v6src_match_nexthop(), Prefix entry is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|src6
argument_list|)
expr_stmt|;
comment|/* search installed gateway from prefix entry */
name|LIST_FOREACH
argument_list|(
argument|pfxrtr
argument_list|,
argument|&pfx->ndpr_advrtrs
argument_list|,
argument|pfr_entry
argument_list|)
block|{
name|memset
argument_list|(
operator|&
name|gw6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|gw6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|gw6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|gw6
operator|.
name|sin6_addr
argument_list|,
operator|&
name|pfxrtr
operator|->
name|router
operator|->
name|rtaddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"prefix router is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|gw6
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"installed router is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|gw6
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"pfxrouter is installed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
literal|"pfxrouter is not installed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_v4src_match_nexthop
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|sifa
parameter_list|,
name|sctp_route_t
modifier|*
name|ro
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|,
modifier|*
name|mask
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|in_addr
name|srcnetaddr
decl_stmt|,
name|gwnetaddr
decl_stmt|;
if|if
condition|(
name|ro
operator|==
name|NULL
operator|||
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
operator|||
name|sifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|sifa
operator|->
name|ifa
expr_stmt|;
name|mask
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|ifa
operator|->
name|ifa_netmask
operator|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|srcnetaddr
operator|.
name|s_addr
operator|=
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"match_nexthop4: src address is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
operator|&
name|sifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"network address is %x\n"
argument_list|,
name|srcnetaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
expr_stmt|;
name|gwnetaddr
operator|.
name|s_addr
operator|=
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|mask
operator|->
name|sin_addr
operator|.
name|s_addr
operator|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"match_nexthop4: nexthop is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_OUTPUT2
argument_list|,
name|ro
operator|->
name|ro_rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"network address is %x\n"
argument_list|,
name|gwnetaddr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|srcnetaddr
operator|.
name|s_addr
operator|==
name|gwnetaddr
operator|.
name|s_addr
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

