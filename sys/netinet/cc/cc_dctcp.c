begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2008  *	Swinburne University of Technology, Melbourne, Australia  * Copyright (c) 2009-2010 Lawrence Stewart<lstewart@freebsd.org>  * Copyright (c) 2014 Midori Kato<katoon@sfc.wide.ad.jp>  * Copyright (c) 2014 The FreeBSD Foundation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * An implementation of the DCTCP algorithm for FreeBSD, based on  * "Data Center TCP (DCTCP)" by M. Alizadeh, A. Greenberg, D. A. Maltz,  * J. Padhye, P. Patel, B. Prabhakar, S. Sengupta, and M. Sridharan.,  * in ACM Conference on SIGCOMM 2010, New York, USA,  * Originally released as the contribution of Microsoft Research project.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/cc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/cc/cc_module.h>
end_include

begin_define
define|#
directive|define
name|CAST_PTR_INT
parameter_list|(
name|X
parameter_list|)
value|(*((int*)(X)))
end_define

begin_define
define|#
directive|define
name|MAX_ALPHA_VALUE
value|1024
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uint32_t
argument_list|,
name|dctcp_alpha
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_dctcp_alpha
value|VNET(dctcp_alpha)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uint32_t
argument_list|,
name|dctcp_shift_g
argument_list|)
operator|=
literal|4
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_dctcp_shift_g
value|VNET(dctcp_shift_g)
end_define

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|uint32_t
argument_list|,
name|dctcp_slowstart
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_dctcp_slowstart
value|VNET(dctcp_slowstart)
end_define

begin_struct
struct|struct
name|dctcp
block|{
name|int
name|bytes_ecn
decl_stmt|;
comment|/* # of marked bytes during a RTT */
name|int
name|bytes_total
decl_stmt|;
comment|/* # of acked bytes during a RTT */
name|int
name|alpha
decl_stmt|;
comment|/* the fraction of marked bytes */
name|int
name|ce_prev
decl_stmt|;
comment|/* CE state of the last segment */
name|int
name|save_sndnxt
decl_stmt|;
comment|/* end sequence number of the current window */
name|int
name|ece_curr
decl_stmt|;
comment|/* ECE flag in this segment */
name|int
name|ece_prev
decl_stmt|;
comment|/* ECE flag in the last segment */
name|uint32_t
name|num_cong_events
decl_stmt|;
comment|/* # of congestion events */
block|}
struct|;
end_struct

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_dctcp
argument_list|,
literal|"dctcp data"
argument_list|,
literal|"Per connection data required for the dctcp algorithm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|dctcp_ack_received
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint16_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_after_idle
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_cb_destroy
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dctcp_cb_init
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_cong_signal
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint32_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_conn_init
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_post_recovery
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_ecnpkt_handler
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dctcp_update_alpha
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cc_algo
name|dctcp_cc_algo
init|=
block|{
operator|.
name|name
operator|=
literal|"dctcp"
block|,
operator|.
name|ack_received
operator|=
name|dctcp_ack_received
block|,
operator|.
name|cb_destroy
operator|=
name|dctcp_cb_destroy
block|,
operator|.
name|cb_init
operator|=
name|dctcp_cb_init
block|,
operator|.
name|cong_signal
operator|=
name|dctcp_cong_signal
block|,
operator|.
name|conn_init
operator|=
name|dctcp_conn_init
block|,
operator|.
name|post_recovery
operator|=
name|dctcp_post_recovery
block|,
operator|.
name|ecnpkt_handler
operator|=
name|dctcp_ecnpkt_handler
block|,
operator|.
name|after_idle
operator|=
name|dctcp_after_idle
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|dctcp_ack_received
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|int
name|bytes_acked
init|=
literal|0
decl_stmt|;
name|dctcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator|&
name|TF_ECN_PERMIT
condition|)
block|{
comment|/* 		 * DCTCP doesn't treat receipt of ECN marked packet as a 		 * congestion event. Thus, DCTCP always executes the ACK 		 * processing out of congestion recovery. 		 */
if|if
condition|(
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
name|EXIT_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
name|newreno_cc_algo
operator|.
name|ack_received
argument_list|(
name|ccv
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ENTER_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|newreno_cc_algo
operator|.
name|ack_received
argument_list|(
name|ccv
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CC_DUPACK
condition|)
name|bytes_acked
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|CC_ACK
condition|)
name|bytes_acked
operator|=
name|ccv
operator|->
name|bytes_this_ack
expr_stmt|;
comment|/* Update total bytes. */
name|dctcp_data
operator|->
name|bytes_total
operator|+=
name|bytes_acked
expr_stmt|;
comment|/* Update total marked bytes. */
if|if
condition|(
name|dctcp_data
operator|->
name|ece_curr
condition|)
block|{
if|if
condition|(
operator|!
name|dctcp_data
operator|->
name|ece_prev
operator|&&
name|bytes_acked
operator|>
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
condition|)
block|{
name|dctcp_data
operator|->
name|bytes_ecn
operator|+=
operator|(
name|bytes_acked
operator|-
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
name|dctcp_data
operator|->
name|bytes_ecn
operator|+=
name|bytes_acked
expr_stmt|;
name|dctcp_data
operator|->
name|ece_prev
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dctcp_data
operator|->
name|ece_prev
operator|&&
name|bytes_acked
operator|>
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
condition|)
name|dctcp_data
operator|->
name|bytes_ecn
operator|+=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
name|dctcp_data
operator|->
name|ece_prev
operator|=
literal|0
expr_stmt|;
block|}
name|dctcp_data
operator|->
name|ece_curr
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Update the fraction of marked bytes at the end of 		 * current window size. 		 */
if|if
condition|(
operator|(
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
operator|&&
name|SEQ_GEQ
argument_list|(
name|ccv
operator|->
name|curack
argument_list|,
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_recover
argument_list|)
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
operator|&&
name|SEQ_GT
argument_list|(
name|ccv
operator|->
name|curack
argument_list|,
name|dctcp_data
operator|->
name|save_sndnxt
argument_list|)
operator|)
condition|)
name|dctcp_update_alpha
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
block|}
else|else
name|newreno_cc_algo
operator|.
name|ack_received
argument_list|(
name|ccv
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dctcp_after_idle
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|dctcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
comment|/* Initialize internal parameters after idle time */
name|dctcp_data
operator|->
name|bytes_ecn
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|bytes_total
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|save_sndnxt
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_nxt
argument_list|)
expr_stmt|;
name|dctcp_data
operator|->
name|alpha
operator|=
name|V_dctcp_alpha
expr_stmt|;
name|dctcp_data
operator|->
name|ece_curr
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|ece_prev
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|num_cong_events
operator|=
literal|0
expr_stmt|;
name|dctcp_cc_algo
operator|.
name|after_idle
operator|=
name|newreno_cc_algo
operator|.
name|after_idle
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dctcp_cb_destroy
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
if|if
condition|(
name|ccv
operator|->
name|cc_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ccv
operator|->
name|cc_data
argument_list|,
name|M_dctcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dctcp_cb_init
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|dctcp_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dctcp
argument_list|)
argument_list|,
name|M_dctcp
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dctcp_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Initialize some key variables with sensible defaults. */
name|dctcp_data
operator|->
name|bytes_ecn
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|bytes_total
operator|=
literal|0
expr_stmt|;
comment|/* 	 * When alpha is set to 0 in the beggining, DCTCP sender transfers as 	 * much data as possible until the value converges which may expand the 	 * queueing delay at the switch. When alpha is set to 1, queueing delay 	 * is kept small. 	 * Throughput-sensitive applications should have alpha = 0 	 * Latency-sensitive applications should have alpha = 1 	 * 	 * Note: DCTCP draft suggests initial alpha to be 1 but we've decided to 	 * keep it 0 as default. 	 */
name|dctcp_data
operator|->
name|alpha
operator|=
name|V_dctcp_alpha
expr_stmt|;
name|dctcp_data
operator|->
name|save_sndnxt
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|ce_prev
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|ece_curr
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|ece_prev
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|num_cong_events
operator|=
literal|0
expr_stmt|;
name|ccv
operator|->
name|cc_data
operator|=
name|dctcp_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform any necessary tasks before we enter congestion recovery.  */
end_comment

begin_function
specifier|static
name|void
name|dctcp_cong_signal
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint32_t
name|type
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|u_int
name|win
decl_stmt|,
name|mss
decl_stmt|;
name|dctcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
name|win
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
expr_stmt|;
name|mss
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CC_NDUPACK
case|:
if|if
condition|(
operator|!
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
name|mss
operator|*
name|max
argument_list|(
name|win
operator|/
literal|2
operator|/
name|mss
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dctcp_data
operator|->
name|num_cong_events
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* cwnd has already updated as congestion 				 * recovery. Reverse cwnd value using 				 * snd_cwnd_prev and recalculate snd_ssthresh 				 */
name|win
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd_prev
argument_list|)
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
name|max
argument_list|(
name|win
operator|/
literal|2
operator|/
name|mss
argument_list|,
literal|2
argument_list|)
operator|*
name|mss
expr_stmt|;
block|}
name|ENTER_RECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_ECN
case|:
comment|/* 		 * Save current snd_cwnd when the host encounters both 		 * congestion recovery and fast recovery. 		 */
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd_prev
argument_list|)
operator|=
name|win
expr_stmt|;
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|V_dctcp_slowstart
operator|&&
name|dctcp_data
operator|->
name|num_cong_events
operator|++
operator|==
literal|0
condition|)
block|{
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
name|mss
operator|*
name|max
argument_list|(
name|win
operator|/
literal|2
operator|/
name|mss
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dctcp_data
operator|->
name|alpha
operator|=
name|MAX_ALPHA_VALUE
expr_stmt|;
name|dctcp_data
operator|->
name|bytes_ecn
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|bytes_total
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|save_sndnxt
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_nxt
argument_list|)
expr_stmt|;
block|}
else|else
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
name|max
argument_list|(
operator|(
name|win
operator|-
operator|(
operator|(
name|win
operator|*
name|dctcp_data
operator|->
name|alpha
operator|)
operator|>>
literal|11
operator|)
operator|)
operator|/
name|mss
argument_list|,
literal|2
argument_list|)
operator|*
name|mss
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
expr_stmt|;
name|ENTER_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dctcp_data
operator|->
name|ece_curr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CC_RTO
case|:
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator|&
name|TF_ECN_PERMIT
condition|)
block|{
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator||=
name|TF_ECN_SND_CWR
expr_stmt|;
name|dctcp_update_alpha
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
name|dctcp_data
operator|->
name|save_sndnxt
operator|+=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
name|dctcp_data
operator|->
name|num_cong_events
operator|++
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dctcp_conn_init
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|dctcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator|&
name|TF_ECN_PERMIT
condition|)
name|dctcp_data
operator|->
name|save_sndnxt
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_nxt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform any necessary tasks before we exit congestion recovery.  */
end_comment

begin_function
specifier|static
name|void
name|dctcp_post_recovery
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|dctcp_cc_algo
operator|.
name|post_recovery
operator|=
name|newreno_cc_algo
operator|.
name|post_recovery
expr_stmt|;
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator|&
name|TF_ECN_PERMIT
condition|)
name|dctcp_update_alpha
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Execute an additional ECN processing using ECN field in IP header and the CWR  * bit in TCP header.  *  * delay_ack == 0 - Delayed ACK disabled  * delay_ack == 1 - Delayed ACK enabled  */
end_comment

begin_function
specifier|static
name|void
name|dctcp_ecnpkt_handler
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|uint32_t
name|ccflag
decl_stmt|;
name|int
name|delay_ack
decl_stmt|;
name|dctcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
name|ccflag
operator|=
name|ccv
operator|->
name|flags
expr_stmt|;
name|delay_ack
operator|=
literal|1
expr_stmt|;
comment|/* 	 * DCTCP responses an ACK immediately when the CE state 	 * in between this segment and the last segment is not same. 	 */
if|if
condition|(
name|ccflag
operator|&
name|CCF_IPHDR_CE
condition|)
block|{
if|if
condition|(
operator|!
name|dctcp_data
operator|->
name|ce_prev
operator|&&
operator|(
name|ccflag
operator|&
name|CCF_DELACK
operator|)
condition|)
name|delay_ack
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|ce_prev
operator|=
literal|1
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator||=
name|TF_ECN_SND_ECE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dctcp_data
operator|->
name|ce_prev
operator|&&
operator|(
name|ccflag
operator|&
name|CCF_DELACK
operator|)
condition|)
name|delay_ack
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|ce_prev
operator|=
literal|0
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
operator|&=
operator|~
name|TF_ECN_SND_ECE
expr_stmt|;
block|}
comment|/* DCTCP sets delayed ack when this segment sets the CWR flag. */
if|if
condition|(
operator|(
name|ccflag
operator|&
name|CCF_DELACK
operator|)
operator|&&
operator|(
name|ccflag
operator|&
name|CCF_TCPHDR_CWR
operator|)
condition|)
name|delay_ack
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|delay_ack
operator|==
literal|0
condition|)
name|ccv
operator|->
name|flags
operator||=
name|CCF_ACKNOW
expr_stmt|;
else|else
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_ACKNOW
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the fraction of marked bytes represented as 'alpha'.  * Also initialize several internal parameters at the end of this function.  */
end_comment

begin_function
specifier|static
name|void
name|dctcp_update_alpha
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|dctcp
modifier|*
name|dctcp_data
decl_stmt|;
name|int
name|alpha_prev
decl_stmt|;
name|dctcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
name|alpha_prev
operator|=
name|dctcp_data
operator|->
name|alpha
expr_stmt|;
name|dctcp_data
operator|->
name|bytes_total
operator|=
name|max
argument_list|(
name|dctcp_data
operator|->
name|bytes_total
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Update alpha: alpha = (1 - g) * alpha + g * F. 	 * Here: 	 * g is weight factor 	 *	recommaded to be set to 1/16 	 *	small g = slow convergence between competitive DCTCP flows 	 *	large g = impacts low utilization of bandwidth at switches 	 * F is fraction of marked segments in last RTT 	 *	updated every RTT 	 * Alpha must be round to 0 - MAX_ALPHA_VALUE. 	 */
name|dctcp_data
operator|->
name|alpha
operator|=
name|min
argument_list|(
name|alpha_prev
operator|-
operator|(
name|alpha_prev
operator|>>
name|V_dctcp_shift_g
operator|)
operator|+
operator|(
name|dctcp_data
operator|->
name|bytes_ecn
operator|<<
operator|(
literal|10
operator|-
name|V_dctcp_shift_g
operator|)
operator|)
operator|/
name|dctcp_data
operator|->
name|bytes_total
argument_list|,
name|MAX_ALPHA_VALUE
argument_list|)
expr_stmt|;
comment|/* Initialize internal parameters for next alpha calculation */
name|dctcp_data
operator|->
name|bytes_ecn
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|bytes_total
operator|=
literal|0
expr_stmt|;
name|dctcp_data
operator|->
name|save_sndnxt
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_nxt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dctcp_alpha_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|;
name|int
name|error
decl_stmt|;
name|new
operator|=
name|V_dctcp_alpha
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CAST_PTR_INT
argument_list|(
name|req
operator|->
name|newptr
argument_list|)
operator|>
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|new
operator|>
name|MAX_ALPHA_VALUE
condition|)
name|V_dctcp_alpha
operator|=
name|MAX_ALPHA_VALUE
expr_stmt|;
else|else
name|V_dctcp_alpha
operator|=
name|new
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dctcp_shift_g_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|;
name|int
name|error
decl_stmt|;
name|new
operator|=
name|V_dctcp_shift_g
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CAST_PTR_INT
argument_list|(
name|req
operator|->
name|newptr
argument_list|)
operator|>
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|V_dctcp_shift_g
operator|=
name|new
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dctcp_slowstart_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|uint32_t
name|new
decl_stmt|;
name|int
name|error
decl_stmt|;
name|new
operator|=
name|V_dctcp_slowstart
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|new
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|CAST_PTR_INT
argument_list|(
name|req
operator|->
name|newptr
argument_list|)
operator|>
literal|1
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
else|else
name|V_dctcp_slowstart
operator|=
name|new
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_tcp_cc_dctcp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_tcp_cc
argument_list|,
name|OID_AUTO
argument_list|,
name|dctcp
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"dctcp congestion control related settings"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_tcp_cc_dctcp
argument_list|,
name|OID_AUTO
argument_list|,
name|alpha
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|dctcp_alpha
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|dctcp_alpha_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"dctcp alpha parameter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_tcp_cc_dctcp
argument_list|,
name|OID_AUTO
argument_list|,
name|shift_g
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|dctcp_shift_g
argument_list|)
argument_list|,
literal|4
argument_list|,
operator|&
name|dctcp_shift_g_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"dctcp shift parameter"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_tcp_cc_dctcp
argument_list|,
name|OID_AUTO
argument_list|,
name|slowstart
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|dctcp_slowstart
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|&
name|dctcp_slowstart_handler
argument_list|,
literal|"IU"
argument_list|,
literal|"half CWND reduction after the first slow start"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_CC_MODULE
argument_list|(
name|dctcp
argument_list|,
operator|&
name|dctcp_cc_algo
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

