begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2008  * 	Swinburne University of Technology, Melbourne, Australia  * Copyright (c) 2009-2010 Lawrence Stewart<lstewart@freebsd.org>  * Copyright (c) 2010 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed at the Centre for Advanced Internet  * Architectures, Swinburne University of Technology, by Lawrence Stewart and  * James Healy, made possible in part by a grant from the Cisco University  * Research Program Fund at Community Foundation Silicon Valley.  *  * Portions of this software were developed at the Centre for Advanced  * Internet Architectures, Swinburne University of Technology, Melbourne,  * Australia by David Hayes under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * An implementation of the H-TCP congestion control algorithm for FreeBSD,  * based on the Internet Draft "draft-leith-tcp-htcp-06.txt" by Leith and  * Shorten. Originally released as part of the NewTCP research project at  * Swinburne University of Technology's Centre for Advanced Internet  * Architectures, Melbourne, Australia, which was made possible in part by a  * grant from the Cisco University Research Program Fund at Community Foundation  * Silicon Valley. More details are available at:  *   http://caia.swin.edu.au/urp/newtcp/  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_cc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/cc/cc_module.h>
end_include

begin_comment
comment|/* Fixed point math shifts. */
end_comment

begin_define
define|#
directive|define
name|HTCP_SHIFT
value|8
end_define

begin_define
define|#
directive|define
name|HTCP_ALPHA_INC_SHIFT
value|4
end_define

begin_define
define|#
directive|define
name|HTCP_INIT_ALPHA
value|1
end_define

begin_define
define|#
directive|define
name|HTCP_DELTA_L
value|hz
end_define

begin_comment
comment|/* 1 sec in ticks. */
end_comment

begin_define
define|#
directive|define
name|HTCP_MINBETA
value|128
end_define

begin_comment
comment|/* 0.5<< HTCP_SHIFT. */
end_comment

begin_define
define|#
directive|define
name|HTCP_MAXBETA
value|204
end_define

begin_comment
comment|/* ~0.8<< HTCP_SHIFT. */
end_comment

begin_define
define|#
directive|define
name|HTCP_MINROWE
value|26
end_define

begin_comment
comment|/* ~0.1<< HTCP_SHIFT. */
end_comment

begin_define
define|#
directive|define
name|HTCP_MAXROWE
value|512
end_define

begin_comment
comment|/* 2<< HTCP_SHIFT. */
end_comment

begin_comment
comment|/* RTT_ref (ms) used in the calculation of alpha if RTT scaling is enabled. */
end_comment

begin_define
define|#
directive|define
name|HTCP_RTT_REF
value|100
end_define

begin_comment
comment|/* Don't trust SRTT until this many samples have been taken. */
end_comment

begin_define
define|#
directive|define
name|HTCP_MIN_RTT_SAMPLES
value|8
end_define

begin_comment
comment|/*  * HTCP_CALC_ALPHA performs a fixed point math calculation to determine the  * value of alpha, based on the function defined in the HTCP spec.  *  * i.e. 1 + 10(delta - delta_l) + ((delta - delta_l) / 2) ^ 2  *  * "diff" is passed in to the macro as "delta - delta_l" and is expected to be  * in units of ticks.  *  * The joyousnous of fixed point maths means our function implementation looks a  * little funky...  *  * In order to maintain some precision in the calculations, a fixed point shift  * HTCP_ALPHA_INC_SHIFT is used to ensure the integer divisions don't  * truncate the results too badly.  *  * The "16" value is the "1" term in the alpha function shifted up by  * HTCP_ALPHA_INC_SHIFT  *  * The "160" value is the "10" multiplier in the alpha function multiplied by  * 2^HTCP_ALPHA_INC_SHIFT  *  * Specifying these as constants reduces the computations required. After  * up-shifting all the terms in the function and performing the required  * calculations, we down-shift the final result by HTCP_ALPHA_INC_SHIFT to  * ensure it is back in the correct range.  *  * The "hz" terms are required as kernels can be configured to run with  * different tick timers, which we have to adjust for in the alpha calculation  * (which originally was defined in terms of seconds).  *  * We also have to be careful to constrain the value of diff such that it won't  * overflow whilst performing the calculation. The middle term i.e. (160 * diff)  * / hz is the limiting factor in the calculation. We must constrain diff to be  * less than the max size of an int divided by the constant 160 figure  * i.e. diff< INT_MAX / 160  *  * NB: Changing HTCP_ALPHA_INC_SHIFT will require you to MANUALLY update the  * constants used in this function!  */
end_comment

begin_define
define|#
directive|define
name|HTCP_CALC_ALPHA
parameter_list|(
name|diff
parameter_list|)
define|\
value|((\ 	(16) + \ 	((160 * (diff)) / hz) + \ 	(((diff) / hz) * (((diff)<< HTCP_ALPHA_INC_SHIFT) / (4 * hz))) \ )>> HTCP_ALPHA_INC_SHIFT)
end_define

begin_function_decl
specifier|static
name|void
name|htcp_ack_received
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint16_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_cb_destroy
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|htcp_cb_init
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_cong_signal
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint32_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|htcp_mod_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_post_recovery
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_recalc_alpha
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_recalc_beta
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_record_rtt
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|htcp_ssthresh_update
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|htcp
block|{
comment|/* cwnd before entering cong recovery. */
name|unsigned
name|long
name|prev_cwnd
decl_stmt|;
comment|/* cwnd additive increase parameter. */
name|int
name|alpha
decl_stmt|;
comment|/* cwnd multiplicative decrease parameter. */
name|int
name|beta
decl_stmt|;
comment|/* Largest rtt seen for the flow. */
name|int
name|maxrtt
decl_stmt|;
comment|/* Shortest rtt seen for the flow. */
name|int
name|minrtt
decl_stmt|;
comment|/* Time of last congestion event in ticks. */
name|int
name|t_last_cong
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|htcp_rtt_ref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The maximum number of ticks the value of diff can reach in  * htcp_recalc_alpha() before alpha will stop increasing due to overflow.  * See comment above HTCP_CALC_ALPHA for more info.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|htcp_max_diff
init|=
name|INT_MAX
operator|/
operator|(
operator|(
literal|1
operator|<<
name|HTCP_ALPHA_INC_SHIFT
operator|)
operator|*
literal|10
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Per-netstack vars. */
end_comment

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|htcp_adaptive_backoff
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|VNET_DEFINE
argument_list|(
name|u_int
argument_list|,
name|htcp_rtt_scaling
argument_list|)
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|V_htcp_adaptive_backoff
value|VNET(htcp_adaptive_backoff)
end_define

begin_define
define|#
directive|define
name|V_htcp_rtt_scaling
value|VNET(htcp_rtt_scaling)
end_define

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_HTCP
argument_list|,
literal|"htcp data"
argument_list|,
literal|"Per connection data required for the HTCP congestion control algorithm"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|cc_algo
name|htcp_cc_algo
init|=
block|{
operator|.
name|name
operator|=
literal|"htcp"
block|,
operator|.
name|ack_received
operator|=
name|htcp_ack_received
block|,
operator|.
name|cb_destroy
operator|=
name|htcp_cb_destroy
block|,
operator|.
name|cb_init
operator|=
name|htcp_cb_init
block|,
operator|.
name|cong_signal
operator|=
name|htcp_cong_signal
block|,
operator|.
name|mod_init
operator|=
name|htcp_mod_init
block|,
operator|.
name|post_recovery
operator|=
name|htcp_post_recovery
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|htcp_ack_received
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
name|htcp_record_rtt
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
comment|/* 	 * Regular ACK and we're not in cong/fast recovery and we're cwnd 	 * limited and we're either not doing ABC or are slow starting or are 	 * doing ABC and we've sent a cwnd's worth of bytes. 	 */
if|if
condition|(
name|type
operator|==
name|CC_ACK
operator|&&
operator|!
name|IN_RECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
operator|&&
operator|(
name|ccv
operator|->
name|flags
operator|&
name|CCF_CWND_LIMITED
operator|)
operator|&&
operator|(
operator|!
name|V_tcp_do_rfc3465
operator|||
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|<=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|||
operator|(
name|V_tcp_do_rfc3465
operator|&&
name|ccv
operator|->
name|flags
operator|&
name|CCF_ABC_SENTAWND
operator|)
operator|)
condition|)
block|{
name|htcp_recalc_beta
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
name|htcp_recalc_alpha
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
comment|/* 		 * Use the logic in NewReno ack_received() for slow start and 		 * for the first HTCP_DELTA_L ticks after either the flow starts 		 * or a congestion event (when alpha equals 1). 		 */
if|if
condition|(
name|htcp_data
operator|->
name|alpha
operator|==
literal|1
operator|||
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|<=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
condition|)
name|newreno_cc_algo
operator|.
name|ack_received
argument_list|(
name|ccv
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|V_tcp_do_rfc3465
condition|)
block|{
comment|/* Increment cwnd by alpha segments. */
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|+=
name|htcp_data
operator|->
name|alpha
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_ABC_SENTAWND
expr_stmt|;
block|}
else|else
comment|/* 				 * Increment cwnd by alpha/cwnd segments to 				 * approximate an increase of alpha segments 				 * per RTT. 				 */
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|+=
operator|(
operator|(
operator|(
name|htcp_data
operator|->
name|alpha
operator|<<
name|HTCP_SHIFT
operator|)
operator|/
operator|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|/
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
operator|)
operator|)
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
operator|)
operator|>>
name|HTCP_SHIFT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|htcp_cb_destroy
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
if|if
condition|(
name|ccv
operator|->
name|cc_data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ccv
operator|->
name|cc_data
argument_list|,
name|M_HTCP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|htcp_cb_init
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|htcp
argument_list|)
argument_list|,
name|M_HTCP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|htcp_data
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* Init some key variables with sensible defaults. */
name|htcp_data
operator|->
name|alpha
operator|=
name|HTCP_INIT_ALPHA
expr_stmt|;
name|htcp_data
operator|->
name|beta
operator|=
name|HTCP_MINBETA
expr_stmt|;
name|htcp_data
operator|->
name|maxrtt
operator|=
name|TCPTV_SRTTBASE
expr_stmt|;
name|htcp_data
operator|->
name|minrtt
operator|=
name|TCPTV_SRTTBASE
expr_stmt|;
name|htcp_data
operator|->
name|prev_cwnd
operator|=
literal|0
expr_stmt|;
name|htcp_data
operator|->
name|t_last_cong
operator|=
name|ticks
expr_stmt|;
name|ccv
operator|->
name|cc_data
operator|=
name|htcp_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform any necessary tasks before we enter congestion recovery.  */
end_comment

begin_function
specifier|static
name|void
name|htcp_cong_signal
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint32_t
name|type
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CC_NDUPACK
case|:
if|if
condition|(
operator|!
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 				 * Apply hysteresis to maxrtt to ensure 				 * reductions in the RTT are reflected in our 				 * measurements. 				 */
name|htcp_data
operator|->
name|maxrtt
operator|=
operator|(
name|htcp_data
operator|->
name|minrtt
operator|+
operator|(
name|htcp_data
operator|->
name|maxrtt
operator|-
name|htcp_data
operator|->
name|minrtt
operator|)
operator|*
literal|95
operator|)
operator|/
literal|100
expr_stmt|;
name|htcp_ssthresh_update
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
name|htcp_data
operator|->
name|t_last_cong
operator|=
name|ticks
expr_stmt|;
name|htcp_data
operator|->
name|prev_cwnd
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
expr_stmt|;
block|}
name|ENTER_RECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_ECN
case|:
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 			 * Apply hysteresis to maxrtt to ensure reductions in 			 * the RTT are reflected in our measurements. 			 */
name|htcp_data
operator|->
name|maxrtt
operator|=
operator|(
name|htcp_data
operator|->
name|minrtt
operator|+
operator|(
name|htcp_data
operator|->
name|maxrtt
operator|-
name|htcp_data
operator|->
name|minrtt
operator|)
operator|*
literal|95
operator|)
operator|/
literal|100
expr_stmt|;
name|htcp_ssthresh_update
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
expr_stmt|;
name|htcp_data
operator|->
name|t_last_cong
operator|=
name|ticks
expr_stmt|;
name|htcp_data
operator|->
name|prev_cwnd
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
expr_stmt|;
name|ENTER_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_RTO
case|:
comment|/* 		 * Grab the current time and record it so we know when the 		 * most recent congestion event was. Only record it when the 		 * timeout has fired more than once, as there is a reasonable 		 * chance the first one is a false alarm and may not indicate 		 * congestion. 		 */
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_rxtshift
argument_list|)
operator|>=
literal|2
condition|)
name|htcp_data
operator|->
name|t_last_cong
operator|=
name|ticks
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|htcp_mod_init
parameter_list|(
name|void
parameter_list|)
block|{
name|htcp_cc_algo
operator|.
name|after_idle
operator|=
name|newreno_cc_algo
operator|.
name|after_idle
expr_stmt|;
comment|/* 	 * HTCP_RTT_REF is defined in ms, and t_srtt in the tcpcb is stored in 	 * units of TCP_RTT_SCALE*hz. Scale HTCP_RTT_REF to be in the same units 	 * as t_srtt. 	 */
name|htcp_rtt_ref
operator|=
operator|(
name|HTCP_RTT_REF
operator|*
name|TCP_RTT_SCALE
operator|*
name|hz
operator|)
operator|/
literal|1000
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform any necessary tasks before we exit congestion recovery.  */
end_comment

begin_function
specifier|static
name|void
name|htcp_post_recovery
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
if|if
condition|(
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * If inflight data is less than ssthresh, set cwnd 		 * conservatively to avoid a burst of data, as suggested in the 		 * NewReno RFC. Otherwise, use the HTCP method. 		 * 		 * XXXLAS: Find a way to do this without needing curack 		 */
if|if
condition|(
name|SEQ_GT
argument_list|(
name|ccv
operator|->
name|curack
operator|+
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
argument_list|,
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_max
argument_list|)
argument_list|)
condition|)
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_max
argument_list|)
operator|-
name|ccv
operator|->
name|curack
operator|+
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
else|else
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|max
argument_list|(
literal|1
argument_list|,
operator|(
operator|(
name|htcp_data
operator|->
name|beta
operator|*
name|htcp_data
operator|->
name|prev_cwnd
operator|/
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
operator|)
operator|>>
name|HTCP_SHIFT
operator|)
argument_list|)
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|htcp_recalc_alpha
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|int
name|alpha
decl_stmt|,
name|diff
decl_stmt|,
name|now
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
name|now
operator|=
name|ticks
expr_stmt|;
comment|/* 	 * If ticks has wrapped around (will happen approximately once every 49 	 * days on a machine with the default kern.hz=1000) and a flow straddles 	 * the wrap point, our alpha calcs will be completely wrong. We cut our 	 * losses and restart alpha from scratch by setting t_last_cong = now - 	 * HTCP_DELTA_L. 	 * 	 * This does not deflate our cwnd at all. It simply slows the rate cwnd 	 * is growing by until alpha regains the value it held prior to taking 	 * this drastic measure. 	 */
if|if
condition|(
name|now
operator|<
name|htcp_data
operator|->
name|t_last_cong
condition|)
name|htcp_data
operator|->
name|t_last_cong
operator|=
name|now
operator|-
name|HTCP_DELTA_L
expr_stmt|;
name|diff
operator|=
name|now
operator|-
name|htcp_data
operator|->
name|t_last_cong
operator|-
name|HTCP_DELTA_L
expr_stmt|;
comment|/* Cap alpha if the value of diff would overflow HTCP_CALC_ALPHA(). */
if|if
condition|(
name|diff
operator|<
name|htcp_max_diff
condition|)
block|{
comment|/* 		 * If it has been more than HTCP_DELTA_L ticks since congestion, 		 * increase alpha according to the function defined in the spec. 		 */
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|alpha
operator|=
name|HTCP_CALC_ALPHA
argument_list|(
name|diff
argument_list|)
expr_stmt|;
comment|/* 			 * Adaptive backoff fairness adjustment: 			 * 2 * (1 - beta) * alpha_raw 			 */
if|if
condition|(
name|V_htcp_adaptive_backoff
condition|)
name|alpha
operator|=
name|max
argument_list|(
literal|1
argument_list|,
operator|(
literal|2
operator|*
operator|(
operator|(
literal|1
operator|<<
name|HTCP_SHIFT
operator|)
operator|-
name|htcp_data
operator|->
name|beta
operator|)
operator|*
name|alpha
operator|)
operator|>>
name|HTCP_SHIFT
argument_list|)
expr_stmt|;
comment|/* 			 * RTT scaling: (RTT / RTT_ref) * alpha 			 * alpha will be the raw value from HTCP_CALC_ALPHA() if 			 * adaptive backoff is off, or the adjusted value if 			 * adaptive backoff is on. 			 */
if|if
condition|(
name|V_htcp_rtt_scaling
condition|)
name|alpha
operator|=
name|max
argument_list|(
literal|1
argument_list|,
operator|(
name|min
argument_list|(
name|max
argument_list|(
name|HTCP_MINROWE
argument_list|,
operator|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_srtt
argument_list|)
operator|<<
name|HTCP_SHIFT
operator|)
operator|/
name|htcp_rtt_ref
argument_list|)
argument_list|,
name|HTCP_MAXROWE
argument_list|)
operator|*
name|alpha
operator|)
operator|>>
name|HTCP_SHIFT
argument_list|)
expr_stmt|;
block|}
else|else
name|alpha
operator|=
literal|1
expr_stmt|;
name|htcp_data
operator|->
name|alpha
operator|=
name|alpha
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|htcp_recalc_beta
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
comment|/* 	 * TCPTV_SRTTBASE is the initialised value of each connection's SRTT, so 	 * we only calc beta if the connection's SRTT has been changed from its 	 * inital value. beta is bounded to ensure it is always between 	 * HTCP_MINBETA and HTCP_MAXBETA. 	 */
if|if
condition|(
name|V_htcp_adaptive_backoff
operator|&&
name|htcp_data
operator|->
name|minrtt
operator|!=
name|TCPTV_SRTTBASE
operator|&&
name|htcp_data
operator|->
name|maxrtt
operator|!=
name|TCPTV_SRTTBASE
condition|)
name|htcp_data
operator|->
name|beta
operator|=
name|min
argument_list|(
name|max
argument_list|(
name|HTCP_MINBETA
argument_list|,
operator|(
name|htcp_data
operator|->
name|minrtt
operator|<<
name|HTCP_SHIFT
operator|)
operator|/
name|htcp_data
operator|->
name|maxrtt
argument_list|)
argument_list|,
name|HTCP_MAXBETA
argument_list|)
expr_stmt|;
else|else
name|htcp_data
operator|->
name|beta
operator|=
name|HTCP_MINBETA
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record the minimum and maximum RTT seen for the connection. These are used in  * the calculation of beta if adaptive backoff is enabled.  */
end_comment

begin_function
specifier|static
name|void
name|htcp_record_rtt
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
comment|/* XXXLAS: Should there be some hysteresis for minrtt? */
comment|/* 	 * Record the current SRTT as our minrtt if it's the smallest we've seen 	 * or minrtt is currently equal to its initialised value. Ignore SRTT 	 * until a min number of samples have been taken. 	 */
if|if
condition|(
operator|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_srtt
argument_list|)
operator|<
name|htcp_data
operator|->
name|minrtt
operator|||
name|htcp_data
operator|->
name|minrtt
operator|==
name|TCPTV_SRTTBASE
operator|)
operator|&&
operator|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_rttupdated
argument_list|)
operator|>=
name|HTCP_MIN_RTT_SAMPLES
operator|)
condition|)
name|htcp_data
operator|->
name|minrtt
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_srtt
argument_list|)
expr_stmt|;
comment|/* 	 * Record the current SRTT as our maxrtt if it's the largest we've 	 * seen. Ignore SRTT until a min number of samples have been taken. 	 */
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_srtt
argument_list|)
operator|>
name|htcp_data
operator|->
name|maxrtt
operator|&&
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_rttupdated
argument_list|)
operator|>=
name|HTCP_MIN_RTT_SAMPLES
condition|)
name|htcp_data
operator|->
name|maxrtt
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_srtt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the ssthresh in the event of congestion.  */
end_comment

begin_function
specifier|static
name|void
name|htcp_ssthresh_update
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|struct
name|htcp
modifier|*
name|htcp_data
decl_stmt|;
name|htcp_data
operator|=
name|ccv
operator|->
name|cc_data
expr_stmt|;
comment|/* 	 * On the first congestion event, set ssthresh to cwnd * 0.5, on 	 * subsequent congestion events, set it to cwnd * beta. 	 */
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|==
name|TCP_MAXWIN
operator|<<
name|TCP_MAX_WINSHIFT
condition|)
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
operator|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|*
name|HTCP_MINBETA
operator|)
operator|>>
name|HTCP_SHIFT
expr_stmt|;
else|else
block|{
name|htcp_recalc_beta
argument_list|(
name|ccv
argument_list|)
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
operator|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|*
name|htcp_data
operator|->
name|beta
operator|)
operator|>>
name|HTCP_SHIFT
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_net_inet_tcp_cc_htcp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net_inet_tcp_cc
argument_list|,
name|OID_AUTO
argument_list|,
name|htcp
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"H-TCP related settings"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_tcp_cc_htcp
argument_list|,
name|OID_AUTO
argument_list|,
name|adaptive_backoff
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|htcp_adaptive_backoff
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"enable H-TCP adaptive backoff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_net_inet_tcp_cc_htcp
argument_list|,
name|OID_AUTO
argument_list|,
name|rtt_scaling
argument_list|,
name|CTLFLAG_VNET
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|VNET_NAME
argument_list|(
name|htcp_rtt_scaling
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|"enable H-TCP RTT scaling"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DECLARE_CC_MODULE
argument_list|(
name|htcp
argument_list|,
operator|&
name|htcp_cc_algo
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

