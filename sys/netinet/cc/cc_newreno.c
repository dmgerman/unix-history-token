begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1982, 1986, 1988, 1990, 1993, 1994, 1995  *	The Regents of the University of California.  * Copyright (c) 2007-2008,2010  *	Swinburne University of Technology, Melbourne, Australia.  * Copyright (c) 2009-2010 Lawrence Stewart<lstewart@freebsd.org>  * Copyright (c) 2010 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed at the Centre for Advanced Internet  * Architectures, Swinburne University of Technology, by Lawrence Stewart, James  * Healy and David Hayes, made possible in part by a grant from the Cisco  * University Research Program Fund at Community Foundation Silicon Valley.  *  * Portions of this software were developed at the Centre for Advanced  * Internet Architectures, Swinburne University of Technology, Melbourne,  * Australia by David Hayes under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * This software was first released in 2007 by James Healy and Lawrence Stewart  * whilst working on the NewTCP research project at Swinburne University of  * Technology's Centre for Advanced Internet Architectures, Melbourne,  * Australia, which was made possible in part by a grant from the Cisco  * University Research Program Fund at Community Foundation Silicon Valley.  * More details are available at:  *   http://caia.swin.edu.au/urp/newtcp/  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_seq.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/cc/cc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/cc/cc_module.h>
end_include

begin_function_decl
specifier|static
name|void
name|newreno_ack_received
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint16_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newreno_after_idle
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newreno_cong_signal
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint32_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|newreno_post_recovery
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|cc_algo
name|newreno_cc_algo
init|=
block|{
operator|.
name|name
operator|=
literal|"newreno"
block|,
operator|.
name|ack_received
operator|=
name|newreno_ack_received
block|,
operator|.
name|after_idle
operator|=
name|newreno_after_idle
block|,
operator|.
name|cong_signal
operator|=
name|newreno_cong_signal
block|,
operator|.
name|post_recovery
operator|=
name|newreno_post_recovery
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|newreno_ack_received
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|CC_ACK
operator|&&
operator|!
name|IN_RECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
operator|&&
operator|(
name|ccv
operator|->
name|flags
operator|&
name|CCF_CWND_LIMITED
operator|)
condition|)
block|{
name|u_int
name|cw
init|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
decl_stmt|;
name|u_int
name|incr
init|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
decl_stmt|;
comment|/* 		 * Regular in-order ACK, open the congestion window. 		 * Method depends on which congestion control state we're 		 * in (slow start or cong avoid) and if ABC (RFC 3465) is 		 * enabled. 		 * 		 * slow start: cwnd<= ssthresh 		 * cong avoid: cwnd> ssthresh 		 * 		 * slow start and ABC (RFC 3465): 		 *   Grow cwnd exponentially by the amount of data 		 *   ACKed capping the max increment per ACK to 		 *   (abc_l_var * maxseg) bytes. 		 * 		 * slow start without ABC (RFC 5681): 		 *   Grow cwnd exponentially by maxseg per ACK. 		 * 		 * cong avoid and ABC (RFC 3465): 		 *   Grow cwnd linearly by maxseg per RTT for each 		 *   cwnd worth of ACKed data. 		 * 		 * cong avoid without ABC (RFC 5681): 		 *   Grow cwnd linearly by approximately maxseg per RTT using 		 *   maxseg^2 / cwnd per ACK as the increment. 		 *   If cwnd> maxseg^2, fix the cwnd increment at 1 byte to 		 *   avoid capping cwnd. 		 */
if|if
condition|(
name|cw
operator|>
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
condition|)
block|{
if|if
condition|(
name|V_tcp_do_rfc3465
condition|)
block|{
if|if
condition|(
name|ccv
operator|->
name|flags
operator|&
name|CCF_ABC_SENTAWND
condition|)
name|ccv
operator|->
name|flags
operator|&=
operator|~
name|CCF_ABC_SENTAWND
expr_stmt|;
else|else
name|incr
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|incr
operator|=
name|max
argument_list|(
operator|(
name|incr
operator|*
name|incr
operator|/
name|cw
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|V_tcp_do_rfc3465
condition|)
block|{
comment|/* 			 * In slow-start with ABC enabled and no RTO in sight? 			 * (Must not use abc_l_var> 1 if slow starting after 			 * an RTO. On RTO, snd_nxt = snd_una, so the 			 * snd_nxt == snd_max check is sufficient to 			 * handle this). 			 * 			 * XXXLAS: Find a way to signal SS after RTO that 			 * doesn't rely on tcpcb vars. 			 */
if|if
condition|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_nxt
argument_list|)
operator|==
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_max
argument_list|)
condition|)
name|incr
operator|=
name|min
argument_list|(
name|ccv
operator|->
name|bytes_this_ack
argument_list|,
name|ccv
operator|->
name|nsegs
operator|*
name|V_tcp_abc_l_var
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|incr
operator|=
name|min
argument_list|(
name|ccv
operator|->
name|bytes_this_ack
argument_list|,
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ABC is on by default, so incr equals 0 frequently. */
if|if
condition|(
name|incr
operator|>
literal|0
condition|)
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|min
argument_list|(
name|cw
operator|+
name|incr
argument_list|,
name|TCP_MAXWIN
operator|<<
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_scale
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|newreno_after_idle
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|int
name|rw
decl_stmt|;
comment|/* 	 * If we've been idle for more than one retransmit timeout the old 	 * congestion window is no longer current and we have to reduce it to 	 * the restart window before we can transmit again. 	 * 	 * The restart window is the initial window or the last CWND, whichever 	 * is smaller. 	 * 	 * This is done to prevent us from flooding the path with a full CWND at 	 * wirespeed, overloading router and switch buffers along the way. 	 * 	 * See RFC5681 Section 4.1. "Restarting Idle Connections". 	 */
if|if
condition|(
name|V_tcp_do_rfc3390
condition|)
name|rw
operator|=
name|min
argument_list|(
literal|4
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
argument_list|,
name|max
argument_list|(
literal|2
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
argument_list|,
literal|4380
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rw
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
operator|*
literal|2
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|min
argument_list|(
name|rw
argument_list|,
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform any necessary tasks before we enter congestion recovery.  */
end_comment

begin_function
specifier|static
name|void
name|newreno_cong_signal
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|,
name|uint32_t
name|type
parameter_list|)
block|{
name|u_int
name|win
decl_stmt|;
comment|/* Catch algos which mistakenly leak private signal types. */
name|KASSERT
argument_list|(
operator|(
name|type
operator|&
name|CC_SIGPRIVMASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: congestion signal type 0x%08x is private\n"
operator|,
name|__func__
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|win
operator|=
name|max
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|/
literal|2
operator|/
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
argument_list|,
literal|2
argument_list|)
operator|*
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|CC_NDUPACK
case|:
if|if
condition|(
operator|!
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
name|win
expr_stmt|;
name|ENTER_RECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CC_ECN
case|:
if|if
condition|(
operator|!
name|IN_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
operator|=
name|win
expr_stmt|;
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|win
expr_stmt|;
name|ENTER_CONGRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Perform any necessary tasks before we exit congestion recovery.  */
end_comment

begin_function
specifier|static
name|void
name|newreno_post_recovery
parameter_list|(
name|struct
name|cc_var
modifier|*
name|ccv
parameter_list|)
block|{
name|int
name|pipe
decl_stmt|;
name|pipe
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IN_FASTRECOVERY
argument_list|(
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_flags
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * Fast recovery will conclude after returning from this 		 * function. Window inflation should have left us with 		 * approximately snd_ssthresh outstanding data. But in case we 		 * would be inclined to send a burst, better to do it via the 		 * slow start mechanism. 		 * 		 * XXXLAS: Find a way to do this without needing curack 		 */
if|if
condition|(
name|V_tcp_do_rfc6675_pipe
condition|)
name|pipe
operator|=
name|tcp_compute_pipe
argument_list|(
name|ccv
operator|->
name|ccvc
operator|.
name|tcp
argument_list|)
expr_stmt|;
else|else
name|pipe
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_max
argument_list|)
operator|-
name|ccv
operator|->
name|curack
expr_stmt|;
if|if
condition|(
name|pipe
operator|<
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
condition|)
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|pipe
operator|+
name|CCV
argument_list|(
name|ccv
argument_list|,
name|t_maxseg
argument_list|)
expr_stmt|;
else|else
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_cwnd
argument_list|)
operator|=
name|CCV
argument_list|(
name|ccv
argument_list|,
name|snd_ssthresh
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|DECLARE_CC_MODULE
argument_list|(
name|newreno
argument_list|,
operator|&
name|newreno_cc_algo
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

