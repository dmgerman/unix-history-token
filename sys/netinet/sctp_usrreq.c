begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2011, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2011, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_usrreq.c,v 1.48 2005/03/07 23:26:08 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_decl_stmt
specifier|extern
name|struct
name|sctp_cc_functions
name|sctp_cc_functions
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|sctp_ss_functions
name|sctp_ss_functions
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|sctp_init
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|sb_max_adj
decl_stmt|;
comment|/* Initialize and modify the sysctled variables */
name|sctp_init_sysctls
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|nmbclusters
operator|/
literal|8
operator|)
operator|>
name|SCTP_ASOC_MAX_CHUNKS_ON_QUEUE
condition|)
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_max_chunks_on_queue
argument_list|)
operator|=
operator|(
name|nmbclusters
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* 	 * Allow a user to take no more than 1/2 the number of clusters or 	 * the SB_MAX whichever is smaller for the send window. 	 */
name|sb_max_adj
operator|=
call|(
name|u_long
call|)
argument_list|(
call|(
name|u_quad_t
call|)
argument_list|(
name|SB_MAX
argument_list|)
operator|*
name|MCLBYTES
operator|/
operator|(
name|MSIZE
operator|+
name|MCLBYTES
operator|)
argument_list|)
expr_stmt|;
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_sendspace
argument_list|)
operator|=
name|min
argument_list|(
name|sb_max_adj
argument_list|,
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|nmbclusters
operator|/
literal|2
operator|)
operator|*
name|SCTP_DEFAULT_MAXSEGMENT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now for the recv window, should we take the same amount? or 	 * should I do 1/2 the SB_MAX instead in the SB_MAX min above. For 	 * now I will just copy. 	 */
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_recvspace
argument_list|)
operator|=
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_sendspace
argument_list|)
expr_stmt|;
name|SCTP_BASE_VAR
argument_list|(
name|first_time
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BASE_VAR
argument_list|(
name|sctp_pcb_initialized
argument_list|)
operator|=
literal|0
expr_stmt|;
name|sctp_pcb_init
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PACKET_LOGGING
argument_list|)
name|SCTP_BASE_VAR
argument_list|(
name|packet_log_writers
argument_list|)
operator|=
literal|0
expr_stmt|;
name|SCTP_BASE_VAR
argument_list|(
name|packet_log_end
argument_list|)
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|SCTP_BASE_VAR
argument_list|(
name|packet_log_buffer
argument_list|)
argument_list|,
name|SCTP_PACKET_LOG_SIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|sctp_finish
parameter_list|(
name|void
parameter_list|)
block|{
name|sctp_pcb_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_pathmtu_adjustment
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint16_t
name|nxtsz
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|uint16_t
name|overhead
decl_stmt|;
comment|/* Adjust that too */
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|nxtsz
expr_stmt|;
comment|/* now off to subtract IP_DF flag if needed */
name|overhead
operator|=
name|IP_HDR_SIZE
expr_stmt|;
if|if
condition|(
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
argument_list|)
condition|)
block|{
name|overhead
operator|+=
name|sctp_get_auth_chunk_len
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|+
name|overhead
operator|)
operator|>
name|nxtsz
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|+
name|overhead
operator|)
operator|>
name|nxtsz
condition|)
block|{
comment|/* 			 * For this guy we also mark for immediate resend 			 * since we sent to big of chunk 			 */
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_decrease
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_PMTU
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|chk
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|chk
operator|->
name|whoTo
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
block|}
comment|/* Clear any time so NO RTT is being done */
name|chk
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|sctp_notify_mbuf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|)
block|{
name|struct
name|icmp
modifier|*
name|icmph
decl_stmt|;
name|int
name|totsz
decl_stmt|,
name|tmr_stopped
init|=
literal|0
decl_stmt|;
name|uint16_t
name|nxtsz
decl_stmt|;
comment|/* protection */
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
comment|/* First job is to verify the vtag matches what I would send */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|icmph
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|icmph
operator|->
name|icmp_type
operator|!=
name|ICMP_UNREACH
condition|)
block|{
comment|/* We only care about unreachable */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|icmph
operator|->
name|icmp_code
operator|!=
name|ICMP_UNREACH_NEEDFRAG
condition|)
block|{
comment|/* not a unreachable message due to frag. */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|totsz
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
name|nxtsz
operator|=
name|ntohs
argument_list|(
name|icmph
operator|->
name|icmp_nextmtu
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtsz
operator|==
literal|0
condition|)
block|{
comment|/* 		 * old type router that does not tell us what the next size 		 * mtu is. Rats we will have to guess (in a educated fashion 		 * of course) 		 */
name|nxtsz
operator|=
name|sctp_get_prev_mtu
argument_list|(
name|totsz
argument_list|)
expr_stmt|;
block|}
comment|/* Stop any PMTU timer */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|tmr_stopped
operator|=
literal|1
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust destination size limit */
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
name|nxtsz
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|nxtsz
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|port
condition|)
block|{
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now what about the ep? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|nxtsz
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|nxtsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmr_stopped
condition|)
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_notify
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
comment|/* protection */
name|int
name|reason
decl_stmt|;
name|struct
name|icmp
modifier|*
name|icmph
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
operator|||
operator|(
name|to
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First job is to verify the vtag matches what I would send */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|icmph
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|icmph
operator|->
name|icmp_type
operator|!=
name|ICMP_UNREACH
condition|)
block|{
comment|/* We only care about unreachable */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_NET
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_HOST
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_NET_UNKNOWN
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_HOST_UNKNOWN
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_ISOLATED
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_NET_PROHIB
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_HOST_PROHIB
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_FILTER_PROHIB
operator|)
condition|)
block|{
comment|/* 		 * Hmm reachablity problems we must examine closely. If its 		 * not reachable, we may have lost a network. Or if there is 		 * NO protocol at the other end named SCTP. well we consider 		 * it a OOTB abort. 		 */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
comment|/* Ok that destination is NOT reachable */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_FAILED_THRESHOLD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_PROTOCOL
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp_code
operator|==
name|ICMP_UNREACH_PORT
operator|)
condition|)
block|{
comment|/* 		 * Here the peer is either playing tricks on us, including 		 * an address that belongs to someone who does not support 		 * SCTP OR was a userland implementation that shutdown and 		 * now is dead. In either case treat it like a OOTB abort 		 * with no TCB 		 */
name|reason
operator|=
name|SCTP_PEER_FAULTY
expr_stmt|;
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
name|reason
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* SCTP_TCB_UNLOCK(stcb); MT: I think this is not needed. */
endif|#
directive|endif
comment|/* no need to unlock here, since the TCB is gone */
block|}
else|else
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
name|void
name|sctp_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|sa
parameter_list|,
name|vip
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|void
modifier|*
name|vip
decl_stmt|;
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|vip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
comment|/* FIX, for non-bsd is this right? */
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|ip
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cmd
operator|>=
name|PRC_NCMDS
operator|||
name|inetctlerrmap
index|[
name|cmd
index|]
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ip
condition|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
name|to
decl_stmt|,
name|from
decl_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|.
name|sin_family
operator|=
name|to
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|from
operator|.
name|sin_len
operator|=
name|to
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|from
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|to
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|to
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
comment|/* 		 * 'to' holds the dest of the packet that failed to be sent. 		 * 'from' holds our local endpoint address. Thus we reverse 		 * the to and the from in the lookup. 		 */
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|to
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
operator|&&
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|!=
name|PRC_MSGSIZE
condition|)
block|{
name|sctp_notify
argument_list|(
name|inp
argument_list|,
name|ip
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|to
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* handle possible ICMP size messages */
name|sctp_notify_mbuf
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ip
argument_list|,
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sctp_getcred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|xucred
name|xuc
decl_stmt|;
name|struct
name|sockaddr_in
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
comment|/* FIX, for non-bsd is this right? */
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|req
operator|->
name|td
argument_list|,
name|PRIV_NETINET_GETCRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|sintosa
argument_list|(
operator|&
name|addrs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sintosa
argument_list|(
operator|&
name|addrs
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
operator|||
name|inp
operator|==
name|NULL
operator|||
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|cred_can_cont
goto|;
block|}
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 	 * We use the write lock here, only since in the error leg we need 	 * it. If we used RLOCK, then we would have to 	 * wlock/decr/unlock/rlock. Which in theory could create a hole. 	 * Better to use higher wlock. 	 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|cred_can_cont
label|:
name|error
operator|=
name|cr_canseesocket
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cru2x
argument_list|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_cred
argument_list|,
operator|&
name|xuc
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xuc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xucred
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|getcred
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sctp_getcred
argument_list|,
literal|"S,ucred"
argument_list|,
literal|"Get the ucred of a SCTP connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|void
name|sctp_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_AFTER_CMPSET_OFCLOSE
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now null out the reference, we are completely detached. */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
name|SCTP_UNUSED
parameter_list|,
name|struct
name|thread
modifier|*
name|p
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|ip_inp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|vrf_id
init|=
name|SCTP_DEFAULT_VRFID
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
name|uint32_t
name|flags
decl_stmt|;
endif|#
directive|endif
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|SCTP_SORESERVE
argument_list|(
name|so
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_sendspace
argument_list|)
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_recvspace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
block|}
name|error
operator|=
name|sctp_inpcb_alloc
argument_list|(
name|so
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_BOUND_V6
expr_stmt|;
comment|/* I'm not v6! */
name|ip_inp
operator|=
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
name|ip_inp
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|ip_inp
operator|->
name|inp_ip_ttl
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ip_defttl
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
name|error
operator|=
name|ipsec_init_policy
argument_list|(
name|so
argument_list|,
operator|&
name|ip_inp
operator|->
name|inp_sp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|15
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_AFTER_CMPSET_OFCLOSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|try_again
goto|;
block|}
else|else
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|addr
operator|&&
name|addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
comment|/* must be a v4 address! */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|addr
operator|&&
operator|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|sctp_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Inform all the lower layer assoc that we are done. 	 */
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_linger
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_AFTER_CMPSET_OFCLOSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|14
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_GRACEFUL_CLOSE
argument_list|,
name|SCTP_CALLED_AFTER_CMPSET_OFCLOSE
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The socket is now detached, no matter what the state of 		 * the SCTP association. 		 */
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now null out the reference, we are completely detached. */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_function_decl
name|int
name|sctp_sendm
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|sctp_sendm
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Got to have an to address if we are NOT a connected socket */
if|if
condition|(
operator|(
name|addr
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|)
condition|)
block|{
goto|goto
name|connected_type
goto|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EDESTADDRREQ
argument_list|)
expr_stmt|;
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
comment|/* must be a v4 address! */
name|SCTP_LTRACE_ERR_RET_PKT
argument_list|(
name|m
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EDESTADDRREQ
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|connected_type
label|:
comment|/* now what about control */
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|control
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"huh? control set?\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|inp
operator|->
name|control
argument_list|)
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|inp
operator|->
name|control
operator|=
name|control
expr_stmt|;
block|}
comment|/* Place the data */
if|if
condition|(
name|inp
operator|->
name|pkt
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|inp
operator|->
name|pkt_last
argument_list|)
operator|=
name|m
expr_stmt|;
name|inp
operator|->
name|pkt_last
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|pkt_last
operator|=
name|inp
operator|->
name|pkt
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
comment|/* FreeBSD uses a flag passed */
operator|(
operator|(
name|flags
operator|&
name|PRUS_MORETOCOME
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * note with the current version this code will only be used 		 * by OpenBSD-- NetBSD, FreeBSD, and MacOS have methods for 		 * re-defining sosend to use the sctp_sosend. One can 		 * optionally switch back to this code (by changing back the 		 * definitions) but this is not advisable. This code is used 		 * by FreeBSD when sending a file with sendfile() though. 		 */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_output
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|pkt
argument_list|,
name|addr
argument_list|,
name|inp
operator|->
name|control
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|inp
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
condition|)
block|{
comment|/* No connection */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* We are about to be freed, out of here */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_linger
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
comment|/* Left with Data unread */
name|struct
name|mbuf
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"disconnect does an abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|err
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
comment|/* No unlock tcb assoc is gone */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* there is nothing queued to send, so done */
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* only send SHUTDOWN 1st time thru */
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * we still got (or just got) data to send, 				 * so set SHUTDOWN_PENDING 				 */
comment|/* 				 * XXX sockets draft says that SCTP_EOF 				 * should be sent with no data. currently, 				 * we will allow user data to be sent first 				 * and move to SHUTDOWN-PENDING 				 */
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* Locked to send out the data */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Error, sp is NULL, locked on sending is non-null strm:%d\n"
argument_list|,
name|asoc
operator|->
name|locked_on_sending
operator|->
name|stream_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_anyway
label|:
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"disconnect does an abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_4
expr_stmt|;
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CLOSING
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|soisdisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* not reached */
block|}
else|else
block|{
comment|/* UDP model does not support this */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_flush
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|how
parameter_list|)
block|{
comment|/* 	 * We will just clear out the values and let subsequent close clear 	 * out the data, if any. Note if the user did a shutdown(SHUT_RD) 	 * they will not be able to read the data, the socket will block 	 * that from happening. 	 */
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* For the 1 to many model this does nothing */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|how
operator|==
name|PRU_FLUSH_RD
operator|)
operator|||
operator|(
name|how
operator|==
name|PRU_FLUSH_RDWR
operator|)
condition|)
block|{
comment|/* 		 * First make sure the sb will be happy, we don't use these 		 * except maybe the count 		 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_READ_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_SOCKET_CANT_READ
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|how
operator|==
name|PRU_FLUSH_WR
operator|)
operator|||
operator|(
name|how
operator|==
name|PRU_FLUSH_RDWR
operator|)
condition|)
block|{
comment|/* 		 * First make sure the sb will be happy, we don't use these 		 * except maybe the count 		 */
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mbcnt
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* For UDP model this is a invalid call */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
comment|/* Restore the flags that the soshutdown took away. */
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&=
operator|~
name|SBS_CANTRCVMORE
expr_stmt|;
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* This proc will wakeup for read and do nothing (I hope) */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* 	 * Ok if we reach here its the TCP model and it is either a SHUT_WR 	 * or SHUT_RDWR. This means we put the shutdown flag against it. 	 */
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
if|if
condition|(
operator|(
name|so
operator|->
name|so_state
operator|&
operator|(
name|SS_ISCONNECTED
operator||
name|SS_ISCONNECTING
operator||
name|SS_ISDISCONNECTING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Ok we hit the case that the shutdown call was 			 * made after an abort or something. Nothing to do 			 * now. 			 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
comment|/* there is nothing queued to send, so I'm done... */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* only send SHUTDOWN the first time through */
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_SENT
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * we still got (or just got) data to send, so set 			 * SHUTDOWN_PENDING 			 */
name|struct
name|sctp_nets
modifier|*
name|netp
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|alternate
expr_stmt|;
block|}
else|else
block|{
name|netp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|netp
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* Locked to send out the data */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Error, sp is NULL, locked on sending is non-null strm:%d\n"
argument_list|,
name|asoc
operator|->
name|locked_on_sending
operator|->
name|stream_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_anyway
label|:
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* Fill in the user initiated abort */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|SCTP_PANIC_ON_ABORT
argument_list|)
name|panic
argument_list|(
literal|"shutdown does an abort"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_6
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
goto|goto
name|skip_unlock
goto|;
block|}
else|else
block|{
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CLOSING
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|skip_unlock
label|:
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * copies a "user" presentable address and removes embedded scope, etc.  * returns 0 on success, 1 on error  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_fill_user_address
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|ss
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|lsa6
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sctp_recover_scope
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
argument_list|,
operator|&
name|lsa6
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|memcpy
argument_list|(
name|ss
argument_list|,
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: assumes addr lock is held  */
end_comment

begin_function
specifier|static
name|size_t
name|sctp_fill_up_addresses_vrf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|sas
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|int
name|loopback_scope
decl_stmt|,
name|ipv4_local_scope
decl_stmt|,
name|local_scope
decl_stmt|,
name|site_scope
decl_stmt|;
name|size_t
name|actual
decl_stmt|;
name|int
name|ipv4_addr_legal
decl_stmt|,
name|ipv6_addr_legal
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|actual
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
literal|0
condition|)
return|return
operator|(
name|actual
operator|)
return|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* Turn on all the appropriate scope */
name|loopback_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
expr_stmt|;
name|ipv4_local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
expr_stmt|;
name|local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
expr_stmt|;
name|site_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn on ALL scope, since we look at the EP */
name|loopback_scope
operator|=
name|ipv4_local_scope
operator|=
name|local_scope
operator|=
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
name|ipv4_addr_legal
operator|=
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* Skip loopback if loopback_scope not set */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* 					 * For the BOUND-ALL case, the list 					 * associated with a TCB is Always 					 * considered a reverse list.. i.e. 					 * it lists addresses that are NOT 					 * part of the association. If this 					 * is one of those we must skip it. 					 */
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* 							 * we skip 							 * unspecifed 							 * addresses 							 */
continue|continue;
block|}
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
block|{
name|in6_sin_2_v4mapsin6
argument_list|(
name|sin
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
operator|)
expr_stmt|;
name|actual
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|memcpy
argument_list|(
name|sas
argument_list|,
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
operator|)
expr_stmt|;
name|actual
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
if|if
condition|(
name|actual
operator|>=
name|limit
condition|)
block|{
return|return
operator|(
name|actual
operator|)
return|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 							 * we skip 							 * unspecifed 							 * addresses 							 */
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_scope
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|!=
literal|0
condition|)
comment|/* 									 *  									 * bad 									 *  									 * li 									 * nk 									 *  									 * loc 									 * al 									 *  									 * add 									 * re 									 * ss 									 * */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|memcpy
argument_list|(
name|sas
argument_list|,
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
operator|)
expr_stmt|;
name|actual
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|>=
name|limit
condition|)
block|{
return|return
operator|(
name|actual
operator|)
return|;
block|}
block|}
else|else
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|sctp_fill_user_address
argument_list|(
name|sas
argument_list|,
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
condition|)
continue|continue;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_len
operator|)
expr_stmt|;
name|actual
operator|+=
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
if|if
condition|(
name|actual
operator|>=
name|limit
condition|)
block|{
return|return
operator|(
name|actual
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|actual
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|sctp_fill_up_addresses
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|sas
parameter_list|)
block|{
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
comment|/* fill up addresses for the endpoint's default vrf */
name|size
operator|=
name|sctp_fill_up_addresses_vrf
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|limit
argument_list|,
name|sas
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: assumes addr lock is held  */
end_comment

begin_function
specifier|static
name|int
name|sctp_count_max_addresses_vrf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
comment|/* 	 * In both sub-set bound an bound_all cases we return the MAXIMUM 	 * number of addresses that you COULD get. In reality the sub-set 	 * bound may have an exclusion list for a given TCB OR in the 	 * bound-all case a TCB may NOT include the loopback or other 	 * addresses as well. 	 */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
comment|/* Count them if they are the right type */
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
switch|switch
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_max_addresses
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
comment|/* count addresses for the endpoint's default VRF */
name|cnt
operator|=
name|sctp_count_max_addresses_vrf
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_do_connect_x
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
name|optsize
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|creat_lock_on
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|num_v6
init|=
literal|0
decl_stmt|,
name|num_v4
init|=
literal|0
decl_stmt|,
modifier|*
name|totaddrp
decl_stmt|,
name|totaddr
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|int
name|bad_addresses
init|=
literal|0
decl_stmt|;
name|sctp_assoc_t
modifier|*
name|a_id
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_PCB1
argument_list|,
literal|"Connectx called\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|&&
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EALREADY
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|creat_lock_on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|totaddrp
operator|=
operator|(
name|int
operator|*
operator|)
name|optval
expr_stmt|;
name|totaddr
operator|=
operator|*
name|totaddrp
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|totaddrp
operator|+
literal|1
operator|)
expr_stmt|;
name|stcb
operator|=
name|sctp_connectx_helper_find
argument_list|(
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|totaddr
argument_list|,
operator|&
name|num_v4
argument_list|,
operator|&
name|num_v6
argument_list|,
operator|&
name|error
argument_list|,
operator|(
name|optsize
operator|-
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
argument_list|,
operator|&
name|bad_addresses
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|||
name|bad_addresses
condition|)
block|{
comment|/* Already have or am bring up an association */
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|creat_lock_on
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bad_addresses
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EALREADY
argument_list|)
expr_stmt|;
name|error
operator|=
name|EALREADY
expr_stmt|;
block|}
goto|goto
name|out_now
goto|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_v6
operator|>
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
operator|(
name|num_v4
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
comment|/* 			 * if IPV6_V6ONLY flag, ignore connections destined 			 * to a v4 addr or v4-mapped addr 			 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* Bind a ephemeral port */
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out_now
goto|;
block|}
block|}
comment|/* FIX ME: do we want to pass in a vrf on the connect call? */
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
comment|/* We are GOOD to go */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Gak! no memory */
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_COOKIE_WAIT
argument_list|)
expr_stmt|;
comment|/* move to second address */
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
operator|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|sctp_connectx_helper_add
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
operator|(
name|totaddr
operator|-
literal|1
operator|)
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
comment|/* Fill in the return id */
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCBFREE_FORCE
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|a_id
operator|=
operator|(
name|sctp_assoc_t
operator|*
operator|)
name|optval
expr_stmt|;
operator|*
name|a_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* initialize authentication parameters for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
comment|/* doing delayed connection */
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|=
literal|1
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|out_now
label|:
if|if
condition|(
name|creat_lock_on
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SCTP_FIND_STCB
parameter_list|(
name|inp
parameter_list|,
name|stcb
parameter_list|,
name|assoc_id
parameter_list|)
value|{ \ 	if ((inp->sctp_flags& SCTP_PCB_FLAGS_TCPTYPE) ||\ 	    (inp->sctp_flags& SCTP_PCB_FLAGS_IN_TCPPOOL)) { \ 		SCTP_INP_RLOCK(inp); \ 		stcb = LIST_FIRST(&inp->sctp_asoc_list); \ 		if (stcb) { \ 			SCTP_TCB_LOCK(stcb); \                 } \ 		SCTP_INP_RUNLOCK(inp); \ 	} else if (assoc_id> SCTP_ALL_ASSOC) { \ 		stcb = sctp_findassociation_ep_asocid(inp, assoc_id, 1); \ 		if (stcb == NULL) { \ 		        SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, ENOENT); \ 			error = ENOENT; \ 			break; \ 		} \ 	} else { \ 		stcb = NULL; \         } \   }
end_define

begin_define
define|#
directive|define
name|SCTP_CHECK_AND_CAST
parameter_list|(
name|destp
parameter_list|,
name|srcp
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|)
value|{\ 	if (size< sizeof(type)) { \ 		SCTP_LTRACE_ERR_RET(inp, NULL, NULL, SCTP_FROM_SCTP_USRREQ, EINVAL); \ 		error = EINVAL; \ 		break; \ 	} else { \ 		destp = (type *)srcp; \ 	} \       }
end_define

begin_function
specifier|static
name|int
name|sctp_getopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|optname
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
modifier|*
name|optsize
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|optval
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_NODELAY
case|:
case|case
name|SCTP_AUTOCLOSE
case|:
case|case
name|SCTP_EXPLICIT_EOR
case|:
case|case
name|SCTP_AUTO_ASCONF
case|:
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NO_FRAGMENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTO_ASCONF
case|:
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* only valid for bound all sockets */
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|flags_out
goto|;
block|}
break|break;
case|case
name|SCTP_EXPLICIT_EOR
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NODELAY
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTOCLOSE
case|:
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
name|val
operator|=
name|TICKS_TO_SEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|auto_close_time
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOPROTOOPT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
comment|/* end switch (sopt->sopt_name) */
if|if
condition|(
operator|*
name|optsize
operator|<
sizeof|sizeof
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|flags_out
label|:
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* return the option value */
operator|*
operator|(
name|int
operator|*
operator|)
name|optval
operator|=
name|val
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_PACKET_LOG
case|:
block|{
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
name|uint8_t
modifier|*
name|target
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|target
argument_list|,
name|optval
argument_list|,
name|uint8_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sctp_copy_out_packet_log
argument_list|(
name|target
argument_list|,
operator|(
name|int
operator|)
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
name|ret
expr_stmt|;
else|#
directive|else
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
case|case
name|SCTP_REUSE_PORT
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
operator|)
condition|)
block|{
comment|/* Can't do this for a 1-m socket */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_PARTIAL_DELIVERY_POINT
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|partial_delivery_point
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_FRAGMENT_INTERLEAVE
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
condition|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
condition|)
block|{
operator|*
name|value
operator|=
name|SCTP_FRAG_LEVEL_2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|value
operator|=
name|SCTP_FRAG_LEVEL_1
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|value
operator|=
name|SCTP_FRAG_LEVEL_0
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_CMT_ON_OFF
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_cmt_on_off
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_PLUGGABLE_CC
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|congestion_control_module
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_cc_module
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_CC_OPTION
case|:
block|{
name|struct
name|sctp_cc_option
modifier|*
name|cc_opt
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|cc_opt
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_cc_option
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|cc_opt
operator|->
name|aid_value
operator|.
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_socket_option
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_socket_option
call|)
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
name|cc_opt
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cc_option
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_PLUGGABLE_SS
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|stream_scheduling_module
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_ss_module
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_SS_VALUE
case|:
block|{
name|struct
name|sctp_stream_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_stream_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_get_value
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|av
operator|->
name|stream_id
index|]
argument_list|,
operator|&
name|av
operator|->
name|stream_value
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_value
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Can't get stream value without 				 * association 				 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_ADDR_LEN
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|av
operator|->
name|assoc_value
operator|==
name|AF_INET
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|av
operator|->
name|assoc_value
operator|==
name|AF_INET6
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_ASSOC_NUMBER
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|,
name|cnt
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|cnt
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_ASSOC_ID_LIST
case|:
block|{
name|struct
name|sctp_assoc_ids
modifier|*
name|ids
decl_stmt|;
name|unsigned
name|int
name|at
decl_stmt|,
name|limit
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ids
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_ids
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|at
operator|=
literal|0
expr_stmt|;
name|limit
operator|=
operator|(
operator|*
name|optsize
operator|-
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|sctp_assoc_t
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
if|if
condition|(
name|at
operator|<
name|limit
condition|)
block|{
name|ids
operator|->
name|gaids_assoc_id
index|[
name|at
operator|++
index|]
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ids
operator|->
name|gaids_number_of_ids
operator|=
name|at
expr_stmt|;
operator|*
name|optsize
operator|=
operator|(
operator|(
name|at
operator|*
sizeof|sizeof
argument_list|(
name|sctp_assoc_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_CONTEXT
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_context
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_VRF_ID
case|:
block|{
name|uint32_t
modifier|*
name|default_vrfid
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|default_vrfid
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|default_vrfid
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_ASOC_VRF
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|id
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|id
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|id
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|id
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_VRF_IDS
case|:
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_NONCE_VALUES
case|:
block|{
name|struct
name|sctp_get_nonce_values
modifier|*
name|gnv
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|gnv
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_get_nonce_values
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|gnv
operator|->
name|gn_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|gnv
operator|->
name|gn_peers_tag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
name|gnv
operator|->
name|gn_local_tag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_get_nonce_values
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_DELAYED_SACK
case|:
block|{
name|struct
name|sctp_sack_info
modifier|*
name|sack
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sack
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sack_info
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sack
operator|->
name|sack_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sack
operator|->
name|sack_delay
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
expr_stmt|;
name|sack
operator|->
name|sack_freq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|sack
operator|->
name|sack_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack_delay
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
argument_list|)
expr_stmt|;
name|sack
operator|->
name|sack_freq
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_sack_freq
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_info
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_SNDBUF_USE
case|:
block|{
name|struct
name|sctp_sockstat
modifier|*
name|ss
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ss
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sockstat
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ss
operator|->
name|ss_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|ss
operator|->
name|ss_total_sndbuf
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
name|ss
operator|->
name|ss_total_recv_buf
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|size_on_reasm_queue
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|size_on_all_streams
operator|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sockstat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_MAX_BURST
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|max_burst
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_burst
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_MAXSEG
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|int
name|ovh
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_frag_point
operator|>=
name|SCTP_DEFAULT_MAXSEGMENT
condition|)
name|av
operator|->
name|assoc_value
operator|=
literal|0
expr_stmt|;
else|else
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_frag_point
operator|-
name|ovh
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_STAT_LOG
case|:
name|error
operator|=
name|sctp_fill_stat_log
argument_list|(
name|optval
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_EVENTS
case|:
block|{
name|struct
name|sctp_event_subscribe
modifier|*
name|events
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|events
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_event_subscribe
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|events
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_event_subscribe
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_data_io_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_association_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_address_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_send_failure_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
condition|)
name|events
operator|->
name|sctp_peer_error_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_shutdown_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_partial_delivery_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_adaptation_layer_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_authentication_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_sender_dry_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_stream_reset_event
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_event_subscribe
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_ADAPTATION_LAYER
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_SET_INITIAL_DBG_SEQ
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_sequence_debug
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_LOCAL_ADDR_SIZE
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|sctp_count_max_addresses
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_REMOTE_ADDR_SIZE
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
comment|/* FIXME MT: change to sctp_assoc_value? */
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_assoc_t
operator|)
operator|*
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Count the sizes */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_PEER_ADDRESSES
case|:
comment|/* 		 * Get the address information, an array is passed in to 		 * fill up we pack it. 		 */
block|{
name|size_t
name|cpsz
decl_stmt|,
name|left
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|sas
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_getaddresses
modifier|*
name|saddr
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|saddr
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|saddr
operator|->
name|sget_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|left
operator|=
operator|(
operator|*
name|optsize
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|saddr
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
condition|)
block|{
name|cpsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|cpsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|cpsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|cpsz
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|cpsz
operator|==
literal|0
condition|)
block|{
break|break;
block|}
if|if
condition|(
name|left
operator|<
name|cpsz
condition|)
block|{
comment|/* not enough room. */
break|break;
block|}
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
comment|/* Must map the address */
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|memcpy
argument_list|(
name|sas
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|cpsz
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
block|}
endif|#
directive|endif
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
name|cpsz
operator|)
expr_stmt|;
name|left
operator|-=
name|cpsz
expr_stmt|;
operator|*
name|optsize
operator|+=
name|cpsz
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_LOCAL_ADDRESSES
case|:
block|{
name|size_t
name|limit
decl_stmt|,
name|actual
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|sas
decl_stmt|;
name|struct
name|sctp_getaddresses
modifier|*
name|saddr
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|saddr
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|saddr
operator|->
name|sget_assoc_id
argument_list|)
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|saddr
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|limit
operator|=
operator|*
name|optsize
operator|-
sizeof|sizeof
argument_list|(
name|sctp_assoc_t
argument_list|)
expr_stmt|;
name|actual
operator|=
name|sctp_fill_up_addresses
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|limit
argument_list|,
name|sas
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|+
name|actual
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_PEER_ADDR_PARAMS
case|:
block|{
name|struct
name|sctp_paddrparams
modifier|*
name|paddrp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|paddrp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrparams
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|paddrp
operator|->
name|spp_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* Applies to the specific association */
name|paddrp
operator|->
name|spp_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|int
name|ovh
decl_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
name|paddrp
operator|->
name|spp_hbinterval
operator|=
name|net
operator|->
name|heart_beat_delay
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
name|net
operator|->
name|failure_threshold
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmtu
operator|=
name|net
operator|->
name|mtu
operator|-
name|ovh
expr_stmt|;
comment|/* get flags for HB */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_DISABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_ENABLE
expr_stmt|;
block|}
comment|/* get flags for PMTU */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NO_PMTUD
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_DISABLE
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|dscp
operator|&
literal|0x01
condition|)
block|{
name|paddrp
operator|->
name|spp_dscp
operator|=
name|net
operator|->
name|dscp
operator|&
literal|0xfc
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_DSCP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|net
operator|->
name|flowlabel
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|=
name|net
operator|->
name|flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV6_FLOWLABEL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 					 * No destination so return default 					 * value 					 */
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmtu
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|default_dscp
operator|&
literal|0x01
condition|)
block|{
name|paddrp
operator|->
name|spp_dscp
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_dscp
operator|&
literal|0xfc
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_DSCP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
operator|&
literal|0x80000000
condition|)
block|{
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV6_FLOWLABEL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* default settings should be these */
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_DISABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_ENABLE
expr_stmt|;
block|}
if|if
condition|(
name|sctp_stcb_is_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DO_NOT_PMTUD
argument_list|)
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_DISABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_ENABLE
expr_stmt|;
block|}
name|paddrp
operator|->
name|spp_hbinterval
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
expr_stmt|;
block|}
name|paddrp
operator|->
name|spp_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|paddrp
operator|->
name|spp_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
comment|/* Use endpoint defaults */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
expr_stmt|;
name|paddrp
operator|->
name|spp_hbinterval
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
argument_list|)
expr_stmt|;
name|paddrp
operator|->
name|spp_assoc_id
operator|=
name|SCTP_FUTURE_ASSOC
expr_stmt|;
comment|/* get inp's default */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|default_dscp
operator|&
literal|0x01
condition|)
block|{
name|paddrp
operator|->
name|spp_dscp
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_dscp
operator|&
literal|0xfc
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_DSCP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV6_FLOWLABEL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* can't return this */
name|paddrp
operator|->
name|spp_pathmtu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_DISABLE
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_NOT_PMTUD
argument_list|)
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_DISABLE
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddrparams
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_GET_PEER_ADDR_INFO
case|:
block|{
name|struct
name|sctp_paddrinfo
modifier|*
name|paddri
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|paddri
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|paddri
operator|->
name|spinfo_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddri
operator|->
name|spinfo_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddri
operator|->
name|spinfo_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|net
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* It's unconfirmed */
name|paddri
operator|->
name|spinfo_state
operator|=
name|SCTP_UNCONFIRMED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
comment|/* It's active */
name|paddri
operator|->
name|spinfo_state
operator|=
name|SCTP_ACTIVE
expr_stmt|;
block|}
else|else
block|{
comment|/* It's inactive */
name|paddri
operator|->
name|spinfo_state
operator|=
name|SCTP_INACTIVE
expr_stmt|;
block|}
name|paddri
operator|->
name|spinfo_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|paddri
operator|->
name|spinfo_srtt
operator|=
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
expr_stmt|;
name|paddri
operator|->
name|spinfo_rto
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
name|paddri
operator|->
name|spinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|paddri
operator|->
name|spinfo_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddrinfo
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_PCB_STATUS
case|:
block|{
name|struct
name|sctp_pcbinfo
modifier|*
name|spcb
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|spcb
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_pcbinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|sctp_fill_pcbinfo
argument_list|(
name|spcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pcbinfo
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_STATUS
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_status
modifier|*
name|sstat
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sstat
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_status
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sstat
operator|->
name|sstat_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * I think passing the state is fine since 			 * sctp_constants.h will be available to the user 			 * land. 			 */
name|sstat
operator|->
name|sstat_state
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|state
expr_stmt|;
name|sstat
operator|->
name|sstat_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sstat
operator|->
name|sstat_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
name|sstat
operator|->
name|sstat_unackdata
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
expr_stmt|;
comment|/* 			 * We can't include chunks that have been passed to 			 * the socket layer. Only things in queue. 			 */
name|sstat
operator|->
name|sstat_penddata
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|cnt_on_reasm_queue
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|cnt_on_all_streams
operator|)
expr_stmt|;
name|sstat
operator|->
name|sstat_instrms
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
expr_stmt|;
name|sstat
operator|->
name|sstat_outstrms
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
name|sstat
operator|->
name|sstat_fragmentation_point
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_address
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_address
operator|)
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
comment|/* 			 * Again the user can get info from sctp_constants.h 			 * for what the state of the network is. 			 */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* It's unconfirmed */
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_state
operator|=
name|SCTP_UNCONFIRMED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
comment|/* It's active */
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_state
operator|=
name|SCTP_ACTIVE
expr_stmt|;
block|}
else|else
block|{
comment|/* It's inactive */
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_state
operator|=
name|SCTP_INACTIVE
expr_stmt|;
block|}
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_srtt
operator|=
name|net
operator|->
name|lastsa
operator|>>
name|SCTP_RTT_SHIFT
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_rto
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_status
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_RTOINFO
case|:
block|{
name|struct
name|sctp_rtoinfo
modifier|*
name|srto
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|srto
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_rtoinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|srto
operator|->
name|srto_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|srto
operator|->
name|srto_initial
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
name|srto
operator|->
name|srto_max
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
name|srto
operator|->
name|srto_min
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|srto
operator|->
name|srto_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|srto
operator|->
name|srto_initial
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_rto
expr_stmt|;
name|srto
operator|->
name|srto_max
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
expr_stmt|;
name|srto
operator|->
name|srto_min
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_rtoinfo
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_TIMEOUTS
case|:
block|{
name|struct
name|sctp_timeouts
modifier|*
name|stimo
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|stimo
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_timeouts
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|stimo
operator|->
name|stimo_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stimo
operator|->
name|stimo_init
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timoinit
expr_stmt|;
name|stimo
operator|->
name|stimo_data
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timodata
expr_stmt|;
name|stimo
operator|->
name|stimo_sack
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timosack
expr_stmt|;
name|stimo
operator|->
name|stimo_shutdown
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timoshutdown
expr_stmt|;
name|stimo
operator|->
name|stimo_heartbeat
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timoheartbeat
expr_stmt|;
name|stimo
operator|->
name|stimo_cookie
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timocookie
expr_stmt|;
name|stimo
operator|->
name|stimo_shutdownack
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|timoshutdownack
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_timeouts
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_ASSOCINFO
case|:
block|{
name|struct
name|sctp_assocparams
modifier|*
name|sasoc
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sasoc
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assocparams
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sasoc
operator|->
name|sasoc_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sasoc
operator|->
name|sasoc_cookie_life
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cookie_life
argument_list|)
expr_stmt|;
name|sasoc
operator|->
name|sasoc_asocmaxrxt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
expr_stmt|;
name|sasoc
operator|->
name|sasoc_number_peer_destinations
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|numnets
expr_stmt|;
name|sasoc
operator|->
name|sasoc_peer_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
name|sasoc
operator|->
name|sasoc_local_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|sasoc
operator|->
name|sasoc_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sasoc
operator|->
name|sasoc_cookie_life
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
argument_list|)
expr_stmt|;
name|sasoc
operator|->
name|sasoc_asocmaxrxt
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_send_times
expr_stmt|;
name|sasoc
operator|->
name|sasoc_number_peer_destinations
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_peer_rwnd
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_local_rwnd
operator|=
name|sbspace
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assocparams
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_DEFAULT_SEND_PARAM
case|:
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|s_info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|s_info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sndrcvinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|s_info
operator|->
name|sinfo_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|memcpy
argument_list|(
name|s_info
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|def_send
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|def_send
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|s_info
operator|->
name|sinfo_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s_info
argument_list|,
operator|&
name|inp
operator|->
name|def_send
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|def_send
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndrcvinfo
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_INITMSG
case|:
block|{
name|struct
name|sctp_initmsg
modifier|*
name|sinit
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sinit
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_initmsg
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sinit
operator|->
name|sinit_num_ostreams
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
name|sinit
operator|->
name|sinit_max_instreams
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
expr_stmt|;
name|sinit
operator|->
name|sinit_max_attempts
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_init_times
expr_stmt|;
name|sinit
operator|->
name|sinit_max_init_timeo
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_init_rto_max
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_initmsg
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_PRIMARY_ADDR
case|:
comment|/* we allow a "get" operation on this */
block|{
name|struct
name|sctp_setprim
modifier|*
name|ssp
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ssp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setprim
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ssp
operator|->
name|ssp_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* simply copy out the sockaddr_storage... */
name|int
name|len
decl_stmt|;
name|len
operator|=
operator|*
name|optsize
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_len
condition|)
name|len
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ssp
operator|->
name|ssp_addr
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_setprim
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_HMAC_IDENT
case|:
block|{
name|struct
name|sctp_hmacalgo
modifier|*
name|shmac
decl_stmt|;
name|sctp_hmaclist_t
modifier|*
name|hmaclist
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|shmac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_hmacalgo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hmaclist
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
expr_stmt|;
if|if
condition|(
name|hmaclist
operator|==
name|NULL
condition|)
block|{
comment|/* no HMACs to return */
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|shmac
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* is there room for all of the hmac ids? */
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|shmac
argument_list|)
operator|+
operator|(
name|hmaclist
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|shmac
operator|->
name|shmac_idents
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
operator|*
name|optsize
argument_list|)
operator|<
name|size
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* copy in the list */
name|shmac
operator|->
name|shmac_number_of_idents
operator|=
name|hmaclist
operator|->
name|num_algo
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hmaclist
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
name|shmac
operator|->
name|shmac_idents
index|[
name|i
index|]
operator|=
name|hmaclist
operator|->
name|hmac
index|[
name|i
index|]
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
name|size
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_AUTH_ACTIVE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|scact
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|scact
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|scact
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* get the active key on the assoc */
name|scact
operator|->
name|scact_keynumber
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|active_keyid
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|scact
operator|->
name|scact_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
comment|/* get the endpoint active key */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|scact
operator|->
name|scact_keynumber
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authkeyid
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_LOCAL_AUTH_CHUNKS
case|:
block|{
name|struct
name|sctp_authchunks
modifier|*
name|sac
decl_stmt|;
name|sctp_auth_chklist_t
modifier|*
name|chklist
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authchunks
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sac
operator|->
name|gauth_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* get off the assoc */
name|chklist
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
expr_stmt|;
comment|/* is there enough space? */
name|size
operator|=
name|sctp_auth_get_chklist_size
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy in the chunks */
operator|(
name|void
operator|)
name|sctp_serialize_auth_chunks
argument_list|(
name|chklist
argument_list|,
name|sac
operator|->
name|gauth_chunks
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|sac
operator|->
name|gauth_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
comment|/* get off the endpoint */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|chklist
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
expr_stmt|;
comment|/* is there enough space? */
name|size
operator|=
name|sctp_auth_get_chklist_size
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy in the chunks */
operator|(
name|void
operator|)
name|sctp_serialize_auth_chunks
argument_list|(
name|chklist
argument_list|,
name|sac
operator|->
name|gauth_chunks
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_PEER_AUTH_CHUNKS
case|:
block|{
name|struct
name|sctp_authchunks
modifier|*
name|sac
decl_stmt|;
name|sctp_auth_chklist_t
modifier|*
name|chklist
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authchunks
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sac
operator|->
name|gauth_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* get off the assoc */
name|chklist
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
expr_stmt|;
comment|/* is there enough space? */
name|size
operator|=
name|sctp_auth_get_chklist_size
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy in the chunks */
operator|(
name|void
operator|)
name|sctp_serialize_auth_chunks
argument_list|(
name|chklist
argument_list|,
name|sac
operator|->
name|gauth_chunks
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_EVENT
case|:
block|{
name|struct
name|sctp_event
modifier|*
name|event
decl_stmt|;
name|uint32_t
name|event_type
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|event
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_event
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event
operator|->
name|se_assoc_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|se_type
condition|)
block|{
case|case
name|SCTP_ASSOC_CHANGE
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_PEER_ADDR_CHANGE
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVPADDREVNT
expr_stmt|;
break|break;
case|case
name|SCTP_REMOTE_ERROR
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVPEERERR
expr_stmt|;
break|break;
case|case
name|SCTP_SEND_FAILED
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_SHUTDOWN_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_ADAPTATION_INDICATION
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_PARTIAL_DELIVERY_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_PDAPIEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHENTICATION_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_AUTHEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_STREAM_RESET_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_SENDER_DRY_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_DRYEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFICATIONS_STOPPED_EVENT
case|:
name|event_type
operator|=
literal|0
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTSUP
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
default|default:
name|event_type
operator|=
literal|0
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|event_type
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
name|event
operator|->
name|se_on
operator|=
name|sctp_stcb_is_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|event
operator|->
name|se_on
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_event
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_RECVRCVINFO
case|:
block|{
name|int
name|onoff
decl_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|onoff
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* return the option value */
operator|*
operator|(
name|int
operator|*
operator|)
name|optval
operator|=
name|onoff
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_RECVNXTINFO
case|:
block|{
name|int
name|onoff
decl_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|onoff
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* return the option value */
operator|*
operator|(
name|int
operator|*
operator|)
name|optval
operator|=
name|onoff
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_DEFAULT_SNDINFO
case|:
block|{
name|struct
name|sctp_sndinfo
modifier|*
name|info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sndinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|info
operator|->
name|snd_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|info
operator|->
name|snd_sid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_stream
expr_stmt|;
name|info
operator|->
name|snd_flags
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
expr_stmt|;
name|info
operator|->
name|snd_flags
operator|&=
literal|0xfff0
expr_stmt|;
name|info
operator|->
name|snd_ppid
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_ppid
expr_stmt|;
name|info
operator|->
name|snd_context
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_context
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|info
operator|->
name|snd_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|info
operator|->
name|snd_sid
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_stream
expr_stmt|;
name|info
operator|->
name|snd_flags
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
expr_stmt|;
name|info
operator|->
name|snd_flags
operator|&=
literal|0xfff0
expr_stmt|;
name|info
operator|->
name|snd_ppid
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_ppid
expr_stmt|;
name|info
operator|->
name|snd_context
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_context
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sndinfo
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_DEFAULT_PRINFO
case|:
block|{
name|struct
name|sctp_default_prinfo
modifier|*
name|info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_default_prinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|info
operator|->
name|pr_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|info
operator|->
name|pr_policy
operator|=
name|PR_SCTP_POLICY
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
argument_list|)
expr_stmt|;
name|info
operator|->
name|pr_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_timetolive
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|info
operator|->
name|pr_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|info
operator|->
name|pr_policy
operator|=
name|PR_SCTP_POLICY
argument_list|(
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
argument_list|)
expr_stmt|;
name|info
operator|->
name|pr_value
operator|=
name|inp
operator|->
name|def_send
operator|.
name|sinfo_timetolive
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_default_prinfo
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_PEER_ADDR_THLDS
case|:
block|{
name|struct
name|sctp_paddrthlds
modifier|*
name|thlds
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|thlds
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrthlds
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|thlds
operator|->
name|spt_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|thlds
operator|->
name|spt_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|thlds
operator|->
name|spt_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|thlds
operator|->
name|spt_address
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|net
condition|)
block|{
name|thlds
operator|->
name|spt_pathmaxrxt
operator|=
name|net
operator|->
name|failure_threshold
expr_stmt|;
name|thlds
operator|->
name|spt_pathpfthld
operator|=
name|net
operator|->
name|pf_threshold
expr_stmt|;
block|}
else|else
block|{
name|thlds
operator|->
name|spt_pathmaxrxt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
expr_stmt|;
name|thlds
operator|->
name|spt_pathpfthld
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_pf_threshold
expr_stmt|;
block|}
name|thlds
operator|->
name|spt_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|thlds
operator|->
name|spt_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
comment|/* Use endpoint defaults */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|thlds
operator|->
name|spt_pathmaxrxt
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
expr_stmt|;
name|thlds
operator|->
name|spt_pathpfthld
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_pf_threshold
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddrthlds
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOPROTOOPT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
comment|/* end switch (sopt->sopt_name) */
if|if
condition|(
name|error
condition|)
block|{
operator|*
name|optsize
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_setopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|optname
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
name|optsize
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|set_opt
decl_stmt|;
name|uint32_t
modifier|*
name|mopt
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
if|if
condition|(
name|optval
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"optval is NULL\n"
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"inp is NULL?\n"
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_NODELAY
case|:
case|case
name|SCTP_AUTOCLOSE
case|:
case|case
name|SCTP_AUTO_ASCONF
case|:
case|case
name|SCTP_EXPLICIT_EOR
case|:
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
comment|/* copy in the option value */
name|SCTP_CHECK_AND_CAST
argument_list|(
name|mopt
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|set_opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_NO_FRAGMENT
expr_stmt|;
break|break;
case|case
name|SCTP_AUTO_ASCONF
case|:
comment|/* 			 * NOTE: we don't really support this flag 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* only valid for bound all sockets */
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_auto_asconf
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|*
name|mopt
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* forbidden by admin */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EPERM
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_AUTO_ASCONF
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_EXPLICIT_EOR
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
expr_stmt|;
break|break;
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_EXT_RCVINFO
expr_stmt|;
break|break;
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_NODELAY
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_NODELAY
expr_stmt|;
break|break;
case|case
name|SCTP_AUTOCLOSE
case|:
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_AUTOCLOSE
expr_stmt|;
comment|/* 			 * The value is in ticks. Note this does not effect 			 * old associations, only new ones. 			 */
name|inp
operator|->
name|sctp_ep
operator|.
name|auto_close_time
operator|=
name|SEC_TO_TICKS
argument_list|(
operator|*
name|mopt
argument_list|)
expr_stmt|;
break|break;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mopt
operator|!=
literal|0
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|set_opt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|set_opt
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_REUSE_PORT
case|:
block|{
name|SCTP_CHECK_AND_CAST
argument_list|(
name|mopt
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't set it after we are bound */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
operator|)
condition|)
block|{
comment|/* Can't do this for a 1-m socket */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|optval
condition|)
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
expr_stmt|;
else|else
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_PARTIAL_DELIVERY_POINT
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|>
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|inp
operator|->
name|partial_delivery_point
operator|=
operator|*
name|value
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_FRAGMENT_INTERLEAVE
case|:
comment|/* not yet until we re-write sctp_recvmsg() */
block|{
name|uint32_t
modifier|*
name|level
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|level
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|level
operator|==
name|SCTP_FRAG_LEVEL_2
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|level
operator|==
name|SCTP_FRAG_LEVEL_1
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|level
operator|==
name|SCTP_FRAG_LEVEL_0
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_INTERLEAVE_STRMS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_CMT_ON_OFF
case|:
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_cmt_on_off
argument_list|)
condition|)
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|->
name|assoc_value
operator|>
name|SCTP_CMT_MAX
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_cmt_on_off
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOPROTOOPT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_PLUGGABLE_CC
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_CC_RFC2581
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_CC_HSTCP
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_CC_HTCP
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_CC_RTCC
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|=
name|sctp_cc_functions
index|[
name|av
operator|->
name|assoc_value
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|congestion_control_module
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_cc_module
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|=
name|sctp_cc_functions
index|[
name|av
operator|->
name|assoc_value
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|congestion_control_module
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_CC_OPTION
case|:
block|{
name|struct
name|sctp_cc_option
modifier|*
name|cc_opt
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|cc_opt
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_cc_option
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|cc_opt
operator|->
name|aid_value
operator|.
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|cc_opt
operator|->
name|aid_value
operator|.
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_socket_option
condition|)
block|{
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_socket_option
call|)
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|cc_opt
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_socket_option
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOTSUP
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
call|(
modifier|*
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_socket_option
call|)
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|cc_opt
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_PLUGGABLE_SS
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_DEFAULT
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_DEFAULT
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_ROUND_ROBIN
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_ROUND_ROBIN_PACKET
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_PRIORITY
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_FAIR_BANDWITH
operator|)
operator|&&
operator|(
name|av
operator|->
name|assoc_value
operator|!=
name|SCTP_SS_FIRST_COME
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_clear
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|=
name|sctp_ss_functions
index|[
name|av
operator|->
name|assoc_value
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|stream_scheduling_module
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_default_ss_module
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_clear
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|=
name|sctp_ss_functions
index|[
name|av
operator|->
name|assoc_value
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|stream_scheduling_module
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_SS_VALUE
case|:
block|{
name|struct
name|sctp_stream_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_stream_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_set_value
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|av
operator|->
name|stream_id
index|]
argument_list|,
name|av
operator|->
name|stream_value
argument_list|)
operator|<
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_set_value
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|av
operator|->
name|stream_id
index|]
argument_list|,
name|av
operator|->
name|stream_value
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * Can't set stream value without 					 * association 					 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_CLR_STAT_LOG
case|:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
case|case
name|SCTP_CONTEXT
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|context
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_context
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|context
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_VRF_ID
case|:
block|{
name|uint32_t
modifier|*
name|default_vrfid
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|default_vrfid
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|default_vrfid
operator|>
name|SCTP_MAX_VRF_ID
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|inp
operator|->
name|def_vrf_id
operator|=
operator|*
name|default_vrfid
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_DEL_VRF_ID
case|:
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_ADD_VRF_ID
case|:
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_DELAYED_SACK
case|:
block|{
name|struct
name|sctp_sack_info
modifier|*
name|sack
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sack
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sack_info
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sack
operator|->
name|sack_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sack
operator|->
name|sack_delay
condition|)
block|{
if|if
condition|(
name|sack
operator|->
name|sack_delay
operator|>
name|SCTP_MAX_SACK_DELAY
condition|)
name|sack
operator|->
name|sack_delay
operator|=
name|SCTP_MAX_SACK_DELAY
expr_stmt|;
if|if
condition|(
name|MSEC_TO_TICKS
argument_list|(
name|sack
operator|->
name|sack_delay
argument_list|)
operator|<
literal|1
condition|)
block|{
name|sack
operator|->
name|sack_delay
operator|=
name|TICKS_TO_MSEC
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sack
operator|->
name|sack_delay
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|=
name|sack
operator|->
name|sack_delay
expr_stmt|;
block|}
if|if
condition|(
name|sack
operator|->
name|sack_freq
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
operator|=
name|sack
operator|->
name|sack_freq
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|sack
operator|->
name|sack_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|sack
operator|->
name|sack_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sack
operator|->
name|sack_delay
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|sack
operator|->
name|sack_delay
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sack
operator|->
name|sack_freq
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_sack_freq
operator|=
name|sack
operator|->
name|sack_freq
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sack
operator|->
name|sack_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|sack
operator|->
name|sack_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sack
operator|->
name|sack_delay
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|=
name|sack
operator|->
name|sack_delay
expr_stmt|;
block|}
if|if
condition|(
name|sack
operator|->
name|sack_freq
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
operator|=
name|sack
operator|->
name|sack_freq
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_AUTH_CHUNK
case|:
block|{
name|struct
name|sctp_authchunk
modifier|*
name|sauth
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sauth
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authchunk
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_auth_add_chunk
argument_list|(
name|sauth
operator|->
name|sauth_chunk
argument_list|,
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_AUTH_KEY
case|:
block|{
name|struct
name|sctp_authkey
modifier|*
name|sca
decl_stmt|;
name|struct
name|sctp_keyhead
modifier|*
name|shared_keys
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|shared_key
decl_stmt|;
name|sctp_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sca
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkey
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sca
operator|->
name|sca_keylength
operator|==
literal|0
condition|)
block|{
name|size
operator|=
name|optsize
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authkey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sca
operator|->
name|sca_keylength
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authkey
argument_list|)
operator|<=
name|optsize
condition|)
block|{
name|size
operator|=
name|sca
operator|->
name|sca_keylength
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sca
operator|->
name|sca_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|shared_keys
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
expr_stmt|;
comment|/* clear the cached keys for this key id */
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|sca
operator|->
name|sca_keynumber
argument_list|)
expr_stmt|;
comment|/* 				 * create the new shared key and 				 * insert/replace it 				 */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|sctp_set_key
argument_list|(
name|sca
operator|->
name|sca_key
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|shared_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|shared_key
operator|==
name|NULL
condition|)
block|{
name|sctp_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
name|shared_key
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|shared_key
operator|->
name|keyid
operator|=
name|sca
operator|->
name|sca_keynumber
expr_stmt|;
name|error
operator|=
name|sctp_insert_sharedkey
argument_list|(
name|shared_keys
argument_list|,
name|shared_key
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|sca
operator|->
name|sca_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|sca
operator|->
name|sca_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|shared_keys
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
expr_stmt|;
comment|/* 					 * clear the cached keys on all 					 * assocs for this key id 					 */
name|sctp_clear_cachedkeys_ep
argument_list|(
name|inp
argument_list|,
name|sca
operator|->
name|sca_keynumber
argument_list|)
expr_stmt|;
comment|/* 					 * create the new shared key and 					 * insert/replace it 					 */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|sctp_set_key
argument_list|(
name|sca
operator|->
name|sca_key
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|shared_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|shared_key
operator|==
name|NULL
condition|)
block|{
name|sctp_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
name|shared_key
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|shared_key
operator|->
name|keyid
operator|=
name|sca
operator|->
name|sca_keynumber
expr_stmt|;
name|error
operator|=
name|sctp_insert_sharedkey
argument_list|(
name|shared_keys
argument_list|,
name|shared_key
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sca
operator|->
name|sca_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|sca
operator|->
name|sca_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|shared_keys
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
expr_stmt|;
comment|/* 						 * clear the cached keys for 						 * this key id 						 */
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|sca
operator|->
name|sca_keynumber
argument_list|)
expr_stmt|;
comment|/* 						 * create the new shared key 						 * and insert/replace it 						 */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|sctp_set_key
argument_list|(
name|sca
operator|->
name|sca_key
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|shared_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|shared_key
operator|==
name|NULL
condition|)
block|{
name|sctp_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|shared_key
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|shared_key
operator|->
name|keyid
operator|=
name|sca
operator|->
name|sca_keynumber
expr_stmt|;
name|error
operator|=
name|sctp_insert_sharedkey
argument_list|(
name|shared_keys
argument_list|,
name|shared_key
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_HMAC_IDENT
case|:
block|{
name|struct
name|sctp_hmacalgo
modifier|*
name|shmac
decl_stmt|;
name|sctp_hmaclist_t
modifier|*
name|hmaclist
decl_stmt|;
name|uint16_t
name|hmacid
decl_stmt|;
name|uint32_t
name|i
decl_stmt|;
name|size_t
name|found
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|shmac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_hmacalgo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|optsize
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_hmacalgo
argument_list|)
operator|+
name|shmac
operator|->
name|shmac_number_of_idents
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|hmaclist
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|shmac
operator|->
name|shmac_number_of_idents
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmaclist
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|shmac
operator|->
name|shmac_number_of_idents
condition|;
name|i
operator|++
control|)
block|{
name|hmacid
operator|=
name|shmac
operator|->
name|shmac_idents
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sctp_auth_add_hmacid
argument_list|(
name|hmaclist
argument_list|,
name|hmacid
argument_list|)
condition|)
block|{
comment|/* invalid HMACs were found */
empty_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|sctp_free_hmaclist
argument_list|(
name|hmaclist
argument_list|)
expr_stmt|;
goto|goto
name|sctp_set_hmac_done
goto|;
block|}
block|}
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hmaclist
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hmaclist
operator|->
name|hmac
index|[
name|i
index|]
operator|==
name|SCTP_AUTH_HMAC_ID_SHA1
condition|)
block|{
comment|/* already in list */
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|sctp_free_hmaclist
argument_list|(
name|hmaclist
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* set it on the endpoint */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
operator|=
name|hmaclist
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_set_hmac_done
label|:
break|break;
block|}
case|case
name|SCTP_AUTH_ACTIVE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|scact
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|scact
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|scact
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
comment|/* set the active key on the right place */
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* set the active key on the assoc */
if|if
condition|(
name|sctp_auth_setactivekey
argument_list|(
name|stcb
argument_list|,
name|scact
operator|->
name|scact_keynumber
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|scact
operator|->
name|scact_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|scact
operator|->
name|scact_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_auth_setactivekey_ep
argument_list|(
name|inp
argument_list|,
name|scact
operator|->
name|scact_keynumber
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scact
operator|->
name|scact_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|scact
operator|->
name|scact_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_auth_setactivekey
argument_list|(
name|stcb
argument_list|,
name|scact
operator|->
name|scact_keynumber
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_AUTH_DELETE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|scdel
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|scdel
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|scdel
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
comment|/* delete the key from the right place */
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_delete_sharedkey
argument_list|(
name|stcb
argument_list|,
name|scdel
operator|->
name|scact_keynumber
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|scdel
operator|->
name|scact_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|scdel
operator|->
name|scact_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_delete_sharedkey_ep
argument_list|(
name|inp
argument_list|,
name|scdel
operator|->
name|scact_keynumber
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|scdel
operator|->
name|scact_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|scdel
operator|->
name|scact_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_delete_sharedkey
argument_list|(
name|stcb
argument_list|,
name|scdel
operator|->
name|scact_keynumber
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_AUTH_DEACTIVATE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|keyid
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|keyid
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|keyid
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
comment|/* deactivate the key from the right place */
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_deact_sharedkey
argument_list|(
name|stcb
argument_list|,
name|keyid
operator|->
name|scact_keynumber
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|keyid
operator|->
name|scact_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|keyid
operator|->
name|scact_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_deact_sharedkey_ep
argument_list|(
name|inp
argument_list|,
name|keyid
operator|->
name|scact_keynumber
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keyid
operator|->
name|scact_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|keyid
operator|->
name|scact_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_deact_sharedkey
argument_list|(
name|stcb
argument_list|,
name|keyid
operator|->
name|scact_keynumber
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_RESET_STREAMS
case|:
block|{
name|struct
name|sctp_stream_reset
modifier|*
name|strrst
decl_stmt|;
name|uint8_t
name|send_in
init|=
literal|0
decl_stmt|,
name|send_tsn
init|=
literal|0
decl_stmt|,
name|send_out
init|=
literal|0
decl_stmt|,
name|addstream
init|=
literal|0
decl_stmt|;
name|uint16_t
name|addstrmcnt
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|strrst
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_stream_reset
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|strrst
operator|->
name|strrst_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Peer does not support it, we return 				 * protocol not supported since this is true 				 * for this feature and this peer, not the 				 * socket request in general. 				 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EPROTONOSUPPORT
argument_list|)
expr_stmt|;
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EALREADY
argument_list|)
expr_stmt|;
name|error
operator|=
name|EALREADY
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_LOCAL_RECV
condition|)
block|{
name|send_in
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_LOCAL_SEND
condition|)
block|{
name|send_out
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_BOTH
condition|)
block|{
name|send_in
operator|=
literal|1
expr_stmt|;
name|send_out
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_TSN
condition|)
block|{
name|send_tsn
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_ADD_STREAMS
condition|)
block|{
if|if
condition|(
name|send_tsn
operator|||
name|send_in
operator|||
name|send_out
condition|)
block|{
comment|/* We can't do that and add streams */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|skip_stuff
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|skip_stuff
goto|;
block|}
name|addstream
operator|=
literal|1
expr_stmt|;
comment|/* We allocate here */
name|addstrmcnt
operator|=
name|strrst
operator|->
name|strrst_num_streams
expr_stmt|;
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|addstrmcnt
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|)
operator|>
literal|0xffff
condition|)
block|{
comment|/* You can't have more than 64k */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|skip_stuff
goto|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|)
operator|<
name|addstrmcnt
condition|)
block|{
comment|/* Need to allocate more */
name|struct
name|sctp_stream_out
modifier|*
name|oldstream
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|oldstream
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|strmout
expr_stmt|;
comment|/* get some more */
name|SCTP_MALLOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
argument_list|,
expr|struct
name|sctp_stream_out
operator|*
argument_list|,
operator|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|+
name|addstrmcnt
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_out
argument_list|)
operator|)
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
operator|==
name|NULL
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
operator|=
name|oldstream
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|skip_stuff
goto|;
block|}
comment|/* 					 * Ok now we proceed with copying 					 * the old out stuff and 					 * initializing the new stuff. 					 */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_clear
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_sent
operator|=
name|oldstream
index|[
name|i
index|]
operator|.
name|next_sequence_sent
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
name|oldstream
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
argument_list|,
operator|&
name|oldstream
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* 						 * now anything on those 						 * queues? 						 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&oldstream[i].outqueue
argument_list|,
argument|next
argument_list|,
argument|nsp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|oldstream
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
comment|/* 						 * Now move assoc pointers 						 * too 						 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_out_stream
operator|==
operator|&
name|oldstream
index|[
name|i
index|]
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_out_stream
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|==
operator|&
name|oldstream
index|[
name|i
index|]
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|locked_on_sending
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* now the new streams */
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
init|;
name|i
operator|<
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|+
name|addstrmcnt
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_sent
operator|=
literal|0x0
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_init_stream
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|+
name|addstrmcnt
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|oldstream
argument_list|,
name|SCTP_M_STRMO
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|skip_stuff
goto|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strrst
operator|->
name|strrst_num_streams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|send_in
operator|)
operator|&&
operator|(
name|strrst
operator|->
name|strrst_list
index|[
name|i
index|]
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|get_out
goto|;
block|}
if|if
condition|(
operator|(
name|send_out
operator|)
operator|&&
operator|(
name|strrst
operator|->
name|strrst_list
index|[
name|i
index|]
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|get_out
goto|;
block|}
block|}
name|skip_stuff
label|:
if|if
condition|(
name|error
condition|)
block|{
name|get_out
label|:
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_send_str_reset_req
argument_list|(
name|stcb
argument_list|,
name|strrst
operator|->
name|strrst_num_streams
argument_list|,
name|strrst
operator|->
name|strrst_list
argument_list|,
name|send_out
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_in
operator|-
literal|3
operator|)
argument_list|,
name|send_in
argument_list|,
name|send_tsn
argument_list|,
name|addstream
argument_list|,
name|addstrmcnt
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_STRRST_REQ
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_CONNECT_X
case|:
if|if
condition|(
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_do_connect_x
argument_list|(
name|so
argument_list|,
name|inp
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CONNECT_X_DELAYED
case|:
if|if
condition|(
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_do_connect_x
argument_list|(
name|so
argument_list|,
name|inp
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CONNECT_X_COMPLETE
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* FIXME MT: check correct? */
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sa
argument_list|,
name|optval
argument_list|,
expr|struct
name|sockaddr
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
comment|/* find tcb */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|==
literal|1
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * already expired or did not use delayed 				 * connectx 				 */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EALREADY
argument_list|)
expr_stmt|;
name|error
operator|=
name|EALREADY
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_MAX_BURST
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|max_burst
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|max_burst
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|max_burst
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_MAXSEG
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|int
name|ovh
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|av
operator|->
name|assoc_value
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sctp_frag_point
operator|=
operator|(
name|av
operator|->
name|assoc_value
operator|+
name|ovh
operator|)
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sctp_frag_point
operator|=
name|SCTP_DEFAULT_MAXSEGMENT
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|av
operator|->
name|assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 					 * FIXME MT: I think this is not in 					 * tune with the API ID 					 */
if|if
condition|(
name|av
operator|->
name|assoc_value
condition|)
block|{
name|inp
operator|->
name|sctp_frag_point
operator|=
operator|(
name|av
operator|->
name|assoc_value
operator|+
name|ovh
operator|)
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|sctp_frag_point
operator|=
name|SCTP_DEFAULT_MAXSEGMENT
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_EVENTS
case|:
block|{
name|struct
name|sctp_event_subscribe
modifier|*
name|events
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|events
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_event_subscribe
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|->
name|sctp_data_io_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_association_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_address_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_send_failure_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_peer_error_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_shutdown_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_partial_delivery_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_adaptation_layer_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_authentication_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_sender_dry_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_stream_reset_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|->
name|sctp_association_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_address_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_send_failure_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_peer_error_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_shutdown_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_partial_delivery_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_adaptation_layer_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_authentication_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_sender_dry_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DRYEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_stream_reset_event
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Send up the sender dry event only for 1-to-1 			 * style sockets. 			 */
if|if
condition|(
name|events
operator|->
name|sctp_sender_dry_event
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENDER_DRY
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_ADAPTATION_LAYER
case|:
block|{
name|struct
name|sctp_setadaptation
modifier|*
name|adap_bits
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|adap_bits
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setadaptation
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
operator|=
name|adap_bits
operator|->
name|ssb_adaptation_ind
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
case|case
name|SCTP_SET_INITIAL_DBG_SEQ
case|:
block|{
name|uint32_t
modifier|*
name|vvv
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|vvv
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_sequence_debug
operator|=
operator|*
name|vvv
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
case|case
name|SCTP_DEFAULT_SEND_PARAM
case|:
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|s_info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|s_info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sndrcvinfo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|s_info
operator|->
name|sinfo_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|s_info
operator|->
name|sinfo_stream
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|def_send
argument_list|,
name|s_info
argument_list|,
name|min
argument_list|(
name|optsize
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|def_send
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|s_info
operator|->
name|sinfo_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|s_info
operator|->
name|sinfo_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|inp
operator|->
name|def_send
argument_list|,
name|s_info
argument_list|,
name|min
argument_list|(
name|optsize
argument_list|,
sizeof|sizeof
argument_list|(
name|inp
operator|->
name|def_send
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s_info
operator|->
name|sinfo_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|s_info
operator|->
name|sinfo_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|s_info
operator|->
name|sinfo_stream
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|def_send
argument_list|,
name|s_info
argument_list|,
name|min
argument_list|(
name|optsize
argument_list|,
sizeof|sizeof
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|def_send
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_PEER_ADDR_PARAMS
case|:
comment|/* Applies to the specific association */
block|{
name|struct
name|sctp_paddrparams
modifier|*
name|paddrp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|paddrp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrparams
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|paddrp
operator|->
name|spp_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* sanity checks */
if|if
condition|(
operator|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
operator|)
operator|&&
operator|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_ENABLE
operator|)
operator|&&
operator|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_DISABLE
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
comment|/************************TCB SPECIFIC SET ******************/
comment|/* 				 * do we change the timer for HB, we run 				 * only one? 				 */
name|int
name|ovh
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
comment|/* network sets ? */
if|if
condition|(
name|net
condition|)
block|{
comment|/************************NET SPECIFIC SET ******************/
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
operator|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
condition|)
block|{
name|net
operator|->
name|heart_beat_delay
operator|=
name|paddrp
operator|->
name|spp_hbinterval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_TIME_IS_ZERO
condition|)
block|{
name|net
operator|->
name|heart_beat_delay
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DEMAND
condition|)
block|{
comment|/* on demand HB */
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_SOCKOPT
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_DISABLE
operator|)
operator|&&
operator|(
name|paddrp
operator|->
name|spp_pathmtu
operator|>=
name|SCTP_SMALLEST_PMTU
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NO_PMTUD
expr_stmt|;
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmtu
operator|>
name|SCTP_DEFAULT_MINSEGMENT
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|paddrp
operator|->
name|spp_pathmtu
operator|+
name|ovh
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|mtu
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_ENABLE
condition|)
block|{
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NO_PMTUD
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|error_count
operator|>
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|error_count
operator|<=
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|)
operator|&&
operator|(
name|net
operator|->
name|error_count
operator|>
name|net
operator|->
name|pf_threshold
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|error_count
operator|>
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|error_count
operator|<=
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|failure_threshold
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_DSCP
condition|)
block|{
name|net
operator|->
name|dscp
operator|=
name|paddrp
operator|->
name|spp_dscp
operator|&
literal|0xfc
expr_stmt|;
name|net
operator|->
name|dscp
operator||=
literal|0x01
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV6_FLOWLABEL
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|net
operator|->
name|flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|net
operator|->
name|flowlabel
operator||=
literal|0x80000000
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/************************ASSOC ONLY -- NO NET SPECIFIC SET ******************/
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|error_count
operator|>
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|error_count
operator|<=
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|)
operator|&&
operator|(
name|net
operator|->
name|error_count
operator|>
name|net
operator|->
name|pf_threshold
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|error_count
operator|>
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|error_count
operator|<=
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|failure_threshold
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
block|}
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
operator|=
name|paddrp
operator|->
name|spp_hbinterval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_TIME_IS_ZERO
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Turn back on the timer */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
condition|)
block|{
name|net
operator|->
name|heart_beat_delay
operator|=
name|paddrp
operator|->
name|spp_hbinterval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_TIME_IS_ZERO
condition|)
block|{
name|net
operator|->
name|heart_beat_delay
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOHB
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_DISABLE
operator|)
operator|&&
operator|(
name|paddrp
operator|->
name|spp_pathmtu
operator|>=
name|SCTP_SMALLEST_PMTU
operator|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NO_PMTUD
expr_stmt|;
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmtu
operator|>
name|SCTP_DEFAULT_MINSEGMENT
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|paddrp
operator|->
name|spp_pathmtu
operator|+
name|ovh
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|mtu
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DO_NOT_PMTUD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_ENABLE
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|!
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NO_PMTUD
expr_stmt|;
block|}
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_PCB_FLAGS_DO_NOT_PMTUD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_DSCP
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|net
operator|->
name|dscp
operator|=
name|paddrp
operator|->
name|spp_dscp
operator|&
literal|0xfc
expr_stmt|;
name|net
operator|->
name|dscp
operator||=
literal|0x01
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|default_dscp
operator|=
name|paddrp
operator|->
name|spp_dscp
operator|&
literal|0xfc
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|default_dscp
operator||=
literal|0x01
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV6_FLOWLABEL
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|net
operator|->
name|flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|net
operator|->
name|flowlabel
operator||=
literal|0x80000000
expr_stmt|;
block|}
block|}
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
operator||=
literal|0x80000000
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/************************NO TCB, SET TO default stuff ******************/
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|paddrp
operator|->
name|spp_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 					 * For the TOS/FLOWLABEL stuff you 					 * set it with the options on the 					 * socket 					 */
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_TIME_IS_ZERO
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
condition|)
block|{
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
operator|>
name|SCTP_MAX_HB_INTERVAL
condition|)
name|paddrp
operator|->
name|spp_hbinterval
operator|=
name|SCTP_MAX_HB_INTERVAL
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|paddrp
operator|->
name|spp_hbinterval
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_TIME_IS_ZERO
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|paddrp
operator|->
name|spp_hbinterval
argument_list|)
expr_stmt|;
block|}
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_ENABLE
condition|)
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_NOT_PMTUD
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_DISABLE
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_NOT_PMTUD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_DSCP
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|default_dscp
operator|=
name|paddrp
operator|->
name|spp_dscp
operator|&
literal|0xfc
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|default_dscp
operator||=
literal|0x01
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV6_FLOWLABEL
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|&
literal|0x000fffff
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|default_flowlabel
operator||=
literal|0x80000000
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_RTOINFO
case|:
block|{
name|struct
name|sctp_rtoinfo
modifier|*
name|srto
decl_stmt|;
name|uint32_t
name|new_init
decl_stmt|,
name|new_min
decl_stmt|,
name|new_max
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|srto
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_rtoinfo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|srto
operator|->
name|srto_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|srto
operator|->
name|srto_initial
condition|)
name|new_init
operator|=
name|srto
operator|->
name|srto_initial
expr_stmt|;
else|else
name|new_init
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_max
condition|)
name|new_max
operator|=
name|srto
operator|->
name|srto_max
expr_stmt|;
else|else
name|new_max
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_min
condition|)
name|new_min
operator|=
name|srto
operator|->
name|srto_min
expr_stmt|;
else|else
name|new_min
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
if|if
condition|(
operator|(
name|new_min
operator|<=
name|new_init
operator|)
operator|&&
operator|(
name|new_init
operator|<=
name|new_max
operator|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
operator|=
name|new_init
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
operator|=
name|new_max
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|minrto
operator|=
name|new_min
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|srto
operator|->
name|srto_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_initial
condition|)
name|new_init
operator|=
name|srto
operator|->
name|srto_initial
expr_stmt|;
else|else
name|new_init
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_rto
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_max
condition|)
name|new_max
operator|=
name|srto
operator|->
name|srto_max
expr_stmt|;
else|else
name|new_max
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_min
condition|)
name|new_min
operator|=
name|srto
operator|->
name|srto_min
expr_stmt|;
else|else
name|new_min
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
expr_stmt|;
if|if
condition|(
operator|(
name|new_min
operator|<=
name|new_init
operator|)
operator|&&
operator|(
name|new_init
operator|<=
name|new_max
operator|)
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_rto
operator|=
name|new_init
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
operator|=
name|new_max
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
operator|=
name|new_min
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_ASSOCINFO
case|:
block|{
name|struct
name|sctp_assocparams
modifier|*
name|sasoc
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sasoc
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assocparams
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sasoc
operator|->
name|sasoc_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_cookie_life
condition|)
block|{
comment|/* boundary check the cookie life */
if|if
condition|(
name|sasoc
operator|->
name|sasoc_cookie_life
operator|<
literal|1000
condition|)
name|sasoc
operator|->
name|sasoc_cookie_life
operator|=
literal|1000
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_cookie_life
operator|>
name|SCTP_MAX_COOKIE_LIFE
condition|)
block|{
name|sasoc
operator|->
name|sasoc_cookie_life
operator|=
name|SCTP_MAX_COOKIE_LIFE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sasoc
operator|->
name|sasoc_asocmaxrxt
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
operator|=
name|sasoc
operator|->
name|sasoc_asocmaxrxt
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_cookie_life
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cookie_life
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|sasoc
operator|->
name|sasoc_cookie_life
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|sasoc
operator|->
name|sasoc_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_asocmaxrxt
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|max_send_times
operator|=
name|sasoc
operator|->
name|sasoc_asocmaxrxt
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_cookie_life
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|sasoc
operator|->
name|sasoc_cookie_life
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_INITMSG
case|:
block|{
name|struct
name|sctp_initmsg
modifier|*
name|sinit
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sinit
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_initmsg
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_num_ostreams
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
operator|=
name|sinit
operator|->
name|sinit_num_ostreams
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_max_instreams
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
operator|=
name|sinit
operator|->
name|sinit_max_instreams
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_max_attempts
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|max_init_times
operator|=
name|sinit
operator|->
name|sinit_max_attempts
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_max_init_timeo
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_init_rto_max
operator|=
name|sinit
operator|->
name|sinit_max_init_timeo
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_PRIMARY_ADDR
case|:
block|{
name|struct
name|sctp_setprim
modifier|*
name|spa
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|spa
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setprim
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|spa
operator|->
name|ssp_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spa
operator|->
name|ssp_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spa
operator|->
name|ssp_addr
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|net
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
operator|&&
operator|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
condition|)
block|{
comment|/* Ok we need to set it */
if|if
condition|(
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|net
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|)
operator|&&
operator|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|)
operator|&&
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_SET_DYNAMIC_PRIMARY
case|:
block|{
name|union
name|sctp_sockstore
modifier|*
name|ss
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|curthread
argument_list|,
name|PRIV_NETINET_RESERVEDPORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ss
argument_list|,
name|optval
argument_list|,
expr|union
name|sctp_sockstore
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
comment|/* SUPER USER CHECK? */
name|error
operator|=
name|sctp_dynamic_set_primary
argument_list|(
operator|&
name|ss
operator|->
name|sa
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_SET_PEER_PRIMARY_ADDR
case|:
block|{
name|struct
name|sctp_setpeerprim
modifier|*
name|sspp
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sspp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setpeerprim
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sspp
operator|->
name|sspp_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sspp
operator|->
name|sspp_addr
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_of_it
goto|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Must validate the ifa found is in 					 * our ep 					 */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_OUTPUT1
argument_list|,
literal|"%s: NULL ifa\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_of_it
goto|;
block|}
block|}
if|if
condition|(
name|sctp_set_primary_ip_address_sa
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sspp
operator|->
name|sspp_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|out_of_it
label|:
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_BINDX_ADD_ADDR
case|:
block|{
name|struct
name|sctp_getaddresses
modifier|*
name|addrs
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|p
expr_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|addrs
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|addrs
operator|->
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|optsize
operator|<
name|sz
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|prison_local_ip4
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|addrs
operator|->
name|addr
operator|)
operator|)
operator|->
name|sin_addr
operator|)
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addrs
operator|->
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|optsize
operator|<
name|sz
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|prison_local_ip6
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|addrs
operator|->
name|addr
operator|)
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
name|sctp_bindx_add_address
argument_list|(
name|so
argument_list|,
name|inp
argument_list|,
name|addrs
operator|->
name|addr
argument_list|,
name|addrs
operator|->
name|sget_assoc_id
argument_list|,
name|vrf_id
argument_list|,
operator|&
name|error
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_BINDX_REM_ADDR
case|:
block|{
name|struct
name|sctp_getaddresses
modifier|*
name|addrs
decl_stmt|;
name|size_t
name|sz
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|td
operator|=
operator|(
expr|struct
name|thread
operator|*
operator|)
name|p
expr_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|addrs
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|addrs
operator|->
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|optsize
operator|<
name|sz
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|prison_local_ip4
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|addrs
operator|->
name|addr
operator|)
operator|)
operator|->
name|sin_addr
operator|)
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addrs
operator|->
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|sz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|optsize
operator|<
name|sz
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|td
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|prison_local_ip6
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|,
operator|&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|addrs
operator|->
name|addr
operator|)
operator|)
operator|->
name|sin6_addr
operator|)
argument_list|,
operator|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
operator|!=
literal|0
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
break|break;
block|}
name|sctp_bindx_delete_address
argument_list|(
name|inp
argument_list|,
name|addrs
operator|->
name|addr
argument_list|,
name|addrs
operator|->
name|sget_assoc_id
argument_list|,
name|vrf_id
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_EVENT
case|:
block|{
name|struct
name|sctp_event
modifier|*
name|event
decl_stmt|;
name|uint32_t
name|event_type
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|event
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_event
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event
operator|->
name|se_assoc_id
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|event
operator|->
name|se_type
condition|)
block|{
case|case
name|SCTP_ASSOC_CHANGE
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_PEER_ADDR_CHANGE
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVPADDREVNT
expr_stmt|;
break|break;
case|case
name|SCTP_REMOTE_ERROR
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVPEERERR
expr_stmt|;
break|break;
case|case
name|SCTP_SEND_FAILED
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_SHUTDOWN_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_ADAPTATION_INDICATION
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_PARTIAL_DELIVERY_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_PDAPIEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHENTICATION_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_AUTHEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_STREAM_RESET_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_SENDER_DRY_EVENT
case|:
name|event_type
operator|=
name|SCTP_PCB_FLAGS_DRYEVNT
expr_stmt|;
break|break;
case|case
name|SCTP_NOTIFICATIONS_STOPPED_EVENT
case|:
name|event_type
operator|=
literal|0
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTSUP
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
default|default:
name|event_type
operator|=
literal|0
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|event_type
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|event
operator|->
name|se_on
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|event_type
operator|==
name|SCTP_PCB_FLAGS_DRYEVNT
condition|)
block|{
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENDER_DRY
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * We don't want to send up a storm 					 * of events, so return an error for 					 * sender dry events 					 */
if|if
condition|(
operator|(
name|event_type
operator|==
name|SCTP_PCB_FLAGS_DRYEVNT
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
operator|||
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTSUP
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOTSUP
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|se_on
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|event
operator|->
name|se_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|event
operator|->
name|se_on
condition|)
block|{
name|sctp_stcb_feature_on
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_stcb_feature_off
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|event_type
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
case|case
name|SCTP_RECVRCVINFO
case|:
block|{
name|int
modifier|*
name|onoff
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|onoff
argument_list|,
name|optval
argument_list|,
name|int
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|onoff
operator|!=
literal|0
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVRCVINFO
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_RECVNXTINFO
case|:
block|{
name|int
modifier|*
name|onoff
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|onoff
argument_list|,
name|optval
argument_list|,
name|int
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|onoff
operator|!=
literal|0
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVNXTINFO
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_DEFAULT_SNDINFO
case|:
block|{
name|struct
name|sctp_sndinfo
modifier|*
name|info
decl_stmt|;
name|uint16_t
name|policy
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sndinfo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|info
operator|->
name|snd_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|snd_sid
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_stream
operator|=
name|info
operator|->
name|snd_sid
expr_stmt|;
name|policy
operator|=
name|PR_SCTP_POLICY
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator|=
name|info
operator|->
name|snd_flags
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator||=
name|policy
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_ppid
operator|=
name|info
operator|->
name|snd_ppid
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_context
operator|=
name|info
operator|->
name|snd_context
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|info
operator|->
name|snd_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|info
operator|->
name|snd_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_stream
operator|=
name|info
operator|->
name|snd_sid
expr_stmt|;
name|policy
operator|=
name|PR_SCTP_POLICY
argument_list|(
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
argument_list|)
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
operator|=
name|info
operator|->
name|snd_flags
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
operator||=
name|policy
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_ppid
operator|=
name|info
operator|->
name|snd_ppid
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_context
operator|=
name|info
operator|->
name|snd_context
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|snd_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|info
operator|->
name|snd_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|snd_sid
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_stream
operator|=
name|info
operator|->
name|snd_sid
expr_stmt|;
name|policy
operator|=
name|PR_SCTP_POLICY
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator|=
name|info
operator|->
name|snd_flags
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator||=
name|policy
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_ppid
operator|=
name|info
operator|->
name|snd_ppid
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_context
operator|=
name|info
operator|->
name|snd_context
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_DEFAULT_PRINFO
case|:
block|{
name|struct
name|sctp_default_prinfo
modifier|*
name|info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_default_prinfo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|info
operator|->
name|pr_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|PR_SCTP_INVALID_POLICY
argument_list|(
name|info
operator|->
name|pr_policy
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator|&=
literal|0xfff0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator||=
name|info
operator|->
name|pr_policy
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_timetolive
operator|=
name|info
operator|->
name|pr_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|info
operator|->
name|pr_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
operator|||
operator|(
name|info
operator|->
name|pr_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
operator|&=
literal|0xfff0
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_flags
operator||=
name|info
operator|->
name|pr_policy
expr_stmt|;
name|inp
operator|->
name|def_send
operator|.
name|sinfo_timetolive
operator|=
name|info
operator|->
name|pr_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|info
operator|->
name|pr_assoc_id
operator|==
name|SCTP_CURRENT_ASSOC
operator|)
operator|||
operator|(
name|info
operator|->
name|pr_assoc_id
operator|==
name|SCTP_ALL_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator|&=
literal|0xfff0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_flags
operator||=
name|info
operator|->
name|pr_policy
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|.
name|sinfo_timetolive
operator|=
name|info
operator|->
name|pr_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
case|case
name|SCTP_PEER_ADDR_THLDS
case|:
comment|/* Applies to the specific association */
block|{
name|struct
name|sctp_paddrthlds
modifier|*
name|thlds
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|thlds
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrthlds
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|thlds
operator|->
name|spt_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|thlds
operator|->
name|spt_assoc_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|thlds
operator|->
name|spt_assoc_id
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|&&
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|thlds
operator|->
name|spt_assoc_id
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
else|else
endif|#
directive|endif
block|{
name|error
operator|=
name|EAFNOSUPPORT
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|net
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|failure_threshold
operator|>
name|thlds
operator|->
name|spt_pathmaxrxt
operator|)
operator|||
operator|(
name|net
operator|->
name|failure_threshold
operator|<=
name|thlds
operator|->
name|spt_pathpfthld
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|failure_threshold
operator|>
name|thlds
operator|->
name|spt_pathpfthld
operator|)
operator|&&
operator|(
name|net
operator|->
name|failure_threshold
operator|<=
name|thlds
operator|->
name|spt_pathmaxrxt
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|failure_threshold
operator|>
name|thlds
operator|->
name|spt_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|failure_threshold
operator|<=
name|thlds
operator|->
name|spt_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|failure_threshold
operator|=
name|thlds
operator|->
name|spt_pathmaxrxt
expr_stmt|;
name|net
operator|->
name|pf_threshold
operator|=
name|thlds
operator|->
name|spt_pathpfthld
expr_stmt|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|failure_threshold
operator|>
name|thlds
operator|->
name|spt_pathmaxrxt
operator|)
operator|||
operator|(
name|net
operator|->
name|failure_threshold
operator|<=
name|thlds
operator|->
name|spt_pathpfthld
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|net
operator|->
name|failure_threshold
operator|>
name|thlds
operator|->
name|spt_pathpfthld
operator|)
operator|&&
operator|(
name|net
operator|->
name|failure_threshold
operator|<=
name|thlds
operator|->
name|spt_pathmaxrxt
operator|)
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_TIMER
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|failure_threshold
operator|>
name|thlds
operator|->
name|spt_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|net
operator|->
name|failure_threshold
operator|<=
name|thlds
operator|->
name|spt_pathmaxrxt
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|net
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
name|net
operator|->
name|failure_threshold
operator|=
name|thlds
operator|->
name|spt_pathmaxrxt
expr_stmt|;
name|net
operator|->
name|pf_threshold
operator|=
name|thlds
operator|->
name|spt_pathpfthld
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
operator|=
name|thlds
operator|->
name|spt_pathmaxrxt
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|def_net_pf_threshold
operator|=
name|thlds
operator|->
name|spt_pathpfthld
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|||
operator|(
name|thlds
operator|->
name|spt_assoc_id
operator|==
name|SCTP_FUTURE_ASSOC
operator|)
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
operator|=
name|thlds
operator|->
name|spt_pathmaxrxt
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_pf_threshold
operator|=
name|thlds
operator|->
name|spt_pathpfthld
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOPROTOOPT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
comment|/* end switch (opt) */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|void
modifier|*
name|optval
init|=
name|NULL
decl_stmt|;
name|size_t
name|optsize
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
comment|/* I made the same as TCP since we are not setup? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|IPPROTO_SCTP
condition|)
block|{
comment|/* wrong proto level... send back up to IP */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|INP_CHECK_SOCKAF
argument_list|(
name|so
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|error
operator|=
name|ip6_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
else|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|error
operator|=
name|ip_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
name|optsize
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|optsize
condition|)
block|{
name|SCTP_MALLOC
argument_list|(
name|optval
argument_list|,
name|void
operator|*
argument_list|,
name|optsize
argument_list|,
name|SCTP_M_SOCKOPT
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOBUFS
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|optval
argument_list|,
name|SCTP_M_SOCKOPT
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|sopt
operator|->
name|sopt_td
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_SET
condition|)
block|{
name|error
operator|=
name|sctp_setopt
argument_list|(
name|so
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
block|{
name|error
operator|=
name|sctp_getopt
argument_list|(
name|so
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|,
name|optval
argument_list|,
operator|&
name|optsize
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|optval
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|optval
argument_list|,
name|SCTP_M_SOCKOPT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optval
operator|!=
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|optval
argument_list|,
name|SCTP_M_SOCKOPT
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
specifier|static
name|int
name|sctp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|create_lock_on
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
comment|/* I made the same as TCP since we are not setup? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6p
decl_stmt|;
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sin6p
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|prison_remote_ip6
argument_list|(
name|p
operator|->
name|td_ucred
argument_list|,
operator|&
name|sin6p
operator|->
name|sin6_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sinp
decl_stmt|;
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|sinp
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|(
name|error
operator|=
name|prison_remote_ip4
argument_list|(
name|p
operator|->
name|td_ucred
argument_list|,
operator|&
name|sinp
operator|->
name|sin_addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EAFNOSUPPORT
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAFNOSUPPORT
operator|)
return|;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
comment|/* Should I really unlock ? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* Bind a ephemeral port */
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out_now
goto|;
block|}
block|}
comment|/* Now do we connect? */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|&&
operator|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We increment here since sctp_findassociation_ep_addr() 		 * will do a decrement if it finds the stcb as long as the 		 * locked tcb (last argument) is NOT a TCB.. aka NULL. 		 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EALREADY
argument_list|)
expr_stmt|;
name|error
operator|=
name|EALREADY
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
comment|/* We are GOOD to go */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Gak! no memory */
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_COOKIE_WAIT
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* initialize authentication parameters for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|out_now
label|:
if|if
condition|(
name|create_lock_on
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * Note this module depends on the protocol processing being called 	 * AFTER any socket level flags and backlog are applied to the 	 * socket. The traditional way that the socket flags are applied is 	 * AFTER protocol processing. We have made a change to the 	 * sys/kern/uipc_socket.c module to reverse this but this MUST be in 	 * place if the socket API for SCTP is to work properly. 	 */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
comment|/* I made the same as TCP since we are not setup? */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
condition|)
block|{
comment|/* See if we have a listener */
name|struct
name|sctp_inpcb
modifier|*
name|tinp
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
operator|&
name|store
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* not bound all */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|store
argument_list|,
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sp
operator|->
name|sin
operator|.
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sp
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
name|tinp
operator|=
name|sctp_pcb_findep
argument_list|(
operator|&
name|sp
operator|->
name|sa
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinp
operator|&&
operator|(
name|tinp
operator|!=
name|inp
operator|)
operator|&&
operator|(
operator|(
name|tinp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tinp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tinp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* 					 * we have a listener already and 					 * its not this inp. 					 */
name|SCTP_INP_DECR_REF
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tinp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Setup a local addr bound all */
name|memset
argument_list|(
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sp
operator|->
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|store
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sp
operator|->
name|sin6
operator|.
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|store
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|store
operator|.
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
name|store
operator|.
name|sa
operator|.
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|store
operator|.
name|sa
operator|.
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tinp
operator|=
name|sctp_pcb_findep
argument_list|(
operator|&
name|sp
operator|->
name|sa
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|tinp
operator|&&
operator|(
name|tinp
operator|!=
name|inp
operator|)
operator|&&
operator|(
operator|(
name|tinp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|tinp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|tinp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* 				 * we have a listener already and its not 				 * this inp. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|tinp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|tinp
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOCK_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LOCK_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_lock
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
name|SCTP_LOG_LOCK_SOCK
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PORTREUSE
argument_list|)
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* 		 * The unlucky case - We are in the tcp pool with this guy. 		 * - Someone else is in the main inp slot. - We must move 		 * this guy (the listener) to the main slot - We must then 		 * move the guy that was listener to the TCP Pool. 		 */
if|if
condition|(
name|sctp_swap_inpcb_for_listen
argument_list|(
name|inp
argument_list|)
condition|)
block|{
goto|goto
name|in_use
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|in_use
label|:
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* We must do a bind. */
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
comment|/* bind error, probably perm */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
comment|/* It appears for 7.0 and on, we must always call this. */
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
comment|/* remove the ACCEPTCONN flag for one-to-many sockets */
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_ACCEPTCONN
expr_stmt|;
block|}
if|if
condition|(
name|backlog
operator|==
literal|0
condition|)
block|{
comment|/* turning off listen */
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_ACCEPTCONN
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sctp_defered_wakeup_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|int
name|error
decl_stmt|;
endif|#
directive|endif
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EOPNOTSUPP
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTED
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNABORTED
operator|)
return|;
block|}
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|store
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&=
operator|~
name|SCTP_STATE_IN_ACCEPT_QUEUE
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|store
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin_port
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin_addr
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin6
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin6_port
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* TSNH */
break|break;
block|}
comment|/* Wake any delayed sleep action */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_DONT_WAKE
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_DONT_WAKE
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEOUTPUT
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAKEOUTPUT
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sowriteable
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
condition|)
block|{
name|sowwakeup_locked
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEINPUT
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAKEINPUT
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|soreadable
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
condition|)
block|{
name|sctp_defered_wakeup_cnt
operator|++
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
name|int
name|sctp_ingetaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
comment|/* 	 * Do the malloc first in case it blocks. 	 */
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin_a
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
goto|goto
name|notConn
goto|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|sin_a
operator|=
name|NULL
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a
operator|==
name|NULL
condition|)
comment|/* this will make coverity happy */
continue|continue;
if|if
condition|(
name|sin_a
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fnd
operator|)
operator|||
operator|(
name|sin_a
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* punt */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|notConn
goto|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|sctp_ifa
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifa
condition|)
block|{
name|sin
operator|->
name|sin_addr
operator|=
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|sctp_ifa
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For the bound all case you get back 0 */
name|notConn
label|:
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Take the first IPv4 address in the list */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin_a
decl_stmt|;
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|sin_a
operator|->
name|sin_addr
expr_stmt|;
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|addr
operator|)
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|*
name|addr
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin_a
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* Do the malloc first in case it blocks. */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* UDP type and listeners will drop out here */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
comment|/* We must recapture incase we blocked */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|sin_a
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
comment|/* No IPv4 address */
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
operator|(
operator|*
name|addr
operator|)
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_decl_stmt
name|struct
name|pr_usrreqs
name|sctp_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|sctp_abort
block|,
operator|.
name|pru_accept
operator|=
name|sctp_accept
block|,
operator|.
name|pru_attach
operator|=
name|sctp_attach
block|,
operator|.
name|pru_bind
operator|=
name|sctp_bind
block|,
operator|.
name|pru_connect
operator|=
name|sctp_connect
block|,
operator|.
name|pru_control
operator|=
name|in_control
block|,
operator|.
name|pru_close
operator|=
name|sctp_close
block|,
operator|.
name|pru_detach
operator|=
name|sctp_close
block|,
operator|.
name|pru_sopoll
operator|=
name|sopoll_generic
block|,
operator|.
name|pru_flush
operator|=
name|sctp_flush
block|,
operator|.
name|pru_disconnect
operator|=
name|sctp_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|sctp_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|sctp_peeraddr
block|,
operator|.
name|pru_send
operator|=
name|sctp_sendm
block|,
operator|.
name|pru_shutdown
operator|=
name|sctp_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|sctp_ingetaddr
block|,
operator|.
name|pru_sosend
operator|=
name|sctp_sosend
block|,
operator|.
name|pru_soreceive
operator|=
name|sctp_soreceive
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

