begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_usrreq.c,v 1.48 2005/03/07 23:26:08 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet6/sctp6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_function
name|void
name|sctp_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Init the SCTP pcb in sctp_pcb.c */
name|u_long
name|sb_max_adj
decl_stmt|;
name|sctp_pcb_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|nmbclusters
operator|/
literal|8
operator|)
operator|>
name|SCTP_ASOC_MAX_CHUNKS_ON_QUEUE
condition|)
name|sctp_max_chunks_on_queue
operator|=
operator|(
name|nmbclusters
operator|/
literal|8
operator|)
expr_stmt|;
comment|/* 	 * Allow a user to take no more than 1/2 the number of clusters or 	 * the SB_MAX whichever is smaller for the send window. 	 */
name|sb_max_adj
operator|=
call|(
name|u_long
call|)
argument_list|(
call|(
name|u_quad_t
call|)
argument_list|(
name|SB_MAX
argument_list|)
operator|*
name|MCLBYTES
operator|/
operator|(
name|MSIZE
operator|+
name|MCLBYTES
operator|)
argument_list|)
expr_stmt|;
name|sctp_sendspace
operator|=
name|min
argument_list|(
operator|(
name|min
argument_list|(
name|SB_MAX
argument_list|,
name|sb_max_adj
argument_list|)
operator|)
argument_list|,
operator|(
operator|(
name|nmbclusters
operator|/
literal|2
operator|)
operator|*
name|SCTP_DEFAULT_MAXSEGMENT
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now for the recv window, should we take the same amount? or 	 * should I do 1/2 the SB_MAX instead in the SB_MAX min above. For 	 * now I will just copy. 	 */
name|sctp_recvspace
operator|=
name|sctp_sendspace
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup of the sctppcbinfo structure.  * Assumes that the sctppcbinfo lock is held.  */
end_comment

begin_function
name|void
name|sctp_pcbinfo_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* free the hash tables */
if|if
condition|(
name|sctppcbinfo
operator|.
name|sctp_asochash
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|sctp_asochash
argument_list|,
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctppcbinfo
operator|.
name|sctp_ephash
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|sctp_ephash
argument_list|,
name|sctppcbinfo
operator|.
name|hashmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctppcbinfo
operator|.
name|sctp_tcpephash
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|sctp_tcpephash
argument_list|,
name|sctppcbinfo
operator|.
name|hashtcpmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctppcbinfo
operator|.
name|sctp_restarthash
operator|!=
name|NULL
condition|)
name|SCTP_HASH_FREE
argument_list|(
name|sctppcbinfo
operator|.
name|sctp_restarthash
argument_list|,
name|sctppcbinfo
operator|.
name|hashrestartmark
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_pathmtu_adjustment
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint16_t
name|nxtsz
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
comment|/* Adjust that too */
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|nxtsz
expr_stmt|;
comment|/* now off to subtract IP_DF flag if needed */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|+
name|IP_HDR_SIZE
operator|)
operator|>
name|nxtsz
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|chk
operator|->
name|send_size
operator|+
name|IP_HDR_SIZE
operator|)
operator|>
name|nxtsz
condition|)
block|{
comment|/* 			 * For this guy we also mark for immediate resend 			 * since we sent to big of chunk 			 */
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
block|}
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_PMTU
argument_list|,
name|chk
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|chk
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|chk
operator|->
name|whoTo
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Clear any time so NO RTT is being done */
name|chk
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
name|sctp_flight_size_decrease
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_notify_mbuf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|ip
modifier|*
name|ip
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|)
block|{
name|struct
name|icmp
modifier|*
name|icmph
decl_stmt|;
name|int
name|totsz
decl_stmt|,
name|tmr_stopped
init|=
literal|0
decl_stmt|;
name|uint16_t
name|nxtsz
decl_stmt|;
comment|/* protection */
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ip
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First job is to verify the vtag matches what I would send */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|icmph
operator|=
operator|(
expr|struct
name|icmp
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|-
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|icmp
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|ip
argument_list|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|icmph
operator|->
name|icmp_type
operator|!=
name|ICMP_UNREACH
condition|)
block|{
comment|/* We only care about unreachable */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|icmph
operator|->
name|icmp_code
operator|!=
name|ICMP_UNREACH_NEEDFRAG
condition|)
block|{
comment|/* not a unreachable message due to frag. */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|totsz
operator|=
name|ip
operator|->
name|ip_len
expr_stmt|;
name|nxtsz
operator|=
name|ntohs
argument_list|(
name|icmph
operator|->
name|icmp_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|nxtsz
operator|==
literal|0
condition|)
block|{
comment|/* 		 * old type router that does not tell us what the next size 		 * mtu is. Rats we will have to guess (in a educated fashion 		 * of course) 		 */
name|nxtsz
operator|=
name|find_next_best_mtu
argument_list|(
name|totsz
argument_list|)
expr_stmt|;
block|}
comment|/* Stop any PMTU timer */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|tmr_stopped
operator|=
literal|1
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
comment|/* Adjust destination size limit */
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
name|nxtsz
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|nxtsz
expr_stmt|;
block|}
comment|/* now what about the ep? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|nxtsz
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|nxtsz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmr_stopped
condition|)
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_notify
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|int
name|error
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* protection */
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
operator|||
operator|(
name|to
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
comment|/* First job is to verify the vtag matches what I would send */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
block|{
return|return;
block|}
comment|/* FIX ME FIX ME PROTOPT i.e. no SCTP should ALWAYS be an ABORT */
if|if
condition|(
operator|(
name|error
operator|==
name|EHOSTUNREACH
operator|)
operator|||
comment|/* Host is not reachable */
operator|(
name|error
operator|==
name|EHOSTDOWN
operator|)
operator|||
comment|/* Host is down */
operator|(
name|error
operator|==
name|ECONNREFUSED
operator|)
operator|||
comment|/* Host refused the connection, (not 					 * an abort?) */
operator|(
name|error
operator|==
name|ENOPROTOOPT
operator|)
comment|/* SCTP is not present on host */
condition|)
block|{
comment|/* 		 * Hmm reachablity problems we must examine closely. If its 		 * not reachable, we may have lost a network. Or if there is 		 * NO protocol at the other end named SCTP. well we consider 		 * it a OOTB abort. 		 */
if|if
condition|(
operator|(
name|error
operator|==
name|EHOSTUNREACH
operator|)
operator|||
operator|(
name|error
operator|==
name|EHOSTDOWN
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
comment|/* Ok that destination is NOT reachable */
name|printf
argument_list|(
literal|"ICMP (thresh %d/%d) takes interface %p down\n"
argument_list|,
name|net
operator|->
name|error_count
argument_list|,
name|net
operator|->
name|failure_threshold
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|net
operator|->
name|error_count
operator|=
name|net
operator|->
name|failure_threshold
operator|+
literal|1
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
name|SCTP_FAILED_THRESHOLD
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Here the peer is either playing tricks on us, 			 * including an address that belongs to someone who 			 * does not support SCTP OR was a userland 			 * implementation that shutdown and now is dead. In 			 * either case treat it like a OOTB abort with no 			 * TCB 			 */
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
name|SCTP_PEER_FAULTY
argument_list|)
expr_stmt|;
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
comment|/* no need to unlock here, since the TCB is gone */
block|}
block|}
else|else
block|{
comment|/* Send all others to the app */
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_socket
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOCK_LOGGING
name|sctp_log_lock
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_LOG_LOCK_SOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SOCK_LOCK
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_socket
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
name|sctp_sowwakeup
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|sa
parameter_list|,
name|vip
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|void
modifier|*
name|vip
decl_stmt|;
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|vip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
comment|/* FIX, for non-bsd is this right? */
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|||
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|ip
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cmd
operator|>=
name|PRC_NCMDS
operator|||
name|inetctlerrmap
index|[
name|cmd
index|]
operator|==
literal|0
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ip
condition|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in
name|to
decl_stmt|,
name|from
decl_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
operator|(
name|ip
operator|->
name|ip_hl
operator|<<
literal|2
operator|)
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|to
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|from
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|from
operator|.
name|sin_family
operator|=
name|to
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|from
operator|.
name|sin_len
operator|=
name|to
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|from
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|from
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|to
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|to
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
comment|/* 		 * 'to' holds the dest of the packet that failed to be sent. 		 * 'from' holds our local endpoint address. Thus we reverse 		 * the to and the from in the lookup. 		 */
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|to
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
operator|&&
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|!=
name|PRC_MSGSIZE
condition|)
block|{
name|int
name|cm
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|PRC_HOSTDEAD
condition|)
block|{
name|cm
operator|=
name|EHOSTUNREACH
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|=
name|inetctlerrmap
index|[
name|cmd
index|]
expr_stmt|;
block|}
name|sctp_notify
argument_list|(
name|inp
argument_list|,
name|cm
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|to
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* handle possible ICMP size messages */
name|sctp_notify_mbuf
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ip
argument_list|,
name|sh
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_getcred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|xucred
name|xuc
decl_stmt|;
name|struct
name|sockaddr_in
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
comment|/* FIX, for non-bsd is this right? */
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
comment|/* 	 * XXXRW: Other instances of getcred use SUSER_ALLOWJAIL, as socket 	 * visibility is scoped using cr_canseesocket(), which it is not 	 * here. 	 */
name|error
operator|=
name|priv_check_cred
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|PRIV_NETINET_GETCRED
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|sintosa
argument_list|(
operator|&
name|addrs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sintosa
argument_list|(
operator|&
name|addrs
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
operator|||
name|inp
operator|==
name|NULL
operator|||
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|cred_can_cont
goto|;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 	 * We use the write lock here, only since in the error leg we need 	 * it. If we used RLOCK, then we would have to 	 * wlock/decr/unlock/rlock. Which in theory could create a hole. 	 * Better to use higher wlock. 	 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|cred_can_cont
label|:
name|error
operator|=
name|cr_canseesocket
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cru2x
argument_list|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_cred
argument_list|,
operator|&
name|xuc
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xuc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xucred
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet_sctp
argument_list|,
name|OID_AUTO
argument_list|,
name|getcred
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sctp_getcred
argument_list|,
literal|"S,ucred"
argument_list|,
literal|"Get the ucred of a SCTP connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|sctp_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return;
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now null out the reference, we are completely detached. */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|ip_inp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
name|uint32_t
name|flags
decl_stmt|;
endif|#
directive|endif
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|error
operator|=
name|SCTP_SORESERVE
argument_list|(
name|so
argument_list|,
name|sctp_sendspace
argument_list|,
name|sctp_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|error
operator|=
name|sctp_inpcb_alloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
name|error
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_BOUND_V6
expr_stmt|;
comment|/* I'm not v6! */
name|ip_inp
operator|=
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
name|ip_inp
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|ip_inp
operator|->
name|inp_ip_ttl
operator|=
name|ip_defttl
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
name|error
operator|=
name|ipsec_init_pcbpolicy
argument_list|(
name|so
argument_list|,
operator|&
name|ip_inp
operator|->
name|inp_sp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|15
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|&&
name|addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
comment|/* must be a v4 address! */
return|return
name|EINVAL
return|;
endif|#
directive|endif
comment|/* INET6 */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Inform all the lower layer assoc that we are done. 	 */
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_linger
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|14
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The socket is now detached, no matter what the state of 		 * the SCTP association. 		 */
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now null out the reference, we are completely detached. */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_function_decl
name|int
name|sctp_sendm
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|sctp_sendm
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
comment|/* Got to have an to address if we are NOT a connected socket */
if|if
condition|(
operator|(
name|addr
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|)
condition|)
block|{
goto|goto
name|connected_type
goto|;
block|}
elseif|else
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
comment|/* must be a v4 address! */
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|error
operator|=
name|EDESTADDRREQ
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
endif|#
directive|endif
comment|/* INET6 */
name|connected_type
label|:
comment|/* now what about control */
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|control
condition|)
block|{
name|printf
argument_list|(
literal|"huh? control set?\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|inp
operator|->
name|control
argument_list|)
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|inp
operator|->
name|control
operator|=
name|control
expr_stmt|;
block|}
comment|/* Place the data */
if|if
condition|(
name|inp
operator|->
name|pkt
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|inp
operator|->
name|pkt_last
argument_list|)
operator|=
name|m
expr_stmt|;
name|inp
operator|->
name|pkt_last
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|pkt_last
operator|=
name|inp
operator|->
name|pkt
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
comment|/* FreeBSD uses a flag passed */
operator|(
operator|(
name|flags
operator|&
name|PRUS_MORETOCOME
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * note with the current version this code will only be used 		 * by OpenBSD-- NetBSD, FreeBSD, and MacOS have methods for 		 * re-defining sosend to use the sctp_sosend. One can 		 * optionally switch back to this code (by changing back the 		 * definitions) but this is not advisable. This code is used 		 * by FreeBSD when sending a file with sendfile() though. 		 */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_output
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|pkt
argument_list|,
name|addr
argument_list|,
name|inp
operator|->
name|control
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|inp
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
if|if
condition|(
name|SCTP_LIST_EMPTY
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
condition|)
block|{
comment|/* No connection */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
condition|)
block|{
comment|/* We are about to be freed, out of here */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_linger
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
comment|/* Left with Data unread */
name|struct
name|mbuf
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
comment|/* No unlock tcb assoc is gone */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* there is nothing queued to send, so done */
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* only send SHUTDOWN 1st time thru */
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * we still got (or just got) data to send, 				 * so set SHUTDOWN_PENDING 				 */
comment|/* 				 * XXX sockets draft says that SCTP_EOF 				 * should be sent with no data. currently, 				 * we will allow user data to be sent first 				 * and move to SHUTDOWN-PENDING 				 */
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* Locked to send out the data */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error, sp is NULL, locked on sending is non-null strm:%d\n"
argument_list|,
name|asoc
operator|->
name|locked_on_sending
operator|->
name|stream_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_anyway
label|:
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_4
expr_stmt|;
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* not reached */
name|printf
argument_list|(
literal|"Not reached reached?\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* UDP model does not support this */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
block|}
end_function

begin_function
name|int
name|sctp_shutdown
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* For UDP model this is a invalid call */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
comment|/* Restore the flags that the soshutdown took away. */
name|so
operator|->
name|so_rcv
operator|.
name|sb_state
operator|&=
operator|~
name|SBS_CANTRCVMORE
expr_stmt|;
comment|/* This proc will wakeup for read and do nothing (I hope) */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOPNOTSUPP
operator|)
return|;
block|}
comment|/* 	 * Ok if we reach here its the TCP model and it is either a SHUT_WR 	 * or SHUT_RDWR. This means we put the shutdown flag against it. 	 */
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|socantsendmore
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Ok we hit the case that the shutdown call was 			 * made after an abort or something. Nothing to do 			 * now. 			 */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
goto|goto
name|abort_anyway
goto|;
block|}
comment|/* there is nothing queued to send, so I'm done... */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* only send SHUTDOWN the first time through */
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * we still got (or just got) data to send, so set 			 * SHUTDOWN_PENDING 			 */
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|locked_on_sending
condition|)
block|{
comment|/* Locked to send out the data */
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|sp
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|asoc
operator|->
name|locked_on_sending
operator|->
name|outqueue
argument_list|,
name|sctp_streamhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Error, sp is NULL, locked on sending is non-null strm:%d\n"
argument_list|,
name|asoc
operator|->
name|locked_on_sending
operator|->
name|stream_no
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|msg_is_complete
operator|==
literal|0
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_PARTIAL_MSG_LEFT
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_PARTIAL_MSG_LEFT
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|abort_anyway
label|:
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* Fill in the user initiated abort */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint32_t
modifier|*
name|ippp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
argument_list|)
expr_stmt|;
name|ippp
operator|=
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|ph
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|ippp
operator|=
name|htonl
argument_list|(
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|sctp_ep
operator|->
name|last_abort_code
operator|=
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_6
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_RESPONSE_TO_USER_REQ
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
goto|goto
name|skip_unlock
goto|;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|skip_unlock
label|:
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * copies a "user" presentable address and removes embedded scope, etc.  * returns 0 on success, 1 on error  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_fill_user_address
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|ss
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sockaddr_in6
name|lsa6
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sctp_recover_scope
argument_list|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
argument_list|,
operator|&
name|lsa6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ss
argument_list|,
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|sctp_fill_up_addresses_vrf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|sas
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|int
name|loopback_scope
decl_stmt|,
name|ipv4_local_scope
decl_stmt|,
name|local_scope
decl_stmt|,
name|site_scope
decl_stmt|;
name|size_t
name|actual
decl_stmt|;
name|int
name|ipv4_addr_legal
decl_stmt|,
name|ipv6_addr_legal
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
decl_stmt|;
name|actual
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
literal|0
condition|)
return|return
operator|(
name|actual
operator|)
return|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* Turn on all the appropriate scope */
name|loopback_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
expr_stmt|;
name|ipv4_local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
expr_stmt|;
name|local_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
expr_stmt|;
name|site_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
expr_stmt|;
block|}
else|else
block|{
comment|/* Turn on ALL scope, since we look at the EP */
name|loopback_scope
operator|=
name|ipv4_local_scope
operator|=
name|local_scope
operator|=
name|site_scope
operator|=
literal|1
expr_stmt|;
block|}
name|ipv4_addr_legal
operator|=
name|ipv6_addr_legal
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ipv6_addr_legal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|ipv4_addr_legal
operator|=
literal|1
expr_stmt|;
block|}
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* Skip loopback if loopback_scope not set */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* 					 * For the BOUND-ALL case, the list 					 * associated with a TCB is Always 					 * considered a reverse list.. i.e. 					 * it lists addresses that are NOT 					 * part of the association. If this 					 * is one of those we must skip it. 					 */
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
operator|(
name|ipv4_addr_legal
operator|)
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* 						 * we skip unspecifed 						 * addresses 						 */
continue|continue;
block|}
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
condition|)
block|{
name|in6_sin_2_v4mapsin6
argument_list|(
name|sin
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
operator|)
expr_stmt|;
name|actual
operator|+=
sizeof|sizeof
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|sas
argument_list|,
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
operator|)
expr_stmt|;
name|actual
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|actual
operator|>=
name|limit
condition|)
block|{
return|return
operator|(
name|actual
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|ipv6_addr_legal
operator|)
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 						 * we skip unspecifed 						 * addresses 						 */
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|local_scope
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sin6
operator|->
name|sin6_scope_id
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|!=
literal|0
condition|)
comment|/* 								 * bad link 								 * local 								 * address 								 */
continue|continue;
block|}
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
name|memcpy
argument_list|(
name|sas
argument_list|,
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
operator|)
expr_stmt|;
name|actual
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|actual
operator|>=
name|limit
condition|)
block|{
return|return
operator|(
name|actual
operator|)
return|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* The list is a NEGATIVE list */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
condition|)
block|{
continue|continue;
block|}
block|}
if|if
condition|(
name|sctp_fill_user_address
argument_list|(
name|sas
argument_list|,
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
condition|)
continue|continue;
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_len
operator|)
expr_stmt|;
name|actual
operator|+=
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_len
expr_stmt|;
if|if
condition|(
name|actual
operator|>=
name|limit
condition|)
block|{
return|return
operator|(
name|actual
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|actual
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|sctp_fill_up_addresses
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|size_t
name|limit
parameter_list|,
name|struct
name|sockaddr_storage
modifier|*
name|sas
parameter_list|)
block|{
name|size_t
name|size
init|=
literal|0
decl_stmt|;
comment|/* fill up addresses for the endpoint's default vrf */
name|size
operator|=
name|sctp_fill_up_addresses_vrf
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|limit
argument_list|,
name|sas
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_max_addresses_vrf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
comment|/* 	 * In both sub-set bound an bound_all cases we return the MAXIMUM 	 * number of addresses that you COULD get. In reality the sub-set 	 * bound may have an exclusion list for a given TCB OR in the 	 * bound-all case a TCB may NOT include the loopback or other 	 * addresses as well. 	 */
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
comment|/* Count them if they are the right type */
if|if
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
condition|)
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
condition|)
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
else|else
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
name|cnt
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_max_addresses
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* count addresses for the endpoint's default VRF */
name|cnt
operator|=
name|sctp_count_max_addresses_vrf
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|def_vrf_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|cnt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_do_connect_x
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
name|optsize
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|int
name|delay
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|creat_lock_on
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|num_v6
init|=
literal|0
decl_stmt|,
name|num_v4
init|=
literal|0
decl_stmt|,
modifier|*
name|totaddrp
decl_stmt|,
name|totaddr
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|incr
decl_stmt|,
name|at
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|sctp_assoc_t
modifier|*
name|a_id
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Connectx called\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|creat_lock_on
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|totaddrp
operator|=
operator|(
name|int
operator|*
operator|)
name|optval
expr_stmt|;
name|totaddr
operator|=
operator|*
name|totaddrp
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|totaddrp
operator|+
literal|1
operator|)
expr_stmt|;
name|at
operator|=
name|incr
operator|=
literal|0
expr_stmt|;
comment|/* account and validate addresses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|totaddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|num_v4
operator|++
expr_stmt|;
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* Must be non-mapped for connectx */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|num_v6
operator|++
expr_stmt|;
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|totaddr
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|creat_lock_on
operator|=
literal|0
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|EALREADY
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|at
operator|+
name|incr
operator|)
operator|>
name|optsize
condition|)
block|{
name|totaddr
operator|=
name|i
expr_stmt|;
break|break;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
name|incr
operator|)
expr_stmt|;
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|totaddrp
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_v6
operator|>
literal|0
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
operator|(
name|num_v4
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
comment|/* 			 * if IPV6_V6ONLY flag, ignore connections destined 			 * to a v4 addr or v4-mapped addr 			 */
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* Bind a ephemeral port */
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out_now
goto|;
block|}
block|}
comment|/* FIX ME: do we want to pass in a vrf on the connect call? */
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
comment|/* We are GOOD to go */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|sa
argument_list|,
literal|1
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Gak! no memory */
goto|goto
name|out_now
goto|;
block|}
comment|/* move to second address */
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
expr_stmt|;
else|else
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|totaddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
comment|/* assoc gone no un-lock */
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|incr
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_IS_CONFIRMED
argument_list|)
condition|)
block|{
comment|/* assoc gone no un-lock */
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOBUFS
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
block|}
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sa
operator|+
name|incr
operator|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
comment|/* Fill in the return id */
name|a_id
operator|=
operator|(
name|sctp_assoc_t
operator|*
operator|)
name|optval
expr_stmt|;
operator|*
name|a_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* initialize authentication parameters for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
condition|)
block|{
comment|/* doing delayed connection */
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|=
literal|1
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|out_now
label|:
if|if
condition|(
name|creat_lock_on
condition|)
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SCTP_FIND_STCB
parameter_list|(
name|inp
parameter_list|,
name|stcb
parameter_list|,
name|assoc_id
parameter_list|)
define|\
value|if (inp->sctp_flags& SCTP_PCB_FLAGS_CONNECTED) { \ 		SCTP_INP_RLOCK(inp); \ 		stcb = LIST_FIRST(&inp->sctp_asoc_list); \ 		if (stcb) \ 			SCTP_TCB_LOCK(stcb); \ 		SCTP_INP_RUNLOCK(inp); \ 	} else if (assoc_id != 0) { \ 		stcb = sctp_findassociation_ep_asocid(inp, assoc_id, 1); \ 		if (stcb == NULL) { \ 			error = ENOENT; \ 			break; \ 		} \ 	} else { \ 		stcb = NULL; \ 	}
end_define

begin_define
define|#
directive|define
name|SCTP_CHECK_AND_CAST
parameter_list|(
name|destp
parameter_list|,
name|srcp
parameter_list|,
name|type
parameter_list|,
name|size
parameter_list|)
define|\
value|if (size< sizeof(type)) { \ 		error = EINVAL; \ 		break; \ 	} else { \ 		destp = (type *)srcp; \ 	}
end_define

begin_function
specifier|static
name|int
name|sctp_getopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|optname
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
modifier|*
name|optsize
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|optval
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_NODELAY
case|:
case|case
name|SCTP_AUTOCLOSE
case|:
case|case
name|SCTP_EXPLICIT_EOR
case|:
case|case
name|SCTP_AUTO_ASCONF
case|:
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NO_FRAGMENT
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTO_ASCONF
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_EXPLICIT_EOR
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NODELAY
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_NODELAY
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
name|val
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_EXT_RCVINFO
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTOCLOSE
case|:
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
name|val
operator|=
name|TICKS_TO_SEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|auto_close_time
argument_list|)
expr_stmt|;
else|else
name|val
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
comment|/* end switch (sopt->sopt_name) */
if|if
condition|(
name|optname
operator|!=
name|SCTP_AUTOCLOSE
condition|)
block|{
comment|/* make it an "on/off" value */
name|val
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|optsize
operator|<
sizeof|sizeof
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* return the option value */
operator|*
operator|(
name|int
operator|*
operator|)
name|optval
operator|=
name|val
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_PARTIAL_DELIVERY_POINT
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|partial_delivery_point
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_FRAGMENT_INTERLEAVE
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_CMT_ON_OFF
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_ADDR_LEN
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|av
operator|->
name|assoc_value
operator|==
name|AF_INET
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|av
operator|->
name|assoc_value
operator|==
name|AF_INET6
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_ASOC_ID_LIST
case|:
block|{
name|struct
name|sctp_assoc_ids
modifier|*
name|ids
decl_stmt|;
name|int
name|cnt
decl_stmt|,
name|at
decl_stmt|;
name|uint16_t
name|orig
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ids
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_ids
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|none_out_now
label|:
name|ids
operator|->
name|asls_numb_present
operator|=
literal|0
expr_stmt|;
name|ids
operator|->
name|asls_more_to_get
operator|=
literal|0
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
name|orig
operator|=
name|ids
operator|->
name|asls_assoc_start
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|orig
condition|)
block|{
name|stcb
operator|=
name|LIST_NEXT
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
name|orig
operator|--
expr_stmt|;
name|cnt
operator|--
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
goto|goto
name|none_out_now
goto|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
goto|goto
name|none_out_now
goto|;
name|at
operator|=
literal|0
expr_stmt|;
name|ids
operator|->
name|asls_numb_present
operator|=
literal|0
expr_stmt|;
name|ids
operator|->
name|asls_more_to_get
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|at
operator|<
name|MAX_ASOC_IDS_RET
condition|)
block|{
name|ids
operator|->
name|asls_assoc_id
index|[
name|at
index|]
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|at
operator|++
expr_stmt|;
name|ids
operator|->
name|asls_numb_present
operator|++
expr_stmt|;
name|stcb
operator|=
name|LIST_NEXT
argument_list|(
name|stcb
argument_list|,
name|sctp_tcblist
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|ids
operator|->
name|asls_more_to_get
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_CONTEXT
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|context
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_context
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_VRF_ID
case|:
block|{
name|uint32_t
modifier|*
name|vrf_id
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|vrf_id
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
operator|*
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_ASOC_VRF
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|id
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|id
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|id
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|id
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_VRF_IDS
case|:
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_GET_NONCE_VALUES
case|:
block|{
name|struct
name|sctp_get_nonce_values
modifier|*
name|gnv
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|gnv
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_get_nonce_values
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|gnv
operator|->
name|gn_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|gnv
operator|->
name|gn_peers_tag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
expr_stmt|;
name|gnv
operator|->
name|gn_local_tag
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gnv
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_DELAYED_ACK_TIME
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|tm
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|tm
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|tm
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|tm
operator|->
name|assoc_value
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|tm
operator|->
name|assoc_value
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|tm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_SNDBUF_USE
case|:
block|{
name|struct
name|sctp_sockstat
modifier|*
name|ss
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ss
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sockstat
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ss
operator|->
name|ss_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|ss
operator|->
name|ss_total_sndbuf
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
expr_stmt|;
name|ss
operator|->
name|ss_total_recv_buf
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|size_on_reasm_queue
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|size_on_all_streams
operator|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sockstat
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_MAXBURST
case|:
block|{
name|uint8_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint8_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_burst
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint8_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_MAXSEG
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|int
name|ovh
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|av
operator|->
name|assoc_id
condition|)
block|{
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|av
operator|->
name|assoc_value
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
name|av
operator|->
name|assoc_value
operator|=
name|inp
operator|->
name|sctp_frag_point
operator|-
name|ovh
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_assoc_value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_STAT_LOG
case|:
ifdef|#
directive|ifdef
name|SCTP_STAT_LOGGING
name|error
operator|=
name|sctp_fill_stat_log
argument_list|(
name|optval
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SCTP_EVENTS
case|:
block|{
name|struct
name|sctp_event_subscribe
modifier|*
name|events
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|events
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_event_subscribe
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|events
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|events
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_data_io_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_association_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_address_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_send_failure_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
condition|)
name|events
operator|->
name|sctp_peer_error_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_shutdown_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_partial_delivery_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_adaptation_layer_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_authentication_event
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
condition|)
name|events
operator|->
name|sctp_stream_reset_events
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_event_subscribe
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_ADAPTATION_LAYER
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SET_INITIAL_DBG_SEQ
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_sequence_debug
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_LOCAL_ADDR_SIZE
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|sctp_count_max_addresses
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_REMOTE_ADDR_SIZE
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
comment|/* FIXME MT: change to sctp_assoc_value? */
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_assoc_t
operator|)
operator|*
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Count the sizes */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
operator|)
operator|||
operator|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* huh */
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
operator|(
name|uint32_t
operator|)
name|size
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_PEER_ADDRESSES
case|:
comment|/* 		 * Get the address information, an array is passed in to 		 * fill up we pack it. 		 */
block|{
name|size_t
name|cpsz
decl_stmt|,
name|left
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|sas
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_getaddresses
modifier|*
name|saddr
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|saddr
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|saddr
operator|->
name|sget_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|left
operator|=
operator|(
operator|*
name|optsize
operator|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_getaddresses
argument_list|)
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|saddr
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
operator|)
operator|||
operator|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|cpsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|cpsz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* huh */
break|break;
block|}
if|if
condition|(
name|left
operator|<
name|cpsz
condition|)
block|{
comment|/* not enough room. */
break|break;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
condition|)
block|{
comment|/* Must map the address */
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sas
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|sas
argument_list|,
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|cpsz
argument_list|)
expr_stmt|;
block|}
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sas
operator|)
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sas
operator|+
name|cpsz
operator|)
expr_stmt|;
name|left
operator|-=
name|cpsz
expr_stmt|;
operator|*
name|optsize
operator|+=
name|cpsz
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_GET_LOCAL_ADDRESSES
case|:
block|{
name|size_t
name|limit
decl_stmt|,
name|actual
decl_stmt|;
name|struct
name|sockaddr_storage
modifier|*
name|sas
decl_stmt|;
name|struct
name|sctp_getaddresses
modifier|*
name|saddr
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|saddr
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|saddr
operator|->
name|sget_assoc_id
argument_list|)
expr_stmt|;
name|sas
operator|=
operator|(
expr|struct
name|sockaddr_storage
operator|*
operator|)
operator|&
name|saddr
operator|->
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|limit
operator|=
operator|*
name|optsize
operator|-
sizeof|sizeof
argument_list|(
name|sctp_assoc_t
argument_list|)
expr_stmt|;
name|actual
operator|=
name|sctp_fill_up_addresses
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|limit
argument_list|,
name|sas
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
operator|+
name|actual
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_PEER_ADDR_PARAMS
case|:
block|{
name|struct
name|sctp_paddrparams
modifier|*
name|paddrp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|paddrp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrparams
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|paddrp
operator|->
name|spp_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* Applys to the specific association */
name|paddrp
operator|->
name|spp_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
name|net
operator|->
name|failure_threshold
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* get flags for HB */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOHB
condition|)
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_DISABLE
expr_stmt|;
else|else
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_ENABLE
expr_stmt|;
comment|/* get flags for PMTU */
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_ENABLE
expr_stmt|;
block|}
else|else
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_PMTUD_DISABLE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|paddrp
operator|->
name|spp_ipv4_tos
operator|=
name|net
operator|->
name|tos_flowlabel
operator|&
literal|0x000000fc
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV4_TOS
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|=
name|net
operator|->
name|tos_flowlabel
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV6_FLOWLABEL
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 					 * No destination so return default 					 * value 					 */
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmtu
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
name|paddrp
operator|->
name|spp_ipv4_tos
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_tos
operator|&
literal|0x000000fc
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV4_TOS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV6_FLOWLABEL
expr_stmt|;
endif|#
directive|endif
comment|/* default settings should be these */
if|if
condition|(
name|sctp_is_hb_timer_running
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_HB_ENABLE
expr_stmt|;
block|}
block|}
name|paddrp
operator|->
name|spp_hbinterval
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
expr_stmt|;
name|paddrp
operator|->
name|spp_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use endpoint defaults */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
expr_stmt|;
name|paddrp
operator|->
name|spp_hbinterval
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
argument_list|)
expr_stmt|;
name|paddrp
operator|->
name|spp_assoc_id
operator|=
operator|(
name|sctp_assoc_t
operator|)
literal|0
expr_stmt|;
comment|/* get inp's default */
ifdef|#
directive|ifdef
name|INET
name|paddrp
operator|->
name|spp_ipv4_tos
operator|=
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_ip_tos
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV4_TOS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|paddrp
operator|->
name|spp_ipv6_flowlabel
operator|=
operator|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
operator|)
operator|->
name|in6p_flowinfo
expr_stmt|;
name|paddrp
operator|->
name|spp_flags
operator||=
name|SPP_IPV6_FLOWLABEL
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* can't return this */
name|paddrp
operator|->
name|spp_pathmaxrxt
operator|=
literal|0
expr_stmt|;
name|paddrp
operator|->
name|spp_pathmtu
operator|=
literal|0
expr_stmt|;
comment|/* default behavior, no stcb */
name|paddrp
operator|->
name|spp_flags
operator|=
name|SPP_HB_ENABLE
operator||
name|SPP_PMTUD_ENABLE
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddrparams
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_GET_PEER_ADDR_INFO
case|:
block|{
name|struct
name|sctp_paddrinfo
modifier|*
name|paddri
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|paddri
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|paddri
operator|->
name|spinfo_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddri
operator|->
name|spinfo_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddri
operator|->
name|spinfo_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|net
operator|)
condition|)
block|{
name|paddri
operator|->
name|spinfo_state
operator|=
name|net
operator|->
name|dest_state
operator|&
operator|(
name|SCTP_REACHABLE_MASK
operator||
name|SCTP_ADDR_NOHB
operator|)
expr_stmt|;
name|paddri
operator|->
name|spinfo_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|paddri
operator|->
name|spinfo_srtt
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
name|paddri
operator|->
name|spinfo_rto
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
name|paddri
operator|->
name|spinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paddrinfo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_PCB_STATUS
case|:
block|{
name|struct
name|sctp_pcbinfo
modifier|*
name|spcb
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|spcb
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_pcbinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|sctp_fill_pcbinfo
argument_list|(
name|spcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pcbinfo
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_STATUS
case|:
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_status
modifier|*
name|sstat
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sstat
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_status
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sstat
operator|->
name|sstat_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 			 * I think passing the state is fine since 			 * sctp_constants.h will be available to the user 			 * land. 			 */
name|sstat
operator|->
name|sstat_state
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|state
expr_stmt|;
name|sstat
operator|->
name|sstat_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
name|sstat
operator|->
name|sstat_unackdata
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
expr_stmt|;
comment|/* 			 * We can't include chunks that have been passed to 			 * the socket layer. Only things in queue. 			 */
name|sstat
operator|->
name|sstat_penddata
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|cnt_on_reasm_queue
operator|+
name|stcb
operator|->
name|asoc
operator|.
name|cnt_on_all_streams
operator|)
expr_stmt|;
name|sstat
operator|->
name|sstat_instrms
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
expr_stmt|;
name|sstat
operator|->
name|sstat_outstrms
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
name|sstat
operator|->
name|sstat_fragmentation_point
operator|=
name|sctp_get_frag_point
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_address
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_address
operator|)
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
comment|/* 			 * Again the user can get info from sctp_constants.h 			 * for what the state of the network is. 			 */
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_state
operator|=
name|net
operator|->
name|dest_state
operator|&
name|SCTP_REACHABLE_MASK
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_srtt
operator|=
name|net
operator|->
name|lastsa
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_rto
operator|=
name|net
operator|->
name|RTO
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_mtu
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
name|sstat
operator|->
name|sstat_primary
operator|.
name|spinfo_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sstat
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_RTOINFO
case|:
block|{
name|struct
name|sctp_rtoinfo
modifier|*
name|srto
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|srto
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_rtoinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|srto
operator|->
name|srto_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|srto
operator|->
name|srto_initial
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
expr_stmt|;
name|srto
operator|->
name|srto_max
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
expr_stmt|;
name|srto
operator|->
name|srto_min
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|minrto
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|srto
operator|->
name|srto_initial
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_rto
expr_stmt|;
name|srto
operator|->
name|srto_max
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
expr_stmt|;
name|srto
operator|->
name|srto_min
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|srto
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_ASSOCINFO
case|:
block|{
name|struct
name|sctp_assocparams
modifier|*
name|sasoc
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sasoc
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assocparams
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sasoc
operator|->
name|sasoc_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sasoc
operator|->
name|sasoc_asocmaxrxt
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
expr_stmt|;
name|sasoc
operator|->
name|sasoc_number_peer_destinations
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|numnets
expr_stmt|;
name|sasoc
operator|->
name|sasoc_peer_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
expr_stmt|;
name|sasoc
operator|->
name|sasoc_local_rwnd
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|my_rwnd
expr_stmt|;
name|sasoc
operator|->
name|sasoc_cookie_life
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cookie_life
expr_stmt|;
name|sasoc
operator|->
name|sasoc_sack_delay
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
expr_stmt|;
name|sasoc
operator|->
name|sasoc_sack_freq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sasoc
operator|->
name|sasoc_asocmaxrxt
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_send_times
expr_stmt|;
name|sasoc
operator|->
name|sasoc_number_peer_destinations
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_peer_rwnd
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_local_rwnd
operator|=
name|sbspace
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
name|sasoc
operator|->
name|sasoc_cookie_life
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
expr_stmt|;
name|sasoc
operator|->
name|sasoc_sack_delay
operator|=
name|TICKS_TO_MSEC
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
argument_list|)
expr_stmt|;
name|sasoc
operator|->
name|sasoc_sack_freq
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_sack_freq
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sasoc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_DEFAULT_SEND_PARAM
case|:
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|s_info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|s_info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sndrcvinfo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|s_info
operator|->
name|sinfo_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
operator|*
name|s_info
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|def_send
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|s_info
operator|=
name|inp
operator|->
name|def_send
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|s_info
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_INITMSG
case|:
block|{
name|struct
name|sctp_initmsg
modifier|*
name|sinit
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sinit
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_initmsg
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sinit
operator|->
name|sinit_num_ostreams
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
expr_stmt|;
name|sinit
operator|->
name|sinit_max_instreams
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
expr_stmt|;
name|sinit
operator|->
name|sinit_max_attempts
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|max_init_times
expr_stmt|;
name|sinit
operator|->
name|sinit_max_init_timeo
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_init_rto_max
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sinit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_PRIMARY_ADDR
case|:
comment|/* we allow a "get" operation on this */
block|{
name|struct
name|sctp_setprim
modifier|*
name|ssp
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ssp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setprim
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ssp
operator|->
name|ssp_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* simply copy out the sockaddr_storage... */
name|memcpy
argument_list|(
operator|&
name|ssp
operator|->
name|ssp_addr
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ssp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_HMAC_IDENT
case|:
block|{
name|struct
name|sctp_hmacalgo
modifier|*
name|shmac
decl_stmt|;
name|sctp_hmaclist_t
modifier|*
name|hmaclist
decl_stmt|;
name|uint32_t
name|size
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|shmac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_hmacalgo
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|hmaclist
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
expr_stmt|;
if|if
condition|(
name|hmaclist
operator|==
name|NULL
condition|)
block|{
comment|/* no HMACs to return */
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|shmac
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* is there room for all of the hmac ids? */
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|shmac
argument_list|)
operator|+
operator|(
name|hmaclist
operator|->
name|num_algo
operator|*
sizeof|sizeof
argument_list|(
name|shmac
operator|->
name|shmac_idents
index|[
literal|0
index|]
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
operator|*
name|optsize
argument_list|)
operator|<
name|size
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* copy in the list */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hmaclist
operator|->
name|num_algo
condition|;
name|i
operator|++
control|)
name|shmac
operator|->
name|shmac_idents
index|[
name|i
index|]
operator|=
name|hmaclist
operator|->
name|hmac
index|[
name|i
index|]
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|*
name|optsize
operator|=
name|size
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_AUTH_ACTIVE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|scact
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|scact
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|scact
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* get the active key on the assoc */
name|scact
operator|->
name|scact_keynumber
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|authinfo
operator|.
name|assoc_keyid
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get the endpoint active key */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|scact
operator|->
name|scact_keynumber
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|default_keyid
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|scact
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_LOCAL_AUTH_CHUNKS
case|:
block|{
name|struct
name|sctp_authchunks
modifier|*
name|sac
decl_stmt|;
name|sctp_auth_chklist_t
modifier|*
name|chklist
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authchunks
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sac
operator|->
name|gauth_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* get off the assoc */
name|chklist
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
expr_stmt|;
comment|/* is there enough space? */
name|size
operator|=
name|sctp_auth_get_chklist_size
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* copy in the chunks */
name|sctp_serialize_auth_chunks
argument_list|(
name|chklist
argument_list|,
name|sac
operator|->
name|gauth_chunks
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get off the endpoint */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|chklist
operator|=
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
expr_stmt|;
comment|/* is there enough space? */
name|size
operator|=
name|sctp_auth_get_chklist_size
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* copy in the chunks */
name|sctp_serialize_auth_chunks
argument_list|(
name|chklist
argument_list|,
name|sac
operator|->
name|gauth_chunks
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_PEER_AUTH_CHUNKS
case|:
block|{
name|struct
name|sctp_authchunks
modifier|*
name|sac
decl_stmt|;
name|sctp_auth_chklist_t
modifier|*
name|chklist
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
init|=
literal|0
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authchunks
argument_list|,
operator|*
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sac
operator|->
name|gauth_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* get off the assoc */
name|chklist
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|peer_auth_chunks
expr_stmt|;
comment|/* is there enough space? */
name|size
operator|=
name|sctp_auth_get_chklist_size
argument_list|(
name|chklist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
comment|/* copy in the chunks */
name|sctp_serialize_auth_chunks
argument_list|(
name|chklist
argument_list|,
name|sac
operator|->
name|gauth_chunks
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
block|}
operator|*
name|optsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_authchunks
argument_list|)
operator|+
name|size
expr_stmt|;
break|break;
block|}
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
operator|*
name|optsize
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* end switch (sopt->sopt_name) */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_setopt
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|optname
parameter_list|,
name|void
modifier|*
name|optval
parameter_list|,
name|size_t
name|optsize
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|set_opt
decl_stmt|;
name|uint32_t
modifier|*
name|mopt
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
if|if
condition|(
name|optval
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"optval is NULL\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"inp is NULL?\n"
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_NODELAY
case|:
case|case
name|SCTP_AUTOCLOSE
case|:
case|case
name|SCTP_AUTO_ASCONF
case|:
case|case
name|SCTP_EXPLICIT_EOR
case|:
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
comment|/* copy in the option value */
name|SCTP_CHECK_AND_CAST
argument_list|(
name|mopt
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|set_opt
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
switch|switch
condition|(
name|optname
condition|)
block|{
case|case
name|SCTP_DISABLE_FRAGMENTS
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_NO_FRAGMENT
expr_stmt|;
break|break;
case|case
name|SCTP_AUTO_ASCONF
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_AUTO_ASCONF
expr_stmt|;
break|break;
case|case
name|SCTP_EXPLICIT_EOR
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_EXPLICIT_EOR
expr_stmt|;
break|break;
case|case
name|SCTP_USE_EXT_RCVINFO
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_EXT_RCVINFO
expr_stmt|;
break|break;
case|case
name|SCTP_I_WANT_MAPPED_V4_ADDR
case|:
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_NEEDS_MAPPED_V4
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_NODELAY
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_NODELAY
expr_stmt|;
break|break;
case|case
name|SCTP_AUTOCLOSE
case|:
name|set_opt
operator|=
name|SCTP_PCB_FLAGS_AUTOCLOSE
expr_stmt|;
comment|/* 			 * The value is in ticks. Note this does not effect 			 * old associations, only new ones. 			 */
name|inp
operator|->
name|sctp_ep
operator|.
name|auto_close_time
operator|=
name|SEC_TO_TICKS
argument_list|(
operator|*
name|mopt
argument_list|)
expr_stmt|;
break|break;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mopt
operator|!=
literal|0
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|set_opt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|set_opt
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_PARTIAL_DELIVERY_POINT
case|:
block|{
name|uint32_t
modifier|*
name|value
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|value
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|>
name|SCTP_SB_LIMIT_RCV
argument_list|(
name|so
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|inp
operator|->
name|partial_delivery_point
operator|=
operator|*
name|value
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_FRAGMENT_INTERLEAVE
case|:
comment|/* not yet until we re-write sctp_recvmsg() */
block|{
name|uint32_t
modifier|*
name|on_off
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|on_off
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|on_off
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_FRAG_INTERLEAVE
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_CMT_ON_OFF
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_cmt_on_off
condition|)
block|{
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sctp_cmt_on_off
operator|=
operator|(
name|uint8_t
operator|)
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|ENOTCONN
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_CLR_STAT_LOG
case|:
ifdef|#
directive|ifdef
name|SCTP_STAT_LOGGING
name|sctp_clr_stat_log
argument_list|()
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|SCTP_CONTEXT
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|context
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_context
operator|=
name|av
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_VRF_ID
case|:
block|{
name|uint32_t
modifier|*
name|vrf_id
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|vrf_id
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vrf_id
operator|>
name|SCTP_MAX_VRF_ID
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|inp
operator|->
name|def_vrf_id
operator|=
operator|*
name|vrf_id
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_DEL_VRF_ID
case|:
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_ADD_VRF_ID
case|:
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_DELAYED_ACK_TIME
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|tm
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|tm
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|tm
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|=
name|tm
operator|->
name|assoc_value
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|tm
operator|->
name|assoc_value
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_AUTH_CHUNK
case|:
block|{
name|struct
name|sctp_authchunk
modifier|*
name|sauth
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sauth
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authchunk
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_auth_add_chunk
argument_list|(
name|sauth
operator|->
name|sauth_chunk
argument_list|,
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SCTP_AUTH_KEY
case|:
block|{
name|struct
name|sctp_authkey
modifier|*
name|sca
decl_stmt|;
name|struct
name|sctp_keyhead
modifier|*
name|shared_keys
decl_stmt|;
name|sctp_sharedkey_t
modifier|*
name|shared_key
decl_stmt|;
name|sctp_key_t
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sca
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkey
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
argument|inp
argument_list|,
argument|stcb
argument_list|,
argument|sca->sca_assoc_id
argument_list|)
name|size
operator|=
name|optsize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|sca
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* set it on the assoc */
name|shared_keys
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|shared_keys
expr_stmt|;
comment|/* clear the cached keys for this key id */
name|sctp_clear_cachedkeys
argument_list|(
name|stcb
argument_list|,
name|sca
operator|->
name|sca_keynumber
argument_list|)
expr_stmt|;
comment|/* 				 * create the new shared key and 				 * insert/replace it 				 */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|sctp_set_key
argument_list|(
name|sca
operator|->
name|sca_key
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|shared_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|shared_key
operator|==
name|NULL
condition|)
block|{
name|sctp_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
name|shared_key
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|shared_key
operator|->
name|keyid
operator|=
name|sca
operator|->
name|sca_keynumber
expr_stmt|;
name|sctp_insert_sharedkey
argument_list|(
name|shared_keys
argument_list|,
name|shared_key
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set it on the endpoint */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|shared_keys
operator|=
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
expr_stmt|;
comment|/* 				 * clear the cached keys on all assocs for 				 * this key id 				 */
name|sctp_clear_cachedkeys_ep
argument_list|(
name|inp
argument_list|,
name|sca
operator|->
name|sca_keynumber
argument_list|)
expr_stmt|;
comment|/* 				 * create the new shared key and 				 * insert/replace it 				 */
if|if
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|key
operator|=
name|sctp_set_key
argument_list|(
name|sca
operator|->
name|sca_key
argument_list|,
operator|(
name|uint32_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|shared_key
operator|=
name|sctp_alloc_sharedkey
argument_list|()
expr_stmt|;
if|if
condition|(
name|shared_key
operator|==
name|NULL
condition|)
block|{
name|sctp_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
break|break;
block|}
name|shared_key
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|shared_key
operator|->
name|keyid
operator|=
name|sca
operator|->
name|sca_keynumber
expr_stmt|;
name|sctp_insert_sharedkey
argument_list|(
name|shared_keys
argument_list|,
name|shared_key
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_HMAC_IDENT
case|:
block|{
name|struct
name|sctp_hmacalgo
modifier|*
name|shmac
decl_stmt|;
name|sctp_hmaclist_t
modifier|*
name|hmaclist
decl_stmt|;
name|uint32_t
name|hmacid
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|i
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|shmac
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_hmacalgo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|optsize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|shmac
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|shmac
operator|->
name|shmac_idents
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|hmaclist
operator|=
name|sctp_alloc_hmaclist
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|hmaclist
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|hmacid
operator|=
name|shmac
operator|->
name|shmac_idents
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sctp_auth_add_hmacid
argument_list|(
name|hmaclist
argument_list|,
operator|(
name|uint16_t
operator|)
name|hmacid
argument_list|)
condition|)
block|{
comment|/* invalid HMACs were found */
empty_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
name|sctp_free_hmaclist
argument_list|(
name|hmaclist
argument_list|)
expr_stmt|;
goto|goto
name|sctp_set_hmac_done
goto|;
block|}
block|}
comment|/* set it on the endpoint */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
operator|=
name|hmaclist
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sctp_set_hmac_done
label|:
break|break;
block|}
case|case
name|SCTP_AUTH_ACTIVE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|scact
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|scact
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|scact
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
comment|/* set the active key on the right place */
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* set the active key on the assoc */
if|if
condition|(
name|sctp_auth_setactivekey
argument_list|(
name|stcb
argument_list|,
name|scact
operator|->
name|scact_keynumber
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set the active key on the endpoint */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_auth_setactivekey_ep
argument_list|(
name|inp
argument_list|,
name|scact
operator|->
name|scact_keynumber
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_AUTH_DELETE_KEY
case|:
block|{
name|struct
name|sctp_authkeyid
modifier|*
name|scdel
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|scdel
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_authkeyid
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|scdel
operator|->
name|scact_assoc_id
argument_list|)
expr_stmt|;
comment|/* delete the key from the right place */
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_delete_sharedkey
argument_list|(
name|stcb
argument_list|,
name|scdel
operator|->
name|scact_keynumber
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_delete_sharedkey_ep
argument_list|(
name|inp
argument_list|,
name|scdel
operator|->
name|scact_keynumber
argument_list|)
condition|)
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|SCTP_RESET_STREAMS
case|:
block|{
name|struct
name|sctp_stream_reset
modifier|*
name|strrst
decl_stmt|;
name|uint8_t
name|send_in
init|=
literal|0
decl_stmt|,
name|send_tsn
init|=
literal|0
decl_stmt|,
name|send_out
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|strrst
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_stream_reset
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|strrst
operator|->
name|strrst_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Peer does not support it, we return 				 * protocol not supported since this is true 				 * for this feature and this peer, not the 				 * socket request in general. 				 */
name|error
operator|=
name|EPROTONOSUPPORT
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
condition|)
block|{
name|error
operator|=
name|EALREADY
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_LOCAL_RECV
condition|)
block|{
name|send_in
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_LOCAL_SEND
condition|)
block|{
name|send_out
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_BOTH
condition|)
block|{
name|send_in
operator|=
literal|1
expr_stmt|;
name|send_out
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strrst
operator|->
name|strrst_flags
operator|==
name|SCTP_RESET_TSN
condition|)
block|{
name|send_tsn
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strrst
operator|->
name|strrst_num_streams
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|send_in
operator|)
operator|&&
operator|(
name|strrst
operator|->
name|strrst_list
index|[
name|i
index|]
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|get_out
goto|;
block|}
if|if
condition|(
operator|(
name|send_out
operator|)
operator|&&
operator|(
name|strrst
operator|->
name|strrst_list
index|[
name|i
index|]
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|get_out
goto|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
name|get_out
label|:
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_send_str_reset_req
argument_list|(
name|stcb
argument_list|,
name|strrst
operator|->
name|strrst_num_streams
argument_list|,
name|strrst
operator|->
name|strrst_list
argument_list|,
name|send_out
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_in
operator|-
literal|3
operator|)
argument_list|,
name|send_in
argument_list|,
name|send_tsn
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_STRRST_REQ
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_CONNECT_X
case|:
if|if
condition|(
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_do_connect_x
argument_list|(
name|so
argument_list|,
name|inp
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CONNECT_X_DELAYED
case|:
if|if
condition|(
name|optsize
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_do_connect_x
argument_list|(
name|so
argument_list|,
name|inp
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CONNECT_X_COMPLETE
case|:
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* FIXME MT: check correct? */
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sa
argument_list|,
name|optval
argument_list|,
expr|struct
name|sockaddr
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
comment|/* find tcb */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|==
literal|1
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|delayed_connection
operator|=
literal|0
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * already expired or did not use delayed 				 * connectx 				 */
name|error
operator|=
name|EALREADY
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_MAXBURST
case|:
block|{
name|uint8_t
modifier|*
name|burst
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|burst
argument_list|,
name|optval
argument_list|,
name|uint8_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|burst
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|max_burst
operator|=
operator|*
name|burst
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_MAXSEG
case|:
block|{
name|struct
name|sctp_assoc_value
modifier|*
name|av
decl_stmt|;
name|int
name|ovh
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|av
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assoc_value
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|av
operator|->
name|assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
condition|)
block|{
name|ovh
operator|=
name|SCTP_MED_OVERHEAD
expr_stmt|;
block|}
else|else
block|{
name|ovh
operator|=
name|SCTP_MED_V4_OVERHEAD
expr_stmt|;
block|}
comment|/* 				 * FIXME MT: I think this is not in tune 				 * with the API ID 				 */
if|if
condition|(
name|av
operator|->
name|assoc_value
condition|)
block|{
name|inp
operator|->
name|sctp_frag_point
operator|=
operator|(
name|av
operator|->
name|assoc_value
operator|+
name|ovh
operator|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_EVENTS
case|:
block|{
name|struct
name|sctp_event_subscribe
modifier|*
name|events
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|events
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_event_subscribe
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|events
operator|->
name|sctp_data_io_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVDATAIOEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_association_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVASSOCEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_address_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPADDREVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_send_failure_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSENDFAILEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_peer_error_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVPEERERR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_shutdown_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_RECVSHUTDOWNEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_partial_delivery_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_PDAPIEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_adaptation_layer_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_ADAPTATIONEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_authentication_event
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTHEVNT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|events
operator|->
name|sctp_stream_reset_events
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_STREAM_RESETEVNT
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_ADAPTATION_LAYER
case|:
block|{
name|struct
name|sctp_setadaptation
modifier|*
name|adap_bits
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|adap_bits
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setadaptation
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|adaptation_layer_indicator
operator|=
name|adap_bits
operator|->
name|ssb_adaptation_ind
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
case|case
name|SCTP_SET_INITIAL_DBG_SEQ
case|:
block|{
name|uint32_t
modifier|*
name|vvv
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|vvv
argument_list|,
name|optval
argument_list|,
name|uint32_t
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_sequence_debug
operator|=
operator|*
name|vvv
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SCTP_DEFAULT_SEND_PARAM
case|:
block|{
name|struct
name|sctp_sndrcvinfo
modifier|*
name|s_info
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|s_info
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_sndrcvinfo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|s_info
operator|->
name|sinfo_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|s_info
operator|->
name|sinfo_stream
operator|<=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|def_send
operator|=
operator|*
name|s_info
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|def_send
operator|=
operator|*
name|s_info
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_PEER_ADDR_PARAMS
case|:
comment|/* Applys to the specific association */
block|{
name|struct
name|sctp_paddrparams
modifier|*
name|paddrp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|paddrp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_paddrparams
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|paddrp
operator|->
name|spp_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|paddrp
operator|->
name|spp_address
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
condition|)
block|{
comment|/************************TCB SPECIFIC SET ******************/
comment|/* 				 * do we change the timer for HB, we run 				 * only one? 				 */
if|if
condition|(
name|paddrp
operator|->
name|spp_hbinterval
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
operator|=
name|paddrp
operator|->
name|spp_hbinterval
expr_stmt|;
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_TIME_IS_ZERO
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|heart_beat_delay
operator|=
literal|0
expr_stmt|;
comment|/* network sets ? */
if|if
condition|(
name|net
condition|)
block|{
comment|/************************NET SPECIFIC SET ******************/
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DEMAND
condition|)
block|{
comment|/* on demand HB */
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOHB
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_DISABLE
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmtu
operator|>
name|SCTP_DEFAULT_MINSEGMENT
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|paddrp
operator|->
name|spp_pathmtu
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|mtu
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
condition|)
name|sctp_pathmtu_adjustment
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_PMTUD_ENABLE
condition|)
block|{
if|if
condition|(
name|SCTP_OS_TIMER_PENDING
argument_list|(
operator|&
name|net
operator|->
name|pmtu_timer
operator|.
name|timer
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
name|net
operator|->
name|failure_threshold
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV4_TOS
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|net
operator|->
name|tos_flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv4_tos
operator|&
literal|0x000000fc
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV6_FLOWLABEL
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sin6
operator|.
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|net
operator|->
name|tos_flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv6_flowlabel
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
else|else
block|{
comment|/************************ASSOC ONLY -- NO NET SPECIFIC SET ******************/
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|def_net_failure
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
comment|/* Turn back on the timer */
name|stcb
operator|->
name|asoc
operator|.
name|hb_is_disabled
operator|=
literal|0
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
condition|)
block|{
name|int
name|cnt_of_unconf
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|hb_is_disabled
operator|=
literal|1
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|lnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|cnt_of_unconf
operator|++
expr_stmt|;
block|}
block|}
comment|/* 						 * stop the timer ONLY if we 						 * have no unconfirmed 						 * addresses 						 */
if|if
condition|(
name|cnt_of_unconf
operator|==
literal|0
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_11
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
comment|/* start up the timer. */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV4_TOS
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|default_tos
operator|=
name|paddrp
operator|->
name|spp_ipv4_tos
operator|&
literal|0x000000fc
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_IPV6_FLOWLABEL
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|default_flowlabel
operator|=
name|paddrp
operator|->
name|spp_ipv6_flowlabel
expr_stmt|;
endif|#
directive|endif
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/************************NO TCB, SET TO default stuff ******************/
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 				 * For the TOS/FLOWLABEL stuff you set it 				 * with the options on the socket 				 */
if|if
condition|(
name|paddrp
operator|->
name|spp_pathmaxrxt
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|def_net_failure
operator|=
name|paddrp
operator|->
name|spp_pathmaxrxt
expr_stmt|;
block|}
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_ENABLE
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_HEARTBEAT
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|paddrp
operator|->
name|spp_hbinterval
argument_list|)
expr_stmt|;
name|sctp_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|paddrp
operator|->
name|spp_flags
operator|&
name|SPP_HB_DISABLE
condition|)
block|{
name|sctp_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DONOT_HEARTBEAT
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_RTOINFO
case|:
block|{
name|struct
name|sctp_rtoinfo
modifier|*
name|srto
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|srto
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_rtoinfo
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|srto
operator|->
name|srto_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* Set in ms we hope :-) */
if|if
condition|(
name|srto
operator|->
name|srto_initial
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|initial_rto
operator|=
name|srto
operator|->
name|srto_initial
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_max
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|maxrto
operator|=
name|srto
operator|->
name|srto_max
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_min
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|minrto
operator|=
name|srto
operator|->
name|srto_min
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 				 * If we have a null asoc, its default for 				 * the endpoint 				 */
if|if
condition|(
name|srto
operator|->
name|srto_initial
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_rto
operator|=
name|srto
operator|->
name|srto_initial
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_max
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_maxrto
operator|=
name|srto
operator|->
name|srto_max
expr_stmt|;
if|if
condition|(
name|srto
operator|->
name|srto_min
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_minrto
operator|=
name|srto
operator|->
name|srto_min
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_ASSOCINFO
case|:
block|{
name|struct
name|sctp_assocparams
modifier|*
name|sasoc
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sasoc
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_assocparams
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sasoc
operator|->
name|sasoc_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sasoc
operator|->
name|sasoc_asocmaxrxt
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
operator|=
name|sasoc
operator|->
name|sasoc_asocmaxrxt
expr_stmt|;
name|sasoc
operator|->
name|sasoc_number_peer_destinations
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|numnets
expr_stmt|;
name|sasoc
operator|->
name|sasoc_peer_rwnd
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_local_rwnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|cookie_life
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|cookie_life
operator|=
name|sasoc
operator|->
name|sasoc_cookie_life
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|delayed_ack
operator|=
name|sasoc
operator|->
name|sasoc_sack_delay
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_sack_freq
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|sack_freq
operator|=
name|sasoc
operator|->
name|sasoc_sack_freq
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_asocmaxrxt
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|max_send_times
operator|=
name|sasoc
operator|->
name|sasoc_asocmaxrxt
expr_stmt|;
name|sasoc
operator|->
name|sasoc_number_peer_destinations
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_peer_rwnd
operator|=
literal|0
expr_stmt|;
name|sasoc
operator|->
name|sasoc_local_rwnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_cookie_life
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|def_cookie_life
operator|=
name|sasoc
operator|->
name|sasoc_cookie_life
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_timeoutticks
index|[
name|SCTP_TIMER_RECV
index|]
operator|=
name|MSEC_TO_TICKS
argument_list|(
name|sasoc
operator|->
name|sasoc_sack_delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|sasoc
operator|->
name|sasoc_sack_freq
condition|)
block|{
name|inp
operator|->
name|sctp_ep
operator|.
name|sctp_sack_freq
operator|=
name|sasoc
operator|->
name|sasoc_sack_freq
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_INITMSG
case|:
block|{
name|struct
name|sctp_initmsg
modifier|*
name|sinit
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sinit
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_initmsg
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_num_ostreams
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|pre_open_stream_count
operator|=
name|sinit
operator|->
name|sinit_num_ostreams
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_max_instreams
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|max_open_streams_intome
operator|=
name|sinit
operator|->
name|sinit_max_instreams
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_max_attempts
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|max_init_times
operator|=
name|sinit
operator|->
name|sinit_max_attempts
expr_stmt|;
if|if
condition|(
name|sinit
operator|->
name|sinit_max_init_timeo
condition|)
name|inp
operator|->
name|sctp_ep
operator|.
name|initial_init_rto_max
operator|=
name|sinit
operator|->
name|sinit_max_init_timeo
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_PRIMARY_ADDR
case|:
block|{
name|struct
name|sctp_setprim
modifier|*
name|spa
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|,
modifier|*
name|lnet
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|spa
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setprim
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|spa
operator|->
name|ssp_assoc_id
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spa
operator|->
name|ssp_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * We increment here since 				 * sctp_findassociation_ep_addr() wil do a 				 * decrement if it finds the stcb as long as 				 * the locked tcb (last argument) is NOT a 				 * TCB.. aka NULL. 				 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|spa
operator|->
name|ssp_addr
argument_list|,
operator|&
name|net
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|net
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|)
operator|&&
operator|(
operator|!
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
condition|)
block|{
comment|/* Ok we need to set it */
name|lnet
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
if|if
condition|(
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|net
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_SWITCH_PRIMARY
condition|)
block|{
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_DOUBLE_SWITCH
expr_stmt|;
block|}
name|net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_SWITCH_PRIMARY
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_SET_DYNAMIC_PRIMARY
case|:
block|{
name|union
name|sctp_sockstore
modifier|*
name|ss
decl_stmt|;
name|error
operator|=
name|priv_check_cred
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|,
name|PRIV_NETINET_RESERVEDPORT
argument_list|,
name|SUSER_ALLOWJAIL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|ss
argument_list|,
name|optval
argument_list|,
expr|union
name|sctp_sockstore
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
comment|/* SUPER USER CHECK? */
name|error
operator|=
name|sctp_dynamic_set_primary
argument_list|(
operator|&
name|ss
operator|->
name|sa
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SET_PEER_PRIMARY_ADDR
case|:
block|{
name|struct
name|sctp_setpeerprim
modifier|*
name|sspp
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|sspp
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_setpeerprim
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FIND_STCB
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|sspp
operator|->
name|sspp_assoc_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|sctp_set_primary_ip_address_sa
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sspp
operator|->
name|sspp_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_BINDX_ADD_ADDR
case|:
block|{
name|struct
name|sctp_getaddresses
modifier|*
name|addrs
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr_touse
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|addrs
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
comment|/* see if we're bound all already! */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* Is the VRF one we have */
name|addr_touse
operator|=
name|addrs
operator|->
name|addr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|addrs
operator|->
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_touse
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* Can't get proc for Net/Open BSD */
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr_touse
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * No locks required here since bind and mgmt_ep_sa 			 * all do their own locking. If we do something for 			 * the FIX: below we may need to lock in that case. 			 */
if|if
condition|(
name|addrs
operator|->
name|sget_assoc_id
operator|==
literal|0
condition|)
block|{
comment|/* add the address */
name|struct
name|sctp_inpcb
modifier|*
name|lep
decl_stmt|;
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_touse
operator|)
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
name|lep
operator|=
name|sctp_pcb_findep
argument_list|(
name|addr_touse
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|lep
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * We must decrement the refcount 					 * since we have the ep already and 					 * are binding. No remove going on 					 * here. 					 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lep
operator|==
name|inp
condition|)
block|{
comment|/* already bound to it.. ok */
break|break;
block|}
elseif|else
if|if
condition|(
name|lep
operator|==
name|NULL
condition|)
block|{
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr_touse
operator|)
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sctp_addr_mgmt_ep_sa
argument_list|(
name|inp
argument_list|,
name|addr_touse
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EADDRNOTAVAIL
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
else|else
block|{
comment|/* 				 * FIX: decide whether we allow assoc based 				 * bindx 				 */
block|}
block|}
break|break;
case|case
name|SCTP_BINDX_REM_ADDR
case|:
block|{
name|struct
name|sctp_getaddresses
modifier|*
name|addrs
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|addr_touse
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|SCTP_CHECK_AND_CAST
argument_list|(
name|addrs
argument_list|,
name|optval
argument_list|,
expr|struct
name|sctp_getaddresses
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
comment|/* see if we're bound all already! */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|addr_touse
operator|=
name|addrs
operator|->
name|addr
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
name|addrs
operator|->
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr_touse
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr_touse
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* 			 * No lock required mgmt_ep_sa does its own locking. 			 * If the FIX: below is ever changed we may need to 			 * lock before calling association level binding. 			 */
if|if
condition|(
name|addrs
operator|->
name|sget_assoc_id
operator|==
literal|0
condition|)
block|{
comment|/* delete the address */
name|sctp_addr_mgmt_ep_sa
argument_list|(
name|inp
argument_list|,
name|addr_touse
argument_list|,
name|SCTP_DEL_IP_ADDRESS
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * FIX: decide whether we allow assoc based 				 * bindx 				 */
block|}
block|}
break|break;
default|default:
name|error
operator|=
name|ENOPROTOOPT
expr_stmt|;
break|break;
block|}
comment|/* end switch (opt) */
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_ctloutput
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockopt
modifier|*
name|sopt
parameter_list|)
block|{
name|void
modifier|*
name|optval
init|=
name|NULL
decl_stmt|;
name|size_t
name|optsize
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
comment|/* I made the same as TCP since we are not setup? */
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
if|if
condition|(
name|sopt
operator|->
name|sopt_level
operator|!=
name|IPPROTO_SCTP
condition|)
block|{
comment|/* wrong proto level... send back up to IP */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|INP_CHECK_SOCKAF
argument_list|(
name|so
argument_list|,
name|AF_INET6
argument_list|)
condition|)
name|error
operator|=
name|ip6_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* INET6 */
name|error
operator|=
name|ip_ctloutput
argument_list|(
name|so
argument_list|,
name|sopt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|optsize
operator|=
name|sopt
operator|->
name|sopt_valsize
expr_stmt|;
if|if
condition|(
name|optsize
condition|)
block|{
name|SCTP_MALLOC
argument_list|(
name|optval
argument_list|,
name|void
operator|*
argument_list|,
name|optsize
argument_list|,
literal|"SCTPSockOpt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optval
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|error
operator|=
name|sooptcopyin
argument_list|(
name|sopt
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|optval
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|p
operator|=
operator|(
name|void
operator|*
operator|)
name|sopt
operator|->
name|sopt_td
expr_stmt|;
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_SET
condition|)
block|{
name|error
operator|=
name|sctp_setopt
argument_list|(
name|so
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sopt
operator|->
name|sopt_dir
operator|==
name|SOPT_GET
condition|)
block|{
name|error
operator|=
name|sctp_getopt
argument_list|(
name|so
argument_list|,
name|sopt
operator|->
name|sopt_name
argument_list|,
name|optval
argument_list|,
operator|&
name|optsize
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
operator|(
name|optval
operator|!=
name|NULL
operator|)
condition|)
block|{
name|error
operator|=
name|sooptcopyout
argument_list|(
name|sopt
argument_list|,
name|optval
argument_list|,
name|optsize
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|optval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|optval
operator|!=
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|optval
argument_list|)
expr_stmt|;
block|}
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|create_lock_on
init|=
literal|0
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
comment|/* I made the same as TCP since we are not setup? */
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|create_lock_on
operator|=
literal|1
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
condition|)
block|{
comment|/* Should I really unlock ? */
name|error
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* Bind a ephemeral port */
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
goto|goto
name|out_now
goto|;
block|}
block|}
comment|/* Now do we connect? */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|error
operator|=
name|EADDRINUSE
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We increment here since sctp_findassociation_ep_addr() 		 * wil do a decrement if it finds the stcb as long as the 		 * locked tcb (last argument) is NOT a TCB.. aka NULL. 		 */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
name|error
operator|=
name|EALREADY
expr_stmt|;
goto|goto
name|out_now
goto|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
comment|/* We are GOOD to go */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Gak! no memory */
goto|goto
name|out_now
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* initialize authentication parameters for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|out_now
label|:
if|if
condition|(
name|create_lock_on
condition|)
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|sctp_listen
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|backlog
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
comment|/* 	 * Note this module depends on the protocol processing being called 	 * AFTER any socket level flags and backlog are applied to the 	 * socket. The traditional way that the socket flags are applied is 	 * AFTER protocol processing. We have made a change to the 	 * sys/kern/uipc_socket.c module to reverse this but this MUST be in 	 * place if the socket API for SCTP is to work properly. 	 */
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
comment|/* I made the same as TCP since we are not setup? */
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOCK_LOGGING
name|sctp_log_lock
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
name|SCTP_LOG_LOCK_SOCK
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|error
operator|=
name|solisten_proto_check
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* We must do a bind. */
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
operator|)
condition|)
block|{
comment|/* bind error, probably perm */
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* It appears for 7.0 and on, we must always call this. */
name|solisten_proto
argument_list|(
name|so
argument_list|,
name|backlog
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
comment|/* remove the ACCEPTCONN flag for one-to-many sockets */
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_ACCEPTCONN
expr_stmt|;
block|}
if|if
condition|(
name|backlog
operator|==
literal|0
condition|)
block|{
comment|/* turning off listen */
name|so
operator|->
name|so_options
operator|&=
operator|~
name|SO_ACCEPTCONN
expr_stmt|;
block|}
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|sctp_defered_wakeup_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp_accept
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|int
name|error
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTSUP
operator|)
return|;
block|}
if|if
condition|(
name|so
operator|->
name|so_state
operator|&
name|SS_ISDISCONNECTED
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNABORTED
operator|)
return|;
block|}
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|store
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|store
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin_port
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin_addr
expr_stmt|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin6
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin6_port
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store
operator|)
operator|->
name|sin6_addr
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
block|}
comment|/* Wake any delayed sleep action */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_DONT_WAKE
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_DONT_WAKE
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEOUTPUT
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAKEOUTPUT
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sowriteable
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
condition|)
block|{
name|sowwakeup_locked
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_snd
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_WAKEINPUT
condition|)
block|{
name|inp
operator|->
name|sctp_flags
operator|&=
operator|~
name|SCTP_PCB_FLAGS_WAKEINPUT
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SOCKBUF_LOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
if|if
condition|(
name|soreadable
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
condition|)
block|{
name|sctp_defered_wakeup_cnt
operator|++
expr_stmt|;
name|sorwakeup_locked
argument_list|(
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SOCKBUF_UNLOCK
argument_list|(
operator|&
name|inp
operator|->
name|sctp_socket
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_ingetaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
comment|/* 	 * Do the malloc first in case it blocks. 	 */
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin_a
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
goto|goto
name|notConn
goto|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|sin_a
operator|=
name|NULL
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a
operator|==
name|NULL
condition|)
comment|/* this will make coverity happy */
continue|continue;
if|if
condition|(
name|sin_a
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fnd
operator|)
operator|||
operator|(
name|sin_a
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* punt */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
goto|goto
name|notConn
goto|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|sctp_ifa
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifa
condition|)
block|{
name|sin
operator|->
name|sin_addr
operator|=
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|sctp_ifa
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For the bound all case you get back 0 */
name|notConn
label|:
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Take the first IPv4 address in the list */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin_a
decl_stmt|;
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|sin_a
operator|->
name|sin_addr
expr_stmt|;
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|addr
operator|)
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|sctp_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|*
name|addr
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin_a
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* Do the malloc first in case it blocks. */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* UDP type and listeners will drop out here */
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin
argument_list|,
expr|struct
name|sockaddr_in
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
comment|/* We must recapture incase we blocked */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|!
name|inp
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a
operator|->
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|=
name|sin_a
operator|->
name|sin_addr
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
comment|/* No IPv4 address */
name|SCTP_FREE_SONAME
argument_list|(
name|sin
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
operator|(
operator|*
name|addr
operator|)
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pr_usrreqs
name|sctp_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|sctp_abort
block|,
operator|.
name|pru_accept
operator|=
name|sctp_accept
block|,
operator|.
name|pru_attach
operator|=
name|sctp_attach
block|,
operator|.
name|pru_bind
operator|=
name|sctp_bind
block|,
operator|.
name|pru_connect
operator|=
name|sctp_connect
block|,
operator|.
name|pru_control
operator|=
name|in_control
block|,
operator|.
name|pru_close
operator|=
name|sctp_close
block|,
operator|.
name|pru_detach
operator|=
name|sctp_close
block|,
operator|.
name|pru_sopoll
operator|=
name|sopoll_generic
block|,
operator|.
name|pru_disconnect
operator|=
name|sctp_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|sctp_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|sctp_peeraddr
block|,
operator|.
name|pru_send
operator|=
name|sctp_sendm
block|,
operator|.
name|pru_shutdown
operator|=
name|sctp_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|sctp_ingetaddr
block|,
operator|.
name|pru_sosend
operator|=
name|sctp_sosend
block|,
operator|.
name|pru_soreceive
operator|=
name|sctp_soreceive
block|}
decl_stmt|;
end_decl_stmt

end_unit

