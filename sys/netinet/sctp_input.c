begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2008, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_function
specifier|static
name|void
name|sctp_stop_all_cookie_timers
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* 	 * This now not only stops all cookie timers it also stops any INIT 	 * timers as well. This will make sure that the timers are stopped 	 * in all collision cases. 	 */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|rxt_timer
operator|.
name|type
operator|==
name|SCTP_TIMER_TYPE_COOKIE
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|rxt_timer
operator|.
name|type
operator|==
name|SCTP_TIMER_TYPE_INIT
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* INIT handler */
end_comment

begin_function
specifier|static
name|void
name|sctp_handle_init
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_init
modifier|*
name|init
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_init: handling INIT tcb:%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* validate length */
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
condition|)
block|{
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
goto|goto
name|outnow
goto|;
block|}
comment|/* validate parameters */
name|init
operator|=
operator|&
name|cp
operator|->
name|init
expr_stmt|;
if|if
condition|(
name|init
operator|->
name|initiate_tag
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
goto|goto
name|outnow
goto|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|init
operator|->
name|a_rwnd
argument_list|)
operator|<
name|SCTP_MIN_RWND
condition|)
block|{
comment|/* invalid parameter... send abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
goto|goto
name|outnow
goto|;
block|}
if|if
condition|(
name|init
operator|->
name|num_inbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
goto|goto
name|outnow
goto|;
block|}
if|if
condition|(
name|init
operator|->
name|num_outbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
goto|goto
name|outnow
goto|;
block|}
if|if
condition|(
name|sctp_validate_init_auth_params
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|,
name|offset
operator|+
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
condition|)
block|{
comment|/* auth parameter(s) error... send abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Problem with AUTH parameters"
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
goto|goto
name|outnow
goto|;
block|}
comment|/* We are only accepting if we have a listening socket. */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
operator|||
operator|(
operator|!
name|SCTP_IS_LISTENING
argument_list|(
name|inp
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * FIX ME ?? What about TCP model and we have a 		 * match/restart case? Actually no fix is needed. the lookup 		 * will always find the existing assoc so stcb would not be 		 * NULL. It may be questionable to do this since we COULD 		 * just send back the INIT-ACK and hope that the app did 		 * accept()'s by the time the COOKIE was sent. But there is 		 * a price to pay for COOKIE generation and I don't want to 		 * pay it on the chance that the app will actually do some 		 * accepts(). The App just looses and should NOT be in this 		 * state :-) 		 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|0
condition|)
block|{
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"No listener"
argument_list|)
expr_stmt|;
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
goto|goto
name|outnow
goto|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"sctp_handle_init: sending SHUTDOWN-ACK\n"
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CONTROL_PROC
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"sctp_handle_init: sending INIT-ACK\n"
argument_list|)
expr_stmt|;
name|sctp_send_initiate_ack
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cp
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|,
operator|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|?
name|SCTP_HOLDS_LOCK
else|:
name|SCTP_NOT_LOCKED
operator|)
argument_list|)
expr_stmt|;
block|}
name|outnow
label|:
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * process peer "INIT/INIT-ACK" chunk returns value< 0 on error  */
end_comment

begin_function
name|int
name|sctp_is_there_unsent_data
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|so_locked
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_UNUSED
endif|#
directive|endif
parameter_list|)
block|{
name|int
name|unsent_data
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
comment|/* 	 * This function returns if any stream has true unsent data on it. 	 * Note that as it looks through it will clean up any places that 	 * have old data that has been sent but left at top of stream queue. 	 */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|unsent_data
operator|=
literal|0
expr_stmt|;
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_is_empty
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
condition|)
block|{
comment|/* Check to see if some data queued */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
comment|/* sa_ignore FREED_MEMORY */
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|sp
operator|->
name|msg_is_complete
operator|)
operator|&&
operator|(
name|sp
operator|->
name|length
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sp
operator|->
name|sender_all_done
operator|)
condition|)
block|{
comment|/* 				 * We are doing differed cleanup. Last time 				 * through when we took all the data the 				 * sender_all_done was not set. 				 */
if|if
condition|(
name|sp
operator|->
name|put_last_out
operator|==
literal|0
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Gak, put out entire msg with NO end!-1\n"
argument_list|)
expr_stmt|;
name|SCTP_PRINTF
argument_list|(
literal|"sender_done:%d len:%d msg_comp:%d put_last_out:%d\n"
argument_list|,
name|sp
operator|->
name|sender_all_done
argument_list|,
name|sp
operator|->
name|length
argument_list|,
name|sp
operator|->
name|msg_is_complete
argument_list|,
name|sp
operator|->
name|put_last_out
argument_list|)
expr_stmt|;
block|}
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_remove_from_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|so_locked
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|outqueue
argument_list|)
condition|)
block|{
name|unsent_data
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|unsent_data
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|unsent_data
operator|>
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsent_data
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_process_init
parameter_list|(
name|struct
name|sctp_init_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_init
modifier|*
name|init
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|init
operator|=
operator|&
name|cp
operator|->
name|init
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* save off parameters */
name|asoc
operator|->
name|peer_vtag
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|initiate_tag
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|peers_rwnd
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|a_rwnd
argument_list|)
expr_stmt|;
comment|/* init tsn's */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|initial_tsn
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
condition|)
block|{
comment|/* update any ssthresh's that may have a default */
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|lnet
operator|->
name|ssthresh
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
operator|(
name|SCTP_CWND_MONITOR_ENABLE
operator||
name|SCTP_CWND_LOGGING_ENABLE
operator|)
condition|)
block|{
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_INITIALIZATION
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|pre_open_streams
operator|>
name|ntohs
argument_list|(
name|init
operator|->
name|num_inbound_streams
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|newcnt
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|,
modifier|*
name|nsp
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
comment|/* abandon the upper streams */
name|newcnt
operator|=
name|ntohs
argument_list|(
name|init
operator|->
name|num_inbound_streams
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&asoc->send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
operator|>=
name|newcnt
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|send_queue_cnt
operator|--
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|>
literal|0
condition|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
index|]
operator|.
name|chunks_on_queues
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"No chunks on the queues for sid %u."
argument_list|,
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|sid
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|chk
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_free_bufspace
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|chk
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_UNSENT_DG_FAIL
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
block|{
for|for
control|(
name|i
operator|=
name|newcnt
init|;
name|i
operator|<
name|asoc
operator|->
name|pre_open_streams
condition|;
name|i
operator|++
control|)
block|{
name|outs
operator|=
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|sp
argument_list|,
argument|&outs->outqueue
argument_list|,
argument|next
argument_list|,
argument|nsp
argument_list|)
block|{
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ss_functions
operator|.
name|sctp_ss_remove_from_stream
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|outs
argument_list|,
name|sp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sp
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|net
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Free the chunk */
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* sa_ignore FREED_MEMORY */
block|}
name|outs
operator|->
name|state
operator|=
name|SCTP_STREAM_CLOSED
expr_stmt|;
block|}
block|}
comment|/* cut back the count */
name|asoc
operator|->
name|pre_open_streams
operator|=
name|newcnt
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|streamoutcnt
operator|=
name|asoc
operator|->
name|pre_open_streams
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_OPEN
expr_stmt|;
block|}
block|}
comment|/* EY - nr_sack: initialize highest tsn in nr_mapping_array */
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
comment|/* This is the next one we expect */
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|asconf_seq_in
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|initial_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|asconf_seq_in
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* open the requested streams */
if|if
condition|(
name|asoc
operator|->
name|strmin
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the old ones */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|sctp_clean_up_stream
argument_list|(
name|stcb
argument_list|,
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
name|sctp_clean_up_stream
argument_list|(
name|stcb
argument_list|,
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|uno_inqueue
argument_list|)
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmin
argument_list|,
name|SCTP_M_STRMI
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|max_inbound_streams
operator|>
name|ntohs
argument_list|(
name|init
operator|->
name|num_outbound_streams
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|streamincnt
operator|=
name|ntohs
argument_list|(
name|init
operator|->
name|num_outbound_streams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|streamincnt
operator|=
name|asoc
operator|->
name|max_inbound_streams
expr_stmt|;
block|}
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|strmin
argument_list|,
expr|struct
name|sctp_stream_in
operator|*
argument_list|,
name|asoc
operator|->
name|streamincnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_in
argument_list|)
argument_list|,
name|SCTP_M_STRMI
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmin
operator|==
name|NULL
condition|)
block|{
comment|/* we didn't get memory for the streams! */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"process_init: couldn't get memory for the streams!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|sid
operator|=
name|i
expr_stmt|;
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|last_mid_delivered
operator|=
literal|0xffffffff
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|uno_inqueue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|pd_api_started
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * load_address_from_init will put the addresses into the 	 * association when the COOKIE is processed or the INIT-ACK is 	 * processed. Both types of COOKIE's existing and new call this 	 * routine. It will remove addresses that are no longer in the 	 * association (for the restarting case where addresses are 	 * removed). Up front when the INIT arrives we will discard it if it 	 * is a restart and new addresses have been added. 	 */
comment|/* sa_ignore MEMLEAK */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * INIT-ACK message processing/consumption returns value< 0 on error  */
end_comment

begin_function
specifier|static
name|int
name|sctp_process_init_ack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|abort_flag
decl_stmt|;
name|uint32_t
name|initack_limit
decl_stmt|;
name|int
name|nat_friendly
init|=
literal|0
decl_stmt|;
comment|/* First verify that we have no illegal param's */
name|abort_flag
operator|=
literal|0
expr_stmt|;
name|op_err
operator|=
name|sctp_arethere_unrecognized_parameters
argument_list|(
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|)
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|cp
argument_list|,
operator|&
name|nat_friendly
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
comment|/* Send an abort and notify peer */
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|asoc
operator|->
name|peer_supports_nat
operator|=
operator|(
name|uint8_t
operator|)
name|nat_friendly
expr_stmt|;
comment|/* process the peer's parameters in the INIT-ACK */
name|retval
operator|=
name|sctp_process_init
argument_list|(
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|cp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|initack_limit
operator|=
name|offset
operator|+
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* load all addresses */
if|if
condition|(
operator|(
name|retval
operator|=
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|)
argument_list|,
name|initack_limit
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|NULL
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|)
operator|)
condition|)
block|{
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Problem with address parameters"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Load addresses from INIT causes an abort %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* if the peer doesn't support asconf, flush the asconf queue */
if|if
condition|(
name|asoc
operator|->
name|asconf_supported
operator|==
literal|0
condition|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|param
decl_stmt|,
modifier|*
name|nparam
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|param
argument_list|,
argument|&asoc->asconf_queue
argument_list|,
argument|next
argument_list|,
argument|nparam
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_queue
argument_list|,
name|param
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|param
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
block|}
block|}
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
operator|=
name|sctp_negotiate_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
comment|/* queuing will steal away the mbuf chain to the out queue */
name|op_err
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* extract the cookie and queue it to "echo" it back... */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Cancel the INIT timer, We do this first before queueing the 	 * cookie. We always cancel at the primary to assue that we are 	 * canceling the timer started by the INIT which always goes to the 	 * primary. 	 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
comment|/* calculate the RTO */
name|net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
operator|&
name|asoc
operator|->
name|time_entered
argument_list|,
name|sctp_align_safe_nocopy
argument_list|,
name|SCTP_RTT_FROM_NON_DATA
argument_list|)
expr_stmt|;
name|retval
operator|=
name|sctp_send_cookie_echo
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
comment|/* 		 * No cookie, we probably should send a op error. But in any 		 * case if there is no cookie in the INIT-ACK, we can 		 * abandon the peer, its broke. 		 */
if|if
condition|(
name|retval
operator|==
operator|-
literal|3
condition|)
block|{
name|uint16_t
name|len
decl_stmt|;
name|len
operator|=
call|(
name|uint16_t
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_missing_param
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We abort with an error of missing mandatory param */
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sctp_error_missing_param
modifier|*
name|cause
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
name|len
expr_stmt|;
name|cause
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_error_missing_param
operator|*
argument_list|)
expr_stmt|;
comment|/* Subtract the reserved param */
name|cause
operator|->
name|cause
operator|.
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_MISSING_PARAM
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|cause
operator|->
name|num_missing_params
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cause
operator|->
name|type
index|[
literal|0
index|]
operator|=
name|htons
argument_list|(
name|SCTP_STATE_COOKIE
argument_list|)
expr_stmt|;
block|}
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_heartbeat_ack
parameter_list|(
name|struct
name|sctp_heartbeat_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|r_net
decl_stmt|,
modifier|*
name|f_net
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|int
name|req_prim
init|=
literal|0
decl_stmt|;
name|uint16_t
name|old_error_counter
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
condition|)
block|{
comment|/* Invalid length */
return|return;
block|}
name|memset
argument_list|(
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|store
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_len
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|store
operator|.
name|sin
operator|.
name|sin_addr
argument_list|,
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|store
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|store
operator|.
name|sin6
operator|.
name|sin6_family
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|store
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
break|break;
endif|#
directive|endif
default|default:
return|return;
block|}
name|r_net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|&
name|store
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_net
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Huh? I can't find the address I sent it to, discard\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|r_net
operator|&&
operator|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
operator|&&
operator|(
name|r_net
operator|->
name|heartbeat_random1
operator|==
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value1
operator|)
operator|&&
operator|(
name|r_net
operator|->
name|heartbeat_random2
operator|==
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value2
operator|)
condition|)
block|{
comment|/* 		 * If the its a HB and it's random value is correct when can 		 * confirm the destination. 		 */
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
if|if
condition|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REQ_PRIMARY
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|r_net
expr_stmt|;
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REQ_PRIMARY
expr_stmt|;
name|f_net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_net
operator|!=
name|r_net
condition|)
block|{
comment|/* 				 * first one on the list is NOT the primary 				 * sctp_cmpaddr() is much more efficient if 				 * the primary is the first on the list, 				 * make it so. 				 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|r_net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|r_net
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
name|req_prim
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|r_net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|r_net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|r_net
argument_list|)
expr_stmt|;
block|}
name|old_error_counter
operator|=
name|r_net
operator|->
name|error_count
expr_stmt|;
name|r_net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
name|r_net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_1
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_2
expr_stmt|;
comment|/* Now lets do a RTO with this */
name|r_net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|r_net
argument_list|,
operator|&
name|tv
argument_list|,
name|sctp_align_safe_nocopy
argument_list|,
name|SCTP_RTT_FROM_NON_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
condition|)
block|{
name|r_net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|r_net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
condition|)
block|{
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_exit_pf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_error_counter
operator|>
literal|0
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|r_net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|r_net
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r_net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
condition|)
block|{
comment|/* release the alternate, primary is good */
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Mobility adaptation */
if|if
condition|(
name|req_prim
condition|)
block|{
if|if
condition|(
operator|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
operator|||
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
operator|)
operator|&&
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PRIM_DELETED
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
condition|)
block|{
name|sctp_assoc_immediate_retrans
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
condition|)
block|{
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
block|}
name|sctp_delete_prim_timer
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_nat_colliding_state
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* 	 * return 0 means we want you to proceed with the abort non-zero 	 * means no abort processing 	 */
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
comment|/* generate a new vtag and send init */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * put it in the bucket in the vtag hash of assoc's for the 		 * system 		 */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* 		 * treat like a case where the cookie expired i.e.: - dump 		 * current cookie. - generate a new vtag. - resend init. 		 */
comment|/* generate a new vtag and send init */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&=
operator|~
name|SCTP_STATE_COOKIE_ECHOED
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|=
name|sctp_select_a_tag
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_lport
argument_list|,
name|stcb
operator|->
name|rport
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * put it in the bucket in the vtag hash of assoc's for the 		 * system 		 */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_nat_missing_state
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * return 0 means we want you to proceed with the abort non-zero 	 * means no abort processing 	 */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_nat_missing_state: Peer does not support AUTH, cannot send an asconf\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sctp_asconf_send_nat_state_update
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_abort
parameter_list|(
name|struct
name|sctp_abort_chunk
modifier|*
name|abort
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|len
decl_stmt|;
name|uint16_t
name|error
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_abort: handling ABORT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|ntohs
argument_list|(
name|abort
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
comment|/* 		 * Need to check the cause codes for our two magic nat 		 * aborts which don't kill the assoc necessarily. 		 */
name|struct
name|sctp_gen_error_cause
modifier|*
name|cause
decl_stmt|;
name|cause
operator|=
operator|(
expr|struct
name|sctp_gen_error_cause
operator|*
operator|)
operator|(
name|abort
operator|+
literal|1
operator|)
expr_stmt|;
name|error
operator|=
name|ntohs
argument_list|(
name|cause
operator|->
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|SCTP_CAUSE_NAT_COLLIDING_STATE
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Received Colliding state abort flags:%x\n"
argument_list|,
name|abort
operator|->
name|ch
operator|.
name|chunk_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_nat_colliding_state
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|SCTP_CAUSE_NAT_MISSING_STATE
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Received missing state abort flags:%x\n"
argument_list|,
name|abort
operator|->
name|ch
operator|.
name|chunk_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_nat_missing_state
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
comment|/* stop any receive timers */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
comment|/* notify user of the abort and clean up... */
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|error
argument_list|,
name|abort
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* free the tcb */
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|sctp_print_out_track_log
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_WAS_ABORTED
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_abort: finished\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_start_net_timers
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|uint32_t
name|cnt_hb_sent
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|cnt_hb_sent
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 		 * For each network start: 1) A pmtu timer. 2) A HB timer 3) 		 * If the dest in unconfirmed send a hb as well if under 		 * max_hb_burst have been sent. 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|&&
operator|(
name|cnt_hb_sent
operator|<
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hb_maxburst
argument_list|)
operator|)
condition|)
block|{
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|cnt_hb_sent
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt_hb_sent
condition|)
block|{
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_COOKIE_ACK
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_shutdown
parameter_list|(
name|struct
name|sctp_shutdown_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|some_on_streamwheel
decl_stmt|;
name|int
name|old_state
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_shutdown: handling SHUTDOWN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
condition|)
block|{
comment|/* Shutdown NOT the expected size */
return|return;
block|}
name|old_state
operator|=
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
expr_stmt|;
name|sctp_update_acked
argument_list|(
name|stcb
argument_list|,
name|cp
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|abort_flag
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
condition|)
block|{
comment|/* 		 * With a normal shutdown we assume the end of last record. 		 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
operator|->
name|on_strm_q
condition|)
block|{
name|struct
name|sctp_stream_in
modifier|*
name|strm
decl_stmt|;
name|strm
operator|=
operator|&
name|asoc
operator|->
name|strmin
index|[
name|asoc
operator|->
name|control_pdapi
operator|->
name|sinfo_stream
index|]
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_UNORDERED
condition|)
block|{
comment|/* Unordered */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|uno_inqueue
argument_list|,
name|asoc
operator|->
name|control_pdapi
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
operator|->
name|on_strm_q
operator|==
name|SCTP_ON_ORDERED
condition|)
block|{
comment|/* Ordered */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|strm
operator|->
name|inqueue
argument_list|,
name|asoc
operator|->
name|control_pdapi
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|on_strm_q
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
block|}
else|else
block|{
name|panic
argument_list|(
literal|"Unknown state on ctrl:%p on_strm_q:%d"
argument_list|,
name|asoc
operator|->
name|control_pdapi
argument_list|,
name|asoc
operator|->
name|control_pdapi
operator|->
name|on_strm_q
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|asoc
operator|->
name|control_pdapi
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* goto SHUTDOWN_RECEIVED state to block new requests */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
condition|)
block|{
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_RECEIVED
argument_list|)
expr_stmt|;
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
comment|/* 			 * notify upper layer that peer has initiated a 			 * shutdown 			 */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PEER_SHUTDOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* reset time */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* 		 * stop the shutdown timer, since we WILL move to 		 * SHUTDOWN-ACK-SENT. 		 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
block|}
comment|/* Now is there unsent data on a stream somewhere? */
name|some_on_streamwheel
operator|=
name|sctp_is_there_unsent_data
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|||
name|some_on_streamwheel
condition|)
block|{
comment|/* By returning we will push more data out */
return|return;
block|}
else|else
block|{
comment|/* no outstanding data to send, so move on... */
comment|/* send SHUTDOWN-ACK */
comment|/* move to SHUTDOWN-ACK-SENT state */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_CLEAR_SUBSTATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_PENDING
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_SHUTDOWN_ACK_SENT
argument_list|)
expr_stmt|;
name|sctp_stop_timers_for_shutdown
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_state
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_shutdown_ack
parameter_list|(
name|struct
name|sctp_shutdown_ack_chunk
modifier|*
name|cp
name|SCTP_UNUSED
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_shutdown_ack: handling SHUTDOWN ACK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* process according to association state */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
comment|/* unexpected SHUTDOWN-ACK... do OOTB handling... */
name|sctp_send_shutdown_complete
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* unexpected SHUTDOWN-ACK... so ignore... */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
condition|)
block|{
comment|/* 		 * With a normal shutdown we assume the end of last record. 		 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* assoc was freed while we were unlocked */
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|||
name|sctp_is_there_unsent_data
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Queues are not empty when handling SHUTDOWN-ACK"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* stop the timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
comment|/* send SHUTDOWN-COMPLETE */
name|sctp_send_shutdown_complete
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* notify upper layer protocol */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
name|stcb
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_shutdown
argument_list|)
expr_stmt|;
comment|/* free the TCB but first save off the ep */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_11
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Skip past the param header and then we will find the chunk that caused the  * problem. There are two possibilities ASCONF or FWD-TSN other than that and  * our peer must be broken.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_process_unrecog_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|phdr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phdr
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|chk
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_ASCONF_ACK
case|:
case|case
name|SCTP_ASCONF
case|:
name|sctp_asconf_cleanup
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_IFORWARD_CUM_TSN
case|:
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Peer does not support chunk type %d(%x)??\n"
argument_list|,
name|chk
operator|->
name|chunk_type
argument_list|,
operator|(
name|uint32_t
operator|)
name|chk
operator|->
name|chunk_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip past the param header and then we will find the param that caused the  * problem.  There are a number of param's in a ASCONF OR the prsctp param  * these will turn of specific features.  * XXX: Is this the right thing to do?  */
end_comment

begin_function
specifier|static
name|void
name|sctp_process_unrecog_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|pbad
decl_stmt|;
name|pbad
operator|=
name|phdr
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|pbad
operator|->
name|param_type
argument_list|)
condition|)
block|{
comment|/* pr-sctp draft */
case|case
name|SCTP_PRSCTP_SUPPORTED
case|:
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_SUPPORTED_CHUNK_EXT
case|:
break|break;
comment|/* draft-ietf-tsvwg-addip-sctp */
case|case
name|SCTP_HAS_NAT_SUPPORT
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_nat
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
case|case
name|SCTP_SET_PRIM_ADDR
case|:
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Huh, the peer does not support success? or error cause?\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Turning off ASCONF to this strange peer\n"
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Peer does not support param type %d(%x)??\n"
argument_list|,
name|pbad
operator|->
name|param_type
argument_list|,
operator|(
name|uint32_t
operator|)
name|pbad
operator|->
name|param_type
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_error
parameter_list|(
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|chklen
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|;
name|uint16_t
name|error
decl_stmt|,
name|error_type
decl_stmt|;
name|uint16_t
name|error_len
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|adjust
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
comment|/* parse through all of the errors and process */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
expr_stmt|;
name|chklen
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|size_t
operator|)
name|chklen
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
comment|/* Process an Error Cause */
name|error_type
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|error_len
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error_len
operator|>
name|chklen
operator|)
operator|||
operator|(
name|error_len
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* invalid param length for this param */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Bogus length in error param- chunk left:%d errorlen:%d\n"
argument_list|,
name|chklen
argument_list|,
name|error_len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* report the first error cause */
name|error
operator|=
name|error_type
expr_stmt|;
block|}
switch|switch
condition|(
name|error_type
condition|)
block|{
case|case
name|SCTP_CAUSE_INVALID_STREAM
case|:
case|case
name|SCTP_CAUSE_MISSING_PARAM
case|:
case|case
name|SCTP_CAUSE_INVALID_PARAM
case|:
case|case
name|SCTP_CAUSE_NO_USER_DATA
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Software error we got a %d back? We have a bug :/ (or do they?)\n"
argument_list|,
name|error_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CAUSE_NAT_COLLIDING_STATE
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Received Colliding state abort flags:%x\n"
argument_list|,
name|ch
operator|->
name|chunk_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_nat_colliding_state
argument_list|(
name|stcb
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_CAUSE_NAT_MISSING_STATE
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Received missing state abort flags:%x\n"
argument_list|,
name|ch
operator|->
name|chunk_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_nat_missing_state
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_CAUSE_STALE_COOKIE
case|:
comment|/* 			 * We only act if we have echoed a cookie and are 			 * waiting. 			 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|phdr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phdr
argument_list|)
operator|)
expr_stmt|;
comment|/* Save the time doubled */
name|asoc
operator|->
name|cookie_preserve_req
operator|=
name|ntohl
argument_list|(
operator|*
name|p
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|asoc
operator|->
name|stale_cookie_count
operator|++
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stale_cookie_count
operator|>
name|asoc
operator|->
name|max_init_times
condition|)
block|{
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* now free the asoc */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_12
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* blast back to INIT state */
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|state
operator|&=
operator|~
name|SCTP_STATE_COOKIE_ECHOED
expr_stmt|;
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
case|:
comment|/* 			 * Nothing we can do here, we don't do hostname 			 * addresses so if the peer does not like my IPv6 			 * (or IPv4 for that matter) it does not matter. If 			 * they don't support that type of address, they can 			 * NOT possibly get that packet type... i.e. with no 			 * IPv6 you can't receive a IPv6 packet. so we can 			 * safely ignore this one. If we ever added support 			 * for HOSTNAME Addresses, then we would need to do 			 * something here. 			 */
break|break;
case|case
name|SCTP_CAUSE_UNRECOG_CHUNK
case|:
name|sctp_process_unrecog_chunk
argument_list|(
name|stcb
argument_list|,
name|phdr
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CAUSE_UNRECOG_PARAM
case|:
name|sctp_process_unrecog_param
argument_list|(
name|stcb
argument_list|,
name|phdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CAUSE_COOKIE_IN_SHUTDOWN
case|:
comment|/* 			 * We ignore this since the timer will drive out a 			 * new cookie anyway and there timer will drive us 			 * to send a SHUTDOWN_COMPLETE. We can't send one 			 * here since we don't have their tag. 			 */
break|break;
case|case
name|SCTP_CAUSE_DELETING_LAST_ADDR
case|:
case|case
name|SCTP_CAUSE_RESOURCE_SHORTAGE
case|:
case|case
name|SCTP_CAUSE_DELETING_SRC_ADDR
case|:
comment|/* 			 * We should NOT get these here, but in a 			 * ASCONF-ACK. 			 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"Peer sends ASCONF errors in a Operational Error?<%d>?\n"
argument_list|,
name|error_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CAUSE_OUT_OF_RESC
case|:
comment|/* 			 * And what, pray tell do we do with the fact that 			 * the peer is out of resources? Not really sure we 			 * could do anything but abort. I suspect this 			 * should have came WITH an abort instead of in a 			 * OP-ERROR. 			 */
break|break;
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"sctp_handle_error: unknown error type = 0x%xh\n"
argument_list|,
name|error_type
argument_list|)
expr_stmt|;
break|break;
block|}
name|adjust
operator|=
name|SCTP_SIZE32
argument_list|(
name|error_len
argument_list|)
expr_stmt|;
name|chklen
operator|-=
name|adjust
expr_stmt|;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|phdr
operator|+
name|adjust
operator|)
expr_stmt|;
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_REMOTE_ERROR
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|,
name|ch
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_init_ack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|)
block|{
name|struct
name|sctp_init_ack
modifier|*
name|init_ack
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_init_ack: handling INIT-ACK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_init_ack: TCB is null\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
condition|)
block|{
comment|/* Invalid length */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|init_ack
operator|=
operator|&
name|cp
operator|->
name|init
expr_stmt|;
comment|/* validate parameters */
if|if
condition|(
name|init_ack
operator|->
name|initiate_tag
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|init_ack
operator|->
name|a_rwnd
argument_list|)
operator|<
name|SCTP_MIN_RWND
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|init_ack
operator|->
name|num_inbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|init_ack
operator|->
name|num_outbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* process according to association state... */
switch|switch
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_MASK
condition|)
block|{
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
comment|/* this is the expected state for this chunk */
comment|/* process the INIT-ACK parameters */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* 			 * The primary is where we sent the INIT, we can 			 * always consider it confirmed when the INIT-ACK is 			 * returned. Do this before we load addresses 			 * though. 			 */
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_process_init_ack
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|abort_no_unlock
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* error in parsing parameters */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* update our state */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"moving to COOKIE-ECHOED state\n"
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|SCTP_STATE_COOKIE_ECHOED
argument_list|)
expr_stmt|;
comment|/* reset the RTO calc */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* 		 * collapse the init timer back in case of a exponential 		 * backoff 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 		 * the send at the end of the inbound data processing will 		 * cause the cookie to be sent 		 */
break|break;
case|case
name|SCTP_STATE_SHUTDOWN_SENT
case|:
comment|/* incorrect state... discard */
break|break;
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
comment|/* incorrect state... discard */
break|break;
case|case
name|SCTP_STATE_OPEN
case|:
comment|/* incorrect state... discard */
break|break;
case|case
name|SCTP_STATE_EMPTY
case|:
case|case
name|SCTP_STATE_INUSE
case|:
default|default:
comment|/* incorrect state... discard */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Leaving handle-init-ack end\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_cookie_new
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
parameter_list|,
name|int
name|cookie_len
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_src
parameter_list|,
name|int
modifier|*
name|notification
parameter_list|,
name|int
name|auth_skipped
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|uint32_t
name|auth_len
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * handle a state cookie for an existing association m: input packet mbuf  * chain-- assumes a pullup on IP/SCTP/COOKIE-ECHO chunk note: this is a  * "split" mbuf and the cookie signature does not exist offset: offset into  * mbuf to the cookie-echo chunk  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_cookie_existing
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
parameter_list|,
name|int
name|cookie_len
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_src
parameter_list|,
name|int
modifier|*
name|notification
parameter_list|,
name|int
name|auth_skipped
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|uint32_t
name|auth_len
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init_cp
decl_stmt|,
name|init_buf
decl_stmt|;
name|struct
name|sctp_init_ack_chunk
modifier|*
name|initack_cp
decl_stmt|,
name|initack_buf
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|int
name|init_offset
decl_stmt|,
name|initack_offset
decl_stmt|,
name|i
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|spec_flag
init|=
literal|0
decl_stmt|;
name|uint32_t
name|how_indx
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_DETAILED_STR_STATS
argument_list|)
name|int
name|j
decl_stmt|;
endif|#
directive|endif
name|net
operator|=
operator|*
name|netp
expr_stmt|;
comment|/* I know that the TCB is non-NULL from the caller */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
for|for
control|(
name|how_indx
operator|=
literal|0
init|;
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|;
name|how_indx
operator|++
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
comment|/* SHUTDOWN came in after sending INIT-ACK */
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_COOKIE_IN_SHUTDOWN
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_send_operr_to
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cookie
operator|->
name|peers_vtag
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|net
operator|->
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * find and validate the INIT chunk in the cookie (peer's info) the 	 * INIT should start after the cookie-echo header struct (chunk 	 * header, state cookie header struct) 	 */
name|init_offset
operator|=
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_echo_chunk
argument_list|)
expr_stmt|;
name|init_cp
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|init_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|init_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull a INIT chunk in cookie */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * find and validate the INIT-ACK chunk in the cookie (my info) the 	 * INIT-ACK follows the INIT chunk 	 */
name|initack_offset
operator|=
name|init_offset
operator|+
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
name|initack_cp
operator|=
operator|(
expr|struct
name|sctp_init_ack_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|initack_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|initack_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|initack_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull INIT-ACK chunk in cookie */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|initack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION_ACK
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
operator|&&
operator|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|peer_vtag
operator|)
condition|)
block|{
comment|/* 		 * case D in Section 5.2.4 Table 2: MMAA process accordingly 		 * to get into the OPEN state 		 */
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
operator|!=
name|asoc
operator|->
name|init_seq_number
condition|)
block|{
comment|/*- 			 * Opps, this means that we somehow generated two vtag's 			 * the same. I.e. we did: 			 *  Us               Peer 			 *<---INIT(tag=a)------ 			 *   ----INIT-ACK(tag=t)--> 			 *   ----INIT(tag=t)------> *1 			 *<---INIT-ACK(tag=a)---                          *<----CE(tag=t)------------- *2 			 * 			 * At point *1 we should be generating a different 			 * tag t'. Which means we would throw away the CE and send 			 * ours instead. Basically this is case C (throw away side). 			 */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|17
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
condition|)
block|{
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
comment|/* 			 * INIT was sent but got a COOKIE_ECHO with the 			 * correct tags... just accept it...but we must 			 * process the init so that we can make sure we have 			 * the right seq no's. 			 */
comment|/* First we must process the INIT !! */
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* we have already processed the INIT so no problem */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_13
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_14
argument_list|)
expr_stmt|;
comment|/* update current state */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
else|else
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
operator|!
name|SCTP_IS_LISTENING
argument_list|(
name|inp
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
comment|/* 				 * Here is where collision would go if we 				 * did a connect() and instead got a 				 * init/init-ack/cookie done before the 				 * init-ack came back.. 				 */
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* notify upper layer */
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_UP
expr_stmt|;
comment|/* 			 * since we did not send a HB make sure we don't 			 * double things 			 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
name|net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
operator|&
name|cookie
operator|->
name|time_entered
argument_list|,
name|sctp_align_unsafe_makecopy
argument_list|,
name|SCTP_RTT_FROM_NON_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
operator|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* 			 * we're in the OPEN state (or beyond), so peer must 			 * have simply lost the COOKIE-ACK 			 */
break|break;
block|}
comment|/* end switch */
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 		 * We ignore the return code here.. not sure if we should 		 * somehow abort.. but we do have an existing asoc. This 		 * really should not fail. 		 */
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|init_src
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|)
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|4
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* respond with a COOKIE-ACK */
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|5
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|my_vtag
operator|&&
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|peer_vtag
operator|&&
name|cookie
operator|->
name|tie_tag_my_vtag
operator|==
literal|0
operator|&&
name|cookie
operator|->
name|tie_tag_peer_vtag
operator|==
literal|0
condition|)
block|{
comment|/* 		 * case C in Section 5.2.4 Table 2: XMOO silently discard 		 */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * If nat support, and the below and stcb is established, send back 	 * a ABORT(colliding state) if we are established. 	 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|&&
operator|(
name|asoc
operator|->
name|peer_supports_nat
operator|)
operator|&&
operator|(
operator|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
operator|&&
operator|(
operator|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
operator|)
operator|||
operator|(
name|asoc
operator|->
name|peer_vtag
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Special case - Peer's support nat. We may have two init's 		 * that we gave out the same tag on since one was not 		 * established.. i.e. we get INIT from host-1 behind the nat 		 * and we respond tag-a, we get a INIT from host-2 behind 		 * the nat and we get tag-a again. Then we bring up host-1 		 * (or 2's) assoc, Then comes the cookie from hsot-2 (or 1). 		 * Now we have colliding state. We must send an abort here 		 * with colliding state indication. 		 */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_NAT_COLLIDING_STATE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
operator|&&
operator|(
operator|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
operator|)
operator|||
operator|(
name|asoc
operator|->
name|peer_vtag
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 		 * case B in Section 5.2.4 Table 2: MXAA or MOAA my info 		 * should be ok, re-accept peer info 		 */
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
operator|!=
name|asoc
operator|->
name|init_seq_number
condition|)
block|{
comment|/* 			 * Extension of case C. If we hit this, then the 			 * random number generator returned the same vtag 			 * when we first sent our INIT-ACK and when we later 			 * sent our INIT. The side with the seq numbers that 			 * are different will be the one that normnally 			 * would have hit case C. This in effect "extends" 			 * our vtags in this collision case to be 64 bits. 			 * The same collision could occur aka you get both 			 * vtag and seq number the same twice in a row.. but 			 * is much less likely. If it did happen then we 			 * would proceed through and bring up the assoc.. we 			 * may end up with the wrong stream setup however.. 			 * which would be bad.. but there is no way to 			 * tell.. until we send on a stream that does not 			 * exist :-) 			 */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|7
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|8
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_15
argument_list|)
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 		 * since we did not send a HB make sure we don't double 		 * things 		 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|my_rwnd
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|pre_open_streams
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
condition|)
block|{
comment|/* 			 * Ok the peer probably discarded our data (if we 			 * echoed a cookie+data). So anything on the 			 * sent_queue should be marked for retransmit, we 			 * may not get something to kick us so it COULD 			 * still take a timeout to move these.. but it can't 			 * hurt to mark them. 			 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_flight_size_decrease
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|spec_flag
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* process the INIT info (peer's info) */
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|9
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|init_src
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|)
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|10
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_UP
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
operator|!
name|SCTP_IS_LISTENING
argument_list|(
name|inp
argument_list|)
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
else|else
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_restartestab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
block|}
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_flag
condition|)
block|{
comment|/* 			 * only if we have retrans set do we do this. What 			 * this call does is get only the COOKIE-ACK out and 			 * then when we return the normal call to 			 * sctp_chunk_output will get the retrans out behind 			 * this. 			 */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_COOKIE_ACK
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|11
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|my_vtag
operator|&&
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
operator|)
operator|&&
name|cookie
operator|->
name|tie_tag_my_vtag
operator|==
name|asoc
operator|->
name|my_vtag_nonce
operator|&&
name|cookie
operator|->
name|tie_tag_peer_vtag
operator|==
name|asoc
operator|->
name|peer_vtag_nonce
operator|&&
name|cookie
operator|->
name|tie_tag_peer_vtag
operator|!=
literal|0
condition|)
block|{
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|peer_supports_nat
condition|)
block|{
comment|/* 			 * This is a gross gross hack. Just call the 			 * cookie_new code since we are allowing a duplicate 			 * association. I hope this works... 			 */
return|return
operator|(
name|sctp_process_cookie_new
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cookie
argument_list|,
name|cookie_len
argument_list|,
name|inp
argument_list|,
name|netp
argument_list|,
name|init_src
argument_list|,
name|notification
argument_list|,
name|auth_skipped
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * case A in Section 5.2.4 Table 2: XXMM (peer restarted) 		 */
comment|/* temp code */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|12
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_16
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_17
argument_list|)
expr_stmt|;
comment|/* notify upper layer */
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_RESTART
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_OPEN
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
condition|)
block|{
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_restartestab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_OPEN
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
condition|)
block|{
comment|/* move to OPEN state, if not in SHUTDOWN_SENT */
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_OPEN
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|pre_open_streams
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|init_seq_number
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sending_seq
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|=
name|asoc
operator|->
name|str_reset_seq_out
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_out_acked
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|mapping_array
condition|)
block|{
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|nr_mapping_array
condition|)
block|{
name|memset
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* send up all the data */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_report_all_outbound
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|chunks_on_queues
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_DETAILED_STR_STATS
argument_list|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|SCTP_PR_SCTP_MAX
operator|+
literal|1
condition|;
name|j
operator|++
control|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_sent
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_unsent
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_sent
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|abandoned_unsent
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|sid
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_mid_ordered
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_mid_unordered
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
block|}
comment|/* process the INIT-ACK info (my info) */
name|asoc
operator|->
name|my_vtag
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_rwnd
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
comment|/* pull from vtag hash */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
comment|/* re-insert to new vtag position */
name|head
operator|=
operator|&
name|SCTP_BASE_INFO
argument_list|(
name|sctp_asochash
argument_list|)
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|,
name|SCTP_BASE_INFO
argument_list|(
name|hashasocmark
argument_list|)
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * put it in the bucket in the vtag hash of assoc's for the 		 * system 		 */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|asoc
operator|->
name|total_flight
operator|=
literal|0
expr_stmt|;
name|asoc
operator|->
name|total_flight_count
operator|=
literal|0
expr_stmt|;
comment|/* process the INIT info (peer's info) */
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|13
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * since we did not send a HB make sure we don't double 		 * things 		 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|init_src
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|)
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|14
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* respond with a COOKIE-ACK */
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|15
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|16
expr_stmt|;
comment|/* all other cases... */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * handle a state cookie for a new association m: input packet mbuf chain--  * assumes a pullup on IP/SCTP/COOKIE-ECHO chunk note: this is a "split" mbuf  * and the cookie signature does not exist offset: offset into mbuf to the  * cookie-echo chunk length: length of the cookie chunk to: where the init  * was from returns a new TCB  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_cookie_new
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
parameter_list|,
name|int
name|cookie_len
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_src
parameter_list|,
name|int
modifier|*
name|notification
parameter_list|,
name|int
name|auth_skipped
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|uint32_t
name|auth_len
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init_cp
decl_stmt|,
name|init_buf
decl_stmt|;
name|struct
name|sctp_init_ack_chunk
modifier|*
name|initack_cp
decl_stmt|,
name|initack_buf
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|init_offset
decl_stmt|,
name|initack_offset
decl_stmt|,
name|initack_limit
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint8_t
name|auth_chunk_buf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * find and validate the INIT chunk in the cookie (peer's info) the 	 * INIT should start after the cookie-echo header struct (chunk 	 * header, state cookie header struct) 	 */
name|init_offset
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_echo_chunk
argument_list|)
expr_stmt|;
name|init_cp
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|init_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|init_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull a INIT chunk in cookie */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"process_cookie_new: could not pull INIT chunk hdr\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"HUH? process_cookie_new: could not find INIT chunk!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|initack_offset
operator|=
name|init_offset
operator|+
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * find and validate the INIT-ACK chunk in the cookie (my info) the 	 * INIT-ACK follows the INIT chunk 	 */
name|initack_cp
operator|=
operator|(
expr|struct
name|sctp_init_ack_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|initack_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|initack_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|initack_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull INIT-ACK chunk in cookie */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"process_cookie_new: could not pull INIT-ACK chunk hdr\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|initack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION_ACK
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * NOTE: We can't use the INIT_ACK's chk_length to determine the 	 * "initack_limit" value.  This is because the chk_length field 	 * includes the length of the cookie, but the cookie is omitted when 	 * the INIT and INIT_ACK are tacked onto the cookie... 	 */
name|initack_limit
operator|=
name|offset
operator|+
name|cookie_len
expr_stmt|;
comment|/* 	 * now that we know the INIT/INIT-ACK are in place, create a new TCB 	 * and popluate 	 */
comment|/* 	 * Here we do a trick, we set in NULL for the proc/thread argument. 	 * We do this since in effect we only use the p argument when the 	 * socket is unbound and we must do an implicit bind. Since we are 	 * getting a cookie, we cannot be unbound. 	 */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|init_src
argument_list|,
operator|&
name|error
argument_list|,
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
argument_list|,
name|vrf_id
argument_list|,
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
argument_list|,
name|port
argument_list|,
operator|(
expr|struct
name|thread
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
comment|/* memory problem? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"process_cookie_new: no room for another TCB!\n"
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* get the correct sctp_nets */
if|if
condition|(
name|netp
condition|)
operator|*
name|netp
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|init_src
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* get scope variables out of cookie */
name|asoc
operator|->
name|scope
operator|.
name|ipv4_local_scope
operator|=
name|cookie
operator|->
name|ipv4_scope
expr_stmt|;
name|asoc
operator|->
name|scope
operator|.
name|site_scope
operator|=
name|cookie
operator|->
name|site_scope
expr_stmt|;
name|asoc
operator|->
name|scope
operator|.
name|local_scope
operator|=
name|cookie
operator|->
name|local_scope
expr_stmt|;
name|asoc
operator|->
name|scope
operator|.
name|loopback_scope
operator|=
name|cookie
operator|->
name|loopback_scope
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|scope
operator|.
name|ipv4_addr_legal
operator|!=
name|cookie
operator|->
name|ipv4_addr_legal
operator|)
operator|||
operator|(
name|asoc
operator|->
name|scope
operator|.
name|ipv6_addr_legal
operator|!=
name|cookie
operator|->
name|ipv6_addr_legal
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
comment|/* 		 * Houston we have a problem. The EP changed while the 		 * cookie was in flight. Only recourse is to abort the 		 * association. 		 */
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_18
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* process the INIT-ACK info (my info) */
name|asoc
operator|->
name|my_vtag
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_rwnd
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|pre_open_streams
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|init_seq_number
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sending_seq
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|=
name|asoc
operator|->
name|str_reset_seq_out
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_out_acked
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* process the INIT info (peer's info) */
if|if
condition|(
name|netp
condition|)
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
else|else
name|retval
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_19
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* load all addresses */
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|init_src
argument_list|,
name|port
argument_list|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_20
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * verify any preceding AUTH chunk that was skipped 	 */
comment|/* pull the local authentication parameters from the cookie/init-ack */
name|sctp_auth_get_cookie_params
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
name|initack_limit
operator|-
operator|(
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_skipped
condition|)
block|{
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
decl_stmt|;
name|auth
operator|=
operator|(
expr|struct
name|sctp_auth_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|auth_chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|||
name|sctp_handle_auth
argument_list|(
name|stcb
argument_list|,
name|auth
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|)
condition|)
block|{
comment|/* auth HMAC failed, dump the assoc and packet */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"COOKIE-ECHO: AUTH failed\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_21
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* remaining chunks checked... good to go */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * if we're doing ASCONFs, check to see if we have any new local 	 * addresses that need to get added to the peer (eg. addresses 	 * changed while cookie echo in flight).  This needs to be done 	 * after we go to the OPEN state to do the correct asconf 	 * processing. else, make sure we have the correct addresses in our 	 * lists 	 */
comment|/* warning, we re-use sin, sin6, sa_store here! */
comment|/* pull in local_address (our "from" address) */
switch|switch
condition|(
name|cookie
operator|->
name|laddr_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
comment|/* source addr is IPv4 */
name|memset
argument_list|(
operator|&
name|store
operator|.
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cookie
operator|->
name|laddress
index|[
literal|0
index|]
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
comment|/* source addr is IPv6 */
name|memset
argument_list|(
operator|&
name|store
operator|.
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|cookie
operator|->
name|scope_id
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|store
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|cookie
operator|->
name|laddress
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* update current state */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"moving to OPEN state\n"
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_passiveestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
comment|/* set up to notify upper layer */
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_UP
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
operator|!
name|SCTP_IS_LISTENING
argument_list|(
name|inp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * This is an endpoint that called connect() how it got a 		 * cookie that is NEW is a bit of a mystery. It must be that 		 * the INIT was sent, but before it got there.. a complete 		 * INIT/INIT-ACK/COOKIE arrived. But of course then it 		 * should have went to the other code.. not here.. oh well.. 		 * a bit of protection is worth having.. 		 */
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|SCTP_IS_LISTENING
argument_list|(
name|inp
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * We don't want to do anything with this one. Since it is 		 * the listening guy. The timer will get started for 		 * accepted connections in the caller. 		 */
empty_stmt|;
block|}
comment|/* since we did not send a HB make sure we don't double things */
if|if
condition|(
operator|(
name|netp
operator|)
operator|&&
operator|(
operator|*
name|netp
operator|)
condition|)
operator|(
operator|*
name|netp
operator|)
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|netp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|netp
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* calculate the RTT and set the encaps port */
operator|(
operator|*
name|netp
operator|)
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|cookie
operator|->
name|time_entered
argument_list|,
name|sctp_align_unsafe_makecopy
argument_list|,
name|SCTP_RTT_FROM_NON_DATA
argument_list|)
expr_stmt|;
block|}
comment|/* respond with a COOKIE-ACK */
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 	 * check the address lists for any ASCONFs that need to be sent 	 * AFTER the cookie-ack is sent 	 */
name|sctp_check_address_list
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
name|initack_limit
operator|-
operator|(
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
operator|)
argument_list|,
operator|&
name|store
operator|.
name|sa
argument_list|,
name|cookie
operator|->
name|local_scope
argument_list|,
name|cookie
operator|->
name|site_scope
argument_list|,
name|cookie
operator|->
name|ipv4_scope
argument_list|,
name|cookie
operator|->
name|loopback_scope
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * CODE LIKE THIS NEEDS TO RUN IF the peer supports the NAT extension, i.e  * we NEED to make sure we are not already using the vtag. If so we  * need to send back an ABORT-TRY-AGAIN-WITH-NEW-TAG No middle box bit! 	head =&SCTP_BASE_INFO(sctp_asochash)[SCTP_PCBHASH_ASOC(tag, 							    SCTP_BASE_INFO(hashasocmark))]; 	LIST_FOREACH(stcb, head, sctp_asocs) { 	        if ((stcb->asoc.my_vtag == tag)&& (stcb->rport == rport)&& (inp == stcb->sctp_ep))  { 		       -- SEND ABORT - TRY AGAIN -- 		} 	} */
end_comment

begin_comment
comment|/*  * handles a COOKIE-ECHO message stcb: modified to either a new or left as  * existing (non-NULL) TCB  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_handle_cookie_echo
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_cookie_echo_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
name|auth_skipped
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|uint32_t
name|auth_len
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
modifier|*
name|locked_tcb
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|l_stcb
init|=
operator|*
name|stcb
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|l_inp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|to
decl_stmt|;
name|struct
name|sctp_pcb
modifier|*
name|ep
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_sig
decl_stmt|;
name|uint8_t
name|calc_sig
index|[
name|SCTP_SIGNATURE_SIZE
index|]
decl_stmt|,
name|tmp_sig
index|[
name|SCTP_SIGNATURE_SIZE
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|sig
decl_stmt|;
name|uint8_t
name|cookie_ok
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|sig_offset
decl_stmt|,
name|cookie_offset
decl_stmt|;
name|unsigned
name|int
name|cookie_len
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|timeval
name|time_expires
decl_stmt|;
name|int
name|notification
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|netl
decl_stmt|;
name|int
name|had_a_existing_tcb
init|=
literal|0
decl_stmt|;
name|int
name|send_int_conf
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_cookie: handling COOKIE-ECHO\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp_p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cookie
operator|=
operator|&
name|cp
operator|->
name|cookie
expr_stmt|;
name|cookie_offset
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|cookie_len
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cookie_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_echo_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
operator|+
name|SCTP_SIGNATURE_SIZE
condition|)
block|{
comment|/* cookie too small */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|cookie
operator|->
name|peerport
operator|!=
name|sh
operator|->
name|src_port
operator|)
operator|||
operator|(
name|cookie
operator|->
name|myport
operator|!=
name|sh
operator|->
name|dest_port
operator|)
operator|||
operator|(
name|cookie
operator|->
name|my_vtag
operator|!=
name|sh
operator|->
name|v_tag
operator|)
condition|)
block|{
comment|/* 		 * invalid ports or bad tag.  Note that we always leave the 		 * v_tag in the header in network order and when we stored 		 * it in the my_vtag slot we also left it in network order. 		 * This maintains the match even though it may be in the 		 * opposite byte order of the machine :-> 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * split off the signature into its own mbuf (since it should not be 	 * calculated in the sctp_hmac_m() call). 	 */
name|sig_offset
operator|=
name|offset
operator|+
name|cookie_len
operator|-
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
name|m_sig
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|sig_offset
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_sig
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory or ?? */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mbc
argument_list|(
name|m_sig
argument_list|,
name|SCTP_MBUF_SPLIT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * compute the signature/digest for the cookie 	 */
name|ep
operator|=
operator|&
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
expr_stmt|;
name|l_inp
operator|=
operator|*
name|inp_p
expr_stmt|;
if|if
condition|(
name|l_stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|l_stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|l_inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|l_stcb
argument_list|)
expr_stmt|;
block|}
comment|/* which cookie is it? */
if|if
condition|(
operator|(
name|cookie
operator|->
name|time_entered
operator|.
name|tv_sec
operator|<
operator|(
name|long
operator|)
name|ep
operator|->
name|time_of_secret_change
operator|)
operator|&&
operator|(
name|ep
operator|->
name|current_secret_number
operator|!=
name|ep
operator|->
name|last_secret_number
operator|)
condition|)
block|{
comment|/* it's the old cookie */
operator|(
name|void
operator|)
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ep
operator|->
name|secret_key
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|last_secret_number
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m
argument_list|,
name|cookie_offset
argument_list|,
name|calc_sig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's the current cookie */
operator|(
name|void
operator|)
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ep
operator|->
name|secret_key
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|current_secret_number
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m
argument_list|,
name|cookie_offset
argument_list|,
name|calc_sig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* get the signature */
name|SCTP_INP_RUNLOCK
argument_list|(
name|l_inp
argument_list|)
expr_stmt|;
name|sig
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m_sig
argument_list|,
literal|0
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|NULL
condition|)
block|{
comment|/* couldn't find signature */
name|sctp_m_freem
argument_list|(
name|m_sig
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* compare the received digest with the computed digest */
if|if
condition|(
name|memcmp
argument_list|(
name|calc_sig
argument_list|,
name|sig
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* try the old cookie? */
if|if
condition|(
operator|(
name|cookie
operator|->
name|time_entered
operator|.
name|tv_sec
operator|==
operator|(
name|long
operator|)
name|ep
operator|->
name|time_of_secret_change
operator|)
operator|&&
operator|(
name|ep
operator|->
name|current_secret_number
operator|!=
name|ep
operator|->
name|last_secret_number
operator|)
condition|)
block|{
comment|/* compute digest with old */
operator|(
name|void
operator|)
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ep
operator|->
name|secret_key
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|last_secret_number
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m
argument_list|,
name|cookie_offset
argument_list|,
name|calc_sig
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* compare */
if|if
condition|(
name|memcmp
argument_list|(
name|calc_sig
argument_list|,
name|sig
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|)
operator|==
literal|0
condition|)
name|cookie_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|cookie_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now before we continue we must reconstruct our mbuf so that 	 * normal processing of any other chunks will work. 	 */
block|{
name|struct
name|mbuf
modifier|*
name|m_at
decl_stmt|;
name|m_at
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|m_sig
expr_stmt|;
block|}
if|if
condition|(
name|cookie_ok
operator|==
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"handle_cookie_echo: cookie signature validation failed!\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"offset = %u, cookie_offset = %u, sig_offset = %u\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|,
name|cookie_offset
argument_list|,
name|sig_offset
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * check the cookie timestamps to be sure it's not stale 	 */
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Expire time is in Ticks, so we convert to seconds */
name|time_expires
operator|.
name|tv_sec
operator|=
name|cookie
operator|->
name|time_entered
operator|.
name|tv_sec
operator|+
name|TICKS_TO_SEC
argument_list|(
name|cookie
operator|->
name|cookie_life
argument_list|)
expr_stmt|;
name|time_expires
operator|.
name|tv_usec
operator|=
name|cookie
operator|->
name|time_entered
operator|.
name|tv_usec
expr_stmt|;
comment|/* 	 * TODO sctp_constants.h needs alternative time macros when _KERNEL 	 * is undefined. 	 */
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|time_expires
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* cookie is stale! */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_error_stale_cookie
modifier|*
name|cause
decl_stmt|;
name|uint32_t
name|tim
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_stale_cookie
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
comment|/* FOOBAR */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Set the len */
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_stale_cookie
argument_list|)
expr_stmt|;
name|cause
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_error_stale_cookie
operator|*
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_STALE_COOKIE
argument_list|)
expr_stmt|;
name|cause
operator|->
name|cause
operator|.
name|length
operator|=
name|htons
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* seconds to usec */
name|tim
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|time_expires
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
comment|/* add in usec */
if|if
condition|(
name|tim
operator|==
literal|0
condition|)
name|tim
operator|=
name|now
operator|.
name|tv_usec
operator|-
name|cookie
operator|->
name|time_entered
operator|.
name|tv_usec
expr_stmt|;
name|cause
operator|->
name|stale_time
operator|=
name|htonl
argument_list|(
name|tim
argument_list|)
expr_stmt|;
name|sctp_send_operr_to
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cookie
operator|->
name|peers_vtag
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|l_inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now we must see with the lookup address if we have an existing 	 * asoc. This will only happen if we were in the COOKIE-WAIT state 	 * and a INIT collided with us and somewhere the peer sent the 	 * cookie on another address besides the single address our assoc 	 * had for him. In this case we will have one of the tie-tags set at 	 * least AND the address field in the cookie can be used to look it 	 * up. 	 */
name|to
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|cookie
operator|->
name|addr_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|cookie
operator|->
name|scope_id
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|cookie
operator|->
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cookie
operator|->
name|address
index|[
literal|0
index|]
expr_stmt|;
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* This should not happen */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Yep, lets check */
operator|*
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
name|to
argument_list|,
name|netp
argument_list|,
name|dst
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We should have only got back the same inp. If we 			 * got back a different ep we have a problem. The 			 * original findep got back l_inp and now 			 */
if|if
condition|(
name|l_inp
operator|!=
operator|*
name|inp_p
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Bad problem find_ep got a diff inp then special_locate?\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * In this case we found the assoc only 				 * after we locked the create lock. This 				 * means we are in a colliding case and we 				 * must make sure that we unlock the tcb if 				 * its one of the cases where we throw away 				 * the incoming packets. 				 */
operator|*
name|locked_tcb
operator|=
operator|*
name|stcb
expr_stmt|;
comment|/* 				 * We must also increment the inp ref count 				 * since the ref_count flags was set when we 				 * did not find the TCB, now we found it 				 * which reduces the refcount.. we must 				 * raise it back out to balance it all :-) 				 */
name|SCTP_INP_INCR_REF
argument_list|(
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
operator|!=
name|l_inp
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Huh? ep:%p diff then l_inp:%p?\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
argument_list|,
operator|(
name|void
operator|*
operator|)
name|l_inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|cookie_len
operator|-=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* this is the "normal" case... get a new TCB */
operator|*
name|stcb
operator|=
name|sctp_process_cookie_new
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cookie
argument_list|,
name|cookie_len
argument_list|,
operator|*
name|inp_p
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
operator|&
name|notification
argument_list|,
name|auth_skipped
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is abnormal... cookie-echo on existing TCB */
name|had_a_existing_tcb
operator|=
literal|1
expr_stmt|;
operator|*
name|stcb
operator|=
name|sctp_process_cookie_existing
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|cookie
argument_list|,
name|cookie_len
argument_list|,
operator|*
name|inp_p
argument_list|,
operator|*
name|stcb
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
operator|&
name|notification
argument_list|,
name|auth_skipped
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* still no TCB... must be bad cookie-echo */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|netp
operator|!=
name|NULL
condition|)
block|{
operator|(
operator|*
name|netp
operator|)
operator|->
name|flowtype
operator|=
name|mflowtype
expr_stmt|;
operator|(
operator|*
name|netp
operator|)
operator|->
name|flowid
operator|=
name|mflowid
expr_stmt|;
block|}
comment|/* 	 * Ok, we built an association so confirm the address we sent the 	 * INIT-ACK to. 	 */
name|netl
operator|=
name|sctp_findnet
argument_list|(
operator|*
name|stcb
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* 	 * This code should in theory NOT run but 	 */
if|if
condition|(
name|netl
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH! Huh, why do I need to add this address here? */
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
operator|*
name|stcb
argument_list|,
name|to
argument_list|,
name|NULL
argument_list|,
name|port
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_IN_COOKIE_PROC
argument_list|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|netl
operator|=
name|sctp_findnet
argument_list|(
operator|*
name|stcb
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netl
condition|)
block|{
if|if
condition|(
name|netl
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|netl
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_set_primary_addr
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|netl
argument_list|)
expr_stmt|;
name|send_int_conf
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|sctp_start_net_timers
argument_list|(
operator|*
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
if|if
condition|(
operator|!
name|had_a_existing_tcb
operator|||
operator|(
operator|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * If we have a NEW cookie or the connect never 			 * reached the connected state during collision we 			 * must do the TCP accept thing. 			 */
name|struct
name|socket
modifier|*
name|so
decl_stmt|,
modifier|*
name|oso
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
if|if
condition|(
name|notification
operator|==
name|SCTP_NOTIFY_ASSOC_RESTART
condition|)
block|{
comment|/* 				 * For a restart we will keep the same 				 * socket, no need to do anything. I THINK!! 				 */
name|sctp_ulp_notify
argument_list|(
name|notification
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_int_conf
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
operator|(
operator|*
name|stcb
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|netl
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
name|oso
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_socket
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|oso
operator|->
name|so_vnet
argument_list|)
expr_stmt|;
name|so
operator|=
name|sonewconn
argument_list|(
name|oso
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|pcb_so
decl_stmt|;
endif|#
directive|endif
comment|/* Too many sockets */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"process_cookie_new: no room for another socket!\n"
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
operator|*
name|inp_p
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|pcb_so
operator|=
name|SCTP_INP_SO
argument_list|(
operator|*
name|inp_p
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|pcb_so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
operator|*
name|inp_p
argument_list|,
operator|*
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|pcb_so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 			 * We add the unbound flag here so that if we get an 			 * soabort() before we get the move_pcb done, we 			 * will properly cleanup. 			 */
name|inp
operator|->
name|sctp_flags
operator|=
operator|(
name|SCTP_PCB_FLAGS_TCPTYPE
operator||
name|SCTP_PCB_FLAGS_CONNECTED
operator||
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator||
name|SCTP_PCB_FLAGS_UNBOUND
operator||
operator|(
name|SCTP_PCB_COPY_FLAGS
operator|&
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|)
operator||
name|SCTP_PCB_FLAGS_DONT_WAKE
operator|)
expr_stmt|;
name|inp
operator|->
name|sctp_features
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_features
expr_stmt|;
name|inp
operator|->
name|sctp_mobility_features
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_mobility_features
expr_stmt|;
name|inp
operator|->
name|sctp_socket
operator|=
name|so
expr_stmt|;
name|inp
operator|->
name|sctp_frag_point
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_frag_point
expr_stmt|;
name|inp
operator|->
name|max_cwnd
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|max_cwnd
expr_stmt|;
name|inp
operator|->
name|sctp_cmt_on_off
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_cmt_on_off
expr_stmt|;
name|inp
operator|->
name|ecn_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|ecn_supported
expr_stmt|;
name|inp
operator|->
name|prsctp_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|prsctp_supported
expr_stmt|;
name|inp
operator|->
name|auth_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|auth_supported
expr_stmt|;
name|inp
operator|->
name|asconf_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|asconf_supported
expr_stmt|;
name|inp
operator|->
name|reconfig_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|reconfig_supported
expr_stmt|;
name|inp
operator|->
name|nrsack_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|nrsack_supported
expr_stmt|;
name|inp
operator|->
name|pktdrop_supported
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|pktdrop_supported
expr_stmt|;
name|inp
operator|->
name|partial_delivery_point
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|partial_delivery_point
expr_stmt|;
name|inp
operator|->
name|sctp_context
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_context
expr_stmt|;
name|inp
operator|->
name|local_strreset_support
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|local_strreset_support
expr_stmt|;
name|inp
operator|->
name|fibnum
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|fibnum
expr_stmt|;
name|inp
operator|->
name|inp_starting_point_for_iterator
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * copy in the authentication parameters from the 			 * original endpoint 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
operator|=
name|sctp_copy_hmaclist
argument_list|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
condition|)
name|sctp_free_chunklist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
operator|=
name|sctp_copy_chunklist
argument_list|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
comment|/* 			 * Now we must move it from one hash table to 			 * another and get the tcb in the right place. 			 */
comment|/* 			 * This is where the one-2-one socket is put into 			 * the accept state waiting for the accept! 			 */
if|if
condition|(
operator|*
name|stcb
condition|)
block|{
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|state
operator||=
name|SCTP_STATE_IN_ACCEPT_QUEUE
expr_stmt|;
block|}
name|sctp_move_pcb_and_assoc
argument_list|(
operator|*
name|inp_p
argument_list|,
name|inp
argument_list|,
operator|*
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|sctp_pull_off_control_to_new_inp
argument_list|(
operator|(
operator|*
name|inp_p
operator|)
argument_list|,
name|inp
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * now we must check to see if we were aborted while 			 * the move was going on and the lock/unlock 			 * happened. 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* 				 * yep it was, we leave the assoc attached 				 * to the socket since the sctp_inpcb_free() 				 * call will send an abort for us. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Switch over to the new guy */
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|notification
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_int_conf
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
operator|(
operator|*
name|stcb
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|netl
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Pull it from the incomplete queue and wake the 			 * guy 			 */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|atomic_add_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_TCB_LOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
operator|(
operator|*
name|stcb
operator|)
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
if|if
condition|(
name|notification
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|notification
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|send_int_conf
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
operator|(
operator|*
name|stcb
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|netl
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_cookie_ack
parameter_list|(
name|struct
name|sctp_cookie_ack_chunk
modifier|*
name|cp
name|SCTP_UNUSED
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* cp must not be used, others call this without a c-ack :-) */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_cookie_ack: handling COOKIE-ACK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* process according to association state */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* state change only needed when I am in right state */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"moving to OPEN state\n"
argument_list|)
expr_stmt|;
name|SCTP_SET_STATE
argument_list|(
name|asoc
argument_list|,
name|SCTP_STATE_OPEN
argument_list|)
expr_stmt|;
name|sctp_start_net_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
comment|/* update RTO */
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|overall_error_count
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
operator|&
name|asoc
operator|->
name|time_entered
argument_list|,
name|sctp_align_safe_nocopy
argument_list|,
name|SCTP_RTT_FROM_NON_DATA
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_UP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
operator|)
operator|==
literal|0
condition|)
block|{
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 		 * since we did not send a HB make sure we don't double 		 * things 		 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_CLOSED_SOCKET
condition|)
block|{
comment|/* 			 * We don't need to do the asconf thing, nor hb or 			 * autoclose if the socket is closed. 			 */
goto|goto
name|closed_socket
goto|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * send ASCONF if parameters are pending and ASCONFs are 		 * allowed (eg. addresses changed when init/cookie echo were 		 * in flight) 		 */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_TIMER_BASED_ASCONF
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|closed_socket
label|:
comment|/* Toss the cookie if I can */
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* Restart the timer if we have pending data */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_ecn_echo
parameter_list|(
name|struct
name|sctp_ecne_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|struct
name|sctp_ecne_chunk
name|bkup
decl_stmt|;
name|uint8_t
name|override_bit
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|,
name|window_data_tsn
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unsigned
name|int
name|pkt_cnt
decl_stmt|;
name|len
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|old_sctp_ecne_chunk
argument_list|)
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|old_sctp_ecne_chunk
argument_list|)
condition|)
block|{
comment|/* Its the old format */
name|memcpy
argument_list|(
operator|&
name|bkup
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|old_sctp_ecne_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|bkup
operator|.
name|num_pkts_since_cwr
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|bkup
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvecne
argument_list|)
expr_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|tsn
argument_list|)
expr_stmt|;
name|pkt_cnt
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|num_pkts_since_cwr
argument_list|)
expr_stmt|;
name|lchk
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|,
name|sctpchunk_listhead
argument_list|)
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
name|window_data_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|window_data_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
comment|/* Find where it was sent to if possible. */
name|net
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|lchk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|tsn
condition|)
block|{
name|net
operator|=
name|lchk
operator|->
name|whoTo
expr_stmt|;
name|net
operator|->
name|ecn_prev_cwnd
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|cwnd_at_send
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tsn
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * What to do. A previous send of a CWR was possibly lost. 		 * See how old it is, we may have it marked on the actual 		 * net. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tsn
operator|==
name|net
operator|->
name|last_cwr_tsn
condition|)
block|{
comment|/* Found him, send it off */
break|break;
block|}
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If we reach here, we need to send a special CWR 			 * that says hey, we did this a long time ago and 			 * you lost the response. 			 */
name|net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
return|return;
block|}
name|override_bit
operator|=
name|SCTP_CWR_REDUCE_OVERRIDE
expr_stmt|;
block|}
else|else
block|{
name|override_bit
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
name|override_bit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|net
operator|->
name|cwr_window_tsn
argument_list|)
operator|&&
operator|(
operator|(
name|override_bit
operator|&
name|SCTP_CWR_REDUCE_OVERRIDE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * JRS - Use the congestion control given in the pluggable 		 * CC module 		 */
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_after_ecn_echo
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|pkt_cnt
argument_list|)
expr_stmt|;
comment|/* 		 * We reduce once every RTT. So we will only lower cwnd at 		 * the next sending seq i.e. the window_data_tsn 		 */
name|net
operator|->
name|cwr_window_tsn
operator|=
name|window_data_tsn
expr_stmt|;
name|net
operator|->
name|ecn_ce_pkt_cnt
operator|+=
name|pkt_cnt
expr_stmt|;
name|net
operator|->
name|lost_cnt
operator|=
name|pkt_cnt
expr_stmt|;
name|net
operator|->
name|last_cwr_tsn
operator|=
name|tsn
expr_stmt|;
block|}
else|else
block|{
name|override_bit
operator||=
name|SCTP_CWR_IN_SAME_WINDOW
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tsn
argument_list|,
name|net
operator|->
name|last_cwr_tsn
argument_list|)
operator|&&
operator|(
operator|(
name|override_bit
operator|&
name|SCTP_CWR_REDUCE_OVERRIDE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Another loss in the same window update how many 			 * marks/packets lost we have had. 			 */
name|int
name|cnt
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|pkt_cnt
operator|>
name|net
operator|->
name|lost_cnt
condition|)
block|{
comment|/* Should be the case */
name|cnt
operator|=
operator|(
name|pkt_cnt
operator|-
name|net
operator|->
name|lost_cnt
operator|)
expr_stmt|;
name|net
operator|->
name|ecn_ce_pkt_cnt
operator|+=
name|cnt
expr_stmt|;
block|}
name|net
operator|->
name|lost_cnt
operator|=
name|pkt_cnt
expr_stmt|;
name|net
operator|->
name|last_cwr_tsn
operator|=
name|tsn
expr_stmt|;
comment|/* 			 * Most CC functions will ignore this call, since we 			 * are in-window yet of the initial CE the peer saw. 			 */
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_after_ecn_echo
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
literal|1
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We always send a CWR this way if our previous one was lost our 	 * peer will get an update, or if it is not time again to reduce we 	 * still get the cwr to the peer. Note we set the override when we 	 * could not find the TSN on the chunk or the destination network. 	 */
name|sctp_send_cwr
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|net
operator|->
name|last_cwr_tsn
argument_list|,
name|override_bit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_ecn_cwr
parameter_list|(
name|struct
name|sctp_cwr_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * Here we get a CWR from the peer. We must look in the outqueue and 	 * make sure that we have a covered ECNE in the control chunk part. 	 * If so remove it. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_ecne_chunk
modifier|*
name|ecne
decl_stmt|;
name|int
name|override
decl_stmt|;
name|uint32_t
name|cwr_tsn
decl_stmt|;
name|cwr_tsn
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|tsn
argument_list|)
expr_stmt|;
name|override
operator|=
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_CWR_REDUCE_OVERRIDE
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|!=
name|SCTP_ECN_ECHO
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|override
operator|==
literal|0
operator|)
operator|&&
operator|(
name|chk
operator|->
name|whoTo
operator|!=
name|net
operator|)
condition|)
block|{
comment|/* Must be from the right src unless override is set */
continue|continue;
block|}
name|ecne
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_ecne_chunk
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|cwr_tsn
argument_list|,
name|ntohl
argument_list|(
name|ecne
operator|->
name|tsn
argument_list|)
argument_list|)
condition|)
block|{
comment|/* this covers this ECNE, we can remove it */
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|override
operator|==
literal|0
condition|)
block|{
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_shutdown_complete
parameter_list|(
name|struct
name|sctp_shutdown_complete_chunk
modifier|*
name|cp
name|SCTP_UNUSED
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_shutdown_complete: handling SHUTDOWN-COMPLETE\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* process according to association state */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
comment|/* unexpected SHUTDOWN-COMPLETE... so ignore... */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_shutdown_complete: not in SCTP_STATE_SHUTDOWN_ACK_SENT --- ignore\n"
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* notify upper layer protocol */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INVARIANTS
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|||
name|sctp_is_there_unsent_data
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
condition|)
block|{
name|panic
argument_list|(
literal|"Queues are not empty when handling SHUTDOWN-COMPLETE"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* stop the timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_24
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_shutdown
argument_list|)
expr_stmt|;
comment|/* free the TCB */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_handle_shutdown_complete: calls free-asoc\n"
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|process_chunk_drop
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_chunk_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint8_t
name|flg
parameter_list|)
block|{
switch|switch
condition|(
name|desc
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_DATA
case|:
comment|/* find the tsn to resend (possibly */
block|{
name|uint32_t
name|tsn
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|desc
operator|->
name|tsn_ifany
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|tsn
condition|)
block|{
comment|/* found it */
break|break;
block|}
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|,
name|tsn
argument_list|)
condition|)
block|{
comment|/* not found */
name|tp1
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Do it the other way , aka without paying 				 * attention to queue seq order. 				 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpdnfnd
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
operator|==
name|tsn
condition|)
block|{
comment|/* found it */
break|break;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrptsnnf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
operator|)
condition|)
block|{
name|uint8_t
modifier|*
name|ddp
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|flg
operator|&
name|SCTP_BADCRC
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flg
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flg
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpdiwnp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|&&
operator|(
name|flg
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpdizrw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ddp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|tp1
operator|->
name|data
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
block|{
name|unsigned
name|int
name|iii
decl_stmt|;
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|data_bytes
argument_list|)
condition|;
name|iii
operator|++
control|)
block|{
if|if
condition|(
name|ddp
index|[
name|iii
index|]
operator|!=
name|desc
operator|->
name|data_bytes
index|[
name|iii
index|]
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpbadd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
comment|/* 					 * this guy had a RTO calculation 					 * pending on it, cancel it 					 */
if|if
condition|(
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|==
literal|0
condition|)
block|{
name|tp1
operator|->
name|whoTo
operator|->
name|rto_needed
operator|=
literal|1
expr_stmt|;
block|}
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
comment|/* 				 * mark it as if we were doing a FR, since 				 * we will be getting gap ack reports behind 				 * the info from the router. 				 */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|1
expr_stmt|;
comment|/* 				 * mark the tsn with what sequences can 				 * cause a new FR. 				 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
condition|)
block|{
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
expr_stmt|;
block|}
comment|/* restart the timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
comment|/* fix counts and things */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_FLIGHT_LOGGING_ENABLE
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_PDRP
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uint32_t
operator|)
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|tsn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
block|}
block|{
comment|/* audit code */
name|unsigned
name|int
name|audit
decl_stmt|;
name|audit
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
name|audit
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
name|audit
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|audit
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"**Local Audit finds cnt:%d asoc cnt:%d\n"
argument_list|,
name|audit
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SCTP_AUDITING_ENABLED
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
name|audit
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
case|case
name|SCTP_ASCONF
case|:
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|asconf
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|asconf
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|asconf
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|asconf
condition|)
block|{
if|if
condition|(
name|asconf
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|asconf
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|asconf
operator|->
name|snd_count
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_INITIATION
case|:
comment|/* resend the INIT */
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|<
name|SCTP_RETRY_DROPPED_THRESH
condition|)
block|{
comment|/* 			 * If we can get it in, in a few attempts we do 			 * this, otherwise we let the timer fire. 			 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_27
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SELECTIVE_ACK
case|:
case|case
name|SCTP_NR_SELECTIVE_ACK
case|:
comment|/* resend the sack */
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
comment|/* resend a demand HB */
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|+
literal|3
operator|)
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|max_send_times
condition|)
block|{
comment|/* 			 * Only retransmit if we KNOW we wont destroy the 			 * tcb 			 */
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SHUTDOWN
case|:
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_COOKIE_ECHO
case|:
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|cookie
decl_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cookie
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|cookie
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cookie
condition|)
block|{
if|if
condition|(
name|cookie
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|cookie
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_COOKIE_ACK
case|:
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ASCONF_ACK
case|:
comment|/* resend last asconf ack */
name|sctp_send_asconf_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_IFORWARD_CUM_TSN
case|:
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
break|break;
comment|/* can't do anything with these */
case|case
name|SCTP_PACKET_DROPPED
case|:
case|case
name|SCTP_INITIATION_ACK
case|:
comment|/* this should not happen */
case|case
name|SCTP_HEARTBEAT_ACK
case|:
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
case|case
name|SCTP_OPERATION_ERROR
case|:
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
case|case
name|SCTP_ECN_ECHO
case|:
case|case
name|SCTP_ECN_CWR
case|:
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_reset_in_stream
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
comment|/* 	 * We set things to 0xffffffff since this is the last delivered 	 * sequence and we will be sending in 0 after the reset. 	 */
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
condition|)
block|{
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|temp
index|]
operator|.
name|last_mid_delivered
operator|=
literal|0xffffffff
expr_stmt|;
block|}
block|}
else|else
block|{
name|list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|last_mid_delivered
operator|=
literal|0xffffffff
expr_stmt|;
block|}
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_RECV
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
operator|(
name|void
operator|*
operator|)
name|list
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_reset_out_streams
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
if|if
condition|(
name|number_entries
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
comment|/* no such stream */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|temp
index|]
operator|.
name|next_mid_ordered
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|temp
index|]
operator|.
name|next_mid_unordered
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_mid_ordered
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_mid_unordered
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_SEND
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
operator|(
name|void
operator|*
operator|)
name|list
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_reset_clear_pending
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|)
block|{
name|uint32_t
name|i
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
if|if
condition|(
name|number_entries
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
comment|/* no such stream */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|temp
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_OPEN
expr_stmt|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_OPEN
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|sctp_stream_reset_request
modifier|*
name|sctp_find_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
modifier|*
name|bchk
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_stream_reset_request
modifier|*
name|r
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|int
name|len
decl_stmt|,
name|clen
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|stream_reset_outstanding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|stream_reset_outstanding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chk
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bchk
condition|)
block|{
comment|/* he wants a copy of the chk pointer */
operator|*
name|bchk
operator|=
name|chk
expr_stmt|;
block|}
name|clen
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
expr|struct
name|sctp_stream_reset_request
operator|*
operator|)
operator|(
name|ch
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|r
operator|->
name|request_seq
argument_list|)
operator|==
name|seq
condition|)
block|{
comment|/* found it */
return|return
operator|(
name|r
operator|)
return|;
block|}
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|r
operator|->
name|ph
operator|.
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
operator|(
name|len
operator|+
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
condition|)
block|{
comment|/* move to the next one, there can only be a max of two */
name|r
operator|=
operator|(
expr|struct
name|sctp_stream_reset_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|r
operator|+
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|r
operator|->
name|request_seq
argument_list|)
operator|==
name|seq
condition|)
block|{
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
comment|/* that seq is not here */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_clean_up_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
init|=
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_28
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_stream_reset_response
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint32_t
name|action
parameter_list|,
name|struct
name|sctp_stream_reset_response
modifier|*
name|respin
parameter_list|)
block|{
name|uint16_t
name|type
decl_stmt|;
name|int
name|lparam_len
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_stream_reset_request
modifier|*
name|req_param
decl_stmt|;
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req_out_param
decl_stmt|;
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req_in_param
decl_stmt|;
name|uint32_t
name|number_entries
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
comment|/* duplicate */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|seq
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
condition|)
block|{
name|req_param
operator|=
name|sctp_find_stream_reset
argument_list|(
name|stcb
argument_list|,
name|seq
argument_list|,
operator|&
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|req_param
operator|!=
name|NULL
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
operator|++
expr_stmt|;
name|type
operator|=
name|ntohs
argument_list|(
name|req_param
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|lparam_len
operator|=
name|ntohs
argument_list|(
name|req_param
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_OUT_REQUEST
condition|)
block|{
name|int
name|no_clear
init|=
literal|0
decl_stmt|;
name|req_out_param
operator|=
operator|(
expr|struct
name|sctp_stream_reset_out_request
operator|*
operator|)
name|req_param
expr_stmt|;
name|number_entries
operator|=
operator|(
name|lparam_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_out_is_outstanding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_PERFORMED
condition|)
block|{
comment|/* do it */
name|sctp_reset_out_streams
argument_list|(
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req_out_param
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_DENIED
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_DENIED_OUT
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req_out_param
operator|->
name|list_of_streams
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_IN_PROGRESS
condition|)
block|{
comment|/* 					 * Set it up so we don't stop 					 * retransmitting 					 */
name|asoc
operator|->
name|stream_reset_outstanding
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
operator|--
expr_stmt|;
name|asoc
operator|->
name|stream_reset_out_is_outstanding
operator|=
literal|1
expr_stmt|;
name|no_clear
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_FAILED_OUT
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req_out_param
operator|->
name|list_of_streams
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|no_clear
operator|==
literal|0
condition|)
block|{
name|sctp_reset_clear_pending
argument_list|(
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req_out_param
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_IN_REQUEST
condition|)
block|{
name|req_in_param
operator|=
operator|(
expr|struct
name|sctp_stream_reset_in_request
operator|*
operator|)
name|req_param
expr_stmt|;
name|number_entries
operator|=
operator|(
name|lparam_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_in_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_DENIED
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_DENIED_IN
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req_in_param
operator|->
name|list_of_streams
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|!=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_FAILED_IN
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req_in_param
operator|->
name|list_of_streams
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_ADD_OUT_STREAMS
condition|)
block|{
comment|/* Ok we now may have more streams */
name|int
name|num_stream
decl_stmt|;
name|num_stream
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|strm_pending_add_size
expr_stmt|;
if|if
condition|(
name|num_stream
operator|>
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
operator|)
condition|)
block|{
comment|/* TSNH */
name|num_stream
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|strm_realoutsize
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strm_pending_add_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_PERFORMED
condition|)
block|{
comment|/* Put the new streams into effect */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|asoc
operator|->
name|streamoutcnt
init|;
name|i
operator|<
operator|(
name|asoc
operator|->
name|streamoutcnt
operator|+
name|num_stream
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_OPEN
expr_stmt|;
block|}
name|asoc
operator|->
name|streamoutcnt
operator|+=
name|num_stream
expr_stmt|;
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_DENIED
condition|)
block|{
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
name|SCTP_STREAM_CHANGE_DENIED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
name|SCTP_STREAM_CHANGE_FAILED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_ADD_IN_STREAMS
condition|)
block|{
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_DENIED
condition|)
block|{
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
name|SCTP_STREAM_CHANGE_DENIED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|!=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
condition|)
block|{
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
name|SCTP_STREAM_CHANGE_FAILED
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_TSN_REQUEST
condition|)
block|{
comment|/** 				 * a) Adopt the new in tsn. 				 * b) reset the map 				 * c) Adopt the new out-tsn 				 */
name|struct
name|sctp_stream_reset_response_tsn
modifier|*
name|resp
decl_stmt|;
name|struct
name|sctp_forward_tsn_chunk
name|fwdtsn
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|respin
operator|==
name|NULL
condition|)
block|{
comment|/* huh ? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|respin
operator|->
name|ph
operator|.
name|param_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_response_tsn
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_PERFORMED
condition|)
block|{
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response_tsn
operator|*
operator|)
name|respin
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|fwdtsn
operator|.
name|new_cumulative_tsn
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|resp
operator|->
name|senders_next_tsn
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sctp_handle_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|fwdtsn
argument_list|,
operator|&
name|abort_flag
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|=
operator|(
name|ntohl
argument_list|(
name|resp
operator|->
name|senders_next_tsn
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|tsn_last_delivered
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|senders_next_tsn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_nr_map
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|receivers_next_tsn
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
name|sctp_reset_out_streams
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sctp_notify_stream_reset_tsn
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_RESULT_DENIED
condition|)
block|{
name|sctp_notify_stream_reset_tsn
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
operator|+
literal|1
operator|)
argument_list|,
name|SCTP_ASSOC_RESET_DENIED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_notify_stream_reset_tsn
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
operator|+
literal|1
operator|)
argument_list|,
name|SCTP_ASSOC_RESET_FAILED
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get rid of the request and get the request flags */
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
name|sctp_clean_up_stream_reset
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
name|sctp_send_stream_reset_out_if_possible
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_str_reset_request_in
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req
parameter_list|,
name|int
name|trunc
parameter_list|)
block|{
name|uint32_t
name|seq
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|int
name|number_entries
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
comment|/* 	 * peer wants me to send a str-reset to him for my outgoing seq's if 	 * seq_in is right. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|local_strreset_support
operator|&
name|SCTP_ENABLE_RESET_STREAM_REQ
operator|)
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trunc
condition|)
block|{
comment|/* Can't do it, since they exceeded our buffer size  */
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_out_is_outstanding
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|number_entries
operator|=
operator|(
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_in_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|list_of_streams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
goto|goto
name|bad_boy
goto|;
block|}
name|req
operator|->
name|list_of_streams
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|req
operator|->
name|list_of_streams
index|[
name|i
index|]
index|]
operator|.
name|state
operator|==
name|SCTP_STREAM_OPEN
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|req
operator|->
name|list_of_streams
index|[
name|i
index|]
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_RESET_PENDING
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Its all */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|state
operator|==
name|SCTP_STREAM_OPEN
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|state
operator|=
name|SCTP_STREAM_RESET_PENDING
expr_stmt|;
block|}
block|}
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
expr_stmt|;
block|}
else|else
block|{
comment|/* Can't do it, since we have sent one out */
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_ERR_IN_PROGRESS
expr_stmt|;
block|}
name|bad_boy
label|:
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_RESULT_ERR_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
name|sctp_send_stream_reset_out_if_possible
argument_list|(
name|stcb
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_str_reset_request_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_tsn_request
modifier|*
name|req
parameter_list|)
block|{
comment|/* reset all in and out and update the tsn */
comment|/* 	 * A) reset my str-seq's on in and out. B) Select a receive next, 	 * and set cum-ack to it. Also process this selected number as a 	 * fwd-tsn as well. C) set in the response my next sending seq. 	 */
name|struct
name|sctp_forward_tsn_chunk
name|fwdtsn
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|local_strreset_support
operator|&
name|SCTP_ENABLE_CHANGE_ASSOC_REQ
operator|)
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
else|else
block|{
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|fwdtsn
operator|.
name|new_cumulative_tsn
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sctp_handle_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|fwdtsn
argument_list|,
operator|&
name|abort_flag
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+=
name|SCTP_STREAM_RESET_TSN_DELTA
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MAP_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|10
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|tsn_last_delivered
operator|=
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|highest_tsn_inside_nr_map
operator|=
name|asoc
operator|->
name|highest_tsn_inside_map
expr_stmt|;
name|memset
argument_list|(
name|asoc
operator|->
name|nr_mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|asoc
operator|->
name|sending_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* save off historical data for retrans */
name|asoc
operator|->
name|last_sending_seq
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_sending_seq
index|[
literal|0
index|]
expr_stmt|;
name|asoc
operator|->
name|last_sending_seq
index|[
literal|0
index|]
operator|=
name|asoc
operator|->
name|sending_seq
expr_stmt|;
name|asoc
operator|->
name|last_base_tsnsent
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_base_tsnsent
index|[
literal|0
index|]
expr_stmt|;
name|asoc
operator|->
name|last_base_tsnsent
index|[
literal|0
index|]
operator|=
name|asoc
operator|->
name|mapping_array_base_tsn
expr_stmt|;
name|sctp_reset_out_streams
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
expr_stmt|;
name|sctp_notify_stream_reset_tsn
argument_list|(
name|stcb
argument_list|,
name|asoc
operator|->
name|sending_seq
argument_list|,
operator|(
name|asoc
operator|->
name|mapping_array_base_tsn
operator|+
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sctp_add_stream_reset_result_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|,
name|asoc
operator|->
name|last_sending_seq
index|[
literal|0
index|]
argument_list|,
name|asoc
operator|->
name|last_base_tsnsent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|,
name|asoc
operator|->
name|last_sending_seq
index|[
literal|0
index|]
argument_list|,
name|asoc
operator|->
name|last_base_tsnsent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|,
name|asoc
operator|->
name|last_sending_seq
index|[
literal|1
index|]
argument_list|,
name|asoc
operator|->
name|last_base_tsnsent
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_RESULT_ERR_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_str_reset_request_out
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req
parameter_list|,
name|int
name|trunc
parameter_list|)
block|{
name|uint32_t
name|seq
decl_stmt|,
name|tsn
decl_stmt|;
name|int
name|number_entries
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
expr_stmt|;
comment|/* now if its not a duplicate we process it */
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|len
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|number_entries
operator|=
operator|(
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * the sender is resetting, handle the list issue.. we must 		 * a) verify if we can do the reset, if so no problem b) If 		 * we can't do the reset we must copy the request. c) queue 		 * it, and setup the data in processor to trigger it off 		 * when needed and dequeue all the queued data. 		 */
name|tsn
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|send_reset_at_tsn
argument_list|)
expr_stmt|;
comment|/* move the reset action back one */
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|local_strreset_support
operator|&
name|SCTP_ENABLE_RESET_STREAM_REQ
operator|)
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|trunc
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|tsn
argument_list|)
condition|)
block|{
comment|/* we can do it now */
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * we must queue it up and thus wait for the TSN's 			 * to arrive that are at or before tsn 			 */
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
name|int
name|siz
decl_stmt|;
name|siz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_list
argument_list|)
operator|+
operator|(
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|liste
argument_list|,
expr|struct
name|sctp_stream_reset_list
operator|*
argument_list|,
name|siz
argument_list|,
name|SCTP_M_STRESET
argument_list|)
expr_stmt|;
if|if
condition|(
name|liste
operator|==
name|NULL
condition|)
block|{
comment|/* gak out of memory */
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|liste
operator|->
name|seq
operator|=
name|seq
expr_stmt|;
name|liste
operator|->
name|tsn
operator|=
name|tsn
expr_stmt|;
name|liste
operator|->
name|number_entries
operator|=
name|number_entries
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|liste
operator|->
name|list_of_streams
argument_list|,
name|req
operator|->
name|list_of_streams
argument_list|,
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|liste
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_IN_PROGRESS
expr_stmt|;
block|}
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * one seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * two seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_RESULT_ERR_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_str_reset_add_strm
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_add_strm
modifier|*
name|str_add
parameter_list|)
block|{
comment|/* 	 * Peer is requesting to add more streams. If its within our 	 * max-streams we will allow it. 	 */
name|uint32_t
name|num_stream
decl_stmt|,
name|i
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|,
modifier|*
name|nctl
decl_stmt|;
comment|/* Get the number. */
name|seq
operator|=
name|ntohl
argument_list|(
name|str_add
operator|->
name|request_seq
argument_list|)
expr_stmt|;
name|num_stream
operator|=
name|ntohs
argument_list|(
name|str_add
operator|->
name|number_of_streams
argument_list|)
expr_stmt|;
comment|/* Now what would be the new total? */
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|num_stream
operator|+=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|local_strreset_support
operator|&
name|SCTP_ENABLE_CHANGE_ASSOC_REQ
operator|)
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num_stream
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|max_inbound_streams
operator|)
operator|||
operator|(
name|num_stream
operator|>
literal|0xffff
operator|)
condition|)
block|{
comment|/* We must reject it they ask for to many */
name|denied
label|:
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
else|else
block|{
comment|/* Ok, we can do that :-) */
name|struct
name|sctp_stream_in
modifier|*
name|oldstrm
decl_stmt|;
comment|/* save off the old */
name|oldstrm
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|strmin
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|strmin
argument_list|,
expr|struct
name|sctp_stream_in
operator|*
argument_list|,
operator|(
name|num_stream
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_in
argument_list|)
operator|)
argument_list|,
name|SCTP_M_STRMI
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|strmin
operator|==
name|NULL
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmin
operator|=
name|oldstrm
expr_stmt|;
goto|goto
name|denied
goto|;
block|}
comment|/* copy off the old data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|uno_inqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|sid
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|last_mid_delivered
operator|=
name|oldstrm
index|[
name|i
index|]
operator|.
name|last_mid_delivered
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|delivery_started
operator|=
name|oldstrm
index|[
name|i
index|]
operator|.
name|delivery_started
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|pd_api_started
operator|=
name|oldstrm
index|[
name|i
index|]
operator|.
name|pd_api_started
expr_stmt|;
comment|/* now anything on those queues? */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ctl
argument_list|,
argument|&oldstrm[i].inqueue
argument_list|,
argument|next_instrm
argument_list|,
argument|nctl
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|oldstrm
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ctl
argument_list|,
argument|&oldstrm[i].uno_inqueue
argument_list|,
argument|next_instrm
argument_list|,
argument|nctl
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|oldstrm
index|[
name|i
index|]
operator|.
name|uno_inqueue
argument_list|,
name|ctl
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|uno_inqueue
argument_list|,
name|ctl
argument_list|,
name|next_instrm
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Init the new streams */
for|for
control|(
name|i
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
init|;
name|i
operator|<
name|num_stream
condition|;
name|i
operator|++
control|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|uno_inqueue
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|sid
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|last_mid_delivered
operator|=
literal|0xffffffff
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|pd_api_started
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|oldstrm
argument_list|,
name|SCTP_M_STRMI
argument_list|)
expr_stmt|;
comment|/* update the size */
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
operator|=
name|num_stream
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
expr_stmt|;
name|sctp_notify_stream_reset_add
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * one seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * two seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_RESULT_ERR_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_str_reset_add_out_strm
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_add_strm
modifier|*
name|str_add
parameter_list|)
block|{
comment|/* 	 * Peer is requesting to add more streams. If its within our 	 * max-streams we will allow it. 	 */
name|uint16_t
name|num_stream
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
comment|/* Get the number. */
name|seq
operator|=
name|ntohl
argument_list|(
name|str_add
operator|->
name|request_seq
argument_list|)
expr_stmt|;
name|num_stream
operator|=
name|ntohs
argument_list|(
name|str_add
operator|->
name|number_of_streams
argument_list|)
expr_stmt|;
comment|/* Now what would be the new total? */
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|local_strreset_support
operator|&
name|SCTP_ENABLE_CHANGE_ASSOC_REQ
operator|)
condition|)
block|{
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
condition|)
block|{
comment|/* We must reject it we have something pending */
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_ERR_IN_PROGRESS
expr_stmt|;
block|}
else|else
block|{
comment|/* Ok, we can do that :-) */
name|int
name|mychk
decl_stmt|;
name|mychk
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
expr_stmt|;
name|mychk
operator|+=
name|num_stream
expr_stmt|;
if|if
condition|(
name|mychk
operator|<
literal|0x10000
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_PERFORMED
expr_stmt|;
if|if
condition|(
name|sctp_send_str_reset_req
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|num_stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_RESULT_DENIED
expr_stmt|;
block|}
block|}
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * one seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * two seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_RESULT_ERR_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_macro
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|sctp_handle_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch_req
parameter_list|)
block|{
name|uint16_t
name|remaining_length
decl_stmt|,
name|param_len
decl_stmt|,
name|ptype
decl_stmt|;
name|struct
name|sctp_paramhdr
name|pstore
decl_stmt|;
name|uint8_t
name|cstore
index|[
name|SCTP_CHUNK_BUFFER_SIZE
index|]
decl_stmt|;
name|uint32_t
name|seq
init|=
literal|0
decl_stmt|;
name|int
name|num_req
init|=
literal|0
decl_stmt|;
name|int
name|trunc
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|int
name|ret_code
init|=
literal|0
decl_stmt|;
name|int
name|num_param
init|=
literal|0
decl_stmt|;
comment|/* now it may be a reset or a reset-response */
name|remaining_length
operator|=
name|ntohs
argument_list|(
name|ch_req
operator|->
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
comment|/* setup for adding the response */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
name|chk
operator|->
name|copy_by_ref
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|strres_nochunk
label|:
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
comment|/* setup chunk parameters */
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|NULL
expr_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|ch
operator|->
name|chunk_type
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|ch
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining_length
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|pstore
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|pstore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
break|break;
block|}
name|param_len
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|param_len
operator|>
name|remaining_length
operator|)
operator|||
operator|(
name|param_len
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* bad parameter length */
break|break;
block|}
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|min
argument_list|(
name|param_len
argument_list|,
sizeof|sizeof
argument_list|(
name|cstore
argument_list|)
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|cstore
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH */
break|break;
block|}
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|num_param
operator|++
expr_stmt|;
if|if
condition|(
name|param_len
operator|>
sizeof|sizeof
argument_list|(
name|cstore
argument_list|)
condition|)
block|{
name|trunc
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|trunc
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|num_param
operator|>
name|SCTP_MAX_RESET_PARAMS
condition|)
block|{
comment|/* hit the max of parameters already sorry.. */
break|break;
block|}
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_OUT_REQUEST
condition|)
block|{
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req_out
decl_stmt|;
if|if
condition|(
name|param_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
condition|)
block|{
break|break;
block|}
name|req_out
operator|=
operator|(
expr|struct
name|sctp_stream_reset_out_request
operator|*
operator|)
name|ph
expr_stmt|;
name|num_req
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|req_out
operator|->
name|response_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
condition|)
block|{
comment|/* implicit ack */
operator|(
name|void
operator|)
name|sctp_handle_stream_reset_response
argument_list|(
name|stcb
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_RESULT_PERFORMED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sctp_handle_str_reset_request_out
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|req_out
argument_list|,
name|trunc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_ADD_OUT_STREAMS
condition|)
block|{
name|struct
name|sctp_stream_reset_add_strm
modifier|*
name|str_add
decl_stmt|;
if|if
condition|(
name|param_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_add_strm
argument_list|)
condition|)
block|{
break|break;
block|}
name|str_add
operator|=
operator|(
expr|struct
name|sctp_stream_reset_add_strm
operator|*
operator|)
name|ph
expr_stmt|;
name|num_req
operator|++
expr_stmt|;
name|sctp_handle_str_reset_add_strm
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|str_add
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_ADD_IN_STREAMS
condition|)
block|{
name|struct
name|sctp_stream_reset_add_strm
modifier|*
name|str_add
decl_stmt|;
if|if
condition|(
name|param_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_add_strm
argument_list|)
condition|)
block|{
break|break;
block|}
name|str_add
operator|=
operator|(
expr|struct
name|sctp_stream_reset_add_strm
operator|*
operator|)
name|ph
expr_stmt|;
name|num_req
operator|++
expr_stmt|;
name|sctp_handle_str_reset_add_out_strm
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|str_add
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_IN_REQUEST
condition|)
block|{
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req_in
decl_stmt|;
name|num_req
operator|++
expr_stmt|;
name|req_in
operator|=
operator|(
expr|struct
name|sctp_stream_reset_in_request
operator|*
operator|)
name|ph
expr_stmt|;
name|sctp_handle_str_reset_request_in
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|req_in
argument_list|,
name|trunc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_TSN_REQUEST
condition|)
block|{
name|struct
name|sctp_stream_reset_tsn_request
modifier|*
name|req_tsn
decl_stmt|;
name|num_req
operator|++
expr_stmt|;
name|req_tsn
operator|=
operator|(
expr|struct
name|sctp_stream_reset_tsn_request
operator|*
operator|)
name|ph
expr_stmt|;
if|if
condition|(
name|sctp_handle_str_reset_request_tsn
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|req_tsn
argument_list|)
condition|)
block|{
name|ret_code
operator|=
literal|1
expr_stmt|;
goto|goto
name|strres_nochunk
goto|;
block|}
comment|/* no more */
break|break;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_RESPONSE
condition|)
block|{
name|struct
name|sctp_stream_reset_response
modifier|*
name|resp
decl_stmt|;
name|uint32_t
name|result
decl_stmt|;
if|if
condition|(
name|param_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_response
argument_list|)
condition|)
block|{
break|break;
block|}
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response
operator|*
operator|)
name|ph
expr_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|response_seq
argument_list|)
expr_stmt|;
name|result
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_stream_reset_response
argument_list|(
name|stcb
argument_list|,
name|seq
argument_list|,
name|result
argument_list|,
name|resp
argument_list|)
condition|)
block|{
name|ret_code
operator|=
literal|1
expr_stmt|;
goto|goto
name|strres_nochunk
goto|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|param_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_length
operator|>=
name|SCTP_SIZE32
argument_list|(
name|param_len
argument_list|)
condition|)
block|{
name|remaining_length
operator|-=
name|SCTP_SIZE32
argument_list|(
name|param_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|remaining_length
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_req
operator|==
literal|0
condition|)
block|{
comment|/* we have no response free the stuff */
goto|goto
name|strres_nochunk
goto|;
block|}
comment|/* ok we have a chunk to link in */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a router or endpoints report of a packet loss, there are two ways  * to handle this, either we get the whole packet and must disect it  * ourselves (possibly with truncation and or corruption) or it is a summary  * from a middle box that did the disectting for us.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_handle_packet_dropped
parameter_list|(
name|struct
name|sctp_pktdrop_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|limit
parameter_list|)
block|{
name|uint32_t
name|bottle_bw
decl_stmt|,
name|on_queue
decl_stmt|;
name|uint16_t
name|trunc_len
decl_stmt|;
name|unsigned
name|int
name|chlen
decl_stmt|;
name|unsigned
name|int
name|at
decl_stmt|;
name|struct
name|sctp_chunk_desc
name|desc
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|chlen
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
name|chlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
expr_stmt|;
comment|/* XXX possible chlen underflow */
if|if
condition|(
name|chlen
operator|==
literal|0
condition|)
block|{
name|ch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpbwrpt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
name|cp
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
name|chlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
comment|/* XXX possible chlen underflow */
name|memset
argument_list|(
operator|&
name|desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|trunc_len
operator|=
operator|(
name|uint16_t
operator|)
name|ntohs
argument_list|(
name|cp
operator|->
name|trunc_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|trunc_len
operator|>
name|limit
condition|)
block|{
name|trunc_len
operator|=
name|limit
expr_stmt|;
block|}
comment|/* now the chunks themselves */
while|while
condition|(
operator|(
name|ch
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|chlen
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
condition|)
block|{
name|desc
operator|.
name|chunk_type
operator|=
name|ch
operator|->
name|chunk_type
expr_stmt|;
comment|/* get amount we need to move */
name|at
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
comment|/* corrupt chunk, maybe at the end? */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpcrupt
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trunc_len
operator|==
literal|0
condition|)
block|{
comment|/* we are supposed to have all of it */
if|if
condition|(
name|at
operator|>
name|chlen
condition|)
block|{
comment|/* corrupt skip it */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpcrupt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* is there enough of it left ? */
if|if
condition|(
name|desc
operator|.
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
if|if
condition|(
name|chlen
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|data_bytes
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|desc
operator|.
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
comment|/* can we get out the tsn? */
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpmbda
argument_list|)
expr_stmt|;
if|if
condition|(
name|chlen
operator|>=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|)
block|{
comment|/* yep */
name|struct
name|sctp_data_chunk
modifier|*
name|dcp
decl_stmt|;
name|uint8_t
modifier|*
name|ddp
decl_stmt|;
name|unsigned
name|int
name|iii
decl_stmt|;
name|dcp
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|ch
expr_stmt|;
name|ddp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|dcp
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|data_bytes
argument_list|)
condition|;
name|iii
operator|++
control|)
block|{
name|desc
operator|.
name|data_bytes
index|[
name|iii
index|]
operator|=
name|ddp
index|[
name|iii
index|]
expr_stmt|;
block|}
name|desc
operator|.
name|tsn_ifany
operator|=
name|dcp
operator|->
name|dp
operator|.
name|tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* nope we are done. */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpnedat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpmbct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|process_chunk_drop
argument_list|(
name|stcb
argument_list|,
operator|&
name|desc
argument_list|,
name|net
argument_list|,
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrppdbrk
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|at
argument_list|)
operator|>
name|chlen
condition|)
block|{
break|break;
block|}
name|chlen
operator|-=
name|SCTP_SIZE32
argument_list|(
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|chlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
comment|/* done, none left */
break|break;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|SCTP_SIZE32
argument_list|(
name|at
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Now update any rwnd --- possibly */
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* From a peer, we get a rwnd report */
name|uint32_t
name|a_rwnd
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpfehos
argument_list|)
expr_stmt|;
name|bottle_bw
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|bottle_bw
argument_list|)
expr_stmt|;
name|on_queue
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|current_onq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottle_bw
operator|&&
name|on_queue
condition|)
block|{
comment|/* a rwnd report is in here */
if|if
condition|(
name|bottle_bw
operator|>
name|on_queue
condition|)
name|a_rwnd
operator|=
name|bottle_bw
operator|-
name|on_queue
expr_stmt|;
else|else
name|a_rwnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a_rwnd
operator|==
literal|0
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|a_rwnd
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
name|a_rwnd
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpfmbox
argument_list|)
expr_stmt|;
block|}
comment|/* now middle boxes in sat networks get a cwnd bump */
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sat_t3_loss_recovery
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
operator|)
condition|)
block|{
comment|/* 		 * This is debatable but for sat networks it makes sense 		 * Note if a T3 timer has went off, we will prohibit any 		 * changes to cwnd until we exit the t3 loss recovery. 		 */
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_cwnd_update_after_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|cp
argument_list|,
operator|&
name|bottle_bw
argument_list|,
operator|&
name|on_queue
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * handles all control chunks in a packet inputs: - m: mbuf chain, assumed to  * still contain IP/SCTP header - stcb: is the tcb found for this packet -  * offset: offset into the mbuf chain to first chunkhdr - length: is the  * length of the complete packet outputs: - length: modified to remaining  * length after control processing - netp: modified to new sctp_nets after  * cookie-echo processing - return NULL to discard the packet (ie. no asoc,  * bad packet,...) otherwise return the tcb for this packet  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_macro
name|__attribute__
argument_list|(
argument|(noinline)
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_control
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
modifier|*
name|fwd_tsn_seen
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint16_t
name|fibnum
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|uint32_t
name|vtag_in
decl_stmt|;
name|int
name|num_chunks
init|=
literal|0
decl_stmt|;
comment|/* number of control chunks processed */
name|uint32_t
name|chk_length
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|abort_no_unlock
init|=
literal|0
decl_stmt|;
name|int
name|ecne_seen
init|=
literal|0
decl_stmt|;
comment|/* 	 * How big should this be, and should it be alloc'd? Lets try the 	 * d-mtu-ceiling for now (2k) and that should hopefully work ... 	 * until we get into jumbo grams and such.. 	 */
name|uint8_t
name|chunk_buf
index|[
name|SCTP_CHUNK_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|locked_tcb
init|=
name|stcb
decl_stmt|;
name|int
name|got_auth
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|,
name|auth_len
init|=
literal|0
decl_stmt|;
name|int
name|auth_skipped
init|=
literal|0
decl_stmt|;
name|int
name|asconf_cnt
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"sctp_process_control: iphlen=%u, offset=%u, length=%u stcb:%p\n"
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|length
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
comment|/* validate chunk header length... */
if|if
condition|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Invalid header length %d\n"
argument_list|,
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * validate the verification tag 	 */
name|vtag_in
operator|=
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Its an INIT of len:%d vtag:%x\n"
argument_list|,
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
argument_list|,
name|vtag_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|vtag_in
operator|!=
literal|0
condition|)
block|{
comment|/* protocol error- silently discard... */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_COOKIE_ECHO
condition|)
block|{
comment|/* 		 * If there is no stcb, skip the AUTH chunk and process 		 * later after a stcb is found (to validate the lookup was 		 * valid. 		 */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_AUTHENTICATION
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|inp
operator|->
name|auth_supported
operator|==
literal|1
operator|)
condition|)
block|{
comment|/* save this chunk for later processing */
name|auth_skipped
operator|=
literal|1
expr_stmt|;
name|auth_offset
operator|=
operator|*
name|offset
expr_stmt|;
name|auth_len
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* (temporarily) move past this chunk */
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|auth_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|>=
name|length
condition|)
block|{
comment|/* no more data left in the mbuf chain */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
comment|/* Help */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
goto|goto
name|process_control_chunks
goto|;
block|}
comment|/* 		 * first check if it's an ASCONF with an unknown src addr we 		 * need to look inside to find the association 		 */
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ASCONF
operator|&&
name|stcb
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|asconf_ch
init|=
name|ch
decl_stmt|;
name|uint32_t
name|asconf_offset
init|=
literal|0
decl_stmt|,
name|asconf_len
init|=
literal|0
decl_stmt|;
comment|/* inp's refcount may be reduced */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|asconf_offset
operator|=
operator|*
name|offset
expr_stmt|;
do|do
block|{
name|asconf_len
operator|=
name|ntohs
argument_list|(
name|asconf_ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|asconf_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
condition|)
break|break;
name|stcb
operator|=
name|sctp_findassociation_ep_asconf
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
operator|&
name|inp
argument_list|,
name|netp
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
break|break;
name|asconf_offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|asconf_len
argument_list|)
expr_stmt|;
name|asconf_ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|asconf_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|asconf_ch
operator|!=
name|NULL
operator|&&
name|asconf_ch
operator|->
name|chunk_type
operator|==
name|SCTP_ASCONF
condition|)
do|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * reduce inp's refcount if not reduced in 				 * sctp_findassociation_ep_asconf(). 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|locked_tcb
operator|=
name|stcb
expr_stmt|;
block|}
comment|/* now go back and verify any auth chunk to be sure */
if|if
condition|(
name|auth_skipped
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
decl_stmt|;
name|auth
operator|=
operator|(
expr|struct
name|sctp_auth_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
name|got_auth
operator|=
literal|1
expr_stmt|;
name|auth_skipped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|auth
operator|==
name|NULL
operator|)
operator|||
name|sctp_handle_auth
argument_list|(
name|stcb
argument_list|,
name|auth
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|)
condition|)
block|{
comment|/* auth HMAC failed so dump it */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* remaining chunks are HMAC checked */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"OOTB, %s:%d at %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
comment|/* no association, so it's out of the blue... */
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* ABORT and SHUTDOWN can use either v_tag... */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ABORT_ASSOCIATION
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_PACKET_DROPPED
operator|)
condition|)
block|{
comment|/* Take the T-bit always into account. */
if|if
condition|(
operator|(
operator|(
operator|(
name|ch
operator|->
name|chunk_flags
operator|&
name|SCTP_HAD_NO_TCB
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|vtag_in
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|ch
operator|->
name|chunk_flags
operator|&
name|SCTP_HAD_NO_TCB
operator|)
operator|==
name|SCTP_HAD_NO_TCB
operator|)
operator|&&
operator|(
name|vtag_in
operator|==
name|asoc
operator|->
name|peer_vtag
operator|)
operator|)
condition|)
block|{
comment|/* this is valid */
block|}
else|else
block|{
comment|/* drop this packet... */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_ACK
condition|)
block|{
if|if
condition|(
name|vtag_in
operator|!=
name|asoc
operator|->
name|my_vtag
condition|)
block|{
comment|/* 				 * this could be a stale SHUTDOWN-ACK or the 				 * peer never got the SHUTDOWN-COMPLETE and 				 * is still hung; we have started a new asoc 				 * but it won't complete until the shutdown 				 * is completed 				 */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"OOTB, %s:%d at %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* for all other chunks, vtag must match */
if|if
condition|(
name|vtag_in
operator|!=
name|asoc
operator|->
name|my_vtag
condition|)
block|{
comment|/* invalid vtag... */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"invalid vtag: %xh, expect %xh\n"
argument_list|,
name|vtag_in
argument_list|,
name|asoc
operator|->
name|my_vtag
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/* end if !SCTP_COOKIE_ECHO */
comment|/* 	 * process all control chunks... 	 */
if|if
condition|(
operator|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_NR_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_HEARTBEAT_REQUEST
operator|)
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
comment|/* implied cookie-ack.. we must have lost the ack */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_cookie_ack
argument_list|(
operator|(
expr|struct
name|sctp_cookie_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
block|}
name|process_control_chunks
label|:
while|while
condition|(
name|IS_SCTP_CONTROL
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* validate chunk length */
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT2
argument_list|,
literal|"sctp_process_control: processing a chunk type=%u, len=%u\n"
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|,
name|chk_length
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_CHK
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|,
name|chk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
operator|||
operator|(
operator|*
name|offset
operator|+
operator|(
name|int
operator|)
name|chk_length
operator|)
operator|>
name|length
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_incontrolchunks
argument_list|)
expr_stmt|;
comment|/* 		 * INIT-ACK only gets the init ack "header" portion only 		 * because we don't have to process the peer's COOKIE. All 		 * others get a complete chunk. 		 */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION_ACK
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
operator|)
condition|)
block|{
comment|/* get an init-ack chunk */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* For cookies and all other chunks. */
if|if
condition|(
name|chk_length
operator|>
sizeof|sizeof
argument_list|(
name|chunk_buf
argument_list|)
condition|)
block|{
comment|/* 				 * use just the size of the chunk buffer so 				 * the front part of our chunks fit in 				 * contiguous space up to the chunk buffer 				 * size (508 bytes). For chunks that need to 				 * get more than that they must use the 				 * sctp_m_getptr() function or other means 				 * (e.g. know how to parse mbuf chains). 				 * Cookies do this already. 				 */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|chunk_buf
argument_list|)
operator|-
literal|4
operator|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* We can fit it all */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"sctp_process_control: Can't get the all data....\n"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
name|num_chunks
operator|++
expr_stmt|;
comment|/* Save off the last place we got a control from */
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|netp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|netp
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ASCONF
operator|)
condition|)
block|{
comment|/* 				 * allow last_control to be NULL if 				 * ASCONF... ASCONF processing will find the 				 * right net later 				 */
if|if
condition|(
operator|(
name|netp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|netp
operator|!=
name|NULL
operator|)
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|=
operator|*
name|netp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB0
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check to see if this chunk required auth, but isn't */
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|1
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|ch
operator|->
name|chunk_type
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
condition|)
block|{
comment|/* "silently" ignore */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthmissing
argument_list|)
expr_stmt|;
goto|goto
name|next_chunk
goto|;
block|}
switch|switch
condition|(
name|ch
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INITIATION
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_INIT\n"
argument_list|)
expr_stmt|;
comment|/* The INIT chunk must be the only chunk. */
if|if
condition|(
operator|(
name|num_chunks
operator|>
literal|1
operator|)
operator|||
operator|(
name|length
operator|-
operator|*
name|offset
operator|>
operator|(
name|int
operator|)
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|)
condition|)
block|{
comment|/* RFC 4960 requires that no ABORT is sent */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Honor our resource limit. */
if|if
condition|(
name|chk_length
operator|>
name|SCTP_LARGEST_INIT_ACCEPTED
condition|)
block|{
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sctp_handle_init
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|ch
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_no_unlock
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|abort_no_unlock
operator|)
operator|&&
operator|(
name|locked_tcb
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_PAD_CHUNK
case|:
break|break;
case|case
name|SCTP_INITIATION_ACK
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_INIT-ACK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|locked_tcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|locked_tcb
operator|!=
name|stcb
operator|)
condition|)
block|{
comment|/* Very unlikely */
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_29
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* The INIT-ACK chunk must be the only chunk. */
if|if
condition|(
operator|(
name|num_chunks
operator|>
literal|1
operator|)
operator|||
operator|(
name|length
operator|-
operator|*
name|offset
operator|>
operator|(
name|int
operator|)
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|netp
operator|)
operator|&&
operator|(
operator|*
name|netp
operator|)
condition|)
block|{
name|ret
operator|=
name|sctp_handle_init_ack
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sctp_init_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_no_unlock
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|abort_no_unlock
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 			 * Special case, I must call the output routine to 			 * get the cookie echoed 			 */
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ret
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CONTROL_PROC
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_SELECTIVE_ACK
case|:
block|{
name|struct
name|sctp_sack_chunk
modifier|*
name|sack
decl_stmt|;
name|int
name|abort_now
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|,
name|cum_ack
decl_stmt|;
name|uint16_t
name|num_seg
decl_stmt|,
name|num_dup
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|int
name|offset_seg
decl_stmt|,
name|offset_dup
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_SACK\n"
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvsacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"No stcb when processing SACK chunk\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Bad size on SACK chunk, too small\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
comment|/*- 					 * If we have sent a shutdown-ack, we will pay no 					 * attention to a sack sent in to us since 					 * we don't care anymore. 					 */
break|break;
block|}
name|sack
operator|=
operator|(
expr|struct
name|sctp_sack_chunk
operator|*
operator|)
name|ch
expr_stmt|;
name|flags
operator|=
name|ch
operator|->
name|chunk_flags
expr_stmt|;
name|cum_ack
operator|=
name|ntohl
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|cum_tsn_ack
argument_list|)
expr_stmt|;
name|num_seg
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|num_gap_ack_blks
argument_list|)
expr_stmt|;
name|num_dup
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|num_dup_tsns
argument_list|)
expr_stmt|;
name|a_rwnd
operator|=
operator|(
name|uint32_t
operator|)
name|ntohl
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
operator|+
name|num_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|+
name|num_dup
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|!=
name|chk_length
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Bad size of SACK chunk\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|offset_seg
operator|=
operator|*
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
expr_stmt|;
name|offset_dup
operator|=
name|offset_seg
operator|+
name|num_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_SACK process cum_ack:%x num_seg:%d a_rwnd:%d\n"
argument_list|,
name|cum_ack
argument_list|,
name|num_seg
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|pr_sctp_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_seg
operator|==
literal|0
operator|)
operator|&&
name|SCTP_TSN_GE
argument_list|(
name|cum_ack
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|saw_sack_with_frags
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|saw_sack_with_nr_frags
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We have a SIMPLE sack having no 					 * prior segments and data on sent 					 * queue to be acked.. Use the 					 * faster path sack processing. We 					 * also allow window update sacks 					 * with no missing segments to go 					 * this way too. 					 */
name|sctp_express_handle_sack
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
operator|&
name|abort_now
argument_list|,
name|ecne_seen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|netp
operator|&&
operator|*
name|netp
condition|)
name|sctp_handle_sack
argument_list|(
name|m
argument_list|,
name|offset_seg
argument_list|,
name|offset_dup
argument_list|,
name|stcb
argument_list|,
name|num_seg
argument_list|,
literal|0
argument_list|,
name|num_dup
argument_list|,
operator|&
name|abort_now
argument_list|,
name|flags
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
name|ecne_seen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abort_now
condition|)
block|{
comment|/* ABORT signal from sack processing */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENDER_DRY
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* 			 * EY - nr_sack:  If the received chunk is an 			 * nr_sack chunk 			 */
case|case
name|SCTP_NR_SELECTIVE_ACK
case|:
block|{
name|struct
name|sctp_nr_sack_chunk
modifier|*
name|nr_sack
decl_stmt|;
name|int
name|abort_now
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|,
name|cum_ack
decl_stmt|;
name|uint16_t
name|num_seg
decl_stmt|,
name|num_nr_seg
decl_stmt|,
name|num_dup
decl_stmt|;
name|uint8_t
name|flags
decl_stmt|;
name|int
name|offset_seg
decl_stmt|,
name|offset_dup
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_NR_SACK\n"
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvsacks
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"No stcb when processing NR-SACK chunk\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|nrsack_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Bad size on NR-SACK chunk, too small\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
comment|/*- 					 * If we have sent a shutdown-ack, we will pay no 					 * attention to a sack sent in to us since 					 * we don't care anymore. 					 */
break|break;
block|}
name|nr_sack
operator|=
operator|(
expr|struct
name|sctp_nr_sack_chunk
operator|*
operator|)
name|ch
expr_stmt|;
name|flags
operator|=
name|ch
operator|->
name|chunk_flags
expr_stmt|;
name|cum_ack
operator|=
name|ntohl
argument_list|(
name|nr_sack
operator|->
name|nr_sack
operator|.
name|cum_tsn_ack
argument_list|)
expr_stmt|;
name|num_seg
operator|=
name|ntohs
argument_list|(
name|nr_sack
operator|->
name|nr_sack
operator|.
name|num_gap_ack_blks
argument_list|)
expr_stmt|;
name|num_nr_seg
operator|=
name|ntohs
argument_list|(
name|nr_sack
operator|->
name|nr_sack
operator|.
name|num_nr_gap_ack_blks
argument_list|)
expr_stmt|;
name|num_dup
operator|=
name|ntohs
argument_list|(
name|nr_sack
operator|->
name|nr_sack
operator|.
name|num_dup_tsns
argument_list|)
expr_stmt|;
name|a_rwnd
operator|=
operator|(
name|uint32_t
operator|)
name|ntohl
argument_list|(
name|nr_sack
operator|->
name|nr_sack
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
operator|+
operator|(
name|num_seg
operator|+
name|num_nr_seg
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
operator|+
name|num_dup
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|!=
name|chk_length
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INDATA1
argument_list|,
literal|"Bad size of NR_SACK chunk\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|offset_seg
operator|=
operator|*
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_nr_sack_chunk
argument_list|)
expr_stmt|;
name|offset_dup
operator|=
name|offset_seg
operator|+
name|num_seg
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gap_ack_block
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_NR_SACK process cum_ack:%x num_seg:%d a_rwnd:%d\n"
argument_list|,
name|cum_ack
argument_list|,
name|num_seg
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|pr_sctp_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_seg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_nr_seg
operator|==
literal|0
operator|)
operator|&&
name|SCTP_TSN_GE
argument_list|(
name|cum_ack
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|saw_sack_with_frags
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|saw_sack_with_nr_frags
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We have a SIMPLE sack having no 					 * prior segments and data on sent 					 * queue to be acked. Use the faster 					 * path sack processing. We also 					 * allow window update sacks with no 					 * missing segments to go this way 					 * too. 					 */
name|sctp_express_handle_sack
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
operator|&
name|abort_now
argument_list|,
name|ecne_seen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|netp
operator|&&
operator|*
name|netp
condition|)
name|sctp_handle_sack
argument_list|(
name|m
argument_list|,
name|offset_seg
argument_list|,
name|offset_dup
argument_list|,
name|stcb
argument_list|,
name|num_seg
argument_list|,
name|num_nr_seg
argument_list|,
name|num_dup
argument_list|,
operator|&
name|abort_now
argument_list|,
name|flags
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
name|ecne_seen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abort_now
condition|)
block|{
comment|/* ABORT signal from sack processing */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_queue_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SENDER_DRY
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_HEARTBEAT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|*
name|netp
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvheartbeat
argument_list|)
expr_stmt|;
name|sctp_send_heartbeat_ack
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
comment|/* He's alive so give him credit */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_HEARTBEAT_ACK
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_HEARTBEAT-ACK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
operator|)
condition|)
block|{
comment|/* Its not ours */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* He's alive so give him credit */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvheartbeatack
argument_list|)
expr_stmt|;
if|if
condition|(
name|netp
operator|&&
operator|*
name|netp
condition|)
name|sctp_handle_heartbeat_ack
argument_list|(
operator|(
expr|struct
name|sctp_heartbeat_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_ABORT, stcb %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|*
name|netp
condition|)
name|sctp_handle_abort
argument_list|(
operator|(
expr|struct
name|sctp_abort_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_SHUTDOWN
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_SHUTDOWN, stcb %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
operator|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|netp
operator|&&
operator|*
name|netp
condition|)
block|{
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
name|sctp_handle_shutdown
argument_list|(
operator|(
expr|struct
name|sctp_shutdown_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_SHUTDOWN-ACK, stcb %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|netp
operator|)
operator|&&
operator|(
operator|*
name|netp
operator|)
condition|)
name|sctp_handle_shutdown_ack
argument_list|(
operator|(
expr|struct
name|sctp_shutdown_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_OPERATION_ERROR
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_OP-ERR\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|*
name|netp
operator|&&
name|sctp_handle_error
argument_list|(
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_COOKIE_ECHO
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_COOKIE-ECHO, stcb %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
name|abend
label|:
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/*- 			 * First are we accepting? We do this again here 			 * since it is possible that a previous endpoint WAS 			 * listening responded to a INIT-ACK and then 			 * closed. We opened and bound.. and are now no 			 * longer listening. 			 * 			 * XXXGL: notes on checking listen queue length. 			 * 1) SCTP_IS_LISTENING() doesn't necessarily mean 			 *    SOLISTENING(), because a listening "UDP type" 			 *    socket isn't listening in terms of the socket 			 *    layer.  It is a normal data flow socket, that 			 *    can fork off new connections.  Thus, we should 			 *    look into sol_qlen only in case we are !UDP. 			 * 2) Checking sol_qlen in general requires locking 			 *    the socket, and this code lacks that. 			 */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|SCTP_IS_LISTENING
argument_list|(
name|inp
argument_list|)
operator|||
operator|(
operator|!
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
operator|)
operator|&&
name|inp
operator|->
name|sctp_socket
operator|->
name|sol_qlen
operator|>=
name|inp
operator|->
name|sctp_socket
operator|->
name|sol_qlimit
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_abort_if_one_2_one_hits_limit
argument_list|)
operator|)
condition|)
block|{
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|ret_buf
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|linp
decl_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|linp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|linp
operator|=
name|inp
expr_stmt|;
block|}
if|if
condition|(
name|linp
condition|)
block|{
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|linp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|||
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_ALLGONE
operator|)
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|linp
argument_list|)
expr_stmt|;
goto|goto
name|abend
goto|;
block|}
block|}
if|if
condition|(
name|netp
condition|)
block|{
name|ret_buf
operator|=
name|sctp_handle_cookie_echo
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sctp_cookie_echo_chunk
operator|*
operator|)
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|stcb
argument_list|,
name|netp
argument_list|,
name|auth_skipped
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
operator|&
name|locked_tcb
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret_buf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|linp
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|linp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret_buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"GAK, null buffer\n"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* if AUTH skipped, see if it verified... */
if|if
condition|(
name|auth_skipped
condition|)
block|{
name|got_auth
operator|=
literal|1
expr_stmt|;
name|auth_skipped
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* 					 * Restart the timer if we have 					 * pending data 					 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_COOKIE_ACK
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_COOKIE-ACK, stcb %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_ack_chunk
argument_list|)
condition|)
block|{
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|stcb
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_30
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* He's alive so give him credit */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|*
name|netp
condition|)
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_cookie_ack
argument_list|(
operator|(
expr|struct
name|sctp_cookie_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_ECN_ECHO
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_ECN-ECHO\n"
argument_list|)
expr_stmt|;
comment|/* He's alive so give him credit */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
operator|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_ecn_echo
argument_list|(
operator|(
expr|struct
name|sctp_ecne_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|ecne_seen
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_ECN_CWR
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_ECN-CWR\n"
argument_list|)
expr_stmt|;
comment|/* He's alive so give him credit */
if|if
condition|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cwr_chunk
argument_list|)
operator|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_ecn_cwr
argument_list|(
operator|(
expr|struct
name|sctp_cwr_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_SHUTDOWN-COMPLETE, stcb %p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
comment|/* must be first and only chunk */
if|if
condition|(
operator|(
name|num_chunks
operator|>
literal|1
operator|)
operator|||
operator|(
name|length
operator|-
operator|*
name|offset
operator|>
operator|(
name|int
operator|)
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|*
name|netp
condition|)
block|{
name|sctp_handle_shutdown_complete
argument_list|(
operator|(
expr|struct
name|sctp_shutdown_complete_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_ASCONF
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_ASCONF\n"
argument_list|)
expr_stmt|;
comment|/* He's alive so give him credit */
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_asconf
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|src
argument_list|,
operator|(
expr|struct
name|sctp_asconf_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
name|asconf_cnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|asconf_cnt
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_ASCONF_ACK
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_ASCONF-ACK\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|*
name|netp
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
comment|/* He's alive so give him credit */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_asconf_ack
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_asconf_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_no_unlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_no_unlock
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
case|case
name|SCTP_IFORWARD_CUM_TSN
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_FWD-TSN\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* He's alive so give him credit */
if|if
condition|(
name|stcb
condition|)
block|{
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|prsctp_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
operator|*
name|fwd_tsn_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_31
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 				 * For sending a SACK this looks like DATA 				 * chunks. 				 */
name|stcb
operator|->
name|asoc
operator|.
name|last_data_chunk_from
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
expr_stmt|;
name|sctp_handle_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sctp_forward_tsn_chunk
operator|*
operator|)
name|ch
argument_list|,
operator|&
name|abort_flag
argument_list|,
name|m
argument_list|,
operator|*
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_STREAM_RESET
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_STREAM_RESET\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|ch
operator|==
name|NULL
operator|)
operator|||
operator|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_tsn_req
argument_list|)
operator|)
operator|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|reconfig_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
if|if
condition|(
name|sctp_handle_stream_reset
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|ch
argument_list|)
condition|)
block|{
comment|/* stop processing */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_PACKET_DROPPED
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_PACKET_DROPPED\n"
argument_list|)
expr_stmt|;
comment|/* re-get it all please */
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|&&
operator|(
name|stcb
operator|)
operator|&&
name|netp
operator|&&
operator|(
operator|*
name|netp
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|pktdrop_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
name|sctp_handle_packet_dropped
argument_list|(
operator|(
expr|struct
name|sctp_pktdrop_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
name|min
argument_list|(
name|chk_length
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|chunk_buf
argument_list|)
operator|-
literal|4
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_AUTHENTICATION
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"SCTP_AUTHENTICATION\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* save the first AUTH for later processing */
if|if
condition|(
name|auth_skipped
operator|==
literal|0
condition|)
block|{
name|auth_offset
operator|=
operator|*
name|offset
expr_stmt|;
name|auth_len
operator|=
name|chk_length
expr_stmt|;
name|auth_skipped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* skip this chunk (temporarily) */
goto|goto
name|next_chunk
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|0
condition|)
block|{
goto|goto
name|unknown_chunk
goto|;
block|}
if|if
condition|(
operator|(
name|chk_length
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|chk_length
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk
argument_list|)
operator|+
name|SCTP_AUTH_DIGEST_LEN_MAX
operator|)
operator|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|got_auth
operator|==
literal|1
condition|)
block|{
comment|/* skip this chunk... it's already auth'd */
goto|goto
name|next_chunk
goto|;
block|}
name|got_auth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|==
name|NULL
operator|)
operator|||
name|sctp_handle_auth
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sctp_auth_chunk
operator|*
operator|)
name|ch
argument_list|,
name|m
argument_list|,
operator|*
name|offset
argument_list|)
condition|)
block|{
comment|/* auth HMAC failed so dump the packet */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
comment|/* remaining chunks are HMAC checked */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|unknown_chunk
label|:
comment|/* it's an unknown chunk! */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|sctp_gen_error_cause
modifier|*
name|cause
decl_stmt|;
name|int
name|len
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gen_error_cause
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|min
argument_list|(
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|length
operator|-
operator|*
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|cause
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_gen_error_cause
operator|*
argument_list|)
expr_stmt|;
name|cause
operator|->
name|code
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRECOG_CHUNK
argument_list|)
expr_stmt|;
name|cause
operator|->
name|length
operator|=
name|htons
argument_list|(
call|(
name|uint16_t
call|)
argument_list|(
name|len
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gen_error_cause
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_gen_error_cause
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|op_err
argument_list|)
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|len
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|op_err
argument_list|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mbc
argument_list|(
name|SCTP_BUF_NEXT
argument_list|(
name|op_err
argument_list|)
argument_list|,
name|SCTP_MBUF_ICOPY
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|op_err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* discard this packet */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
comment|/* else skip this bad chunk and continue... */
break|break;
block|}
comment|/* switch (ch->chunk_type) */
name|next_chunk
label|:
comment|/* get the next chunk */
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|>=
name|length
condition|)
block|{
comment|/* no more data left in the mbuf chain */
break|break;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* while */
if|if
condition|(
name|asconf_cnt
operator|>
literal|0
operator|&&
name|stcb
operator|!=
name|NULL
condition|)
block|{
name|sctp_send_asconf_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * common input chunk processing (v4 and v6)  */
end_comment

begin_function
name|void
name|sctp_common_input_processing
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|uint8_t
name|compute_crc
parameter_list|,
endif|#
directive|endif
name|uint8_t
name|ecn_bits
parameter_list|,
name|uint8_t
name|mflowtype
parameter_list|,
name|uint32_t
name|mflowid
parameter_list|,
name|uint16_t
name|fibnum
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|uint32_t
name|high_tsn
decl_stmt|;
name|int
name|fwd_tsn_seen
init|=
literal|0
decl_stmt|,
name|data_processed
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mm
decl_stmt|,
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|int
name|un_sent
decl_stmt|;
name|int
name|cnt_ctrl_ready
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|,
modifier|*
name|inp_decr
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdatagrams
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xE0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|0
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
if|if
condition|(
name|compute_crc
operator|!=
literal|0
condition|)
block|{
name|uint32_t
name|check
decl_stmt|,
name|calc_check
decl_stmt|;
name|check
operator|=
name|sh
operator|->
name|checksum
expr_stmt|;
name|sh
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|calc_check
operator|=
name|sctp_calculate_cksum
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
name|sh
operator|->
name|checksum
operator|=
name|check
expr_stmt|;
if|if
condition|(
name|calc_check
operator|!=
name|check
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Bad CSUM on SCTP packet calc_check:%x check:%x  m:%p mlen:%d iphlen:%d\n"
argument_list|,
name|calc_check
argument_list|,
name|check
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
argument_list|,
name|length
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|&&
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|port
operator|!=
name|port
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|port
operator|==
literal|0
condition|)
block|{
comment|/* UDP encapsulation turned on. */
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
comment|/* UDP encapsulation turned off. */
name|net
operator|->
name|mtu
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
comment|/* XXX Update smallest_mtu */
block|}
name|net
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
name|net
operator|->
name|flowtype
operator|=
name|mflowtype
expr_stmt|;
name|net
operator|->
name|flowid
operator|=
name|mflowid
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|m
argument_list|,
name|length
argument_list|,
name|iphlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_INPUT_ERROR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
name|inp_decr
operator|=
name|inp
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_checksumerrors
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
endif|#
directive|endif
comment|/* Destination port of 0 is illegal, based on RFC4960. */
if|if
condition|(
name|sh
operator|->
name|dest_port
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|&&
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|port
operator|!=
name|port
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|port
operator|==
literal|0
condition|)
block|{
comment|/* UDP encapsulation turned on. */
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
comment|/* UDP encapsulation turned off. */
name|net
operator|->
name|mtu
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
comment|/* XXX Update smallest_mtu */
block|}
name|net
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
name|net
operator|->
name|flowtype
operator|=
name|mflowtype
expr_stmt|;
name|net
operator|->
name|flowid
operator|=
name|mflowid
expr_stmt|;
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_noport
argument_list|)
expr_stmt|;
if|if
condition|(
name|badport_bandlim
argument_list|(
name|BANDLIM_SCTP_OOTB
argument_list|)
operator|<
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_ACK
condition|)
block|{
name|sctp_send_shutdown_complete2
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_ABORT_ASSOCIATION
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INIT
operator|)
operator|)
condition|)
block|{
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
literal|"Out of the blue"
argument_list|)
expr_stmt|;
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|inp_decr
operator|=
name|inp
expr_stmt|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Ok, Common input processing called, m:%p iphlen:%d offset:%d length:%d stcb:%p\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* always clear this before beginning a packet */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
operator|=
literal|0
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"stcb:%p state:%x\n"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|state
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_WAS_ABORTED
operator|)
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|&
name|SCTP_STATE_ABOUT_TO_BE_FREED
operator|)
condition|)
block|{
comment|/*- 			 * If we hit here, we had a ref count 			 * up when the assoc was aborted and the 			 * timer is clearing out the assoc, we should 			 * NOT respond to any packet.. its OOTB. 			 */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|NULL
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"OOTB, %s:%d at %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|IS_SCTP_CONTROL
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* process the control portion of the SCTP packet */
comment|/* sa_ignore NO_NULL_CHK */
name|stcb
operator|=
name|sctp_process_control
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|&
name|offset
argument_list|,
name|length
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|net
argument_list|,
operator|&
name|fwd_tsn_seen
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* 			 * This covers us if the cookie-echo was there and 			 * it changes our INP. 			 */
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INITIATION
operator|)
operator|&&
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|net
operator|->
name|port
operator|!=
name|port
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|port
operator|==
literal|0
condition|)
block|{
comment|/* UDP encapsulation turned on. */
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|net
operator|->
name|mtu
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|port
operator|==
literal|0
condition|)
block|{
comment|/* UDP encapsulation turned off. */
name|net
operator|->
name|mtu
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
comment|/* XXX Update smallest_mtu */
block|}
name|net
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* 		 * no control chunks, so pre-process DATA chunks (these 		 * checks are taken care of by control processing) 		 */
comment|/* 		 * if DATA only packet, and auth is required, then punt... 		 * can't have authenticated without any AUTH (control) 		 * chunks 		 */
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|1
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
condition|)
block|{
comment|/* "silently" ignore */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthmissing
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* out of the blue DATA chunk */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"OOTB, %s:%d at %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|!=
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
condition|)
block|{
comment|/* v_tag mismatch! */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * no valid TCB for this packet, or we found it's a bad 		 * packet while processing control, or we're done with this 		 * packet (done or skip rest of data), so we drop it... 		 */
goto|goto
name|out
goto|;
block|}
comment|/* 	 * DATA chunk processing 	 */
comment|/* plow through the data chunks while length> offset */
comment|/* 	 * Rest should be DATA only.  Check authentication state if AUTH for 	 * DATA is required. 	 */
if|if
condition|(
operator|(
name|length
operator|>
name|offset
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|auth_supported
operator|==
literal|1
operator|)
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
condition|)
block|{
comment|/* "silently" ignore */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthmissing
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_AUTH1
argument_list|,
literal|"Data chunk requires AUTH, skipped\n"
argument_list|)
expr_stmt|;
goto|goto
name|trigger_send
goto|;
block|}
if|if
condition|(
name|length
operator|>
name|offset
condition|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* 		 * First check to make sure our state is correct. We would 		 * not get here unless we really did have a tag, so we don't 		 * abort if this happens, just dump the chunk silently. 		 */
switch|switch
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
condition|)
block|{
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
comment|/* 			 * we consider data with valid tags in this state 			 * shows us the cookie-ack was lost. Imply it was 			 * there. 			 */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_INPUT
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_cookie_ack
argument_list|(
operator|(
expr|struct
name|sctp_cookie_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
comment|/* 			 * We consider OOTB any data sent during asoc setup. 			 */
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"OOTB, %s:%d at %s"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_diag_info_code
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|op_err
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|inp
operator|->
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* sa_ignore NOTREACHED */
break|break;
case|case
name|SCTP_STATE_EMPTY
case|:
comment|/* should not happen */
case|case
name|SCTP_STATE_INUSE
case|:
comment|/* should not happen */
case|case
name|SCTP_STATE_SHUTDOWN_RECEIVED
case|:
comment|/* This is a peer error */
case|case
name|SCTP_STATE_SHUTDOWN_ACK_SENT
case|:
default|default:
goto|goto
name|out
goto|;
comment|/* sa_ignore NOTREACHED */
break|break;
case|case
name|SCTP_STATE_OPEN
case|:
case|case
name|SCTP_STATE_SHUTDOWN_SENT
case|:
break|break;
block|}
comment|/* plow through the data chunks while length> offset */
name|retval
operator|=
name|sctp_process_data
argument_list|(
name|mm
argument_list|,
name|iphlen
argument_list|,
operator|&
name|offset
argument_list|,
name|length
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|&
name|high_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
comment|/* 			 * The association aborted, NO UNLOCK needed since 			 * the association is destroyed. 			 */
name|stcb
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|data_processed
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Anything important needs to have been m_copy'ed in 		 * process_data 		 */
block|}
comment|/* take care of ecn */
if|if
condition|(
operator|(
name|data_processed
operator|==
literal|1
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_supported
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|ecn_bits
operator|&
name|SCTP_CE_BITS
operator|)
operator|==
name|SCTP_CE_BITS
operator|)
condition|)
block|{
comment|/* Yep, we need to add a ECNE */
name|sctp_send_ecn_echo
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|high_tsn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|data_processed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fwd_tsn_seen
operator|)
condition|)
block|{
name|int
name|was_a_gap
decl_stmt|;
name|uint32_t
name|highest_tsn
decl_stmt|;
if|if
condition|(
name|SCTP_TSN_GT
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_nr_map
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
argument_list|)
condition|)
block|{
name|highest_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_nr_map
expr_stmt|;
block|}
else|else
block|{
name|highest_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
expr_stmt|;
block|}
name|was_a_gap
operator|=
name|SCTP_TSN_GT
argument_list|(
name|highest_tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
name|was_a_gap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fwd_tsn_seen
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|send_sack
operator|=
literal|1
expr_stmt|;
block|}
comment|/* trigger send of any chunks in queue... */
name|trigger_send
label|:
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xE0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|1
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Check for chunk output prw:%d tqe:%d tf=%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|)
expr_stmt|;
name|un_sent
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
condition|)
block|{
name|cnt_ctrl_ready
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_send_queue
argument_list|)
operator|||
name|cnt_ctrl_ready
operator|||
name|stcb
operator|->
name|asoc
operator|.
name|trigger_reset
operator|||
operator|(
operator|(
name|un_sent
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|>
literal|0
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|<=
literal|0
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"Calling chunk OUTPUT\n"
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CONTROL_PROC
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT3
argument_list|,
literal|"chunk OUTPUT returns\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xE0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|2
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|out
label|:
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp_decr
operator|!=
name|NULL
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp_decr
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp_decr
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp_decr
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_function
name|void
name|sctp_input_with_port
parameter_list|(
name|struct
name|mbuf
modifier|*
name|i_pak
parameter_list|,
name|int
name|off
parameter_list|,
name|uint16_t
name|port
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|uint32_t
name|vrf_id
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ecn_bits
decl_stmt|;
name|struct
name|sockaddr_in
name|src
decl_stmt|,
name|dst
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|int
name|length
decl_stmt|,
name|offset
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|uint8_t
name|compute_crc
decl_stmt|;
endif|#
directive|endif
name|uint32_t
name|mflowid
decl_stmt|;
name|uint8_t
name|mflowtype
decl_stmt|;
name|uint16_t
name|fibnum
decl_stmt|;
name|iphlen
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|SCTP_GET_PKT_VRFID
argument_list|(
name|i_pak
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
name|SCTP_RELEASE_PKT
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
return|return;
block|}
name|m
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
comment|/* Log in any input mbufs */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|sctp_log_mbc
argument_list|(
name|m
argument_list|,
name|SCTP_MBUF_INPUT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LAST_PACKET_TRACING
condition|)
block|{
name|sctp_packet_log
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_CRCOFFLOAD
argument_list|,
literal|"sctp_input(): Packet of length %d received on %s with csum_flags 0x%b.\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|if_name
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|,
name|CSUM_BITS
argument_list|)
expr_stmt|;
name|mflowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|mflowtype
operator|=
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|fibnum
operator|=
name|M_GETFIB
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inpackets
argument_list|)
expr_stmt|;
comment|/* Get IP, SCTP, and first chunk header together in the first mbuf. */
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|<
name|offset
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
name|offset
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|src
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|src
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|src
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|src
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|memset
argument_list|(
operator|&
name|dst
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|dst
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|dst
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|dst
operator|.
name|sin_addr
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
name|length
operator|=
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_len
argument_list|)
expr_stmt|;
comment|/* Validate mbuf chain length with IP payload length. */
if|if
condition|(
name|SCTP_HEADER_LEN
argument_list|(
name|m
argument_list|)
operator|!=
name|length
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"sctp_input() length:%d reported length:%d\n"
argument_list|,
name|length
argument_list|,
name|SCTP_HEADER_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* SCTP does not allow broadcasts or multicasts */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|dst
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|SCTP_IS_IT_BROADCAST
argument_list|(
name|dst
operator|.
name|sin_addr
argument_list|,
name|m
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|ecn_bits
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP_VALID
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvhwcrc
argument_list|)
expr_stmt|;
name|compute_crc
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvswcrc
argument_list|)
expr_stmt|;
name|compute_crc
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_common_input_processing
argument_list|(
operator|&
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dst
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|compute_crc
argument_list|,
endif|#
directive|endif
name|ecn_bits
argument_list|,
name|mflowtype
argument_list|,
name|mflowid
argument_list|,
name|fibnum
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_MCORE_INPUT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
end_if

begin_decl_stmt
specifier|extern
name|int
modifier|*
name|sctp_cpuarry
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|sctp_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|off
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|off
operator|=
operator|*
name|offp
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SCTP_MCORE_INPUT
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMP
argument_list|)
if|if
condition|(
name|mp_ncpus
operator|>
literal|1
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|cpu_to_use
decl_stmt|;
name|uint32_t
name|flowid
decl_stmt|,
name|tag
decl_stmt|;
if|if
condition|(
name|M_HASHTYPE_GET
argument_list|(
name|m
argument_list|)
operator|!=
name|M_HASHTYPE_NONE
condition|)
block|{
name|flowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No flow id built by lower layers fix it so we 			 * create one. 			 */
name|offset
operator|=
name|off
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|<
name|offset
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|off
operator|)
expr_stmt|;
name|tag
operator|=
name|htonl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
expr_stmt|;
name|flowid
operator|=
name|tag
operator|^
name|ntohs
argument_list|(
name|sh
operator|->
name|dest_port
argument_list|)
operator|^
name|ntohs
argument_list|(
name|sh
operator|->
name|src_port
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
operator|=
name|flowid
expr_stmt|;
name|M_HASHTYPE_SET
argument_list|(
name|m
argument_list|,
name|M_HASHTYPE_OPAQUE_HASH
argument_list|)
expr_stmt|;
block|}
name|cpu_to_use
operator|=
name|sctp_cpuarry
index|[
name|flowid
operator|%
name|mp_ncpus
index|]
expr_stmt|;
name|sctp_queue_to_mcore
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
name|cpu_to_use
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
endif|#
directive|endif
name|sctp_input_with_port
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

