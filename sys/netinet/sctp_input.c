begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_input.c,v 1.27 2005/03/06 16:04:17 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_function
specifier|static
name|void
name|sctp_stop_all_cookie_timers
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* 	 * This now not only stops all cookie timers it also stops any INIT 	 * timers as well. This will make sure that the timers are stopped 	 * in all collision cases. 	 */
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|->
name|rxt_timer
operator|.
name|type
operator|==
name|SCTP_TIMER_TYPE_COOKIE
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|net
operator|->
name|rxt_timer
operator|.
name|type
operator|==
name|SCTP_TIMER_TYPE_INIT
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* INIT handler */
end_comment

begin_function
specifier|static
name|void
name|sctp_handle_init
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|)
block|{
name|struct
name|sctp_init
modifier|*
name|init
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|uint32_t
name|init_limit
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_init: handling INIT tcb:%p\n"
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|op_err
operator|=
name|NULL
expr_stmt|;
name|init
operator|=
operator|&
name|cp
operator|->
name|init
expr_stmt|;
comment|/* First are we accepting? */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_init: Abort, so_qlimit:%d\n"
argument_list|,
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * FIX ME ?? What about TCP model and we have a 		 * match/restart case? 		 */
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
condition|)
block|{
comment|/* Invalid length */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* validate parameters */
if|if
condition|(
name|init
operator|->
name|initiate_tag
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|init
operator|->
name|a_rwnd
argument_list|)
operator|<
name|SCTP_MIN_RWND
condition|)
block|{
comment|/* invalid parameter... send abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
operator|->
name|num_inbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|init
operator|->
name|num_outbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
name|init_limit
operator|=
name|offset
operator|+
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_validate_init_auth_params
argument_list|(
name|m
argument_list|,
name|offset
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|cp
argument_list|)
argument_list|,
name|init_limit
argument_list|)
condition|)
block|{
comment|/* auth parameter(s) error... send abort */
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* send an INIT-ACK w/cookie */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_init: sending INIT-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_send_initiate_ack
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process peer "INIT/INIT-ACK" chunk returns value< 0 on error  */
end_comment

begin_function
specifier|static
name|int
name|sctp_process_init
parameter_list|(
name|struct
name|sctp_init_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_init
modifier|*
name|init
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|lnet
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|init
operator|=
operator|&
name|cp
operator|->
name|init
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* save off parameters */
name|asoc
operator|->
name|peer_vtag
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|initiate_tag
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|peers_rwnd
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|a_rwnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|nets
argument_list|)
condition|)
block|{
comment|/* update any ssthresh's that may have a default */
name|TAILQ_FOREACH
argument_list|(
argument|lnet
argument_list|,
argument|&asoc->nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|lnet
operator|->
name|ssthresh
operator|=
name|asoc
operator|->
name|peers_rwnd
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_CWND_MONITOR
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_CWND_LOGGING
argument_list|)
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|lnet
argument_list|,
literal|0
argument_list|,
name|SCTP_CWND_INITIALIZATION
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|pre_open_streams
operator|>
name|ntohs
argument_list|(
name|init
operator|->
name|num_inbound_streams
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|newcnt
decl_stmt|;
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|struct
name|sctp_stream_queue_pending
modifier|*
name|sp
decl_stmt|;
comment|/* cut back on number of streams */
name|newcnt
operator|=
name|ntohs
argument_list|(
name|init
operator|->
name|num_inbound_streams
argument_list|)
expr_stmt|;
comment|/* This if is probably not needed but I am cautious */
if|if
condition|(
name|asoc
operator|->
name|strmout
condition|)
block|{
comment|/* First make sure no data chunks are trapped */
for|for
control|(
name|i
operator|=
name|newcnt
init|;
name|i
operator|<
name|asoc
operator|->
name|pre_open_streams
condition|;
name|i
operator|++
control|)
block|{
name|outs
operator|=
operator|&
name|asoc
operator|->
name|strmout
index|[
name|i
index|]
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|sp
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|,
name|sp
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_queue_cnt
operator|--
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_SPECIAL_SP_FAIL
argument_list|,
name|stcb
argument_list|,
name|SCTP_NOTIFY_DATAGRAM_UNSENT
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|sp
operator|->
name|data
argument_list|)
expr_stmt|;
name|sp
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_remote_addr
argument_list|(
name|sp
operator|->
name|net
argument_list|)
expr_stmt|;
name|sp
operator|->
name|net
operator|=
name|NULL
expr_stmt|;
comment|/* Free the chunk */
name|printf
argument_list|(
literal|"sp:%p tcb:%p weird free case\n"
argument_list|,
name|sp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_free_a_strmoq
argument_list|(
name|stcb
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* cut back the count and abandon the upper streams */
name|asoc
operator|->
name|pre_open_streams
operator|=
name|newcnt
expr_stmt|;
block|}
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|streamoutcnt
operator|=
name|asoc
operator|->
name|pre_open_streams
expr_stmt|;
comment|/* init tsn's */
name|asoc
operator|->
name|highest_tsn_inside_map
operator|=
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|initial_tsn
argument_list|)
operator|-
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MAP_LOGGING
name|sctp_log_map
argument_list|(
literal|0
argument_list|,
literal|5
argument_list|,
name|asoc
operator|->
name|highest_tsn_inside_map
argument_list|,
name|SCTP_MAP_SLIDE_RESULT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* This is the next one we expect */
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|asconf_seq_in
operator|+
literal|1
expr_stmt|;
name|asoc
operator|->
name|mapping_array_base_tsn
operator|=
name|ntohl
argument_list|(
name|init
operator|->
name|initial_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|cumulative_tsn
operator|=
name|asoc
operator|->
name|asconf_seq_in
expr_stmt|;
name|asoc
operator|->
name|last_echo_tsn
operator|=
name|asoc
operator|->
name|asconf_seq_in
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* open the requested streams */
if|if
condition|(
name|asoc
operator|->
name|strmin
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the old ones */
name|struct
name|sctp_queued_to_read
modifier|*
name|ctl
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
while|while
condition|(
name|ctl
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|,
name|ctl
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|ctl
operator|->
name|whoFrom
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|ctl
operator|->
name|data
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|sctp_free_a_readq
argument_list|(
name|stcb
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
name|ctl
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_FREE
argument_list|(
name|asoc
operator|->
name|strmin
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|streamincnt
operator|=
name|ntohs
argument_list|(
name|init
operator|->
name|num_outbound_streams
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|streamincnt
operator|>
name|MAX_SCTP_STREAMS
condition|)
block|{
name|asoc
operator|->
name|streamincnt
operator|=
name|MAX_SCTP_STREAMS
expr_stmt|;
block|}
name|SCTP_MALLOC
argument_list|(
name|asoc
operator|->
name|strmin
argument_list|,
expr|struct
name|sctp_stream_in
operator|*
argument_list|,
name|asoc
operator|->
name|streamincnt
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_in
argument_list|)
argument_list|,
literal|"StreamsIn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|strmin
operator|==
name|NULL
condition|)
block|{
comment|/* we didn't get memory for the streams! */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"process_init: couldn't get memory for the streams!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|asoc
operator|->
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|last_sequence_delivered
operator|=
literal|0xffff
expr_stmt|;
comment|/* 		 * U-stream ranges will be set when the cookie is unpacked. 		 * Or for the INIT sender they are un set (if pr-sctp not 		 * supported) when the INIT-ACK arrives. 		 */
name|TAILQ_INIT
argument_list|(
operator|&
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|inqueue
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|strmin
index|[
name|i
index|]
operator|.
name|delivery_started
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * load_address_from_init will put the addresses into the 	 * association when the COOKIE is processed or the INIT-ACK is 	 * processed. Both types of COOKIE's existing and new call this 	 * routine. It will remove addresses that are no longer in the 	 * association (for the restarting case where addresses are 	 * removed). Up front when the INIT arrives we will discard it if it 	 * is a restart and new addresses have been added. 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * INIT-ACK message processing/consumption returns value< 0 on error  */
end_comment

begin_function
specifier|static
name|int
name|sctp_process_init_ack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|int
name|retval
decl_stmt|,
name|abort_flag
decl_stmt|;
name|uint32_t
name|initack_limit
decl_stmt|;
comment|/* First verify that we have no illegal param's */
name|abort_flag
operator|=
literal|0
expr_stmt|;
name|op_err
operator|=
name|NULL
expr_stmt|;
name|op_err
operator|=
name|sctp_arethere_unrecognized_parameters
argument_list|(
name|m
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|)
argument_list|,
operator|&
name|abort_flag
argument_list|,
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
comment|/* Send an abort and notify peer */
if|if
condition|(
name|op_err
operator|!=
name|NULL
condition|)
block|{
name|sctp_send_operr_to
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|op_err
argument_list|,
name|cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Just notify (abort_assoc does this if we send an 			 * abort). 			 */
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * No sense in further INIT's since we will get the 			 * same param back 			 */
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* process the peer's parameters in the INIT-ACK */
name|retval
operator|=
name|sctp_process_init
argument_list|(
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|cp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|initack_limit
operator|=
name|offset
operator|+
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* load all addresses */
if|if
condition|(
operator|(
name|retval
operator|=
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|)
argument_list|,
name|initack_limit
argument_list|,
name|sh
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
comment|/* Huh, we should abort */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Load addresses from INIT causes an abort %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmac_id
operator|=
name|sctp_negotiate_hmacid
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_hmacs
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
comment|/* queuing will steal away the mbuf chain to the out queue */
name|op_err
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* extract the cookie and queue it to "echo" it back... */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Cancel the INIT timer, We do this first before queueing the 	 * cookie. We always cancel at the primary to assue that we are 	 * canceling the timer started by the INIT which always goes to the 	 * primary. 	 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
comment|/* calculate the RTO */
name|net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
name|retval
operator|=
name|sctp_send_cookie_echo
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
comment|/* 		 * No cookie, we probably should send a op error. But in any 		 * case if there is no cookie in the INIT-ACK, we can 		 * abandon the peer, its broke. 		 */
if|if
condition|(
name|retval
operator|==
operator|-
literal|3
condition|)
block|{
comment|/* We abort with an error of missing mandatory param */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_MISSING_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
condition|)
block|{
comment|/* 				 * Expand beyond to include the mandatory 				 * param cookie 				 */
name|struct
name|sctp_inv_mandatory_param
modifier|*
name|mp
decl_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_inv_mandatory_param
argument_list|)
expr_stmt|;
name|mp
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_inv_mandatory_param
operator|*
argument_list|)
expr_stmt|;
comment|/* Subtract the reserved param */
name|mp
operator|->
name|length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_inv_mandatory_param
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
name|mp
operator|->
name|num_param
operator|=
name|htonl
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mp
operator|->
name|param
operator|=
name|htons
argument_list|(
name|SCTP_STATE_COOKIE
argument_list|)
expr_stmt|;
name|mp
operator|->
name|resv
operator|=
literal|0
expr_stmt|;
block|}
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_heartbeat_ack
parameter_list|(
name|struct
name|sctp_heartbeat_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sockaddr_storage
name|store
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|r_net
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
condition|)
block|{
comment|/* Invalid length */
return|return;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|store
expr_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|store
expr_stmt|;
name|memset
argument_list|(
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|store
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
operator|==
name|AF_INET
operator|&&
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|sin
operator|->
name|sin_family
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
operator|==
name|AF_INET6
operator|&&
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|sin6
operator|->
name|sin6_family
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_family
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|addr_len
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|r_net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_net
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Huh? I can't find the address I sent it to, discard\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
operator|(
name|r_net
operator|&&
operator|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|)
operator|&&
operator|(
name|r_net
operator|->
name|heartbeat_random1
operator|==
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value1
operator|)
operator|&&
operator|(
name|r_net
operator|->
name|heartbeat_random2
operator|==
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|random_value2
operator|)
condition|)
block|{
comment|/* 		 * If the its a HB and it's random value is correct when can 		 * confirm the destination. 		 */
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
if|if
condition|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REQ_PRIMARY
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|=
name|r_net
expr_stmt|;
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_WAS_PRIMARY
expr_stmt|;
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REQ_PRIMARY
expr_stmt|;
name|r_net
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|)
expr_stmt|;
if|if
condition|(
name|r_net
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
comment|/* 				 * first one on the list is NOT the primary 				 * sctp_cmpaddr() is much more efficent if 				 * the primary is the first on the list, 				 * make it so. 				 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|nets
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|r_net
argument_list|)
expr_stmt|;
block|}
name|r_net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
name|r_net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
name|tv
operator|.
name|tv_sec
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_1
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|cp
operator|->
name|heartbeat
operator|.
name|hb_info
operator|.
name|time_value_2
expr_stmt|;
if|if
condition|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_NOT_REACHABLE
condition|)
block|{
name|r_net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_NOT_REACHABLE
expr_stmt|;
name|r_net
operator|->
name|dest_state
operator||=
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_UP
argument_list|,
name|stcb
argument_list|,
name|SCTP_HEARTBEAT_SUCCESS
argument_list|,
operator|(
name|void
operator|*
operator|)
name|r_net
argument_list|)
expr_stmt|;
comment|/* now was it the primary? if so restore */
if|if
condition|(
name|r_net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_WAS_PRIMARY
condition|)
block|{
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|r_net
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now lets do a RTO with this */
name|r_net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|,
name|r_net
argument_list|,
operator|&
name|tv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_abort
parameter_list|(
name|struct
name|sctp_abort_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_abort: handling ABORT\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
comment|/* verify that the destination addr is in the association */
comment|/* ignore abort for addresses being deleted */
comment|/* stop any receive timers */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_RECV
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
comment|/* notify user of the abort and clean up... */
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* free the tcb */
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_ASOCLOG_OF_TSNS
name|sctp_print_out_track_log
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_6
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_abort: finished\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_shutdown
parameter_list|(
name|struct
name|sctp_shutdown_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_flag
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|some_on_streamwheel
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_shutdown: handling SHUTDOWN\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
condition|)
block|{
comment|/* Shutdown NOT the expected size */
return|return;
block|}
else|else
block|{
name|sctp_update_acked
argument_list|(
name|stcb
argument_list|,
name|cp
argument_list|,
name|net
argument_list|,
name|abort_flag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
condition|)
block|{
comment|/* 		 * With a normal shutdown we assume the end of last record. 		 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
comment|/* goto SHUTDOWN_RECEIVED state to block new requests */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
condition|)
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_RECEIVED
expr_stmt|;
comment|/* 			 * notify upper layer that peer has initiated a 			 * shutdown 			 */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_PEER_SHUTDOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* reset time */
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
comment|/* 		 * stop the shutdown timer, since we WILL move to 		 * SHUTDOWN-ACK-SENT. 		 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_7
argument_list|)
expr_stmt|;
block|}
comment|/* Now are we there yet? */
name|some_on_streamwheel
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
condition|)
block|{
comment|/* Check to see if some data queued */
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|outs
argument_list|,
argument|&asoc->out_wheel
argument_list|,
argument|next_spoke
argument_list|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
condition|)
block|{
name|some_on_streamwheel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|||
name|some_on_streamwheel
condition|)
block|{
comment|/* By returning we will push more data out */
return|return;
block|}
else|else
block|{
comment|/* no outstanding data to send, so move on... */
comment|/* send SHUTDOWN-ACK */
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
comment|/* move to SHUTDOWN-ACK-SENT state */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
expr_stmt|;
comment|/* start SHUTDOWN timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNACK
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_shutdown_ack
parameter_list|(
name|struct
name|sctp_shutdown_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_shutdown_ack: handling SHUTDOWN ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* process according to association state */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* unexpected SHUTDOWN-ACK... so ignore... */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|asoc
operator|->
name|control_pdapi
condition|)
block|{
comment|/* 		 * With a normal shutdown we assume the end of last record. 		 */
name|SCTP_INP_READ_LOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|end_added
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|->
name|pdapi_aborted
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|control_pdapi
operator|=
name|NULL
expr_stmt|;
name|SCTP_INP_READ_UNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|sctp_sorwakeup
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
comment|/* are the queues empty? */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
condition|)
block|{
name|sctp_report_all_outbound
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* stop the timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_8
argument_list|)
expr_stmt|;
comment|/* send SHUTDOWN-COMPLETE */
name|sctp_send_shutdown_complete
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* notify upper layer protocol */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* Set the connected flag to disconnected */
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_socket
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_shutdown
argument_list|)
expr_stmt|;
comment|/* free the TCB but first save off the ep */
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_9
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Skip past the param header and then we will find the chunk that caused the  * problem. There are two possiblities ASCONF or FWD-TSN other than that and  * our peer must be broken.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_process_unrecog_chunk
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_chunkhdr
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|phdr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phdr
argument_list|)
operator|)
expr_stmt|;
switch|switch
condition|(
name|chk
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_ASCONF_ACK
case|:
case|case
name|SCTP_ASCONF
case|:
name|sctp_asconf_cleanup
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Peer does not support chunk type %d(%x)??\n"
argument_list|,
name|chk
operator|->
name|chunk_type
argument_list|,
operator|(
name|uint32_t
operator|)
name|chk
operator|->
name|chunk_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Skip past the param header and then we will find the param that caused the  * problem.  There are a number of param's in a ASCONF OR the prsctp param  * these will turn of specific features.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_process_unrecog_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|pbad
decl_stmt|;
name|pbad
operator|=
name|phdr
operator|+
literal|1
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|pbad
operator|->
name|param_type
argument_list|)
condition|)
block|{
comment|/* pr-sctp draft */
case|case
name|SCTP_PRSCTP_SUPPORTED
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_prsctp
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_SUPPORTED_CHUNK_EXT
case|:
break|break;
comment|/* draft-ietf-tsvwg-addip-sctp */
case|case
name|SCTP_ECN_NONCE_SUPPORTED
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_ecn_nonce
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ecn_nonce_allowed
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
case|case
name|SCTP_SET_PRIM_ADDR
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Huh, the peer does not support success? or error cause?\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Turning off ASCONF to this strange peer\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Peer does not support param type %d(%x)??\n"
argument_list|,
name|pbad
operator|->
name|param_type
argument_list|,
operator|(
name|uint32_t
operator|)
name|pbad
operator|->
name|param_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_error
parameter_list|(
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|int
name|chklen
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|;
name|uint16_t
name|error_type
decl_stmt|;
name|uint16_t
name|error_len
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|int
name|adjust
decl_stmt|;
comment|/* parse through all of the errors and process */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
expr_stmt|;
name|chklen
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|size_t
operator|)
name|chklen
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
comment|/* Process an Error Cause */
name|error_type
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|error_len
operator|=
name|ntohs
argument_list|(
name|phdr
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error_len
operator|>
name|chklen
operator|)
operator|||
operator|(
name|error_len
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* invalid param length for this param */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Bogus length in error param- chunk left:%d errorlen:%d\n"
argument_list|,
name|chklen
argument_list|,
name|error_len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|error_type
condition|)
block|{
case|case
name|SCTP_CAUSE_INVALID_STREAM
case|:
case|case
name|SCTP_CAUSE_MISSING_PARAM
case|:
case|case
name|SCTP_CAUSE_INVALID_PARAM
case|:
case|case
name|SCTP_CAUSE_NO_USER_DATA
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Software error we got a %d back? We have a bug :/ (or do they?)\n"
argument_list|,
name|error_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SCTP_CAUSE_STALE_COOKIE
case|:
comment|/* 			 * We only act if we have echoed a cookie and are 			 * waiting. 			 */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
name|int
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|phdr
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phdr
argument_list|)
operator|)
expr_stmt|;
comment|/* Save the time doubled */
name|asoc
operator|->
name|cookie_preserve_req
operator|=
name|ntohl
argument_list|(
operator|*
name|p
argument_list|)
operator|<<
literal|1
expr_stmt|;
name|asoc
operator|->
name|stale_cookie_count
operator|++
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stale_cookie_count
operator|>
name|asoc
operator|->
name|max_init_times
condition|)
block|{
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* now free the asoc */
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_10
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* blast back to INIT state */
name|asoc
operator|->
name|state
operator|&=
operator|~
name|SCTP_STATE_COOKIE_ECHOED
expr_stmt|;
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
case|:
comment|/* 			 * Nothing we can do here, we don't do hostname 			 * addresses so if the peer does not like my IPv6 			 * (or IPv4 for that matter) it does not matter. If 			 * they don't support that type of address, they can 			 * NOT possibly get that packet type... i.e. with no 			 * IPv6 you can't recieve a IPv6 packet. so we can 			 * safely ignore this one. If we ever added support 			 * for HOSTNAME Addresses, then we would need to do 			 * something here. 			 */
break|break;
case|case
name|SCTP_CAUSE_UNRECOG_CHUNK
case|:
name|sctp_process_unrecog_chunk
argument_list|(
name|stcb
argument_list|,
name|phdr
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CAUSE_UNRECOG_PARAM
case|:
name|sctp_process_unrecog_param
argument_list|(
name|stcb
argument_list|,
name|phdr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_CAUSE_COOKIE_IN_SHUTDOWN
case|:
comment|/* 			 * We ignore this since the timer will drive out a 			 * new cookie anyway and there timer will drive us 			 * to send a SHUTDOWN_COMPLETE. We can't send one 			 * here since we don't have their tag. 			 */
break|break;
case|case
name|SCTP_CAUSE_DELETING_LAST_ADDR
case|:
case|case
name|SCTP_CAUSE_RESOURCE_SHORTAGE
case|:
case|case
name|SCTP_CAUSE_DELETING_SRC_ADDR
case|:
comment|/* 			 * We should NOT get these here, but in a 			 * ASCONF-ACK. 			 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"Peer sends ASCONF errors in a Operational Error?<%d>?\n"
argument_list|,
name|error_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|SCTP_CAUSE_OUT_OF_RESC
case|:
comment|/* 			 * And what, pray tell do we do with the fact that 			 * the peer is out of resources? Not really sure we 			 * could do anything but abort. I suspect this 			 * should have came WITH an abort instead of in a 			 * OP-ERROR. 			 */
break|break;
default|default:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
comment|/* don't know what this error cause is... */
name|printf
argument_list|(
literal|"sctp_handle_error: unknown error type = 0x%xh\n"
argument_list|,
name|error_type
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
break|break;
block|}
name|adjust
operator|=
name|SCTP_SIZE32
argument_list|(
name|error_len
argument_list|)
expr_stmt|;
name|chklen
operator|-=
name|adjust
expr_stmt|;
name|phdr
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|phdr
operator|+
name|adjust
operator|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_init_ack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_init_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|)
block|{
name|struct
name|sctp_init_ack
modifier|*
name|init_ack
decl_stmt|;
name|int
modifier|*
name|state
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_init_ack: handling INIT-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_init_ack: TCB is null\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
condition|)
block|{
comment|/* Invalid length */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|init_ack
operator|=
operator|&
name|cp
operator|->
name|init
expr_stmt|;
comment|/* validate parameters */
if|if
condition|(
name|init_ack
operator|->
name|initiate_tag
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|init_ack
operator|->
name|a_rwnd
argument_list|)
operator|<
name|SCTP_MIN_RWND
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|init_ack
operator|->
name|num_inbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|init_ack
operator|->
name|num_outbound_streams
operator|==
literal|0
condition|)
block|{
comment|/* protocol error... send an abort */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_INVALID_PARAM
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* process according to association state... */
name|state
operator|=
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|state
expr_stmt|;
switch|switch
condition|(
operator|*
name|state
operator|&
name|SCTP_STATE_MASK
condition|)
block|{
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
comment|/* this is the expected state for this chunk */
comment|/* process the INIT-ACK parameters */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
comment|/* 			 * The primary is where we sent the INIT, we can 			 * always consider it confirmed when the INIT-ACK is 			 * returned. Do this before we load addresses 			 * though. 			 */
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_process_init_ack
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|cp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|abort_no_unlock
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* error in parsing parameters */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* update our state */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"moving to COOKIE-ECHOED state\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
operator|*
name|state
operator|=
name|SCTP_STATE_COOKIE_ECHOED
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
block|}
else|else
block|{
operator|*
name|state
operator|=
name|SCTP_STATE_COOKIE_ECHOED
expr_stmt|;
block|}
comment|/* reset the RTO calc */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* 		 * collapse the init timer back in case of a exponential 		 * backoff 		 */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_COOKIE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 		 * the send at the end of the inbound data processing will 		 * cause the cookie to be sent 		 */
break|break;
case|case
name|SCTP_STATE_SHUTDOWN_SENT
case|:
comment|/* incorrect state... discard */
break|break;
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
comment|/* incorrect state... discard */
break|break;
case|case
name|SCTP_STATE_OPEN
case|:
comment|/* incorrect state... discard */
break|break;
case|case
name|SCTP_STATE_EMPTY
case|:
case|case
name|SCTP_STATE_INUSE
case|:
default|default:
comment|/* incorrect state... discard */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
comment|/* end switch asoc state */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Leaving handle-init-ack end\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * handle a state cookie for an existing association m: input packet mbuf  * chain-- assumes a pullup on IP/SCTP/COOKIE-ECHO chunk note: this is a  * "split" mbuf and the cookie signature does not exist offset: offset into  * mbuf to the cookie-echo chunk  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_cookie_existing
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
parameter_list|,
name|int
name|cookie_len
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_src
parameter_list|,
name|int
modifier|*
name|notification
parameter_list|,
name|sctp_assoc_t
modifier|*
name|sac_assoc_id
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init_cp
decl_stmt|,
name|init_buf
decl_stmt|;
name|struct
name|sctp_init_ack_chunk
modifier|*
name|initack_cp
decl_stmt|,
name|initack_buf
decl_stmt|;
name|int
name|chk_length
decl_stmt|;
name|int
name|init_offset
decl_stmt|,
name|initack_offset
decl_stmt|,
name|i
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|spec_flag
init|=
literal|0
decl_stmt|;
name|int
name|how_indx
decl_stmt|;
comment|/* I know that the TCB is non-NULL from the caller */
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
for|for
control|(
name|how_indx
operator|=
literal|0
init|;
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|;
name|how_indx
operator|++
control|)
block|{
if|if
condition|(
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
comment|/* SHUTDOWN came in after sending INIT-ACK */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
comment|/* FOOBAR */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* pre-reserve some space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the len */
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_COOKIE_IN_SHUTDOWN
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_send_operr_to
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|op_err
argument_list|,
name|cookie
operator|->
name|peers_vtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|2
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * find and validate the INIT chunk in the cookie (peer's info) the 	 * INIT should start after the cookie-echo header struct (chunk 	 * header, state cookie header struct) 	 */
name|init_offset
operator|=
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_echo_chunk
argument_list|)
expr_stmt|;
name|init_cp
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|init_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|init_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull a INIT chunk in cookie */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chk_length
operator|=
name|ntohs
argument_list|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * find and validate the INIT-ACK chunk in the cookie (my info) the 	 * INIT-ACK follows the INIT chunk 	 */
name|initack_offset
operator|=
name|init_offset
operator|+
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
name|initack_cp
operator|=
operator|(
expr|struct
name|sctp_init_ack_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|initack_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|initack_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|initack_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull INIT-ACK chunk in cookie */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chk_length
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|initack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION_ACK
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
operator|&&
operator|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|peer_vtag
operator|)
condition|)
block|{
comment|/* 		 * case D in Section 5.2.4 Table 2: MMAA process accordingly 		 * to get into the OPEN state 		 */
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
operator|!=
name|asoc
operator|->
name|init_seq_number
condition|)
block|{
ifdef|#
directive|ifdef
name|INVARIANTS
name|panic
argument_list|(
literal|"Case D and non-match seq?"
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Case D, seq non-match %x vs %x?\n"
argument_list|,
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
argument_list|,
name|asoc
operator|->
name|init_seq_number
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
switch|switch SCTP_GET_STATE
condition|(
name|asoc
condition|)
block|{
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
comment|/* 			 * INIT was sent, but got got a COOKIE_ECHO with the 			 * correct tags... just accept it...but we must 			 * process the init so that we can make sure we have 			 * the right seq no's. 			 */
comment|/* First we must process the INIT !! */
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|3
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* we have already processed the INIT so no problem */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_11
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_12
argument_list|)
expr_stmt|;
comment|/* update current state */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
else|else
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if ok, move to OPEN state */
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
expr_stmt|;
block|}
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 				 * Here is where collision would go if we 				 * did a connect() and instead got a 				 * init/init-ack/cookie done before the 				 * init-ack came back.. 				 */
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
comment|/* notify upper layer */
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_UP
expr_stmt|;
comment|/* 			 * since we did not send a HB make sure we don't 			 * double things 			 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
operator|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
operator|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
comment|/* 			 * we're in the OPEN state (or beyond), so peer must 			 * have simply lost the COOKIE-ACK 			 */
break|break;
block|}
comment|/* end switch */
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 		 * We ignore the return code here.. not sure if we should 		 * somehow abort.. but we do have an existing asoc. This 		 * really should not fail. 		 */
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|sh
argument_list|,
name|init_src
argument_list|)
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|4
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* respond with a COOKIE-ACK */
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|5
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
comment|/* end if */
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|my_vtag
operator|&&
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|peer_vtag
operator|&&
name|cookie
operator|->
name|tie_tag_my_vtag
operator|==
literal|0
operator|&&
name|cookie
operator|->
name|tie_tag_peer_vtag
operator|==
literal|0
condition|)
block|{
comment|/* 		 * case C in Section 5.2.4 Table 2: XMOO silently discard 		 */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|6
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|==
name|asoc
operator|->
name|my_vtag
operator|&&
operator|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
operator|||
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * case B in Section 5.2.4 Table 2: MXAA or MOAA my info 		 * should be ok, re-accept peer info 		 */
if|if
condition|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
operator|!=
name|asoc
operator|->
name|init_seq_number
condition|)
block|{
comment|/* 			 * Extension of case C. If we hit this, then the 			 * random number generator returned the same vtag 			 * when we first sent our INIT-ACK and when we later 			 * sent our INIT. The side with the seq numbers that 			 * are different will be the one that normnally 			 * would have hit case C. This in effect "extends" 			 * our vtags in this collision case to be 64 bits. 			 * The same collision could occur aka you get both 			 * vtag and seq number the same twice in a row.. but 			 * is much less likely. If it did happen then we 			 * would proceed through and bring up the assoc.. we 			 * may end up with the wrong stream setup however.. 			 * which would be bad.. but there is no way to 			 * tell.. until we send on a stream that does not 			 * exist :-) 			 */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|7
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|8
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_13
argument_list|)
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 		 * since we did not send a HB make sure we don't double 		 * things 		 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|my_rwnd
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|pre_open_streams
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
expr_stmt|;
comment|/* Note last_cwr_tsn? where is this used? */
name|asoc
operator|->
name|last_cwr_tsn
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
condition|)
block|{
comment|/* 			 * Ok the peer probably discarded our data (if we 			 * echoed a cookie+data). So anything on the 			 * sent_queue should be marked for retransmit, we 			 * may not get something to kick us so it COULD 			 * still take a timeout to move these.. but it can't 			 * hurt to mark them. 			 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|spec_flag
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* process the INIT info (peer's info) */
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|9
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|sh
argument_list|,
name|init_src
argument_list|)
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|10
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_COOKIE_WAIT
operator|)
operator|||
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_UP
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|==
literal|0
operator|)
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
else|else
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_restartestab
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
expr_stmt|;
block|}
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|spec_flag
condition|)
block|{
comment|/* 			 * only if we have retrans set do we do this. What 			 * this call does is get only the COOKIE-ACK out and 			 * then when we return the normal call to 			 * sctp_chunk_output will get the retrans out behind 			 * this. 			 */
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_COOKIE_ACK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|11
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|my_vtag
operator|&&
name|ntohl
argument_list|(
name|init_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
operator|!=
name|asoc
operator|->
name|peer_vtag
operator|)
operator|&&
name|cookie
operator|->
name|tie_tag_my_vtag
operator|==
name|asoc
operator|->
name|my_vtag_nonce
operator|&&
name|cookie
operator|->
name|tie_tag_peer_vtag
operator|==
name|asoc
operator|->
name|peer_vtag_nonce
operator|&&
name|cookie
operator|->
name|tie_tag_peer_vtag
operator|!=
literal|0
condition|)
block|{
name|struct
name|sctpasochead
modifier|*
name|head
decl_stmt|;
comment|/* 		 * case A in Section 5.2.4 Table 2: XXMM (peer restarted) 		 */
comment|/* temp code */
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|12
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_14
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_15
argument_list|)
expr_stmt|;
operator|*
name|sac_assoc_id
operator|=
name|sctp_get_associd
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* notify upper layer */
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_RESTART
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_OPEN
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
condition|)
block|{
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_restartestab
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
condition|)
block|{
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_collisionestab
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
condition|)
block|{
comment|/* move to OPEN state, if not in SHUTDOWN_SENT */
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
expr_stmt|;
block|}
name|asoc
operator|->
name|pre_open_streams
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|init_seq_number
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sending_seq
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|=
name|asoc
operator|->
name|str_reset_seq_out
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|last_cwr_tsn
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|mapping_array
condition|)
name|memset
argument_list|(
name|asoc
operator|->
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|asoc
operator|->
name|mapping_array_size
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WLOCK
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* send up all the data */
name|SCTP_TCB_SEND_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_report_all_outbound
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|stream_no
operator|=
name|i
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_sent
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|last_msg_incomplete
operator|=
literal|0
expr_stmt|;
block|}
comment|/* process the INIT-ACK info (my info) */
name|asoc
operator|->
name|my_vtag
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_rwnd
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
comment|/* pull from vtag hash */
name|LIST_REMOVE
argument_list|(
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
comment|/* re-insert to new vtag position */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_asochash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|,
name|sctppcbinfo
operator|.
name|hashasocmark
argument_list|)
index|]
expr_stmt|;
comment|/* 		 * put it in the bucket in the vtag hash of assoc's for the 		 * system 		 */
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_asocs
argument_list|)
expr_stmt|;
comment|/* Is this the first restart? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|in_restart_hash
operator|==
literal|0
condition|)
block|{
comment|/* Ok add it to assoc_id vtag hash */
name|head
operator|=
operator|&
name|sctppcbinfo
operator|.
name|sctp_restarthash
index|[
name|SCTP_PCBHASH_ASOC
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|assoc_id
argument_list|,
name|sctppcbinfo
operator|.
name|hashrestartmark
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|stcb
argument_list|,
name|sctp_tcbrestarhash
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|in_restart_hash
operator|=
literal|1
expr_stmt|;
block|}
comment|/* process the INIT info (peer's info) */
name|SCTP_TCB_SEND_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_INP_INFO_WUNLOCK
argument_list|()
expr_stmt|;
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|13
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * since we did not send a HB make sure we don't double 		 * things 		 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|sh
argument_list|,
name|init_src
argument_list|)
condition|)
block|{
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|14
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* respond with a COOKIE-ACK */
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|15
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
if|if
condition|(
name|how_indx
operator|<
sizeof|sizeof
argument_list|(
name|asoc
operator|->
name|cookie_how
argument_list|)
condition|)
name|asoc
operator|->
name|cookie_how
index|[
name|how_indx
index|]
operator|=
literal|16
expr_stmt|;
comment|/* all other cases... */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * handle a state cookie for a new association m: input packet mbuf chain--  * assumes a pullup on IP/SCTP/COOKIE-ECHO chunk note: this is a "split" mbuf  * and the cookie signature does not exist offset: offset into mbuf to the  * cookie-echo chunk length: length of the cookie chunk to: where the init  * was from returns a new TCB  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_cookie_new
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
parameter_list|,
name|int
name|cookie_len
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_src
parameter_list|,
name|int
modifier|*
name|notification
parameter_list|,
name|int
name|auth_skipped
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|uint32_t
name|auth_len
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_init_chunk
modifier|*
name|init_cp
decl_stmt|,
name|init_buf
decl_stmt|;
name|struct
name|sctp_init_ack_chunk
modifier|*
name|initack_cp
decl_stmt|,
name|initack_buf
decl_stmt|;
name|struct
name|sockaddr_storage
name|sa_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|initack_src
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_store
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|int
name|chk_length
decl_stmt|;
name|int
name|init_offset
decl_stmt|,
name|initack_offset
decl_stmt|,
name|initack_limit
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint32_t
name|old_tag
decl_stmt|;
name|uint8_t
name|auth_chunk_buf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
comment|/* 	 * find and validate the INIT chunk in the cookie (peer's info) the 	 * INIT should start after the cookie-echo header struct (chunk 	 * header, state cookie header struct) 	 */
name|init_offset
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_echo_chunk
argument_list|)
expr_stmt|;
name|init_cp
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|init_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|init_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull a INIT chunk in cookie */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"process_cookie_new: could not pull INIT chunk hdr\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chk_length
operator|=
name|ntohs
argument_list|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"HUH? process_cookie_new: could not find INIT chunk!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|initack_offset
operator|=
name|init_offset
operator|+
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
comment|/* 	 * find and validate the INIT-ACK chunk in the cookie (my info) the 	 * INIT-ACK follows the INIT chunk 	 */
name|initack_cp
operator|=
operator|(
expr|struct
name|sctp_init_ack_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|initack_offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|initack_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|initack_cp
operator|==
name|NULL
condition|)
block|{
comment|/* could not pull INIT-ACK chunk in cookie */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"process_cookie_new: could not pull INIT-ACK chunk hdr\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chk_length
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|initack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|!=
name|SCTP_INITIATION_ACK
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * NOTE: We can't use the INIT_ACK's chk_length to determine the 	 * "initack_limit" value.  This is because the chk_length field 	 * includes the length of the cookie, but the cookie is omitted when 	 * the INIT and INIT_ACK are tacked onto the cookie... 	 */
name|initack_limit
operator|=
name|offset
operator|+
name|cookie_len
expr_stmt|;
comment|/* 	 * now that we know the INIT/INIT-ACK are in place, create a new TCB 	 * and popluate 	 */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|init_src
argument_list|,
literal|0
argument_list|,
operator|&
name|error
argument_list|,
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
comment|/* memory problem? */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"process_cookie_new: no room for another TCB!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* get the correct sctp_nets */
operator|*
name|netp
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|init_src
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* get scope variables out of cookie */
name|asoc
operator|->
name|ipv4_local_scope
operator|=
name|cookie
operator|->
name|ipv4_scope
expr_stmt|;
name|asoc
operator|->
name|site_scope
operator|=
name|cookie
operator|->
name|site_scope
expr_stmt|;
name|asoc
operator|->
name|local_scope
operator|=
name|cookie
operator|->
name|local_scope
expr_stmt|;
name|asoc
operator|->
name|loopback_scope
operator|=
name|cookie
operator|->
name|loopback_scope
expr_stmt|;
if|if
condition|(
operator|(
name|asoc
operator|->
name|ipv4_addr_legal
operator|!=
name|cookie
operator|->
name|ipv4_addr_legal
operator|)
operator|||
operator|(
name|asoc
operator|->
name|ipv6_addr_legal
operator|!=
name|cookie
operator|->
name|ipv6_addr_legal
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
comment|/* 		 * Houston we have a problem. The EP changed while the 		 * cookie was in flight. Only recourse is to abort the 		 * association. 		 */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* process the INIT-ACK info (my info) */
name|old_tag
operator|=
name|asoc
operator|->
name|my_vtag
expr_stmt|;
name|asoc
operator|->
name|assoc_id
operator|=
name|asoc
operator|->
name|my_vtag
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initiate_tag
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|my_rwnd
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|pre_open_streams
operator|=
name|ntohs
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|num_outbound_streams
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|init_seq_number
operator|=
name|ntohl
argument_list|(
name|initack_cp
operator|->
name|init
operator|.
name|initial_tsn
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|sending_seq
operator|=
name|asoc
operator|->
name|asconf_seq_out
operator|=
name|asoc
operator|->
name|str_reset_seq_out
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|last_cwr_tsn
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|asoc
operator|->
name|last_acked_seq
operator|=
name|asoc
operator|->
name|init_seq_number
operator|-
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|=
name|asoc
operator|->
name|init_seq_number
expr_stmt|;
name|asoc
operator|->
name|advanced_peer_ack_point
operator|=
name|asoc
operator|->
name|last_acked_seq
expr_stmt|;
comment|/* process the INIT info (peer's info) */
name|retval
operator|=
name|sctp_process_init
argument_list|(
name|init_cp
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|<
literal|0
condition|)
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_16
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* load all addresses */
if|if
condition|(
name|sctp_load_addresses_from_init
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|init_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
argument_list|,
name|initack_offset
argument_list|,
name|sh
argument_list|,
name|init_src
argument_list|)
condition|)
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_17
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * verify any preceding AUTH chunk that was skipped 	 */
comment|/* pull the local authentication parameters from the cookie/init-ack */
name|sctp_auth_get_cookie_params
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
name|initack_limit
operator|-
operator|(
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_skipped
condition|)
block|{
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
decl_stmt|;
name|auth
operator|=
operator|(
expr|struct
name|sctp_auth_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|auth_chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_auth
argument_list|(
name|stcb
argument_list|,
name|auth
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|)
condition|)
block|{
comment|/* auth HMAC failed, dump the assoc and packet */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"COOKIE-ECHO: AUTH failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_18
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* remaining chunks checked... good to go */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* update current state */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"moving to OPEN state\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
expr_stmt|;
block|}
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_passiveestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
comment|/* 	 * if we're doing ASCONFs, check to see if we have any new local 	 * addresses that need to get added to the peer (eg. addresses 	 * changed while cookie echo in flight).  This needs to be done 	 * after we go to the OPEN state to do the correct asconf 	 * processing. else, make sure we have the correct addresses in our 	 * lists 	 */
comment|/* warning, we re-use sin, sin6, sa_store here! */
comment|/* pull in local_address (our "from" address) */
if|if
condition|(
name|cookie
operator|->
name|laddr_type
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
comment|/* source addr is IPv4 */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|initack_src
expr_stmt|;
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|cookie
operator|->
name|laddress
index|[
literal|0
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cookie
operator|->
name|laddr_type
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
comment|/* source addr is IPv6 */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|initack_src
expr_stmt|;
name|memset
argument_list|(
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|cookie
operator|->
name|scope_id
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|cookie
operator|->
name|laddress
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_19
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sctp_check_address_list
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
name|initack_limit
operator|-
operator|(
name|initack_offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
operator|)
argument_list|,
name|initack_src
argument_list|,
name|cookie
operator|->
name|local_scope
argument_list|,
name|cookie
operator|->
name|site_scope
argument_list|,
name|cookie
operator|->
name|ipv4_scope
argument_list|,
name|cookie
operator|->
name|loopback_scope
argument_list|)
expr_stmt|;
comment|/* set up to notify upper layer */
operator|*
name|notification
operator|=
name|SCTP_NOTIFY_ASSOC_UP
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * This is an endpoint that called connect() how it got a 		 * cookie that is NEW is a bit of a mystery. It must be that 		 * the INIT was sent, but before it got there.. a complete 		 * INIT/INIT-ACK/COOKIE arrived. But of course then it 		 * should have went to the other code.. not here.. oh well.. 		 * a bit of protection is worth having.. 		 */
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|)
condition|)
block|{
comment|/* 		 * We don't want to do anything with this one. Since it is 		 * the listening guy. The timer will get started for 		 * accepted connections in the caller. 		 */
empty_stmt|;
block|}
comment|/* since we did not send a HB make sure we don't double things */
operator|(
operator|*
name|netp
operator|)
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* respond with a COOKIE-ACK */
comment|/* calculate the RTT */
operator|(
operator|*
name|netp
operator|)
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|cookie
operator|->
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * handles a COOKIE-ECHO message stcb: modified to either a new or left as  * existing (non-NULL) TCB  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_handle_cookie_echo
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_cookie_echo_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
modifier|*
name|inp_p
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
name|auth_skipped
parameter_list|,
name|uint32_t
name|auth_offset
parameter_list|,
name|uint32_t
name|auth_len
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
modifier|*
name|locked_tcb
parameter_list|)
block|{
name|struct
name|sctp_state_cookie
modifier|*
name|cookie
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|l_stcb
init|=
operator|*
name|stcb
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|l_inp
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|to
decl_stmt|;
name|sctp_assoc_t
name|sac_restart_id
decl_stmt|;
name|struct
name|sctp_pcb
modifier|*
name|ep
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_sig
decl_stmt|;
name|uint8_t
name|calc_sig
index|[
name|SCTP_SIGNATURE_SIZE
index|]
decl_stmt|,
name|tmp_sig
index|[
name|SCTP_SIGNATURE_SIZE
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|sig
decl_stmt|;
name|uint8_t
name|cookie_ok
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|size_of_pkt
decl_stmt|,
name|sig_offset
decl_stmt|,
name|cookie_offset
decl_stmt|;
name|unsigned
name|int
name|cookie_len
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|timeval
name|time_expires
decl_stmt|;
name|struct
name|sockaddr_storage
name|dest_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|localep_sa
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|dest_store
decl_stmt|;
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|int
name|notification
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|netl
decl_stmt|;
name|int
name|had_a_existing_tcb
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_cookie: handling COOKIE-ECHO\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp_p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* First get the destination address setup too. */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* its IPv4 */
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|localep_sa
operator|)
expr_stmt|;
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_dst
operator|.
name|s_addr
expr_stmt|;
name|size_of_pkt
operator|=
name|SCTP_GET_IPV4_LENGTH
argument_list|(
name|iph
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* its IPv6 */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|localep_sa
operator|)
expr_stmt|;
name|memset
argument_list|(
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|dest_port
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
name|size_of_pkt
operator|=
name|SCTP_GET_IPV6_LENGTH
argument_list|(
name|ip6
argument_list|)
operator|+
name|iphlen
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cookie
operator|=
operator|&
name|cp
operator|->
name|cookie
expr_stmt|;
name|cookie_offset
operator|=
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|cookie_len
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cookie
operator|->
name|peerport
operator|!=
name|sh
operator|->
name|src_port
operator|)
operator|&&
operator|(
name|cookie
operator|->
name|myport
operator|!=
name|sh
operator|->
name|dest_port
operator|)
operator|&&
operator|(
name|cookie
operator|->
name|my_vtag
operator|!=
name|sh
operator|->
name|v_tag
operator|)
condition|)
block|{
comment|/* 		 * invalid ports or bad tag.  Note that we always leave the 		 * v_tag in the header in network order and when we stored 		 * it in the my_vtag slot we also left it in network order. 		 * This maintians the match even though it may be in the 		 * opposite byte order of the machine :-> 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|cookie_len
operator|>
name|size_of_pkt
operator|||
name|cookie_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cookie_echo_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
operator|+
name|SCTP_SIGNATURE_SIZE
condition|)
block|{
comment|/* cookie too long!  or too small */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * split off the signature into its own mbuf (since it should not be 	 * calculated in the sctp_hmac_m() call). 	 */
name|sig_offset
operator|=
name|offset
operator|+
name|cookie_len
operator|-
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
if|if
condition|(
name|sig_offset
operator|>
name|size_of_pkt
condition|)
block|{
comment|/* packet not correct size! */
comment|/* XXX this may already be accounted for earlier... */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_sig
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|sig_offset
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_sig
operator|==
name|NULL
condition|)
block|{
comment|/* out of memory or ?? */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * compute the signature/digest for the cookie 	 */
name|ep
operator|=
operator|&
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
expr_stmt|;
name|l_inp
operator|=
operator|*
name|inp_p
expr_stmt|;
if|if
condition|(
name|l_stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|l_stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|l_inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|l_stcb
argument_list|)
expr_stmt|;
block|}
comment|/* which cookie is it? */
if|if
condition|(
operator|(
name|cookie
operator|->
name|time_entered
operator|.
name|tv_sec
operator|<
operator|(
name|long
operator|)
name|ep
operator|->
name|time_of_secret_change
operator|)
operator|&&
operator|(
name|ep
operator|->
name|current_secret_number
operator|!=
name|ep
operator|->
name|last_secret_number
operator|)
condition|)
block|{
comment|/* it's the old cookie */
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ep
operator|->
name|secret_key
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|last_secret_number
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m
argument_list|,
name|cookie_offset
argument_list|,
name|calc_sig
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's the current cookie */
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ep
operator|->
name|secret_key
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|current_secret_number
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m
argument_list|,
name|cookie_offset
argument_list|,
name|calc_sig
argument_list|)
expr_stmt|;
block|}
comment|/* get the signature */
name|SCTP_INP_RUNLOCK
argument_list|(
name|l_inp
argument_list|)
expr_stmt|;
name|sig
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m_sig
argument_list|,
literal|0
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_sig
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|==
name|NULL
condition|)
block|{
comment|/* couldn't find signature */
name|sctp_m_freem
argument_list|(
name|m_sig
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* compare the received digest with the computed digest */
if|if
condition|(
name|memcmp
argument_list|(
name|calc_sig
argument_list|,
name|sig
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* try the old cookie? */
if|if
condition|(
operator|(
name|cookie
operator|->
name|time_entered
operator|.
name|tv_sec
operator|==
operator|(
name|long
operator|)
name|ep
operator|->
name|time_of_secret_change
operator|)
operator|&&
operator|(
name|ep
operator|->
name|current_secret_number
operator|!=
name|ep
operator|->
name|last_secret_number
operator|)
condition|)
block|{
comment|/* compute digest with old */
name|sctp_hmac_m
argument_list|(
name|SCTP_HMAC
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ep
operator|->
name|secret_key
index|[
operator|(
name|int
operator|)
name|ep
operator|->
name|last_secret_number
index|]
argument_list|,
name|SCTP_SECRET_SIZE
argument_list|,
name|m
argument_list|,
name|cookie_offset
argument_list|,
name|calc_sig
argument_list|)
expr_stmt|;
comment|/* compare */
if|if
condition|(
name|memcmp
argument_list|(
name|calc_sig
argument_list|,
name|sig
argument_list|,
name|SCTP_SIGNATURE_SIZE
argument_list|)
operator|==
literal|0
condition|)
name|cookie_ok
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
name|cookie_ok
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Now before we continue we must reconstruct our mbuf so that 	 * normal processing of any other chunks will work. 	 */
block|{
name|struct
name|mbuf
modifier|*
name|m_at
decl_stmt|;
name|m_at
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|m_at
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|m_at
argument_list|)
operator|=
name|m_sig
expr_stmt|;
block|}
if|if
condition|(
name|cookie_ok
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"handle_cookie_echo: cookie signature validation failed!\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"offset = %u, cookie_offset = %u, sig_offset = %u\n"
argument_list|,
operator|(
name|uint32_t
operator|)
name|offset
argument_list|,
name|cookie_offset
argument_list|,
name|sig_offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * check the cookie timestamps to be sure it's not stale 	 */
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* Expire time is in Ticks, so we convert to seconds */
name|time_expires
operator|.
name|tv_sec
operator|=
name|cookie
operator|->
name|time_entered
operator|.
name|tv_sec
operator|+
name|cookie
operator|->
name|cookie_life
expr_stmt|;
name|time_expires
operator|.
name|tv_usec
operator|=
name|cookie
operator|->
name|time_entered
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|timevalcmp
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|time_expires
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* cookie is stale! */
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|struct
name|sctp_stale_cookie_msg
modifier|*
name|scm
decl_stmt|;
name|uint32_t
name|tim
decl_stmt|;
name|op_err
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stale_cookie_msg
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|op_err
operator|==
name|NULL
condition|)
block|{
comment|/* FOOBAR */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* pre-reserve some space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_RESV_UF
argument_list|(
name|op_err
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the len */
name|SCTP_BUF_LEN
argument_list|(
name|op_err
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stale_cookie_msg
argument_list|)
expr_stmt|;
name|scm
operator|=
name|mtod
argument_list|(
name|op_err
argument_list|,
expr|struct
name|sctp_stale_cookie_msg
operator|*
argument_list|)
expr_stmt|;
name|scm
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_STALE_COOKIE
argument_list|)
expr_stmt|;
name|scm
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* seconds to usec */
name|tim
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|time_expires
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
expr_stmt|;
comment|/* add in usec */
if|if
condition|(
name|tim
operator|==
literal|0
condition|)
name|tim
operator|=
name|now
operator|.
name|tv_usec
operator|-
name|cookie
operator|->
name|time_entered
operator|.
name|tv_usec
expr_stmt|;
name|scm
operator|->
name|time_usec
operator|=
name|htonl
argument_list|(
name|tim
argument_list|)
expr_stmt|;
name|sctp_send_operr_to
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|op_err
argument_list|,
name|cookie
operator|->
name|peers_vtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Now we must see with the lookup address if we have an existing 	 * asoc. This will only happen if we were in the COOKIE-WAIT state 	 * and a INIT collided with us and somewhere the peer sent the 	 * cookie on another address besides the single address our assoc 	 * had for him. In this case we will have one of the tie-tags set at 	 * least AND the address field in the cookie can be used to look it 	 * up. 	 */
name|to
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cookie
operator|->
name|addr_type
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin6
operator|.
name|sin6_scope_id
operator|=
name|cookie
operator|->
name|scope_id
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|,
name|cookie
operator|->
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|.
name|sin6_addr
operator|.
name|s6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cookie
operator|->
name|addr_type
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|cookie
operator|->
name|address
index|[
literal|0
index|]
expr_stmt|;
name|to
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|stcb
operator|==
name|NULL
operator|)
operator|&&
name|to
condition|)
block|{
comment|/* Yep, lets check */
operator|*
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
name|inp_p
argument_list|,
name|to
argument_list|,
name|netp
argument_list|,
name|localep_sa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * We should have only got back the same inp. If we 			 * got back a different ep we have a problem. The 			 * original findep got back l_inp and now 			 */
if|if
condition|(
name|l_inp
operator|!=
operator|*
name|inp_p
condition|)
block|{
name|printf
argument_list|(
literal|"Bad problem find_ep got a diff inp then special_locate?\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|locked_tcb
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * In this case we found the assoc only 				 * after we locked the create lock. This 				 * means we are in a colliding case and we 				 * must make sure that we unlock the tcb if 				 * its one of the cases where we throw away 				 * the incoming packets. 				 */
operator|*
name|locked_tcb
operator|=
operator|*
name|stcb
expr_stmt|;
comment|/* 				 * We must also increment the inp ref count 				 * since the ref_count flags was set when we 				 * did not find the TCB, now we found it 				 * which reduces the refcount.. we must 				 * raise it back out to balance it all :-) 				 */
name|SCTP_INP_INCR_REF
argument_list|(
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
operator|!=
name|l_inp
condition|)
block|{
name|printf
argument_list|(
literal|"Huh? ep:%p diff then l_inp:%p?\n"
argument_list|,
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
argument_list|,
name|l_inp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|cookie_len
operator|-=
name|SCTP_SIGNATURE_SIZE
expr_stmt|;
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* this is the "normal" case... get a new TCB */
operator|*
name|stcb
operator|=
name|sctp_process_cookie_new
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|cookie
argument_list|,
name|cookie_len
argument_list|,
operator|*
name|inp_p
argument_list|,
name|netp
argument_list|,
name|to
argument_list|,
operator|&
name|notification
argument_list|,
name|auth_skipped
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this is abnormal... cookie-echo on existing TCB */
name|had_a_existing_tcb
operator|=
literal|1
expr_stmt|;
operator|*
name|stcb
operator|=
name|sctp_process_cookie_existing
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|cookie
argument_list|,
name|cookie_len
argument_list|,
operator|*
name|inp_p
argument_list|,
operator|*
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
name|to
argument_list|,
operator|&
name|notification
argument_list|,
operator|&
name|sac_restart_id
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* still no TCB... must be bad cookie-echo */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Ok, we built an association so confirm the address we sent the 	 * INIT-ACK to. 	 */
name|netl
operator|=
name|sctp_findnet
argument_list|(
operator|*
name|stcb
argument_list|,
name|to
argument_list|)
expr_stmt|;
comment|/* 	 * This code should in theory NOT run but 	 */
if|if
condition|(
name|netl
operator|==
name|NULL
condition|)
block|{
comment|/* TSNH! Huh, why do I need to add this address here? */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_add_remote_addr
argument_list|(
operator|*
name|stcb
argument_list|,
name|to
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_IN_COOKIE_PROC
argument_list|)
expr_stmt|;
name|netl
operator|=
name|sctp_findnet
argument_list|(
operator|*
name|stcb
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|netl
condition|)
block|{
if|if
condition|(
name|netl
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
name|netl
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_UNCONFIRMED
expr_stmt|;
name|sctp_set_primary_addr
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|NULL
argument_list|,
name|netl
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_CONFIRMED
argument_list|,
operator|(
operator|*
name|stcb
operator|)
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|netl
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|stcb
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
operator|*
name|inp_p
argument_list|,
operator|*
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
if|if
condition|(
operator|!
name|had_a_existing_tcb
operator|||
operator|(
operator|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * If we have a NEW cookie or the connect never 			 * reached the connected state during collision we 			 * must do the TCP accept thing. 			 */
name|struct
name|socket
modifier|*
name|so
decl_stmt|,
modifier|*
name|oso
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
if|if
condition|(
name|notification
operator|==
name|SCTP_NOTIFY_ASSOC_RESTART
condition|)
block|{
comment|/* 				 * For a restart we will keep the same 				 * socket, no need to do anything. I THINK!! 				 */
name|sctp_ulp_notify
argument_list|(
name|notification
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|sac_restart_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
name|oso
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_socket
expr_stmt|;
comment|/* 			 * We do this to keep the sockets side happy durin 			 * the sonewcon ONLY. 			 */
name|NET_LOCK_GIANT
argument_list|()
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|so
operator|=
name|sonewconn
argument_list|(
name|oso
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NET_UNLOCK_GIANT
argument_list|()
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
operator|(
operator|*
name|stcb
operator|)
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|so
operator|==
name|NULL
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
comment|/* Too many sockets */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"process_cookie_new: no room for another socket!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|op_err
operator|=
name|sctp_generate_invmanparam
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|sctp_abort_association
argument_list|(
operator|*
name|inp_p
argument_list|,
name|NULL
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|op_err
argument_list|)
expr_stmt|;
name|sctp_free_assoc
argument_list|(
operator|*
name|inp_p
argument_list|,
operator|*
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_20
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* 			 * We add the unbound flag here so that if we get an 			 * soabort() before we get the move_pcb done, we 			 * will properly cleanup. 			 */
name|inp
operator|->
name|sctp_flags
operator|=
operator|(
name|SCTP_PCB_FLAGS_TCPTYPE
operator||
name|SCTP_PCB_FLAGS_CONNECTED
operator||
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator||
name|SCTP_PCB_FLAGS_UNBOUND
operator||
operator|(
name|SCTP_PCB_COPY_FLAGS
operator|&
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|)
operator||
name|SCTP_PCB_FLAGS_DONT_WAKE
operator|)
expr_stmt|;
name|inp
operator|->
name|sctp_features
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_features
expr_stmt|;
name|inp
operator|->
name|sctp_socket
operator|=
name|so
expr_stmt|;
name|inp
operator|->
name|sctp_frag_point
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_frag_point
expr_stmt|;
name|inp
operator|->
name|partial_delivery_point
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|partial_delivery_point
expr_stmt|;
name|inp
operator|->
name|sctp_context
operator|=
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_context
expr_stmt|;
name|inp
operator|->
name|inp_starting_point_for_iterator
operator|=
name|NULL
expr_stmt|;
comment|/* 			 * copy in the authentication parameters from the 			 * original endpoint 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
condition|)
name|sctp_free_hmaclist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|local_hmacs
operator|=
name|sctp_copy_hmaclist
argument_list|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
operator|.
name|local_hmacs
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
condition|)
name|sctp_free_chunklist
argument_list|(
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
operator|=
name|sctp_copy_chunklist
argument_list|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
operator|.
name|local_auth_chunks
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_copy_skeylist
argument_list|(
operator|&
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|,
operator|&
name|inp
operator|->
name|sctp_ep
operator|.
name|shared_keys
argument_list|)
expr_stmt|;
comment|/* 			 * Now we must move it from one hash table to 			 * another and get the tcb in the right place. 			 */
name|sctp_move_pcb_and_assoc
argument_list|(
operator|*
name|inp_p
argument_list|,
name|inp
argument_list|,
operator|*
name|stcb
argument_list|)
expr_stmt|;
name|sctp_pull_off_control_to_new_inp
argument_list|(
operator|(
operator|*
name|inp_p
operator|)
argument_list|,
name|inp
argument_list|,
operator|*
name|stcb
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
comment|/* 			 * now we must check to see if we were aborted while 			 * the move was going on and the lock/unlock 			 * happened. 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* 				 * yep it was, we leave the assoc attached 				 * to the socket since the sctp_inpcb_free() 				 * call will send an abort for us. 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Switch over to the new guy */
operator|*
name|inp_p
operator|=
name|inp
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|notification
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Pull it from the incomplete queue and wake the 			 * guy 			 */
name|soisconnected
argument_list|(
name|so
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|notification
operator|)
operator|&&
operator|(
operator|(
operator|*
name|inp_p
operator|)
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UDPTYPE
operator|)
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|notification
argument_list|,
operator|*
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_cookie_ack
parameter_list|(
name|struct
name|sctp_cookie_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* cp must not be used, others call this without a c-ack :-) */
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_cookie_ack: handling COOKIE-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* process according to association state */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
condition|)
block|{
comment|/* state change only needed when I am in right state */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"moving to OPEN state\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|asoc
operator|->
name|state
operator|&
name|SCTP_STATE_SHUTDOWN_PENDING
condition|)
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
operator||
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_OPEN
expr_stmt|;
block|}
comment|/* update RTO */
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_activeestab
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|overall_error_count
operator|==
literal|0
condition|)
block|{
name|net
operator|->
name|RTO
operator|=
name|sctp_calculate_rto
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|,
name|net
argument_list|,
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
block|}
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|asoc
operator|->
name|time_entered
argument_list|)
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_UP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|||
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
name|soisconnected
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* 		 * since we did not send a HB make sure we don't double 		 * things 		 */
name|net
operator|->
name|hb_responded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|sctp_autoclose_ticks
operator|&&
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_AUTOCLOSE
argument_list|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_AUTOCLOSE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * set ASCONF timer if ASCONFs are pending and allowed (eg. 		 * addresses changed when init/cookie echo in flight) 		 */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
operator|)
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Toss the cookie if I can */
name|sctp_toss_old_cookies
argument_list|(
name|stcb
argument_list|,
name|asoc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* Restart the timer if we have pending data */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_ecn_echo
parameter_list|(
name|struct
name|sctp_ecne_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|lchk
decl_stmt|;
name|uint32_t
name|tsn
decl_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
condition|)
block|{
return|return;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvecne
argument_list|)
expr_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|tsn
argument_list|)
expr_stmt|;
comment|/* ECN Nonce stuff: need a resync and disable the nonce sum check */
comment|/* Also we make sure we disable the nonce_wait */
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|lchk
operator|==
name|NULL
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|nonce_resync_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|nonce_resync_tsn
operator|=
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|nonce_wait_for_ecne
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|nonce_sum_check
operator|=
literal|0
expr_stmt|;
comment|/* Find where it was sent, if possible */
name|net
operator|=
name|NULL
expr_stmt|;
name|lchk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|lchk
condition|)
block|{
if|if
condition|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tsn
condition|)
block|{
name|net
operator|=
name|lchk
operator|->
name|whoTo
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|lchk
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tsn
argument_list|,
name|MAX_SEQ
argument_list|)
condition|)
break|break;
name|lchk
operator|=
name|TAILQ_NEXT
argument_list|(
name|lchk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
comment|/* default is we use the primary */
name|net
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_cwr_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|int
name|old_cwnd
decl_stmt|;
name|old_cwnd
operator|=
name|net
operator|->
name|cwnd
expr_stmt|;
endif|#
directive|endif
name|SCTP_STAT_INCR
argument_list|(
name|sctps_ecnereducedcwnd
argument_list|)
expr_stmt|;
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ssthresh
operator|<
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
comment|/* here back off the timer as well, to slow us down */
name|net
operator|->
name|RTO
operator|<<=
literal|2
expr_stmt|;
block|}
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|ssthresh
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_SAT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * we reduce once every RTT. So we will only lower cwnd at 		 * the next sending seq i.e. the resync_tsn. 		 */
name|stcb
operator|->
name|asoc
operator|.
name|last_cwr_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|nonce_resync_tsn
expr_stmt|;
block|}
comment|/* 	 * We always send a CWR this way if our previous one was lost our 	 * peer will get an update, or if it is not time again to reduce we 	 * still get the cwr to the peer. 	 */
name|sctp_send_cwr
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|tsn
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_ecn_cwr
parameter_list|(
name|struct
name|sctp_cwr_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* 	 * Here we get a CWR from the peer. We must look in the outqueue and 	 * make sure that we have a covered ECNE in teh control chunk part. 	 * If so remove it. 	 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_ecne_chunk
modifier|*
name|ecne
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|!=
name|SCTP_ECN_ECHO
condition|)
block|{
continue|continue;
block|}
comment|/* 		 * Look for and remove if it is the right TSN. Since there 		 * is only ONE ECNE on the control queue at any one time we 		 * don't need to worry about more than one! 		 */
name|ecne
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_ecne_chunk
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|ntohl
argument_list|(
name|cp
operator|->
name|tsn
argument_list|)
argument_list|,
name|ntohl
argument_list|(
name|ecne
operator|->
name|tsn
argument_list|)
argument_list|,
name|MAX_TSN
argument_list|)
operator|||
operator|(
name|cp
operator|->
name|tsn
operator|==
name|ecne
operator|->
name|tsn
operator|)
condition|)
block|{
comment|/* this covers this ECNE, we can remove it */
name|stcb
operator|->
name|asoc
operator|.
name|ecn_echo_cnt_onq
operator|--
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_shutdown_complete
parameter_list|(
name|struct
name|sctp_shutdown_complete_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_handle_shutdown_complete: handling SHUTDOWN-COMPLETE\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
return|return;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* process according to association state */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
condition|)
block|{
comment|/* unexpected SHUTDOWN-COMPLETE... so ignore... */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* notify upper layer protocol */
if|if
condition|(
name|stcb
operator|->
name|sctp_socket
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASSOC_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* are the queues empty? they should be */
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|||
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
condition|)
block|{
name|sctp_report_all_outbound
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* stop the timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_21
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_shutdown
argument_list|)
expr_stmt|;
comment|/* free the TCB */
name|sctp_free_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_22
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|process_chunk_drop
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_chunk_desc
modifier|*
name|desc
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint8_t
name|flg
parameter_list|)
block|{
switch|switch
condition|(
name|desc
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_DATA
case|:
comment|/* find the tsn to resend (possibly */
block|{
name|uint32_t
name|tsn
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|tp1
decl_stmt|;
name|tsn
operator|=
name|ntohl
argument_list|(
name|desc
operator|->
name|tsn_ifany
argument_list|)
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tsn
condition|)
block|{
comment|/* found it */
break|break;
block|}
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|,
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* not found */
name|tp1
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Do it the other way , aka without paying 				 * attention to queue seq order. 				 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpdnfnd
argument_list|)
expr_stmt|;
name|tp1
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
while|while
condition|(
name|tp1
condition|)
block|{
if|if
condition|(
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
operator|==
name|tsn
condition|)
block|{
comment|/* found it */
break|break;
block|}
name|tp1
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp1
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tp1
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrptsnnf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp1
operator|)
operator|&&
operator|(
name|tp1
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_ACKED
operator|)
condition|)
block|{
name|uint8_t
modifier|*
name|ddp
decl_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|flg
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpdiwnp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|==
literal|0
operator|&&
operator|(
name|flg
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpdizrw
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ddp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|tp1
operator|->
name|data
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|)
expr_stmt|;
block|{
name|unsigned
name|int
name|iii
decl_stmt|;
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|data_bytes
argument_list|)
condition|;
name|iii
operator|++
control|)
block|{
if|if
condition|(
name|ddp
index|[
name|iii
index|]
operator|!=
name|desc
operator|->
name|data_bytes
index|[
name|iii
index|]
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpbadd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
comment|/* 				 * We zero out the nonce so resync not 				 * needed 				 */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|ect_nonce
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|do_rtt
condition|)
block|{
comment|/* 					 * this guy had a RTO calculation 					 * pending on it, cancel it 					 */
name|tp1
operator|->
name|do_rtt
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp1
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|tp1
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
comment|/* 				 * mark it as if we were doing a FR, since 				 * we will be getting gap ack reports behind 				 * the info from the router. 				 */
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|1
expr_stmt|;
comment|/* 				 * mark the tsn with what sequences can 				 * cause a new FR. 				 */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
condition|)
block|{
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
block|}
else|else
block|{
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|fast_retran_tsn
operator|=
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|send_queue
argument_list|)
operator|)
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
expr_stmt|;
block|}
comment|/* restart the timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_23
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|tp1
operator|->
name|whoTo
argument_list|)
expr_stmt|;
comment|/* fix counts and things */
ifdef|#
directive|ifdef
name|SCTP_FLIGHT_LOGGING
name|sctp_misc_ints
argument_list|(
name|SCTP_FLIGHT_LOG_DOWN_PDRP
argument_list|,
name|tp1
operator|->
name|whoTo
operator|->
name|flight_size
argument_list|,
name|tp1
operator|->
name|book_size
argument_list|,
operator|(
name|uintptr_t
operator|)
name|stcb
argument_list|,
name|tp1
operator|->
name|rec
operator|.
name|data
operator|.
name|TSN_seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_flight_size_decrease
argument_list|(
name|tp1
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|tp1
argument_list|)
expr_stmt|;
block|}
block|{
comment|/* audit code */
name|unsigned
name|int
name|audit
decl_stmt|;
name|audit
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
name|audit
operator|++
expr_stmt|;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|tp1
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|tp1
operator|->
name|sent
operator|==
name|SCTP_DATAGRAM_RESEND
condition|)
name|audit
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|audit
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
condition|)
block|{
name|printf
argument_list|(
literal|"**Local Audit finds cnt:%d asoc cnt:%d\n"
argument_list|,
name|audit
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SCTP_AUDITING_ENABLED
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|=
name|audit
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
break|break;
case|case
name|SCTP_ASCONF
case|:
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|asconf
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|asconf
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|asconf
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_ASCONF
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|asconf
condition|)
block|{
if|if
condition|(
name|asconf
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|asconf
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|asconf
operator|->
name|snd_count
operator|--
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_INITIATION
case|:
comment|/* resend the INIT */
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|dropped_special_cnt
operator|<
name|SCTP_RETRY_DROPPED_THRESH
condition|)
block|{
comment|/* 			 * If we can get it in, in a few attempts we do 			 * this, otherwise we let the timer fire. 			 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_INIT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_24
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SCTP_SELECTIVE_ACK
case|:
comment|/* resend the sack */
name|sctp_send_sack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
comment|/* resend a demand HB */
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SHUTDOWN
case|:
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_COOKIE_ECHO
case|:
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|cookie
decl_stmt|;
name|cookie
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|cookie
argument_list|,
argument|&stcb->asoc.control_send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|cookie
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|cookie
condition|)
block|{
if|if
condition|(
name|cookie
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|cookie
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_stop_all_cookie_timers
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_COOKIE_ACK
case|:
name|sctp_send_cookie_ack
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ASCONF_ACK
case|:
comment|/* resend last asconf ack */
name|sctp_send_asconf_ack
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
name|send_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
expr_stmt|;
break|break;
comment|/* can't do anything with these */
case|case
name|SCTP_PACKET_DROPPED
case|:
case|case
name|SCTP_INITIATION_ACK
case|:
comment|/* this should not happen */
case|case
name|SCTP_HEARTBEAT_ACK
case|:
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
case|case
name|SCTP_OPERATION_ERROR
case|:
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
case|case
name|SCTP_ECN_ECHO
case|:
case|case
name|SCTP_ECN_CWR
case|:
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_reset_in_stream
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
comment|/* 	 * We set things to 0xffff since this is the last delivered sequence 	 * and we will be sending in 0 after the reset. 	 */
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
condition|)
block|{
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|temp
index|]
operator|.
name|last_sequence_delivered
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
else|else
block|{
name|list
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamincnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmin
index|[
name|i
index|]
operator|.
name|last_sequence_delivered
operator|=
literal|0xffff
expr_stmt|;
block|}
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_RECV
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
operator|(
name|void
operator|*
operator|)
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_reset_out_streams
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|number_entries
parameter_list|,
name|uint16_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|number_entries
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|;
name|i
operator|++
control|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|i
index|]
operator|.
name|next_sequence_sent
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|number_entries
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|uint16_t
name|temp
decl_stmt|;
name|temp
operator|=
name|ntohs
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|>=
name|stcb
operator|->
name|asoc
operator|.
name|streamoutcnt
condition|)
block|{
comment|/* no such stream */
continue|continue;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|strmout
index|[
name|temp
index|]
operator|.
name|next_sequence_sent
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_SEND
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
operator|(
name|void
operator|*
operator|)
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|sctp_find_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
modifier|*
name|bchk
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_stream_reset_out_req
modifier|*
name|req
decl_stmt|;
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|r
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|int
name|len
decl_stmt|,
name|clen
decl_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
condition|)
block|{
name|asoc
operator|->
name|stream_reset_outstanding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
operator|==
name|NULL
condition|)
block|{
name|asoc
operator|->
name|stream_reset_outstanding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chk
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|bchk
condition|)
block|{
comment|/* he wants a copy of the chk pointer */
operator|*
name|bchk
operator|=
name|chk
expr_stmt|;
block|}
name|clen
operator|=
name|chk
operator|->
name|send_size
expr_stmt|;
name|req
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_stream_reset_out_req
operator|*
argument_list|)
expr_stmt|;
name|r
operator|=
operator|&
name|req
operator|->
name|sr_req
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|r
operator|->
name|request_seq
argument_list|)
operator|==
name|seq
condition|)
block|{
comment|/* found it */
return|return
operator|(
name|r
operator|)
return|;
block|}
name|len
operator|=
name|SCTP_SIZE32
argument_list|(
name|ntohs
argument_list|(
name|r
operator|->
name|ph
operator|.
name|param_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|>
operator|(
name|len
operator|+
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
condition|)
block|{
comment|/* move to the next one, there can only be a max of two */
name|r
operator|=
operator|(
expr|struct
name|sctp_stream_reset_out_request
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|r
operator|+
name|len
operator|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
name|r
operator|->
name|request_seq
argument_list|)
operator|==
name|seq
condition|)
block|{
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
comment|/* that seq is not here */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_clean_up_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
init|=
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_25
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|asoc
operator|->
name|ctrl_queue_cnt
operator|--
expr_stmt|;
name|sctp_free_remote_addr
argument_list|(
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|str_reset
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_stream_reset_response
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|uint32_t
name|action
parameter_list|,
name|struct
name|sctp_stream_reset_response
modifier|*
name|respin
parameter_list|)
block|{
name|uint16_t
name|type
decl_stmt|;
name|int
name|lparm_len
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|srparam
decl_stmt|;
name|int
name|number_entries
decl_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
comment|/* duplicate */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|seq
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
condition|)
block|{
name|srparam
operator|=
name|sctp_find_stream_reset
argument_list|(
name|stcb
argument_list|,
name|seq
argument_list|,
operator|&
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|srparam
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
operator|++
expr_stmt|;
name|type
operator|=
name|ntohs
argument_list|(
name|srparam
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|lparm_len
operator|=
name|ntohs
argument_list|(
name|srparam
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_OUT_REQUEST
condition|)
block|{
name|number_entries
operator|=
operator|(
name|lparm_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_out_is_outstanding
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_PERFORMED
condition|)
block|{
comment|/* do it */
name|sctp_reset_out_streams
argument_list|(
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|srparam
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_FAILED_OUT
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|srparam
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_IN_REQUEST
condition|)
block|{
comment|/* Answered my request */
name|number_entries
operator|=
operator|(
name|lparm_len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_in_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
condition|)
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
if|if
condition|(
name|action
operator|!=
name|SCTP_STREAM_RESET_PERFORMED
condition|)
block|{
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_STR_RESET_FAILED_IN
argument_list|,
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|srparam
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_STR_RESET_TSN_REQUEST
condition|)
block|{
comment|/** 				 * a) Adopt the new in tsn. 				 * b) reset the map 				 * c) Adopt the new out-tsn 				 */
name|struct
name|sctp_stream_reset_response_tsn
modifier|*
name|resp
decl_stmt|;
name|struct
name|sctp_forward_tsn_chunk
name|fwdtsn
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|respin
operator|==
name|NULL
condition|)
block|{
comment|/* huh ? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|action
operator|==
name|SCTP_STREAM_RESET_PERFORMED
condition|)
block|{
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response_tsn
operator|*
operator|)
name|respin
expr_stmt|;
name|asoc
operator|->
name|stream_reset_outstanding
operator|--
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|fwdtsn
operator|.
name|new_cumulative_tsn
operator|=
name|htonl
argument_list|(
name|ntohl
argument_list|(
name|resp
operator|->
name|senders_next_tsn
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|sctp_handle_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|fwdtsn
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|=
operator|(
name|ntohl
argument_list|(
name|resp
operator|->
name|senders_next_tsn
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|senders_next_tsn
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|receivers_next_tsn
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
name|sctp_reset_out_streams
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get rid of the request and get the request flags */
if|if
condition|(
name|asoc
operator|->
name|stream_reset_outstanding
operator|==
literal|0
condition|)
block|{
name|sctp_clean_up_stream_reset
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_str_reset_request_in
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req
parameter_list|)
block|{
name|uint32_t
name|seq
decl_stmt|;
name|int
name|len
decl_stmt|,
name|i
decl_stmt|;
name|int
name|number_entries
decl_stmt|;
name|uint16_t
name|temp
decl_stmt|;
comment|/* 	 * peer wants me to send a str-reset to him for my outgoing seq's if 	 * seq_in is right. 	 */
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_out_is_outstanding
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|number_entries
operator|=
operator|(
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_in_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|number_entries
condition|;
name|i
operator|++
control|)
block|{
name|temp
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|list_of_streams
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|req
operator|->
name|list_of_streams
index|[
name|i
index|]
operator|=
name|temp
expr_stmt|;
block|}
comment|/* move the reset action back one */
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_PERFORMED
expr_stmt|;
name|sctp_add_stream_reset_out
argument_list|(
name|chk
argument_list|,
name|number_entries
argument_list|,
name|req
operator|->
name|list_of_streams
argument_list|,
name|asoc
operator|->
name|str_reset_seq_out
argument_list|,
name|seq
argument_list|,
operator|(
name|asoc
operator|->
name|sending_seq
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|stream_reset_out_is_outstanding
operator|=
literal|1
expr_stmt|;
name|asoc
operator|->
name|str_reset
operator|=
name|chk
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_STRRESET
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* Can't do it, since we have sent one out */
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_TRY_LATER
expr_stmt|;
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_str_reset_request_tsn
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_tsn_request
modifier|*
name|req
parameter_list|)
block|{
comment|/* reset all in and out and update the tsn */
comment|/* 	 * A) reset my str-seq's on in and out. B) Select a receive next, 	 * and set cum-ack to it. Also process this selected number as a 	 * fwd-tsn as well. C) set in the response my next sending seq. 	 */
name|struct
name|sctp_forward_tsn_chunk
name|fwdtsn
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
argument_list|)
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_FORWARD_CUM_TSN
expr_stmt|;
name|fwdtsn
operator|.
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|fwdtsn
operator|.
name|new_cumulative_tsn
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sctp_handle_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|&
name|fwdtsn
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|+=
name|SCTP_STREAM_RESET_TSN_DELTA
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
operator|+
literal|1
expr_stmt|;
name|memset
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array
argument_list|,
literal|0
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_size
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* save off historical data for retrans */
name|stcb
operator|->
name|asoc
operator|.
name|last_sending_seq
index|[
literal|1
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_sending_seq
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_sending_seq
index|[
literal|0
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_base_tsnsent
index|[
literal|1
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_base_tsnsent
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_base_tsnsent
index|[
literal|0
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
expr_stmt|;
name|sctp_add_stream_reset_result_tsn
argument_list|(
name|chk
argument_list|,
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
argument_list|,
name|SCTP_STREAM_RESET_PERFORMED
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|sending_seq
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|mapping_array_base_tsn
argument_list|)
expr_stmt|;
name|sctp_reset_out_streams
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|uint16_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_PERFORMED
expr_stmt|;
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_sending_seq
index|[
literal|0
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_base_tsnsent
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|==
name|seq
condition|)
block|{
name|sctp_add_stream_reset_result_tsn
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_sending_seq
index|[
literal|1
index|]
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_base_tsnsent
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_handle_str_reset_request_out
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
parameter_list|,
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req
parameter_list|)
block|{
name|uint32_t
name|seq
decl_stmt|,
name|tsn
decl_stmt|;
name|int
name|number_entries
decl_stmt|,
name|len
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
init|=
operator|&
name|stcb
operator|->
name|asoc
decl_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|request_seq
argument_list|)
expr_stmt|;
comment|/* now if its not a duplicate we process it */
if|if
condition|(
name|asoc
operator|->
name|str_reset_seq_in
operator|==
name|seq
condition|)
block|{
name|len
operator|=
name|ntohs
argument_list|(
name|req
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|number_entries
operator|=
operator|(
operator|(
name|len
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
comment|/* 		 * the sender is resetting, handle the list issue.. we must 		 * a) verify if we can do the reset, if so no problem b) If 		 * we can't do the reset we must copy the request. c) queue 		 * it, and setup the data in processor to trigger it off 		 * when needed and dequeue all the queued data. 		 */
name|tsn
operator|=
name|ntohl
argument_list|(
name|req
operator|->
name|send_reset_at_tsn
argument_list|)
expr_stmt|;
comment|/* move the reset action back one */
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
operator|=
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tsn
operator|==
name|asoc
operator|->
name|cumulative_tsn
operator|)
operator|||
operator|(
name|compare_with_wrap
argument_list|(
name|asoc
operator|->
name|cumulative_tsn
argument_list|,
name|tsn
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
condition|)
block|{
comment|/* we can do it now */
name|sctp_reset_in_stream
argument_list|(
name|stcb
argument_list|,
name|number_entries
argument_list|,
name|req
operator|->
name|list_of_streams
argument_list|)
expr_stmt|;
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_PERFORMED
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_PERFORMED
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * we must queue it up and thus wait for the TSN's 			 * to arrive that are at or before tsn 			 */
name|struct
name|sctp_stream_reset_list
modifier|*
name|liste
decl_stmt|;
name|int
name|siz
decl_stmt|;
name|siz
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_list
argument_list|)
operator|+
operator|(
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|liste
argument_list|,
expr|struct
name|sctp_stream_reset_list
operator|*
argument_list|,
name|siz
argument_list|,
literal|"StrRstList"
argument_list|)
expr_stmt|;
if|if
condition|(
name|liste
operator|==
name|NULL
condition|)
block|{
comment|/* gak out of memory */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_DENIED
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_DENIED
expr_stmt|;
return|return;
block|}
name|liste
operator|->
name|tsn
operator|=
name|tsn
expr_stmt|;
name|liste
operator|->
name|number_entries
operator|=
name|number_entries
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|liste
operator|->
name|req
argument_list|,
name|req
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_out_request
argument_list|)
operator|+
operator|(
name|number_entries
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|)
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|asoc
operator|->
name|resetHead
argument_list|,
name|liste
argument_list|,
name|next_resp
argument_list|)
expr_stmt|;
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_PERFORMED
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
operator|=
name|SCTP_STREAM_RESET_PERFORMED
expr_stmt|;
block|}
name|asoc
operator|->
name|str_reset_seq_in
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|1
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * one seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|asoc
operator|->
name|str_reset_seq_in
operator|-
literal|2
operator|)
operator|==
name|seq
condition|)
block|{
comment|/* 		 * two seq back, just echo back last action since my 		 * response was lost. 		 */
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|asoc
operator|->
name|last_reset_action
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_add_stream_reset_result
argument_list|(
name|chk
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_BAD_SEQNO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_handle_stream_reset
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_stream_reset_out_req
modifier|*
name|sr_req
parameter_list|)
block|{
name|int
name|chk_length
decl_stmt|,
name|param_len
decl_stmt|,
name|ptype
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|int
name|num_req
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|int
name|ret_code
init|=
literal|0
decl_stmt|;
name|int
name|num_param
init|=
literal|0
decl_stmt|;
comment|/* now it may be a reset or a reset-response */
name|chk_length
operator|=
name|ntohs
argument_list|(
name|sr_req
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* setup for adding the response */
name|sctp_alloc_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|id
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|chunk_id
operator|.
name|can_take_data
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|chk
operator|->
name|no_fr_allowed
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|book_size
operator|=
name|chk
operator|->
name|send_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|chk
operator|->
name|book_size_scale
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|strres_nochunk
label|:
if|if
condition|(
name|chk
operator|->
name|data
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|chk
operator|->
name|data
argument_list|)
expr_stmt|;
name|chk
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
name|sctp_free_a_chunk
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
name|SCTP_BUF_RESV_UF
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|SCTP_MIN_OVERHEAD
argument_list|)
expr_stmt|;
comment|/* setup chunk parameters */
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_UNSENT
expr_stmt|;
name|chk
operator|->
name|snd_count
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|whoTo
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|chk
operator|->
name|whoTo
operator|->
name|ref_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ch
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_chunkhdr
operator|*
argument_list|)
expr_stmt|;
name|ch
operator|->
name|chunk_type
operator|=
name|SCTP_STREAM_RESET
expr_stmt|;
name|ch
operator|->
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ch
operator|->
name|chunk_length
operator|=
name|htons
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|chk
operator|->
name|data
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|chk
operator|->
name|send_size
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|&
name|sr_req
operator|->
name|sr_req
expr_stmt|;
while|while
condition|(
operator|(
name|size_t
operator|)
name|chk_length
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_tsn_request
argument_list|)
condition|)
block|{
name|param_len
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|param_len
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_tsn_request
argument_list|)
condition|)
block|{
comment|/* bad param */
break|break;
block|}
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|num_param
operator|++
expr_stmt|;
if|if
condition|(
name|num_param
operator|>
name|SCTP_MAX_RESET_PARAMS
condition|)
block|{
comment|/* hit the max of parameters already sorry.. */
break|break;
block|}
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_OUT_REQUEST
condition|)
block|{
name|struct
name|sctp_stream_reset_out_request
modifier|*
name|req_out
decl_stmt|;
name|req_out
operator|=
operator|(
expr|struct
name|sctp_stream_reset_out_request
operator|*
operator|)
name|ph
expr_stmt|;
name|num_req
operator|++
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|stream_reset_outstanding
condition|)
block|{
name|seq
operator|=
name|ntohl
argument_list|(
name|req_out
operator|->
name|response_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|seq
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|str_reset_seq_out
condition|)
block|{
comment|/* implicit ack */
name|sctp_handle_stream_reset_response
argument_list|(
name|stcb
argument_list|,
name|seq
argument_list|,
name|SCTP_STREAM_RESET_PERFORMED
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|sctp_handle_str_reset_request_out
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|req_out
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_IN_REQUEST
condition|)
block|{
name|struct
name|sctp_stream_reset_in_request
modifier|*
name|req_in
decl_stmt|;
name|num_req
operator|++
expr_stmt|;
name|req_in
operator|=
operator|(
expr|struct
name|sctp_stream_reset_in_request
operator|*
operator|)
name|ph
expr_stmt|;
name|sctp_handle_str_reset_request_in
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|req_in
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_TSN_REQUEST
condition|)
block|{
name|struct
name|sctp_stream_reset_tsn_request
modifier|*
name|req_tsn
decl_stmt|;
name|num_req
operator|++
expr_stmt|;
name|req_tsn
operator|=
operator|(
expr|struct
name|sctp_stream_reset_tsn_request
operator|*
operator|)
name|ph
expr_stmt|;
if|if
condition|(
name|sctp_handle_str_reset_request_tsn
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|,
name|req_tsn
argument_list|)
condition|)
block|{
name|ret_code
operator|=
literal|1
expr_stmt|;
goto|goto
name|strres_nochunk
goto|;
block|}
comment|/* no more */
break|break;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_STR_RESET_RESPONSE
condition|)
block|{
name|struct
name|sctp_stream_reset_response
modifier|*
name|resp
decl_stmt|;
name|uint32_t
name|result
decl_stmt|;
name|resp
operator|=
operator|(
expr|struct
name|sctp_stream_reset_response
operator|*
operator|)
name|ph
expr_stmt|;
name|seq
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|response_seq
argument_list|)
expr_stmt|;
name|result
operator|=
name|ntohl
argument_list|(
name|resp
operator|->
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_handle_stream_reset_response
argument_list|(
name|stcb
argument_list|,
name|seq
argument_list|,
name|result
argument_list|,
name|resp
argument_list|)
condition|)
block|{
name|ret_code
operator|=
literal|1
expr_stmt|;
goto|goto
name|strres_nochunk
goto|;
block|}
block|}
else|else
block|{
break|break;
block|}
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ph
operator|+
name|SCTP_SIZE32
argument_list|(
name|param_len
argument_list|)
operator|)
expr_stmt|;
name|chk_length
operator|-=
name|SCTP_SIZE32
argument_list|(
name|param_len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_req
operator|==
literal|0
condition|)
block|{
comment|/* we have no response free the stuff */
goto|goto
name|strres_nochunk
goto|;
block|}
comment|/* ok we have a chunk to link in */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|,
name|chk
argument_list|,
name|sctp_next
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|ctrl_queue_cnt
operator|++
expr_stmt|;
return|return
operator|(
name|ret_code
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a router or endpoints report of a packet loss, there are two ways  * to handle this, either we get the whole packet and must disect it  * ourselves (possibly with truncation and or corruption) or it is a summary  * from a middle box that did the disectting for us.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_handle_packet_dropped
parameter_list|(
name|struct
name|sctp_pktdrop_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|bottle_bw
decl_stmt|,
name|on_queue
decl_stmt|;
name|uint16_t
name|trunc_len
decl_stmt|;
name|unsigned
name|int
name|chlen
decl_stmt|;
name|unsigned
name|int
name|at
decl_stmt|;
name|struct
name|sctp_chunk_desc
name|desc
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|chlen
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
name|chlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
expr_stmt|;
comment|/* XXX possible chlen underflow */
if|if
condition|(
name|chlen
operator|==
literal|0
condition|)
block|{
name|ch
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpbwrpt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
name|cp
operator|->
name|data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
name|chlen
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
expr_stmt|;
comment|/* XXX possible chlen underflow */
name|memset
argument_list|(
operator|&
name|desc
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|trunc_len
operator|=
operator|(
name|uint16_t
operator|)
name|ntohs
argument_list|(
name|cp
operator|->
name|trunc_len
argument_list|)
expr_stmt|;
comment|/* now the chunks themselves */
while|while
condition|(
operator|(
name|ch
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|chlen
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
operator|)
condition|)
block|{
name|desc
operator|.
name|chunk_type
operator|=
name|ch
operator|->
name|chunk_type
expr_stmt|;
comment|/* get amount we need to move */
name|at
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
comment|/* corrupt chunk, maybe at the end? */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpcrupt
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trunc_len
operator|==
literal|0
condition|)
block|{
comment|/* we are supposed to have all of it */
if|if
condition|(
name|at
operator|>
name|chlen
condition|)
block|{
comment|/* corrupt skip it */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpcrupt
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* is there enough of it left ? */
if|if
condition|(
name|desc
operator|.
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
if|if
condition|(
name|chlen
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|data_bytes
argument_list|)
operator|)
condition|)
block|{
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|chlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
name|desc
operator|.
name|chunk_type
operator|==
name|SCTP_DATA
condition|)
block|{
comment|/* can we get out the tsn? */
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpmbda
argument_list|)
expr_stmt|;
if|if
condition|(
name|chlen
operator|>=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_data_chunk
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|)
condition|)
block|{
comment|/* yep */
name|struct
name|sctp_data_chunk
modifier|*
name|dcp
decl_stmt|;
name|uint8_t
modifier|*
name|ddp
decl_stmt|;
name|unsigned
name|int
name|iii
decl_stmt|;
name|dcp
operator|=
operator|(
expr|struct
name|sctp_data_chunk
operator|*
operator|)
name|ch
expr_stmt|;
name|ddp
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|dcp
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|iii
operator|=
literal|0
init|;
name|iii
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|data_bytes
argument_list|)
condition|;
name|iii
operator|++
control|)
block|{
name|desc
operator|.
name|data_bytes
index|[
name|iii
index|]
operator|=
name|ddp
index|[
name|iii
index|]
expr_stmt|;
block|}
name|desc
operator|.
name|tsn_ifany
operator|=
name|dcp
operator|->
name|dp
operator|.
name|tsn
expr_stmt|;
block|}
else|else
block|{
comment|/* nope we are done. */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpnedat
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
condition|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpmbct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|process_chunk_drop
argument_list|(
name|stcb
argument_list|,
operator|&
name|desc
argument_list|,
name|net
argument_list|,
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
argument_list|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrppdbrk
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|at
argument_list|)
operator|>
name|chlen
condition|)
block|{
break|break;
block|}
name|chlen
operator|-=
name|SCTP_SIZE32
argument_list|(
name|at
argument_list|)
expr_stmt|;
if|if
condition|(
name|chlen
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
condition|)
block|{
comment|/* done, none left */
break|break;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ch
operator|+
name|SCTP_SIZE32
argument_list|(
name|at
argument_list|)
operator|)
expr_stmt|;
block|}
comment|/* Now update any rwnd --- possibly */
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* From a peer, we get a rwnd report */
name|uint32_t
name|a_rwnd
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpfehos
argument_list|)
expr_stmt|;
name|bottle_bw
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|bottle_bw
argument_list|)
expr_stmt|;
name|on_queue
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|current_onq
argument_list|)
expr_stmt|;
if|if
condition|(
name|bottle_bw
operator|&&
name|on_queue
condition|)
block|{
comment|/* a rwnd report is in here */
if|if
condition|(
name|bottle_bw
operator|>
name|on_queue
condition|)
name|a_rwnd
operator|=
name|bottle_bw
operator|-
name|on_queue
expr_stmt|;
else|else
name|a_rwnd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|a_rwnd
operator|==
literal|0
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|a_rwnd
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
name|a_rwnd
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
expr_stmt|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|<
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_ep
operator|.
name|sctp_sws_sender
condition|)
block|{
comment|/* SWS sender side engages */
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_pdrpfmbox
argument_list|)
expr_stmt|;
block|}
comment|/* now middle boxes in sat networks get a cwnd bump */
if|if
condition|(
operator|(
name|cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|&
name|SCTP_FROM_MIDDLE_BOX
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sat_t3_loss_recovery
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sat_network
operator|)
condition|)
block|{
comment|/* 		 * This is debateable but for sat networks it makes sense 		 * Note if a T3 timer has went off, we will prohibit any 		 * changes to cwnd until we exit the t3 loss recovery. 		 */
name|uint32_t
name|bw_avail
decl_stmt|;
name|int
name|rtt
decl_stmt|,
name|incr
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
name|int
name|old_cwnd
init|=
name|net
operator|->
name|cwnd
decl_stmt|;
endif|#
directive|endif
comment|/* need real RTT for this calc */
name|rtt
operator|=
operator|(
operator|(
name|net
operator|->
name|lastsa
operator|>>
literal|2
operator|)
operator|+
name|net
operator|->
name|lastsv
operator|)
operator|>>
literal|1
expr_stmt|;
comment|/* get bottle neck bw */
name|bottle_bw
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|bottle_bw
argument_list|)
expr_stmt|;
comment|/* and whats on queue */
name|on_queue
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|current_onq
argument_list|)
expr_stmt|;
comment|/* 		 * adjust the on-queue if our flight is more it could be 		 * that the router has not yet gotten data "in-flight" to it 		 */
if|if
condition|(
name|on_queue
operator|<
name|net
operator|->
name|flight_size
condition|)
name|on_queue
operator|=
name|net
operator|->
name|flight_size
expr_stmt|;
comment|/* calculate the available space */
name|bw_avail
operator|=
operator|(
name|bottle_bw
operator|*
name|rtt
operator|)
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|bw_avail
operator|>
name|bottle_bw
condition|)
block|{
comment|/* 			 * Cap the growth to no more than the bottle neck. 			 * This can happen as RTT slides up due to queues. 			 * It also means if you have more than a 1 second 			 * RTT with a empty queue you will be limited to the 			 * bottle_bw per second no matter if other points 			 * have 1/2 the RTT and you could get more out... 			 */
name|bw_avail
operator|=
name|bottle_bw
expr_stmt|;
block|}
if|if
condition|(
name|on_queue
operator|>
name|bw_avail
condition|)
block|{
comment|/* 			 * No room for anything else don't allow anything 			 * else to be "added to the fire". 			 */
name|int
name|seg_inflight
decl_stmt|,
name|seg_onqueue
decl_stmt|,
name|my_portion
decl_stmt|;
name|net
operator|->
name|partial_bytes_acked
operator|=
literal|0
expr_stmt|;
comment|/* how much are we over queue size? */
name|incr
operator|=
name|on_queue
operator|-
name|bw_avail
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
condition|)
block|{
comment|/* 				 * undo any cwnd adjustment that the sack 				 * might have made 				 */
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|prev_cwnd
expr_stmt|;
block|}
comment|/* Now how much of that is mine? */
name|seg_inflight
operator|=
name|net
operator|->
name|flight_size
operator|/
name|net
operator|->
name|mtu
expr_stmt|;
name|seg_onqueue
operator|=
name|on_queue
operator|/
name|net
operator|->
name|mtu
expr_stmt|;
name|my_portion
operator|=
operator|(
name|incr
operator|*
name|seg_inflight
operator|)
operator|/
name|seg_onqueue
expr_stmt|;
comment|/* Have I made an adjustment already */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|net
operator|->
name|flight_size
condition|)
block|{
comment|/* 				 * for this flight I made an adjustment we 				 * need to decrease the portion by a share 				 * our previous adjustment. 				 */
name|int
name|diff_adj
decl_stmt|;
name|diff_adj
operator|=
name|net
operator|->
name|cwnd
operator|-
name|net
operator|->
name|flight_size
expr_stmt|;
if|if
condition|(
name|diff_adj
operator|>
name|my_portion
condition|)
name|my_portion
operator|=
literal|0
expr_stmt|;
else|else
name|my_portion
operator|-=
name|diff_adj
expr_stmt|;
block|}
comment|/* 			 * back down to the previous cwnd (assume we have 			 * had a sack before this packet). minus what ever 			 * portion of the overage is my fault. 			 */
name|net
operator|->
name|cwnd
operator|-=
name|my_portion
expr_stmt|;
comment|/* we will NOT back down more than 1 MTU */
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<=
name|net
operator|->
name|mtu
condition|)
block|{
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
comment|/* force into CA */
name|net
operator|->
name|ssthresh
operator|=
name|net
operator|->
name|cwnd
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Take 1/4 of the space left or max burst up .. 			 * whichever is less. 			 */
name|incr
operator|=
name|min
argument_list|(
operator|(
name|bw_avail
operator|-
name|on_queue
operator|)
operator|>>
literal|2
argument_list|,
operator|(
name|int
operator|)
name|stcb
operator|->
name|asoc
operator|.
name|max_burst
operator|*
operator|(
name|int
operator|)
name|net
operator|->
name|mtu
argument_list|)
expr_stmt|;
name|net
operator|->
name|cwnd
operator|+=
name|incr
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|cwnd
operator|>
name|bw_avail
condition|)
block|{
comment|/* We can't exceed the pipe size */
name|net
operator|->
name|cwnd
operator|=
name|bw_avail
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|cwnd
operator|<
name|net
operator|->
name|mtu
condition|)
block|{
comment|/* We always have 1 MTU */
name|net
operator|->
name|cwnd
operator|=
name|net
operator|->
name|mtu
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_CWND_MONITOR
if|if
condition|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|!=
literal|0
condition|)
block|{
comment|/* log only changes */
name|sctp_log_cwnd
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
operator|(
name|net
operator|->
name|cwnd
operator|-
name|old_cwnd
operator|)
argument_list|,
name|SCTP_CWND_LOG_FROM_SAT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * handles all control chunks in a packet inputs: - m: mbuf chain, assumed to  * still contain IP/SCTP header - stcb: is the tcb found for this packet -  * offset: offset into the mbuf chain to first chunkhdr - length: is the  * length of the complete packet outputs: - length: modified to remaining  * length after control processing - netp: modified to new sctp_nets after  * cookie-echo processing - return NULL to discard the packet (ie. no asoc,  * bad packet,...) otherwise return the tcb for this packet  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_tcb
modifier|*
name|sctp_process_control
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
modifier|*
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
modifier|*
name|netp
parameter_list|,
name|int
modifier|*
name|fwd_tsn_seen
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|vtag_in
decl_stmt|;
name|int
name|num_chunks
init|=
literal|0
decl_stmt|;
comment|/* number of control chunks processed */
name|int
name|chk_length
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|abort_no_unlock
init|=
literal|0
decl_stmt|;
comment|/* 	 * How big should this be, and should it be alloc'd? Lets try the 	 * d-mtu-ceiling for now (2k) and that should hopefully work ... 	 * until we get into jumbo grams and such.. 	 */
name|uint8_t
name|chunk_buf
index|[
name|SCTP_CHUNK_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|locked_tcb
init|=
name|stcb
decl_stmt|;
name|int
name|got_auth
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auth_offset
init|=
literal|0
decl_stmt|,
name|auth_len
init|=
literal|0
decl_stmt|;
name|int
name|auth_skipped
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_process_control: iphlen=%u, offset=%u, length=%u stcb:%p\n"
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|length
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* validate chunk header length... */
if|if
condition|(
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * validate the verification tag 	 */
name|vtag_in
operator|=
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
condition|)
block|{
if|if
condition|(
name|vtag_in
operator|!=
literal|0
condition|)
block|{
comment|/* protocol error- silently discard... */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_COOKIE_ECHO
condition|)
block|{
comment|/* 		 * If there is no stcb, skip the AUTH chunk and process 		 * later after a stcb is found (to validate the lookup was 		 * valid. 		 */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_AUTHENTICATION
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|&&
operator|!
name|sctp_auth_disable
condition|)
block|{
comment|/* save this chunk for later processing */
name|auth_skipped
operator|=
literal|1
expr_stmt|;
name|auth_offset
operator|=
operator|*
name|offset
expr_stmt|;
name|auth_len
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* (temporarily) move past this chunk */
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|auth_len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|>=
name|length
condition|)
block|{
comment|/* no more data left in the mbuf chain */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
goto|goto
name|process_control_chunks
goto|;
block|}
comment|/* 		 * first check if it's an ASCONF with an unknown src addr we 		 * need to look inside to find the association 		 */
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ASCONF
operator|&&
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* inp's refcount may be reduced */
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_asconf
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|sh
argument_list|,
operator|&
name|inp
argument_list|,
name|netp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * reduce inp's refcount if not reduced in 				 * sctp_findassociation_ep_asconf(). 				 */
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
comment|/* now go back and verify any auth chunk to be sure */
if|if
condition|(
name|auth_skipped
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|sctp_auth_chunk
modifier|*
name|auth
decl_stmt|;
name|auth
operator|=
operator|(
expr|struct
name|sctp_auth_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
name|got_auth
operator|=
literal|1
expr_stmt|;
name|auth_skipped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sctp_handle_auth
argument_list|(
name|stcb
argument_list|,
name|auth
argument_list|,
name|m
argument_list|,
name|auth_offset
argument_list|)
condition|)
block|{
comment|/* auth HMAC failed so dump it */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
comment|/* remaining chunks are HMAC checked */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* no association, so it's out of the blue... */
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
comment|/* ABORT and SHUTDOWN can use either v_tag... */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ABORT_ASSOCIATION
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_PACKET_DROPPED
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|vtag_in
operator|==
name|asoc
operator|->
name|my_vtag
operator|)
operator|||
operator|(
operator|(
name|ch
operator|->
name|chunk_flags
operator|&
name|SCTP_HAD_NO_TCB
operator|)
operator|&&
operator|(
name|vtag_in
operator|==
name|asoc
operator|->
name|peer_vtag
operator|)
operator|)
condition|)
block|{
comment|/* this is valid */
block|}
else|else
block|{
comment|/* drop this packet... */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_ACK
condition|)
block|{
if|if
condition|(
name|vtag_in
operator|!=
name|asoc
operator|->
name|my_vtag
condition|)
block|{
comment|/* 				 * this could be a stale SHUTDOWN-ACK or the 				 * peer never got the SHUTDOWN-COMPLETE and 				 * is still hung; we have started a new asoc 				 * but it won't complete until the shutdown 				 * is completed 				 */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* for all other chunks, vtag must match */
if|if
condition|(
name|vtag_in
operator|!=
name|asoc
operator|->
name|my_vtag
condition|)
block|{
comment|/* invalid vtag... */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"invalid vtag: %xh, expect %xh\n"
argument_list|,
name|vtag_in
argument_list|,
name|asoc
operator|->
name|my_vtag
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
comment|/* end if !SCTP_COOKIE_ECHO */
comment|/* 	 * process all control chunks... 	 */
if|if
condition|(
operator|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SELECTIVE_ACK
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_HEARTBEAT_REQUEST
operator|)
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_COOKIE_ECHOED
operator|)
condition|)
block|{
comment|/* implied cookie-ack.. we must have lost the ack */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_cookie_ack
argument_list|(
operator|(
expr|struct
name|sctp_cookie_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
block|}
name|process_control_chunks
label|:
while|while
condition|(
name|IS_SCTP_CONTROL
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* validate chunk length */
name|chk_length
operator|=
name|ntohs
argument_list|(
name|ch
operator|->
name|chunk_length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT2
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_process_control: processing a chunk type=%u, len=%u\n"
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|,
name|chk_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
operator|(
name|size_t
operator|)
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
operator|||
operator|(
operator|*
name|offset
operator|+
name|chk_length
operator|)
operator|>
name|length
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_incontrolchunks
argument_list|)
expr_stmt|;
comment|/* 		 * INIT-ACK only gets the init ack "header" portion only 		 * because we don't have to process the peer's COOKIE. All 		 * others get a complete chunk. 		 */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION_ACK
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
operator|)
condition|)
block|{
comment|/* get an init-ack chunk */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_init_ack_chunk
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_COOKIE_ECHO
condition|)
block|{
if|if
condition|(
name|chk_length
operator|>
sizeof|sizeof
argument_list|(
name|chunk_buf
argument_list|)
condition|)
block|{
comment|/* 				 * use just the size of the chunk buffer so 				 * the front part of our cookie is intact. 				 * The rest of cookie processing should use 				 * the sctp_m_getptr() function to access 				 * the other parts. 				 */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|chunk_buf
argument_list|)
operator|-
literal|4
operator|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* We can fit it all */
goto|goto
name|all_fits
goto|;
block|}
block|}
else|else
block|{
comment|/* get a complete chunk... */
if|if
condition|(
operator|(
name|size_t
operator|)
name|chk_length
operator|>
sizeof|sizeof
argument_list|(
name|chunk_buf
argument_list|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|;
name|oper
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
comment|/* pre-reserve some space */
name|SCTP_BUF_RESV_UF
argument_list|(
name|oper
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|oper
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|all_fits
label|:
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"sctp_process_control: Can't get the all data....\n"
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|num_chunks
operator|++
expr_stmt|;
comment|/* Save off the last place we got a control from */
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|netp
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_ASCONF
operator|)
condition|)
block|{
comment|/* 				 * allow last_control to be NULL if 				 * ASCONF... ASCONF processing will find the 				 * right net later 				 */
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|=
operator|*
name|netp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xB0
argument_list|,
name|ch
operator|->
name|chunk_type
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* check to see if this chunk required auth, but isn't */
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|sctp_auth_disable
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|ch
operator|->
name|chunk_type
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
condition|)
block|{
comment|/* "silently" ignore */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthmissing
argument_list|)
expr_stmt|;
goto|goto
name|next_chunk
goto|;
block|}
switch|switch
condition|(
name|ch
operator|->
name|chunk_type
condition|)
block|{
case|case
name|SCTP_INITIATION
case|:
comment|/* must be first and only chunk */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_INIT\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore? */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
comment|/* 					 * collision case where we are 					 * sending to them too 					 */
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|num_chunks
operator|>
literal|1
operator|)
operator|||
operator|(
name|sctp_strict_init
operator|&&
operator|(
name|length
operator|-
operator|*
name|offset
operator|>
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|)
operator|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
name|sctp_send_shutdown_ack
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CONTROL_PROC
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sctp_handle_init
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|ch
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_no_unlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_no_unlock
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_INITIATION_ACK
case|:
comment|/* must be first and only chunk */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_INIT-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_26
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|num_chunks
operator|>
literal|1
operator|)
operator|||
operator|(
name|sctp_strict_init
operator|&&
operator|(
name|length
operator|-
operator|*
name|offset
operator|>
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|)
operator|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ret
operator|=
name|sctp_handle_init_ack
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sctp_init_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_no_unlock
argument_list|)
expr_stmt|;
comment|/* 			 * Special case, I must call the output routine to 			 * get the cookie echoed 			 */
if|if
condition|(
name|abort_no_unlock
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
name|ret
operator|==
literal|0
condition|)
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CONTROL_PROC
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_SELECTIVE_ACK
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_SACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvsacks
argument_list|)
expr_stmt|;
block|{
name|struct
name|sctp_sack_chunk
modifier|*
name|sack
decl_stmt|;
name|int
name|abort_now
init|=
literal|0
decl_stmt|;
name|uint32_t
name|a_rwnd
decl_stmt|,
name|cum_ack
decl_stmt|;
name|uint16_t
name|num_seg
decl_stmt|;
name|int
name|nonce_sum_flag
decl_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_sack_chunk
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INDATA1
condition|)
block|{
name|printf
argument_list|(
literal|"Bad size on sack chunk .. to small\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sack
operator|=
operator|(
expr|struct
name|sctp_sack_chunk
operator|*
operator|)
name|ch
expr_stmt|;
name|nonce_sum_flag
operator|=
name|ch
operator|->
name|chunk_flags
operator|&
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
name|cum_ack
operator|=
name|ntohl
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|cum_tsn_ack
argument_list|)
expr_stmt|;
name|num_seg
operator|=
name|ntohs
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|num_gap_ack_blks
argument_list|)
expr_stmt|;
name|a_rwnd
operator|=
operator|(
name|uint32_t
operator|)
name|ntohl
argument_list|(
name|sack
operator|->
name|sack
operator|.
name|a_rwnd
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|pr_sctp_cnt
operator|==
literal|0
operator|)
operator|&&
operator|(
name|num_seg
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|compare_with_wrap
argument_list|(
name|cum_ack
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
argument_list|,
name|MAX_TSN
argument_list|)
operator|)
operator|||
operator|(
name|cum_ack
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|last_acked_seq
operator|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|saw_sack_with_frags
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
operator|)
condition|)
block|{
comment|/* 					 * We have a SIMPLE sack having no 					 * prior segments and data on sent 					 * queue to be acked.. Use the 					 * faster path sack processing. We 					 * also allow window update sacks 					 * with no missing segments to go 					 * this way too. 					 */
name|sctp_express_handle_sack
argument_list|(
name|stcb
argument_list|,
name|cum_ack
argument_list|,
name|a_rwnd
argument_list|,
name|nonce_sum_flag
argument_list|,
operator|&
name|abort_now
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_handle_sack
argument_list|(
name|sack
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_now
argument_list|,
name|chk_length
argument_list|,
name|a_rwnd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|abort_now
condition|)
block|{
comment|/* ABORT signal from sack processing */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|SCTP_HEARTBEAT_REQUEST
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_HEARTBEAT\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvheartbeat
argument_list|)
expr_stmt|;
name|sctp_send_heartbeat_ack
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
comment|/* He's alive so give him credit */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_HEARTBEAT_ACK
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_HEARTBEAT-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_heartbeat_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* He's alive so give him credit */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvheartbeatack
argument_list|)
expr_stmt|;
name|sctp_handle_heartbeat_ack
argument_list|(
operator|(
expr|struct
name|sctp_heartbeat_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ABORT_ASSOCIATION
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_ABORT\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_handle_abort
argument_list|(
operator|(
expr|struct
name|sctp_abort_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_SHUTDOWN
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_SHUTDOWN\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_shutdown_chunk
argument_list|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|{
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
name|sctp_handle_shutdown
argument_list|(
operator|(
expr|struct
name|sctp_shutdown_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
break|break;
case|case
name|SCTP_SHUTDOWN_ACK
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_SHUTDOWN-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_handle_shutdown_ack
argument_list|(
operator|(
expr|struct
name|sctp_shutdown_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_OPERATION_ERROR
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_OP-ERR\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|sctp_handle_error
argument_list|(
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_COOKIE_ECHO
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_COOKIE-ECHO stcb is %p\n"
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* We are not interested anymore */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* 			 * First are we accepting? We do this again here 			 * since it is possible that a previous endpoint WAS 			 * listening responded to a INIT-ACK and then 			 * closed. We opened and bound.. and are now no 			 * longer listening. 			 */
if|if
condition|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_IN_TCPPOOL
operator|)
condition|)
block|{
comment|/* 					 * special case, is this a retran'd 					 * COOKIE-ECHO or a restarting assoc 					 * that is a peeled off or 					 * one-to-one style socket. 					 */
goto|goto
name|process_cookie_anyway
goto|;
block|}
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
condition|)
block|{
comment|/* we are accepting so check limits like TCP */
if|if
condition|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlen
operator|>
name|inp
operator|->
name|sctp_socket
operator|->
name|so_qlimit
condition|)
block|{
comment|/* no space */
name|struct
name|mbuf
modifier|*
name|oper
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phdr
decl_stmt|;
if|if
condition|(
name|sctp_abort_if_one_2_one_hits_limit
condition|)
block|{
name|oper
operator|=
name|NULL
expr_stmt|;
name|oper
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|oper
condition|)
block|{
name|SCTP_BUF_LEN
argument_list|(
name|oper
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|phdr
operator|=
name|mtod
argument_list|(
name|oper
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_OUT_OF_RESC
argument_list|)
expr_stmt|;
name|phdr
operator|->
name|param_length
operator|=
name|htons
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sctp_abort_association
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
name|oper
argument_list|)
expr_stmt|;
block|}
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|process_cookie_anyway
label|:
block|{
name|struct
name|mbuf
modifier|*
name|ret_buf
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|linp
decl_stmt|;
if|if
condition|(
name|stcb
condition|)
name|linp
operator|=
name|NULL
expr_stmt|;
else|else
name|linp
operator|=
name|inp
expr_stmt|;
if|if
condition|(
name|linp
condition|)
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|linp
argument_list|)
expr_stmt|;
name|ret_buf
operator|=
name|sctp_handle_cookie_echo
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|*
name|offset
argument_list|,
name|sh
argument_list|,
operator|(
expr|struct
name|sctp_cookie_echo_chunk
operator|*
operator|)
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|stcb
argument_list|,
name|netp
argument_list|,
name|auth_skipped
argument_list|,
name|auth_offset
argument_list|,
name|auth_len
argument_list|,
operator|&
name|locked_tcb
argument_list|)
expr_stmt|;
if|if
condition|(
name|linp
condition|)
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|linp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret_buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked_tcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"GAK, null buffer\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|auth_skipped
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* if AUTH skipped, see if it verified... */
if|if
condition|(
name|auth_skipped
condition|)
block|{
name|got_auth
operator|=
literal|1
expr_stmt|;
name|auth_skipped
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
condition|)
block|{
comment|/* 					 * Restart the timer if we have 					 * pending data 					 */
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|SCTP_COOKIE_ACK
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_COOKIE-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
if|if
condition|(
operator|(
name|stcb
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_27
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* He's alive so give him credit */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_cookie_ack
argument_list|(
operator|(
expr|struct
name|sctp_cookie_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ECN_ECHO
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_ECN-ECHO\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* He's alive so give him credit */
if|if
condition|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ecne_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_ecn_echo
argument_list|(
operator|(
expr|struct
name|sctp_ecne_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ECN_CWR
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_ECN-CWR\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* He's alive so give him credit */
if|if
condition|(
name|chk_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_cwr_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_ecn_cwr
argument_list|(
operator|(
expr|struct
name|sctp_cwr_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SHUTDOWN_COMPLETE
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_SHUTDOWN-COMPLETE\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* must be first and only chunk */
if|if
condition|(
operator|(
name|num_chunks
operator|>
literal|1
operator|)
operator|||
operator|(
name|length
operator|-
operator|*
name|offset
operator|>
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
operator|)
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sctp_handle_shutdown_complete
argument_list|(
operator|(
expr|struct
name|sctp_shutdown_complete_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
case|case
name|SCTP_ASCONF
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_ASCONF\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* He's alive so give him credit */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_asconf
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_asconf_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ASCONF_ACK
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_ASCONF-ACK\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* He's alive so give him credit */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_asconf_ack
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
operator|(
expr|struct
name|sctp_asconf_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_FORWARD_CUM_TSN
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_FWD-TSN\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_forward_tsn_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* He's alive so give him credit */
block|{
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
operator|*
name|fwd_tsn_seen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_28
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sctp_handle_forward_tsn
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sctp_forward_tsn_chunk
operator|*
operator|)
name|ch
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
block|{
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SCTP_STREAM_RESET
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_STREAM_RESET\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_stream_reset_tsn_req
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
condition|)
block|{
comment|/* We are not interested anymore */
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_INPUT
operator|+
name|SCTP_LOC_29
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|==
literal|0
condition|)
block|{
comment|/* 				 * hmm, peer should have announced this, but 				 * we will turn it on since he is sending us 				 * a stream reset. 				 */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_strreset
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sctp_handle_stream_reset
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sctp_stream_reset_out_req
operator|*
operator|)
name|ch
argument_list|)
condition|)
block|{
comment|/* stop processing */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|SCTP_PACKET_DROPPED
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_PACKET_DROPPED\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* re-get it all please */
if|if
condition|(
name|chk_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_pktdrop_chunk
argument_list|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
name|sctp_handle_packet_dropped
argument_list|(
operator|(
expr|struct
name|sctp_pktdrop_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
operator|*
name|netp
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_AUTHENTICATION
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"SCTP_AUTHENTICATION\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|sctp_auth_disable
condition|)
goto|goto
name|unknown_chunk
goto|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* save the first AUTH for later processing */
if|if
condition|(
name|auth_skipped
operator|==
literal|0
condition|)
block|{
name|auth_offset
operator|=
operator|*
name|offset
expr_stmt|;
name|auth_len
operator|=
name|chk_length
expr_stmt|;
name|auth_skipped
operator|=
literal|1
expr_stmt|;
block|}
comment|/* skip this chunk (temporarily) */
goto|goto
name|next_chunk
goto|;
block|}
if|if
condition|(
operator|(
name|chk_length
operator|<
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|chk_length
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_auth_chunk
argument_list|)
operator|+
name|SCTP_AUTH_DIGEST_LEN_MAX
operator|)
operator|)
condition|)
block|{
comment|/* Its not ours */
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|got_auth
operator|==
literal|1
condition|)
block|{
comment|/* skip this chunk... it's already auth'd */
goto|goto
name|next_chunk
goto|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|chk_length
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
name|got_auth
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|sctp_handle_auth
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sctp_auth_chunk
operator|*
operator|)
name|ch
argument_list|,
name|m
argument_list|,
operator|*
name|offset
argument_list|)
condition|)
block|{
comment|/* auth HMAC failed so dump the packet */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
else|else
block|{
comment|/* remaining chunks are HMAC checked */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|1
expr_stmt|;
block|}
break|break;
default|default:
name|unknown_chunk
label|:
comment|/* it's an unknown chunk! */
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|&
literal|0x40
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mm
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|phd
decl_stmt|;
name|mm
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|mm
condition|)
block|{
name|phd
operator|=
name|mtod
argument_list|(
name|mm
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
comment|/* 					 * We cheat and use param type since 					 * we did not bother to define a 					 * error cause struct. They are the 					 * same basic format with different 					 * names. 					 */
name|phd
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_UNRECOG_CHUNK
argument_list|)
expr_stmt|;
name|phd
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|chk_length
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mm
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|phd
argument_list|)
expr_stmt|;
name|SCTP_BUF_NEXT
argument_list|(
name|mm
argument_list|)
operator|=
name|SCTP_M_COPYM
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mm
argument_list|)
condition|)
block|{
name|sctp_queue_op_err
argument_list|(
name|stcb
argument_list|,
name|mm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_m_freem
argument_list|(
name|mm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|ch
operator|->
name|chunk_type
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* discard this packet */
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|stcb
operator|)
return|;
block|}
comment|/* else skip this bad chunk and continue... */
break|break;
block|}
comment|/* switch (ch->chunk_type) */
name|next_chunk
label|:
comment|/* get the next chunk */
operator|*
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|chk_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|offset
operator|>=
name|length
condition|)
block|{
comment|/* no more data left in the mbuf chain */
break|break;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
operator|*
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|,
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked_tcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|locked_tcb
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|length
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* while */
return|return
operator|(
name|stcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process the ECN bits we have something set so we must look to see if it is  * ECN(0) or ECN(1) or CE  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|sctp_process_ecn_marked_a
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint8_t
name|ecn_bits
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ecn_bits
operator|&
name|SCTP_CE_BITS
operator|)
operator|==
name|SCTP_CE_BITS
condition|)
block|{
empty_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ecn_bits
operator|&
name|SCTP_ECT1_BIT
operator|)
operator|==
name|SCTP_ECT1_BIT
condition|)
block|{
comment|/* 		 * we only add to the nonce sum for ECT1, ECT0 does not 		 * change the NS bit (that we have yet to find a way to send 		 * it yet). 		 */
comment|/* ECN Nonce stuff */
name|stcb
operator|->
name|asoc
operator|.
name|receiver_nonce_sum
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|receiver_nonce_sum
operator|&=
name|SCTP_SACK_NONCE_SUM
expr_stmt|;
comment|/* 		 * Drag up the last_echo point if cumack is larger since we 		 * don't want the point falling way behind by more than 		 * 2^^31 and then having it be incorrect. 		 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_echo_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_echo_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ecn_bits
operator|&
name|SCTP_ECT0_BIT
operator|)
operator|==
name|SCTP_ECT0_BIT
condition|)
block|{
comment|/* 		 * Drag up the last_echo point if cumack is larger since we 		 * don't want the point falling way behind by more than 		 * 2^^31 and then having it be incorrect. 		 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_echo_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_echo_tsn
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|sctp_process_ecn_marked_b
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint32_t
name|high_tsn
parameter_list|,
name|uint8_t
name|ecn_bits
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ecn_bits
operator|&
name|SCTP_CE_BITS
operator|)
operator|==
name|SCTP_CE_BITS
condition|)
block|{
comment|/* 		 * we possibly must notify the sender that a congestion 		 * window reduction is in order. We do this by adding a ECNE 		 * chunk to the output chunk queue. The incoming CWR will 		 * remove this chunk. 		 */
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|high_tsn
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|last_echo_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* Yep, we need to add a ECNE */
name|sctp_send_ecn_echo
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|high_tsn
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_echo_tsn
operator|=
name|high_tsn
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * common input chunk processing (v4 and v6)  */
end_comment

begin_function
name|int
name|sctp_common_input_processing
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|mm
parameter_list|,
name|int
name|iphlen
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
parameter_list|,
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|uint8_t
name|ecn_bits
parameter_list|)
block|{
comment|/* 	 * Control chunk processing 	 */
name|uint32_t
name|high_tsn
decl_stmt|;
name|int
name|fwd_tsn_seen
init|=
literal|0
decl_stmt|,
name|data_processed
init|=
literal|0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mm
decl_stmt|;
name|int
name|abort_flag
init|=
literal|0
decl_stmt|;
name|int
name|un_sent
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvdatagrams
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xE0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|0
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Ok, Common input processing called, m:%p iphlen:%d offset:%d\n"
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* always clear this before beginning a packet */
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|seen_a_sack_this_pkt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|IS_SCTP_CONTROL
argument_list|(
name|ch
argument_list|)
condition|)
block|{
comment|/* process the control portion of the SCTP packet */
name|stcb
operator|=
name|sctp_process_control
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
operator|&
name|offset
argument_list|,
name|length
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
operator|&
name|net
argument_list|,
operator|&
name|fwd_tsn_seen
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
comment|/* 			 * This covers us if the cookie-echo was there and 			 * it changes our INP. 			 */
name|inp
operator|=
name|stcb
operator|->
name|sctp_ep
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * no control chunks, so pre-process DATA chunks (these 		 * checks are taken care of by control processing) 		 */
comment|/* 		 * if DATA only packet, and auth is required, then punt... 		 * can't have authenticated without any AUTH (control) 		 * chunks 		 */
if|if
condition|(
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|sctp_auth_disable
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
condition|)
block|{
comment|/* "silently" ignore */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthmissing
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* out of the blue DATA chunk */
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
operator|!=
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
condition|)
block|{
comment|/* v_tag mismatch! */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badvtag
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * no valid TCB for this packet, or we found it's a bad 		 * packet while processing control, or we're done with this 		 * packet (done or skip rest of data), so we drop it... 		 */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * DATA chunk processing 	 */
comment|/* plow through the data chunks while length> offset */
comment|/* 	 * Rest should be DATA only.  Check authentication state if AUTH for 	 * DATA is required. 	 */
if|if
condition|(
operator|(
name|length
operator|>
name|offset
operator|)
operator|&&
operator|(
name|stcb
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|sctp_auth_disable
operator|&&
name|sctp_auth_is_required_chunk
argument_list|(
name|SCTP_DATA
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|local_auth_chunks
argument_list|)
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|authenticated
condition|)
block|{
comment|/* "silently" ignore */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvauthmissing
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_AUTH1
condition|)
name|printf
argument_list|(
literal|"Data chunk requires AUTH, skipped\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|trigger_send
goto|;
block|}
if|if
condition|(
name|length
operator|>
name|offset
condition|)
block|{
name|int
name|retval
decl_stmt|;
comment|/* 		 * First check to make sure our state is correct. We would 		 * not get here unless we really did have a tag, so we don't 		 * abort if this happens, just dump the chunk silently. 		 */
switch|switch
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
condition|)
block|{
case|case
name|SCTP_STATE_COOKIE_ECHOED
case|:
comment|/* 			 * we consider data with valid tags in this state 			 * shows us the cookie-ack was lost. Imply it was 			 * there. 			 */
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
name|sctp_handle_cookie_ack
argument_list|(
operator|(
expr|struct
name|sctp_cookie_ack_chunk
operator|*
operator|)
name|ch
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_STATE_COOKIE_WAIT
case|:
comment|/* 			 * We consider OOTB any data sent during asoc setup. 			 */
name|sctp_handle_ootb
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|SCTP_STATE_EMPTY
case|:
comment|/* should not happen */
case|case
name|SCTP_STATE_INUSE
case|:
comment|/* should not happen */
case|case
name|SCTP_STATE_SHUTDOWN_RECEIVED
case|:
comment|/* This is a peer error */
case|case
name|SCTP_STATE_SHUTDOWN_ACK_SENT
case|:
default|default:
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|SCTP_STATE_OPEN
case|:
case|case
name|SCTP_STATE_SHUTDOWN_SENT
case|:
break|break;
block|}
comment|/* take care of ECN, part 1. */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|&&
operator|(
name|ecn_bits
operator|&
operator|(
name|SCTP_ECT0_BIT
operator||
name|SCTP_ECT1_BIT
operator|)
operator|)
condition|)
block|{
name|sctp_process_ecn_marked_a
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|ecn_bits
argument_list|)
expr_stmt|;
block|}
comment|/* plow through the data chunks while length> offset */
name|retval
operator|=
name|sctp_process_data
argument_list|(
name|mm
argument_list|,
name|iphlen
argument_list|,
operator|&
name|offset
argument_list|,
name|length
argument_list|,
name|sh
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
operator|&
name|high_tsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|2
condition|)
block|{
comment|/* 			 * The association aborted, NO UNLOCK needed since 			 * the association is destroyed. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|data_processed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|retval
operator|==
literal|0
condition|)
block|{
comment|/* take care of ecn part 2. */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ecn_allowed
operator|&&
operator|(
name|ecn_bits
operator|&
operator|(
name|SCTP_ECT0_BIT
operator||
name|SCTP_ECT1_BIT
operator|)
operator|)
condition|)
block|{
name|sctp_process_ecn_marked_b
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|high_tsn
argument_list|,
name|ecn_bits
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Anything important needs to have been m_copy'ed in 		 * process_data 		 */
block|}
if|if
condition|(
operator|(
name|data_processed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|fwd_tsn_seen
operator|)
condition|)
block|{
name|int
name|was_a_gap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|compare_with_wrap
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|highest_tsn_inside_map
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|cumulative_tsn
argument_list|,
name|MAX_TSN
argument_list|)
condition|)
block|{
comment|/* there was a gap before this data was processed */
name|was_a_gap
operator|=
literal|1
expr_stmt|;
block|}
name|sctp_sack_check
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
name|was_a_gap
argument_list|,
operator|&
name|abort_flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|abort_flag
condition|)
block|{
comment|/* Again, we aborted so NO UNLOCK needed */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* trigger send of any chunks in queue... */
name|trigger_send
label|:
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xE0
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|1
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Check for chunk output prw:%d tqe:%d tf=%d\n"
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
argument_list|,
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|un_sent
operator|=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|total_output_queue_size
operator|-
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|control_send_queue
argument_list|)
operator|||
operator|(
operator|(
name|un_sent
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|>
literal|0
operator|||
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peers_rwnd
operator|<=
literal|0
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"Calling chunk OUTPUT\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_CONTROL_PROC
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT3
condition|)
block|{
name|printf
argument_list|(
literal|"chunk OUTPUT returns\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_audit_log
argument_list|(
literal|0xE0
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|sctp_auditing
argument_list|(
literal|2
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_input
parameter_list|(
name|i_pak
parameter_list|,
name|off
parameter_list|)
name|struct
name|mbuf
modifier|*
name|i_pak
decl_stmt|;
name|int
name|off
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
endif|#
directive|endif
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|uint8_t
name|ecn_bits
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|check
decl_stmt|,
name|calc_check
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|int
name|refcount_up
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|,
name|mlen
decl_stmt|,
name|offset
decl_stmt|;
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
name|mlen
operator|=
name|SCTP_HEADER_LEN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
name|iphlen
operator|=
name|off
expr_stmt|;
name|m
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inpackets
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
comment|/* Log in any input mbufs */
name|mat
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|mat
condition|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_INPUT
argument_list|)
expr_stmt|;
block|}
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Get IP, SCTP, and first chunk header together in first mbuf. 	 */
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
operator|<
name|offset
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|offset
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
block|}
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip
operator|+
name|iphlen
operator|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sh
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|)
expr_stmt|;
comment|/* SCTP does not allow broadcasts or multicasts */
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|SCTP_IS_IT_BROADCAST
argument_list|(
name|ip
operator|->
name|ip_dst
argument_list|,
name|m
argument_list|)
condition|)
block|{
comment|/* 		 * We only look at broadcast if its a front state, All 		 * others we will not have a tcb for anyway. 		 */
goto|goto
name|bad
goto|;
block|}
comment|/* validate SCTP checksum */
if|if
condition|(
operator|(
name|sctp_no_csum_on_loopback
operator|==
literal|0
operator|)
operator|||
operator|!
name|SCTP_IS_IT_LOOPBACK
argument_list|(
name|m
argument_list|)
condition|)
block|{
comment|/* 		 * we do NOT validate things from the loopback if the sysctl 		 * is set to 1. 		 */
name|check
operator|=
name|sh
operator|->
name|checksum
expr_stmt|;
comment|/* save incoming checksum */
if|if
condition|(
operator|(
name|check
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_no_csum_on_loopback
operator|)
condition|)
block|{
comment|/* 			 * special hook for where we got a local address 			 * somehow routed across a non IFT_LOOP type 			 * interface 			 */
if|if
condition|(
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
goto|goto
name|sctp_skip_csum_4
goto|;
block|}
name|sh
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* prepare for calc */
name|calc_check
operator|=
name|sctp_calculate_sum
argument_list|(
name|m
argument_list|,
operator|&
name|mlen
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_check
operator|!=
name|check
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Bad CSUM on SCTP packet calc_check:%x check:%x  m:%p mlen:%d iphlen:%d\n"
argument_list|,
name|calc_check
argument_list|,
name|check
argument_list|,
name|m
argument_list|,
name|mlen
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|)
operator|&&
operator|(
name|stcb
operator|)
condition|)
block|{
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_INPUT_ERROR
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
name|refcount_up
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_checksumerrors
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sh
operator|->
name|checksum
operator|=
name|calc_check
expr_stmt|;
block|}
name|sctp_skip_csum_4
label|:
comment|/* destination port of 0 is illegal, based on RFC2960. */
if|if
condition|(
name|sh
operator|->
name|dest_port
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* validate mbuf chain length with IP payload length */
if|if
condition|(
name|mlen
operator|<
operator|(
name|ip
operator|->
name|ip_len
operator|-
name|iphlen
operator|)
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Locate pcb and tcb for datagram sctp_findassociation_addr() wants 	 * IP/SCTP/first chunk header... 	 */
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
comment|/* inp's ref-count increased&& stcb locked */
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_init_chunk
modifier|*
name|init_chk
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_noport
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ICMP_BANDLIM
comment|/* 		 * we use the bandwidth limiting to protect against sending 		 * too many ABORTS all at once. In this case these count the 		 * same as an ICMP message. 		 */
if|if
condition|(
name|badport_bandlim
argument_list|(
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
endif|#
directive|endif
comment|/* ICMP_BANDLIM */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Sending a ABORT from packet entry!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
condition|)
block|{
comment|/* 			 * we do a trick here to get the INIT tag, dig in 			 * and get the tag from the INIT and put it in the 			 * common header. 			 */
name|init_chk
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|init_chk
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|init_chk
operator|!=
name|NULL
condition|)
name|sh
operator|->
name|v_tag
operator|=
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_ACK
condition|)
block|{
name|sctp_send_shutdown_complete2
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_ABORT_ASSOCIATION
condition|)
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|refcount_up
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * I very much doubt any of the IPSEC stuff will work but I have no 	 * idea, so I will leave it in place. 	 */
if|if
condition|(
name|inp
operator|&&
name|ipsec4_in_reject
argument_list|(
name|m
argument_list|,
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
argument_list|)
condition|)
block|{
name|ipsecstat
operator|.
name|in_polvio
operator|++
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 	 * common chunk processing 	 */
name|length
operator|=
name|ip
operator|->
name|ip_len
operator|+
name|iphlen
expr_stmt|;
name|offset
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|ecn_bits
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|sctp_common_input_processing
argument_list|(
operator|&
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ecn_bits
argument_list|)
expr_stmt|;
comment|/* inp's ref-count reduced&& stcb unlocked */
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|)
operator|&&
operator|(
name|refcount_up
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return;
name|bad
label|:
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|)
operator|&&
operator|(
name|refcount_up
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* For BSD/MAC this does nothing */
name|SCTP_RELEASE_PAK
argument_list|(
name|i_pak
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

end_unit

