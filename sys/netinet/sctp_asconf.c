begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_comment
comment|/*  * debug flags:  * SCTP_DEBUG_ASCONF1: protocol info, general info and errors  * SCTP_DEBUG_ASCONF2: detailed info  */
end_comment

begin_comment
comment|/*  * RFC 5061  *  * An ASCONF parameter queue exists per asoc which holds the pending address  * operations.  Lists are updated upon receipt of ASCONF-ACK.  *  * A restricted_addrs list exists per assoc to hold local addresses that are  * not (yet) usable by the assoc as a source address.  These addresses are  * either pending an ASCONF operation (and exist on the ASCONF parameter  * queue), or they are permanently restricted (the peer has returned an  * ERROR indication to an ASCONF(ADD), or the peer does not support ASCONF).  *  * Deleted addresses are always immediately removed from the lists as they will  * (shortly) no longer exist in the kernel.  We send ASCONFs as a courtesy,  * only if allowed.  */
end_comment

begin_comment
comment|/*  * ASCONF parameter processing.  * response_required: set if a reply is required (eg. SUCCESS_REPORT).  * returns a mbuf to an "error" response parameter or NULL/"success" if ok.  * FIX: allocating this many mbufs on the fly is pretty inefficient...  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_asconf_success_response
parameter_list|(
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|m_reply
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_reply
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_success_response: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m_reply
argument_list|,
expr|struct
name|sctp_asconf_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|aph
operator|->
name|correlation_id
operator|=
name|id
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUCCESS_REPORT
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_reply
argument_list|)
operator|=
name|aph
operator|->
name|ph
operator|.
name|param_length
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_asconf_error_response
parameter_list|(
name|uint32_t
name|id
parameter_list|,
name|uint16_t
name|cause
parameter_list|,
name|uint8_t
modifier|*
name|error_tlv
parameter_list|,
name|uint16_t
name|tlv_length
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_error_cause
modifier|*
name|error
decl_stmt|;
name|uint8_t
modifier|*
name|tlv
decl_stmt|;
name|m_reply
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
name|tlv_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_reply
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_error_response: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m_reply
argument_list|,
expr|struct
name|sctp_asconf_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
expr|struct
name|sctp_error_cause
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|aph
operator|->
name|correlation_id
operator|=
name|id
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ERROR_CAUSE_IND
argument_list|)
expr_stmt|;
name|error
operator|->
name|code
operator|=
name|htons
argument_list|(
name|cause
argument_list|)
expr_stmt|;
name|error
operator|->
name|length
operator|=
name|tlv_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|error
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|>
name|MLEN
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_error_response: tlv_length (%xh) too big\n"
argument_list|,
name|tlv_length
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m_reply
argument_list|)
expr_stmt|;
comment|/* discard */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|error_tlv
operator|!=
name|NULL
condition|)
block|{
name|tlv
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|error
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|tlv
argument_list|,
name|error_tlv
argument_list|,
name|tlv_length
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_reply
argument_list|)
operator|=
name|aph
operator|->
name|ph
operator|.
name|param_length
expr_stmt|;
name|error
operator|->
name|length
operator|=
name|htons
argument_list|(
name|error
operator|->
name|length
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_process_asconf_add_ip
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|send_hb
parameter_list|,
name|int
name|response_required
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|,
name|aparam_length
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|uint16_t
name|param_length
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
name|int
name|bad_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
endif|#
directive|endif
name|aparam_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|param_length
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sa
operator|=
operator|&
name|store
operator|.
name|sa
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|ph
expr_stmt|;
name|sin
operator|=
operator|&
name|store
operator|.
name|sin
expr_stmt|;
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|v4addr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_BROADCAST
operator|)
operator|||
name|IN_MULTICAST
argument_list|(
name|ntohl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
block|{
name|bad_address
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_add_ip: adding "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|ph
expr_stmt|;
name|sin6
operator|=
operator|&
name|store
operator|.
name|sin6
expr_stmt|;
name|memset
argument_list|(
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|v6addr
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|bad_address
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_add_ip: adding "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
comment|/* end switch */
comment|/* if 0.0.0.0/::0, add the source address instead */
if|if
condition|(
name|zero_address
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nat_friendly
argument_list|)
condition|)
block|{
name|sa
operator|=
name|src
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_add_ip: using source addr "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* add the address */
if|if
condition|(
name|bad_address
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
operator|&
name|net
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|port
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_DYNAMIC_ADDED
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_add_ip: error adding address\n"
argument_list|)
expr_stmt|;
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_RESOURCE_SHORTAGE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_ADD_IP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sa
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
if|if
condition|(
name|send_hb
condition|)
block|{
name|sctp_send_hb
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_asconf_del_remote_addrs_except
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|src_net
decl_stmt|,
modifier|*
name|net
decl_stmt|;
comment|/* make sure the source address exists as a destination net */
name|src_net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_net
operator|==
name|NULL
condition|)
block|{
comment|/* not found */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* delete all destination addresses except the source */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|!=
name|src_net
condition|)
block|{
comment|/* delete this address */
name|sctp_remove_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_del_remote_addrs_except: deleting "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
expr_stmt|;
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_DELETE_IP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_process_asconf_delete_ip
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|response_required
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|,
name|aparam_length
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|uint16_t
name|param_length
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
endif|#
directive|endif
name|aparam_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|param_length
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sa
operator|=
operator|&
name|store
operator|.
name|sa
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|ph
expr_stmt|;
name|sin
operator|=
operator|&
name|store
operator|.
name|sin
expr_stmt|;
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|v4addr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_delete_ip: deleting "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|ph
expr_stmt|;
name|sin6
operator|=
operator|&
name|store
operator|.
name|sin6
expr_stmt|;
name|memset
argument_list|(
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|v6addr
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_delete_ip: deleting "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
comment|/* make sure the source address is not being deleted */
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|sa
argument_list|,
name|src
argument_list|)
condition|)
block|{
comment|/* trying to delete the source address! */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_delete_ip: tried to delete source addr\n"
argument_list|)
expr_stmt|;
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_DELETING_SRC_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
comment|/* if deleting 0.0.0.0/::0, delete all addresses except src addr */
if|if
condition|(
name|zero_address
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nat_friendly
argument_list|)
condition|)
block|{
name|result
operator|=
name|sctp_asconf_del_remote_addrs_except
argument_list|(
name|stcb
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* src address did not exist? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_delete_ip: src addr does not exist?\n"
argument_list|)
expr_stmt|;
comment|/* what error to reply with?? */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_REQUEST_REFUSED
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
comment|/* delete the address */
name|result
operator|=
name|sctp_del_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|)
expr_stmt|;
comment|/* 	 * note if result == -2, the address doesn't exist in the asoc but 	 * since it's being deleted anyways, we just ack the delete -- but 	 * this probably means something has already gone awry 	 */
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* only one address in the asoc */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_delete_ip: tried to delete last IP addr!\n"
argument_list|)
expr_stmt|;
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_DELETING_LAST_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_DELETE_IP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sa
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_process_asconf_set_primary
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|response_required
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|,
name|aparam_length
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|uint16_t
name|param_length
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
endif|#
directive|endif
name|aparam_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|param_length
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sa
operator|=
operator|&
name|store
operator|.
name|sa
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|ph
expr_stmt|;
name|sin
operator|=
operator|&
name|store
operator|.
name|sin
expr_stmt|;
name|memset
argument_list|(
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|v4addr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_set_primary: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|ph
expr_stmt|;
name|sin6
operator|=
operator|&
name|store
operator|.
name|sin6
expr_stmt|;
name|memset
argument_list|(
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|v6addr
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_set_primary: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
comment|/* if 0.0.0.0/::0, use the source address instead */
if|if
condition|(
name|zero_address
operator|&&
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_nat_friendly
argument_list|)
condition|)
block|{
name|sa
operator|=
name|src
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_set_primary: using source addr "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
comment|/* set the primary address */
if|if
condition|(
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_set_primary: primary address set\n"
argument_list|)
expr_stmt|;
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_SET_PRIMARY
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sa
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
operator|)
operator|&&
operator|(
operator|!
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_PF
operator|)
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|)
condition|)
block|{
name|sctp_free_remote_addr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|alternate
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|alternate
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Mobility adaptation. Ideally, when the reception of SET 		 * PRIMARY with DELETE IP ADDRESS of the previous primary 		 * destination, unacknowledged DATA are retransmitted 		 * immediately to the new primary destination for seamless 		 * handover. If the destination is UNCONFIRMED and marked to 		 * REQ_PRIM, The retransmission occur when reception of the 		 * HEARTBEAT-ACK.  (See sctp_handle_heartbeat_ack in 		 * sctp_input.c) Also, when change of the primary 		 * destination, it is better that all subsequent new DATA 		 * containing already queued DATA are transmitted to the new 		 * primary destination. (by micchie) 		 */
if|if
condition|(
operator|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
operator|||
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
operator|)
operator|&&
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_PRIM_DELETED
argument_list|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
operator|)
operator|==
literal|0
condition|)
block|{
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PRIM_DELETED
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
condition|)
block|{
name|sctp_assoc_immediate_retrans
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
condition|)
block|{
name|sctp_move_chunks_from_net
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
block|}
name|sctp_delete_prim_timer
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* couldn't set the requested primary address! */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_asconf_set_primary: set primary failed!\n"
argument_list|)
expr_stmt|;
comment|/* must have been an invalid address, so report */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m_reply
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * handles an ASCONF chunk.  * if all parameters are processed ok, send a plain (empty) ASCONF-ACK  */
end_comment

begin_function
name|void
name|sctp_handle_asconf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sctp_asconf_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|first
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|serial_num
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|,
modifier|*
name|m_ack
decl_stmt|,
modifier|*
name|m_result
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|struct
name|sctp_asconf_ack_chunk
modifier|*
name|ack_cp
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p_addr
decl_stmt|;
name|unsigned
name|int
name|asconf_limit
decl_stmt|,
name|cnt
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* did an error occur? */
comment|/* asconf param buffer */
name|uint8_t
name|aparam_buf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_asconf_ack
modifier|*
name|ack
decl_stmt|,
modifier|*
name|ack_next
decl_stmt|;
comment|/* verify minimum length */
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: chunk too small = %xh\n"
argument_list|,
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|serial_num
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|serial_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_TSN_GE
argument_list|(
name|asoc
operator|->
name|asconf_seq_in
argument_list|,
name|serial_num
argument_list|)
condition|)
block|{
comment|/* got a duplicate ASCONF */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: got duplicate serial number = %xh\n"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|serial_num
operator|!=
operator|(
name|asoc
operator|->
name|asconf_seq_in
operator|+
literal|1
operator|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: incorrect serial number = %xh (expected next = %xh)\n"
argument_list|,
name|serial_num
argument_list|,
name|asoc
operator|->
name|asconf_seq_in
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* it's the expected "next" sequence number, so process it */
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|serial_num
expr_stmt|;
comment|/* update sequence */
comment|/* get length of all the param's in the ASCONF */
name|asconf_limit
operator|=
name|offset
operator|+
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: asconf_limit=%u, sequence=%xh\n"
argument_list|,
name|asconf_limit
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
comment|/* delete old cache */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: Now processing first ASCONF. Try to delete old cache\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ack
argument_list|,
argument|&asoc->asconf_ack_sent
argument_list|,
argument|next
argument_list|,
argument|ack_next
argument_list|)
block|{
if|if
condition|(
name|ack
operator|->
name|serial_number
operator|==
name|serial_num
condition|)
break|break;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: delete old(%u)< first(%u)\n"
argument_list|,
name|ack
operator|->
name|serial_number
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|asoc
operator|->
name|asconf_ack_sent
argument_list|,
name|ack
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|->
name|data
operator|!=
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|ack
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf_ack
argument_list|)
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
block|}
name|m_ack
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_ack
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_tail
operator|=
name|m_ack
expr_stmt|;
comment|/* current reply chain's tail */
comment|/* fill in ASCONF-ACK header */
name|ack_cp
operator|=
name|mtod
argument_list|(
name|m_ack
argument_list|,
expr|struct
name|sctp_asconf_ack_chunk
operator|*
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ack_cp
operator|->
name|serial_number
operator|=
name|htonl
argument_list|(
name|serial_num
argument_list|)
expr_stmt|;
comment|/* set initial lengths (eg. just an ASCONF-ACK), ntohx at the end! */
name|SCTP_BUF_LEN
argument_list|(
name|m_ack
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
comment|/* skip the lookup address parameter */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
expr_stmt|;
name|p_addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_addr
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: couldn't get lookup addr!\n"
argument_list|)
expr_stmt|;
comment|/* respond with a missing/invalid mandatory parameter error */
return|return;
block|}
comment|/* param_length is already validated in process_control... */
name|offset
operator|+=
name|ntohs
argument_list|(
name|p_addr
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
comment|/* skip lookup addr */
comment|/* get pointer to first asconf param in ASCONF */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"Empty ASCONF received?\n"
argument_list|)
expr_stmt|;
goto|goto
name|send_reply
goto|;
block|}
comment|/* process through all parameters */
name|cnt
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|aph
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|param_length
decl_stmt|,
name|param_type
decl_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|param_length
operator|>
name|asconf_limit
condition|)
block|{
comment|/* parameter goes beyond end of chunk! */
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|param_length
operator|>
sizeof|sizeof
argument_list|(
name|aparam_buf
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: param length (%u) larger than buffer size!\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param_length
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: param length (%u) too short\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
block|}
comment|/* get the entire parameter */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|param_length
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: couldn't get entire param\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
name|m_result
operator|=
name|sctp_process_asconf_add_ip
argument_list|(
name|src
argument_list|,
name|aph
argument_list|,
name|stcb
argument_list|,
operator|(
name|cnt
operator|<
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_hb_maxburst
argument_list|)
operator|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|cnt
operator|++
expr_stmt|;
break|break;
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
name|m_result
operator|=
name|sctp_process_asconf_delete_ip
argument_list|(
name|src
argument_list|,
name|aph
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
comment|/* not valid in an ASCONF chunk */
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
name|m_result
operator|=
name|sctp_process_asconf_set_primary
argument_list|(
name|src
argument_list|,
name|aph
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_NAT_VTAGS
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: sees a NAT VTAG state parameter\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
comment|/* not valid in an ASCONF chunk */
break|break;
case|case
name|SCTP_ULP_ADAPTATION
case|:
comment|/* FIX */
break|break;
default|default:
if|if
condition|(
operator|(
name|param_type
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Been told to STOP at this param */
name|asconf_limit
operator|=
name|offset
expr_stmt|;
comment|/* 				 * FIX FIX - We need to call 				 * sctp_arethere_unrecognized_parameters() 				 * to get a operr and send it for any 				 * param's with the 0x4000 bit set OR do it 				 * here ourselves... note we still must STOP 				 * if the 0x8000 bit is clear. 				 */
block|}
comment|/* unknown/invalid param type */
break|break;
block|}
comment|/* switch */
comment|/* add any (error) result to the reply mbuf chain */
if|if
condition|(
name|m_result
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m_tail
argument_list|)
operator|=
name|m_result
expr_stmt|;
name|m_tail
operator|=
name|m_result
expr_stmt|;
comment|/* update lengths, make sure it's aligned too */
name|SCTP_BUF_LEN
argument_list|(
name|m_result
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m_result
argument_list|)
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_result
argument_list|)
expr_stmt|;
comment|/* set flag to force success reports */
name|error
operator|=
literal|1
expr_stmt|;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
comment|/* update remaining ASCONF message length to process */
if|if
condition|(
name|offset
operator|>=
name|asconf_limit
condition|)
block|{
comment|/* no more data in the mbuf chain */
break|break;
block|}
comment|/* get pointer to next asconf param */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
comment|/* can't get an asconf paramhdr */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: can't get asconf param hdr!\n"
argument_list|)
expr_stmt|;
comment|/* FIX ME - add error here... */
block|}
block|}
name|send_reply
label|:
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* save the ASCONF-ACK reply */
name|ack
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_asconf_ack
argument_list|)
argument_list|,
expr|struct
name|sctp_asconf_ack
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|==
name|NULL
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
name|ack
operator|->
name|serial_number
operator|=
name|serial_num
expr_stmt|;
name|ack
operator|->
name|last_sent_to
operator|=
name|NULL
expr_stmt|;
name|ack
operator|->
name|data
operator|=
name|m_ack
expr_stmt|;
name|ack
operator|->
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|m_ack
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|n
argument_list|)
control|)
block|{
name|ack
operator|->
name|len
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_ack_sent
argument_list|,
name|ack
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* see if last_control_chunk_from is set properly (use IP src addr) */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * this could happen if the source address was just newly 		 * added 		 */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: looking up net for IP source address\n"
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"Looking for IP source: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|src
argument_list|)
expr_stmt|;
comment|/* look up the from address */
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|src
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf: IP source address not found?!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * does the address match? returns 0 if not, 1 if so  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_asconf_addr_match
parameter_list|(
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* XXX scopeid */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_IPV6_ADDRESS
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_IPV4_ADDRESS
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * does the address match? returns 0 if not, 1 if so  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_addr_match
parameter_list|(
name|struct
name|sctp_paramhdr
modifier|*
name|ph
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
name|uint16_t
name|param_type
decl_stmt|,
name|param_length
decl_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* XXX scopeid */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|ph
expr_stmt|;
if|if
condition|(
operator|(
name|param_type
operator|==
name|SCTP_IPV6_ADDRESS
operator|)
operator|&&
operator|(
name|param_length
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|v6addr
operator|->
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|ph
expr_stmt|;
if|if
condition|(
operator|(
name|param_type
operator|==
name|SCTP_IPV4_ADDRESS
operator|)
operator|&&
operator|(
name|param_length
operator|==
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|v4addr
operator|->
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup for non-responded/OP ERR'd ASCONF  */
end_comment

begin_function
name|void
name|sctp_asconf_cleanup
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* 	 * clear out any existing asconfs going out 	 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_seq_out_acked
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|asconf_seq_out
expr_stmt|;
comment|/* remove the old ASCONF on our outbound queue */
name|sctp_toss_old_asconf
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup any cached source addresses that may be topologically  * incorrect after a new address has been added to this interface.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_nets_cleanup
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifn
modifier|*
name|ifn
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* 	 * Ideally, we want to only clear cached routes and source addresses 	 * that are topologically incorrect.  But since there is no easy way 	 * to know whether the newly added address on the ifn would cause a 	 * routing change (i.e. a new egress interface would be chosen) 	 * without doing a new routing lookup and source address selection, 	 * we will (for now) just flush any cached route using a different 	 * ifn (and cached source addrs) and let output re-choose them 	 * during the next send on that net. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* 		 * clear any cached route (and cached source address) if the 		 * route's interface is NOT the same as the address change. 		 * If it's the same interface, just clear the cached source 		 * address. 		 */
if|if
condition|(
name|SCTP_ROUTE_HAS_VALID_IFN
argument_list|(
operator|&
name|net
operator|->
name|ro
argument_list|)
operator|&&
operator|(
operator|(
name|ifn
operator|==
name|NULL
operator|)
operator|||
operator|(
name|SCTP_GET_IF_INDEX_FROM_ROUTE
argument_list|(
operator|&
name|net
operator|->
name|ro
argument_list|)
operator|!=
name|ifn
operator|->
name|ifn_index
operator|)
operator|)
condition|)
block|{
comment|/* clear any cached route */
name|RTFREE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* clear any cached source address */
if|if
condition|(
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|sctp_assoc_immediate_retrans
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|dstnet
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|dstnet
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_UNCONFIRMED
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"assoc_immediate_retrans: Deleted primary is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"Current Primary is "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|--
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|<
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|error
operator|=
name|sctp_t3rxt_timer
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_INP_DECR_REF
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_TCB_LOCK_ASSERT
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_AUDITING_ENABLED
name|sctp_auditing
argument_list|(
literal|4
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|deleted_primary
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|num_send_timers_up
operator|==
literal|0
operator|)
operator|&&
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_cnt
operator|>
literal|0
operator|)
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|chk
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|chk
operator|->
name|whoTo
argument_list|)
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|sctp_asconf_queue_mgmt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
parameter_list|,
name|uint16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|sctp_net_immediate_retrans
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"net_immediate_retrans: RTO is %d\n"
argument_list|,
name|net
operator|->
name|RTO
argument_list|)
expr_stmt|;
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_SEND
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_4
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|whoTo
operator|==
name|net
condition|)
block|{
if|if
condition|(
name|chk
operator|->
name|sent
operator|<
name|SCTP_DATAGRAM_RESEND
condition|)
block|{
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|sctp_ucount_incr
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
argument_list|)
expr_stmt|;
name|sctp_flight_size_decrease
argument_list|(
name|chk
argument_list|)
expr_stmt|;
name|sctp_total_flight_decrease
argument_list|(
name|stcb
argument_list|,
name|chk
argument_list|)
expr_stmt|;
name|net
operator|->
name|marked_retrans
operator|++
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|marked_retrans
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|net
operator|->
name|marked_retrans
condition|)
block|{
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_T3
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_path_check_and_react
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|newifa
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|addrnum
decl_stmt|,
name|changed
decl_stmt|;
comment|/* 	 * If number of local valid addresses is 1, the valid address is 	 * probably newly added address. Several valid addresses in this 	 * association.  A source address may not be changed.  Additionally, 	 * they can be configured on a same interface as "alias" addresses. 	 * (by micchie) 	 */
name|addrnum
operator|=
name|sctp_local_addr_count
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"p_check_react(): %d local addresses\n"
argument_list|,
name|addrnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addrnum
operator|==
literal|1
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* clear any cached route and source address */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Retransmit unacknowledged DATA chunks immediately */
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
condition|)
block|{
name|sctp_net_immediate_retrans
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* also, SET PRIMARY is maybe already sent */
block|}
return|return;
block|}
comment|/* Multiple local addresses exsist in the association.  */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
comment|/* clear any cached route and source address */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
condition|)
block|{
name|RTFREE
argument_list|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|net
operator|->
name|src_addr_selected
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * Check if the nexthop is corresponding to the new address. 		 * If the new address is corresponding to the current 		 * nexthop, the path will be changed. If the new address is 		 * NOT corresponding to the current nexthop, the path will 		 * not be changed. 		 */
name|SCTP_RTALLOC
argument_list|(
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|def_vrf_id
argument_list|,
name|stcb
operator|->
name|sctp_ep
operator|->
name|fibnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|==
name|NULL
condition|)
continue|continue;
name|changed
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|sctp_v4src_match_nexthop
argument_list|(
name|newifa
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|sctp_v6src_match_nexthop
argument_list|(
operator|&
name|newifa
operator|->
name|address
operator|.
name|sin6
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|)
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* 		 * if the newly added address does not relate routing 		 * information, we skip. 		 */
if|if
condition|(
name|changed
operator|==
literal|0
condition|)
continue|continue;
comment|/* Retransmit unacknowledged DATA chunks immediately */
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
condition|)
block|{
name|sctp_net_immediate_retrans
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
comment|/* Send SET PRIMARY for this new address */
if|if
condition|(
name|net
operator|==
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
condition|)
block|{
operator|(
name|void
operator|)
name|sctp_asconf_queue_mgmt
argument_list|(
name|stcb
argument_list|,
name|newifa
argument_list|,
name|SCTP_SET_PRIM_ADDR
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * process an ADD/DELETE IP ack from peer.  * addr: corresponding sctp_ifa to the address being added/deleted.  * type: SCTP_ADD_IP_ADDRESS or SCTP_DEL_IP_ADDRESS.  * flag: 1=success, 0=failure.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_addr_mgmt_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|addr
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
comment|/* 	 * do the necessary asoc list work- if we get a failure indication, 	 * leave the address on the assoc's restricted list.  If we get a 	 * success indication, remove the address from the restricted list. 	 */
comment|/* 	 * Note: this will only occur for ADD_IP_ADDRESS, since 	 * DEL_IP_ADDRESS is never actually added to the list... 	 */
if|if
condition|(
name|flag
condition|)
block|{
comment|/* success case, so remove from the restricted list */
name|sctp_del_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_BASE
argument_list|)
operator|||
name|sctp_is_mobility_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_MOBILITY_FASTHANDOFF
argument_list|)
condition|)
block|{
name|sctp_path_check_and_react
argument_list|(
name|stcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* clear any cached/topologically incorrect source addresses */
name|sctp_asconf_nets_cleanup
argument_list|(
name|stcb
argument_list|,
name|addr
operator|->
name|ifn_p
argument_list|)
expr_stmt|;
block|}
comment|/* else, leave it on the list */
block|}
end_function

begin_comment
comment|/*  * add an asconf add/delete/set primary IP address parameter to the queue.  * type = SCTP_ADD_IP_ADDRESS, SCTP_DEL_IP_ADDRESS, SCTP_SET_PRIM_ADDR.  * returns 0 if queued, -1 if not queued/removed.  * NOTE: if adding, but a delete for the same address is already scheduled  * (and not yet sent out), simply remove it from queue.  Same for deleting  * an address already scheduled for add.  If a duplicate operation is found,  * ignore the new one.  */
end_comment

begin_function
specifier|static
name|int
name|sctp_asconf_queue_mgmt
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|,
modifier|*
name|aa_next
decl_stmt|;
comment|/* make sure the request isn't already in the queue */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|,
argument|aa_next
argument_list|)
block|{
comment|/* address match? */
if|if
condition|(
name|sctp_asconf_addr_match
argument_list|(
name|aa
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * is the request already in queue but not sent? pass the 		 * request already sent in order to resolve the following 		 * case: 1. arrival of ADD, then sent 2. arrival of DEL. we 		 * can't remove the ADD request already sent 3. arrival of 		 * ADD 		 */
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|type
operator|&&
name|aa
operator|->
name|sent
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* is the negative request already in queue, and not sent */
if|if
condition|(
operator|(
name|aa
operator|->
name|sent
operator|==
literal|0
operator|)
operator|&&
operator|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
operator|&&
operator|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|)
condition|)
block|{
comment|/* add requested, delete already queued */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* remove the ifa from the restricted list */
name|sctp_del_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
comment|/* free the asconf param */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
literal|"asconf_queue_mgmt: add removes queued entry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|aa
operator|->
name|sent
operator|==
literal|0
operator|)
operator|&&
operator|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|)
operator|&&
operator|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
condition|)
block|{
comment|/* delete requested, add already queued */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* remove the aa->ifa from the restricted list */
name|sctp_del_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|aa
operator|->
name|ifa
argument_list|)
expr_stmt|;
comment|/* free the asconf param */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
literal|"asconf_queue_mgmt: delete removes queued entry\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* for each aa */
comment|/* adding new request to the queue */
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_queue_mgmt: failed to get memory!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|aa
operator|->
name|special_del
operator|=
literal|0
expr_stmt|;
comment|/* fill in asconf address parameter fields */
comment|/* top level elements are "networked" during send */
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|type
expr_stmt|;
name|aa
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* correlation_id filled in during send routine later... */
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* invalid family! */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|aa
operator|->
name|sent
operator|=
literal|0
expr_stmt|;
comment|/* clear sent flag */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_debug_on
argument_list|)
operator|&
name|SCTP_DEBUG_ASCONF2
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"asconf_queue_mgmt: inserted asconf ADD_IP_ADDRESS: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"asconf_queue_mgmt: appended asconf DEL_IP_ADDRESS: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_PRINTF
argument_list|(
literal|"asconf_queue_mgmt: appended asconf SET_PRIM_ADDR: "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add an asconf operation for the given ifa and type.  * type = SCTP_ADD_IP_ADDRESS, SCTP_DEL_IP_ADDRESS, SCTP_SET_PRIM_ADDR.  * returns 0 if completed, -1 if not completed, 1 if immediate send is  * advisable.  */
end_comment

begin_function
specifier|static
name|int
name|sctp_asconf_queue_add
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|uint32_t
name|status
decl_stmt|;
name|int
name|pending_delete_queued
init|=
literal|0
decl_stmt|;
name|int
name|last
decl_stmt|;
comment|/* see if peer supports ASCONF */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * if this is deleting the last address from the assoc, mark it as 	 * pending. 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|)
operator|&&
operator|!
name|stcb
operator|->
name|asoc
operator|.
name|asconf_del_pending
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|last
operator|=
operator|(
name|sctp_local_addr_count
argument_list|(
name|stcb
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|last
operator|=
operator|(
name|sctp_local_addr_count
argument_list|(
name|stcb
argument_list|)
operator|==
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
comment|/* set the pending delete info only */
name|stcb
operator|->
name|asoc
operator|.
name|asconf_del_pending
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_addr_del_pending
operator|=
name|ifa
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
literal|"asconf_queue_add: mark delete last address pending\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* queue an asconf parameter */
name|status
operator|=
name|sctp_asconf_queue_mgmt
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * if this is an add, and there is a delete also pending (i.e. the 	 * last local address is being changed), queue the pending delete 	 * too. 	 */
if|if
condition|(
operator|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_del_pending
operator|&&
operator|(
name|status
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* queue in the pending delete */
if|if
condition|(
name|sctp_asconf_queue_mgmt
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|asconf_addr_del_pending
argument_list|,
name|SCTP_DEL_IP_ADDRESS
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
literal|"asconf_queue_add: queing pending delete\n"
argument_list|)
expr_stmt|;
name|pending_delete_queued
operator|=
literal|1
expr_stmt|;
comment|/* clear out the pending delete info */
name|stcb
operator|->
name|asoc
operator|.
name|asconf_del_pending
operator|=
literal|0
expr_stmt|;
name|sctp_free_ifa
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_addr_del_pending
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_addr_del_pending
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pending_delete_queued
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* 		 * since we know that the only/last address is now being 		 * changed in this case, reset the cwnd/rto on all nets to 		 * start as a new address and path.  Also clear the error 		 * counts to give the assoc the best chance to complete the 		 * address change. 		 */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|RTO
operator|=
literal|0
expr_stmt|;
name|net
operator|->
name|error_count
operator|=
literal|0
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_THRESHOLD_LOGGING
condition|)
block|{
name|sctp_misc_ints
argument_list|(
name|SCTP_THRESHOLD_CLEAR
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|overall_error_count
argument_list|,
literal|0
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
comment|/* queue in an advisory set primary too */
operator|(
name|void
operator|)
name|sctp_asconf_queue_mgmt
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|SCTP_SET_PRIM_ADDR
argument_list|)
expr_stmt|;
comment|/* let caller know we should send this out immediately */
name|status
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * add an asconf delete IP address parameter to the queue by sockaddr and  * possibly with no sctp_ifa available.  This is only called by the routine  * that checks the addresses in an INIT-ACK against the current address list.  * returns 0 if completed, non-zero if not completed.  * NOTE: if an add is already scheduled (and not yet sent out), simply  * remove it from queue.  If a duplicate operation is found, ignore the  * new one.  */
end_comment

begin_function
specifier|static
name|int
name|sctp_asconf_queue_sa_delete
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|,
modifier|*
name|aa_next
decl_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* see if peer supports ASCONF */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure the request isn't already in the queue */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|,
argument|aa_next
argument_list|)
block|{
comment|/* address match? */
if|if
condition|(
name|sctp_asconf_addr_match
argument_list|(
name|aa
argument_list|,
name|sa
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* is the request already in queue (sent or not) */
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* is the negative request already in queue, and not sent */
if|if
condition|(
name|aa
operator|->
name|sent
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* add already queued, so remove existing entry */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|sctp_del_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|aa
operator|->
name|ifa
argument_list|)
expr_stmt|;
comment|/* free the entry */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* for each aa */
comment|/* find any existing ifa-- NOTE ifa CAN be allowed to be NULL */
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
comment|/* adding new request to the queue */
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_queue_sa_delete: failed to get memory!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|aa
operator|->
name|special_del
operator|=
literal|0
expr_stmt|;
comment|/* fill in asconf address parameter fields */
comment|/* top level elements are "networked" during send */
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_DEL_IP_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* correlation_id filled in during send routine later... */
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* IPv6 address */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
comment|/* IPv4 address */
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* invalid family! */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
name|sctp_free_ifa
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|aa
operator|->
name|sent
operator|=
literal|0
expr_stmt|;
comment|/* clear sent flag */
comment|/* delete goes to the back of the queue */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* sa_ignore MEMLEAK {memory is put on the tailq} */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find a specific asconf param on our "sent" queue  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_asconf_addr
modifier|*
name|sctp_asconf_find_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|correlation_id
parameter_list|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|correlation_id
operator|==
name|correlation_id
operator|&&
name|aa
operator|->
name|sent
operator|==
literal|1
condition|)
block|{
comment|/* found it */
return|return
operator|(
name|aa
operator|)
return|;
block|}
block|}
comment|/* didn't find it */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process an SCTP_ERROR_CAUSE_IND for a ASCONF-ACK parameter and do  * notifications based on the error response  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_process_error
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
name|SCTP_UNUSED
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|)
block|{
name|struct
name|sctp_error_cause
modifier|*
name|eh
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|;
name|uint16_t
name|error_code
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|sctp_error_cause
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* validate lengths */
if|if
condition|(
name|htons
argument_list|(
name|eh
operator|->
name|length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
operator|>
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
condition|)
block|{
comment|/* invalid error cause length */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_process_error: cause element too long\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|htons
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|>
name|htons
argument_list|(
name|eh
operator|->
name|length
argument_list|)
condition|)
block|{
comment|/* invalid included TLV length */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"asconf_process_error: included TLV too long\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* which error code ? */
name|error_code
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|code
argument_list|)
expr_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
comment|/* FIX: this should go back up the REMOTE_ERROR ULP notify */
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
name|SCTP_CAUSE_RESOURCE_SHORTAGE
case|:
comment|/* we allow ourselves to "try again" for this error */
break|break;
default|default:
comment|/* peer can't handle it... */
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
case|case
name|SCTP_SET_PRIM_ADDR
case|:
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * process an asconf queue param.  * aparam: parameter to process, will be removed from the queue.  * flag: 1=success case, 0=failure case  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_process_param_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_asconf_addr
modifier|*
name|aparam
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
name|uint16_t
name|param_type
decl_stmt|;
comment|/* process this param */
name|param_type
operator|=
name|aparam
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_param_ack: added IP address\n"
argument_list|)
expr_stmt|;
name|sctp_asconf_addr_mgmt_ack
argument_list|(
name|stcb
argument_list|,
name|aparam
operator|->
name|ifa
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_param_ack: deleted IP address\n"
argument_list|)
expr_stmt|;
comment|/* nothing really to do... lists already updated */
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"process_param_ack: set primary IP address\n"
argument_list|)
expr_stmt|;
comment|/* nothing to do... peer may start using this addr */
break|break;
default|default:
comment|/* should NEVER happen */
break|break;
block|}
comment|/* remove the param and free it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aparam
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|aparam
operator|->
name|ifa
condition|)
name|sctp_free_ifa
argument_list|(
name|aparam
operator|->
name|ifa
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|aparam
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup from a bad asconf ack parameter  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_ack_clear
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
name|SCTP_UNUSED
parameter_list|)
block|{
comment|/* assume peer doesn't really know how to do asconfs */
comment|/* XXX we could free the pending queue here */
block|}
end_function

begin_function
name|void
name|sctp_handle_asconf_ack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_asconf_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
modifier|*
name|abort_no_unlock
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|serial_num
decl_stmt|;
name|uint16_t
name|ack_length
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|,
modifier|*
name|aa_next
decl_stmt|;
name|uint32_t
name|last_error_id
init|=
literal|0
decl_stmt|;
comment|/* last error correlation id */
name|uint32_t
name|id
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|ap
decl_stmt|;
comment|/* asconf param buffer */
name|uint8_t
name|aparam_buf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* verify minimum length */
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf_ack: chunk too small = %xh\n"
argument_list|,
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|serial_num
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|serial_number
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: we may want to handle this differently- currently, we will 	 * abort when we get an ack for the expected serial number + 1 (eg. 	 * we didn't send it), process an ack normally if it is the expected 	 * serial number, and re-send the previous ack for *ALL* other 	 * serial numbers 	 */
comment|/* 	 * if the serial number is the next expected, but I didn't send it, 	 * abort the asoc, since someone probably just hijacked us... 	 */
if|if
condition|(
name|serial_num
operator|==
operator|(
name|asoc
operator|->
name|asconf_seq_out
operator|+
literal|1
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|op_err
decl_stmt|;
name|char
name|msg
index|[
name|SCTP_DIAG_INFO_LEN
index|]
decl_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf_ack: got unexpected next serial number! Aborting asoc!\n"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|,
literal|"Never sent serial number %8.8x"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
name|op_err
operator|=
name|sctp_generate_cause
argument_list|(
name|SCTP_CAUSE_PROTOCOL_VIOLATION
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|op_err
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
operator|*
name|abort_no_unlock
operator|=
literal|1
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|serial_num
operator|!=
name|asoc
operator|->
name|asconf_seq_out_acked
operator|+
literal|1
condition|)
block|{
comment|/* got a duplicate/unexpected ASCONF-ACK */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"handle_asconf_ack: got duplicate/unexpected serial number = %xh (expected = %xh)\n"
argument_list|,
name|serial_num
argument_list|,
name|asoc
operator|->
name|asconf_seq_out_acked
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|serial_num
operator|==
name|asoc
operator|->
name|asconf_seq_out
operator|-
literal|1
condition|)
block|{
comment|/* stop our timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_5
argument_list|)
expr_stmt|;
block|}
comment|/* process the ASCONF-ACK contents */
name|ack_length
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
comment|/* process through all parameters */
while|while
condition|(
name|ack_length
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|param_length
decl_stmt|,
name|param_type
decl_stmt|;
comment|/* get pointer to next asconf parameter */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
comment|/* can't get an asconf paramhdr */
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|param_length
operator|>
name|ack_length
condition|)
block|{
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the complete parameter... */
if|if
condition|(
name|param_length
operator|>
sizeof|sizeof
argument_list|(
name|aparam_buf
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"param length (%u) larger than buffer size!\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|param_length
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* correlation_id is transparent to peer, no ntohl needed */
name|id
operator|=
name|aph
operator|->
name|correlation_id
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
name|last_error_id
operator|=
name|id
expr_stmt|;
comment|/* find the corresponding asconf param in our queue */
name|ap
operator|=
name|sctp_asconf_find_param
argument_list|(
name|stcb
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
comment|/* hmm... can't find this in our queue! */
break|break;
block|}
comment|/* process the parameter, failed flag */
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|ap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* process the error response */
name|sctp_asconf_process_error
argument_list|(
name|stcb
argument_list|,
name|aph
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
comment|/* find the corresponding asconf param in our queue */
name|ap
operator|=
name|sctp_asconf_find_param
argument_list|(
name|stcb
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
comment|/* hmm... can't find this in our queue! */
break|break;
block|}
comment|/* process the parameter, success flag */
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|ap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* switch */
comment|/* update remaining ASCONF-ACK message length to process */
name|ack_length
operator|-=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_length
operator|<=
literal|0
condition|)
block|{
comment|/* no more data in the mbuf chain */
break|break;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
block|}
comment|/* while */
comment|/* 	 * if there are any "sent" params still on the queue, these are 	 * implicitly "success", or "failed" (if we got an error back) ... 	 * so process these appropriately 	 * 	 * we assume that the correlation_id's are monotonically increasing 	 * beginning from 1 and that we don't have *that* many outstanding 	 * at any given time 	 */
if|if
condition|(
name|last_error_id
operator|==
literal|0
condition|)
name|last_error_id
operator|--
expr_stmt|;
comment|/* set to "max" value */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|,
argument|aa_next
argument_list|)
block|{
if|if
condition|(
name|aa
operator|->
name|sent
operator|==
literal|1
condition|)
block|{
comment|/* 			 * implicitly successful or failed if correlation_id 			 *< last_error_id, then success else, failure 			 */
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|correlation_id
operator|<
name|last_error_id
condition|)
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|aa
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|aa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * since we always process in order (FIFO queue) if 			 * we reach one that hasn't been sent, the rest 			 * should not have been sent either. so, we're 			 * done... 			 */
break|break;
block|}
block|}
comment|/* update the next sequence number to use */
name|asoc
operator|->
name|asconf_seq_out_acked
operator|++
expr_stmt|;
comment|/* remove the old ASCONF on our outbound queue */
name|sctp_toss_old_asconf
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_TIMER_BASED_ASCONF
comment|/* we have more params, so restart our timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* we have more params, so send out more */
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|uint32_t
name|sctp_is_scopeid_in_nets
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|net6
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
block|{
comment|/* wrong family */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* not link local address */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* hunt through our destination nets list for this scope_id */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|)
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|net6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|net6
operator|->
name|sin6_addr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_same_scope
argument_list|(
name|sin6
argument_list|,
name|net6
argument_list|)
condition|)
block|{
comment|/* found one */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* didn't find one */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * address management functions  */
end_comment

begin_function
specifier|static
name|void
name|sctp_addr_mgmt_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|int
name|addr_locked
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
operator|||
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* subset bound, no ASCONF allowed case, so ignore */
return|return;
block|}
comment|/* 	 * note: we know this is not the subset bound, no ASCONF case eg. 	 * this is boundall or subset bound w/ASCONF allowed 	 */
comment|/* first, make sure that the address is IPv4 or IPv6 and not jailed */
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
operator|.
name|sin_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return;
block|}
break|break;
endif|#
directive|endif
default|default:
return|return;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* make sure we're "allowed" to add this type of addr */
if|if
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* invalid if we're not a v6 endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* is the v6 addr really valid ? */
if|if
condition|(
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
return|return;
block|}
block|}
endif|#
directive|endif
comment|/* put this address on the "pending/do not use yet" list */
name|sctp_add_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
comment|/* 	 * check address scope if address is out of scope, don't queue 	 * anything... note: this would leave the address on both inp and 	 * asoc lists 	 */
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* we skip unspecifed addresses */
return|return;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|local_scope
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* is it the right link local scope? */
if|if
condition|(
name|sctp_is_scopeid_in_nets
argument_list|(
name|stcb
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|site_scope
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return;
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
comment|/* invalid if we are a v6 only endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
return|return;
name|sin
operator|=
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* we skip unspecifed addresses */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|&&
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
return|return;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* else, not AF_INET or AF_INET6, so skip */
return|return;
block|}
comment|/* queue an asconf for this address add/delete */
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* does the peer do asconf? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
condition|)
block|{
comment|/* queue an asconf for this addr */
name|status
operator|=
name|sctp_asconf_queue_add
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * if queued ok, and in the open state, send out the 			 * ASCONF.  If in the non-open state, these will be 			 * sent when the state goes open. 			 */
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
operator|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_TIMER_BASED_ASCONF
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|addr_locked
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
block|}
end_function

begin_function
name|int
name|sctp_asconf_iterator_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|l
decl_stmt|;
name|int
name|cnt_invalid
init|=
literal|0
decl_stmt|;
name|asc
operator|=
operator|(
expr|struct
name|sctp_asconf_iterator
operator|*
operator|)
name|ptr
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|l
argument_list|,
argument|&asc->list_of_work
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|ifa
operator|=
name|l
operator|->
name|ifa
expr_stmt|;
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* invalid if we're not a v6 endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
name|cnt_invalid
operator|++
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
name|cnt_invalid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
comment|/* invalid if we are a v6 only endpoint */
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
name|cnt_invalid
operator|++
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
name|cnt_invalid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* invalid address family */
name|cnt_invalid
operator|++
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
name|cnt_invalid
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_asconf_iterator_ep_end
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|nladdr
decl_stmt|,
modifier|*
name|l
decl_stmt|;
comment|/* Only for specific case not bound all */
name|asc
operator|=
operator|(
expr|struct
name|sctp_asconf_iterator
operator|*
operator|)
name|ptr
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|l
argument_list|,
argument|&asc->list_of_work
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|ifa
operator|=
name|l
operator|->
name|ifa
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|action
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|laddr
operator|->
name|action
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nladdr
argument_list|)
block|{
comment|/* remove only after all guys are done */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sctp_del_local_addr_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_asconf_iterator_stcb
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|l
decl_stmt|;
name|int
name|cnt_invalid
init|=
literal|0
decl_stmt|;
name|int
name|type
decl_stmt|,
name|status
decl_stmt|;
name|int
name|num_queued
init|=
literal|0
decl_stmt|;
name|asc
operator|=
operator|(
expr|struct
name|sctp_asconf_iterator
operator|*
operator|)
name|ptr
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|l
argument_list|,
argument|&asc->list_of_work
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|ifa
operator|=
name|l
operator|->
name|ifa
expr_stmt|;
name|type
operator|=
name|l
operator|->
name|action
expr_stmt|;
comment|/* address's vrf_id must be the vrf_id of the assoc */
if|if
condition|(
name|ifa
operator|->
name|vrf_id
operator|!=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
condition|)
block|{
continue|continue;
block|}
comment|/* Same checks again for assoc */
switch|switch
condition|(
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
comment|/* invalid if we're not a v6 endpoint */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
name|cnt_invalid
operator|++
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
name|cnt_invalid
condition|)
return|return;
else|else
continue|continue;
block|}
name|sin6
operator|=
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* we skip unspecifed addresses */
continue|continue;
block|}
if|if
condition|(
name|prison_check_ip6
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|local_scope
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* is it the right link local scope? */
if|if
condition|(
name|sctp_is_scopeid_in_nets
argument_list|(
name|stcb
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
block|{
comment|/* invalid if we are a v6 only endpoint */
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
comment|/* invalid if we are a v6 only endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
continue|continue;
name|sin
operator|=
operator|&
name|ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* we skip unspecifed addresses */
continue|continue;
block|}
if|if
condition|(
name|prison_check_ip4
argument_list|(
name|inp
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|&&
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
name|cnt_invalid
operator|++
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
name|cnt_invalid
condition|)
return|return;
else|else
continue|continue;
block|}
break|break;
block|}
endif|#
directive|endif
default|default:
comment|/* invalid address family */
name|cnt_invalid
operator|++
expr_stmt|;
if|if
condition|(
name|asc
operator|->
name|cnt
operator|==
name|cnt_invalid
condition|)
return|return;
else|else
continue|continue;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* prevent this address from being used as a source */
name|sctp_add_local_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sctp_rtentry_t
modifier|*
name|rt
decl_stmt|;
comment|/* delete this address if cached */
if|if
condition|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|==
name|ifa
condition|)
block|{
name|sctp_free_ifa
argument_list|(
name|net
operator|->
name|ro
operator|.
name|_s_addr
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|_s_addr
operator|=
name|NULL
expr_stmt|;
name|net
operator|->
name|src_addr_selected
operator|=
literal|0
expr_stmt|;
name|rt
operator|=
name|net
operator|->
name|ro
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 					 * Now we deleted our src address, 					 * should we not also now reset the 					 * cwnd/rto to start as if its a new 					 * address? 					 */
name|stcb
operator|->
name|asoc
operator|.
name|cc_functions
operator|.
name|sctp_set_initial_cc_param
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
name|net
operator|->
name|RTO
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_SET_PRIM_ADDR
condition|)
block|{
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* must validate the ifa is in the ep */
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|ifa
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
else|else
block|{
comment|/* Need to check scopes for this guy */
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|ifa
argument_list|,
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|scope
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
block|}
block|}
comment|/* queue an asconf for this address add/delete */
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
operator|==
literal|1
condition|)
block|{
comment|/* queue an asconf for this addr */
name|status
operator|=
name|sctp_asconf_queue_add
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * if queued ok, and in the open state, update the 			 * count of queued params.  If in the non-open 			 * state, these get sent when the assoc goes open. 			 */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
if|if
condition|(
name|status
operator|>=
literal|0
condition|)
block|{
name|num_queued
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * If we have queued params in the open state, send out an ASCONF. 	 */
if|if
condition|(
name|num_queued
operator|>
literal|0
condition|)
block|{
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_asconf_iterator_end
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uint32_t
name|val
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|l
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|asc
operator|=
operator|(
expr|struct
name|sctp_asconf_iterator
operator|*
operator|)
name|ptr
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|l
argument_list|,
argument|&asc->list_of_work
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nl
argument_list|)
block|{
name|ifa
operator|=
name|l
operator|->
name|ifa
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|action
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* Clear the defer use flag */
name|ifa
operator|->
name|localifa_flags
operator|&=
operator|~
name|SCTP_ADDR_DEFER_USE
expr_stmt|;
block|}
name|sctp_free_ifa
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|SCTP_ZONE_FREE
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|SCTP_DECR_LADDR_COUNT
argument_list|()
expr_stmt|;
block|}
name|SCTP_FREE
argument_list|(
name|asc
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sa is the sockaddr to ask the peer to set primary to.  * returns: 0 = completed, -1 = error  */
end_comment

begin_function
name|int32_t
name|sctp_set_primary_ip_address_sa
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|uint32_t
name|vrf_id
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
comment|/* find the ifa for the desired set primary */
name|vrf_id
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|,
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* Invalid address */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* queue an ASCONF:SET_PRIM_ADDR to be sent */
if|if
condition|(
operator|!
name|sctp_asconf_queue_add
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|SCTP_SET_PRIM_ADDR
argument_list|)
condition|)
block|{
comment|/* set primary queuing succeeded */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"set_primary_ip_address_sa: queued on tcb=%p, "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_TIMER_BASED_ASCONF
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"set_primary_ip_address_sa: failed to add to queue on tcb=%p, "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
name|sa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_set_primary_ip_address
parameter_list|(
name|struct
name|sctp_ifa
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* go through all our PCB's */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|&SCTP_BASE_INFO(listhead)
argument_list|,
argument|sctp_list
argument_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
comment|/* process for all associations for this endpoint */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
comment|/* queue an ASCONF:SET_PRIM_ADDR to be sent */
if|if
condition|(
operator|!
name|sctp_asconf_queue_add
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|SCTP_SET_PRIM_ADDR
argument_list|)
condition|)
block|{
comment|/* set primary queuing succeeded */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"set_primary_ip_address: queued on stcb=%p, "
argument_list|,
operator|(
name|void
operator|*
operator|)
name|stcb
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
operator|&
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_TIMER_BASED_ASCONF
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
comment|/* for each stcb */
block|}
comment|/* for each inp */
block|}
end_function

begin_function
name|int
name|sctp_is_addr_pending
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
parameter_list|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|,
modifier|*
name|nchk
decl_stmt|;
name|unsigned
name|int
name|offset
decl_stmt|,
name|asconf_limit
decl_stmt|;
name|struct
name|sctp_asconf_chunk
modifier|*
name|acp
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|uint8_t
name|aparam_buf
index|[
name|SCTP_PARAM_BUFFER_SIZE
index|]
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|int
name|add_cnt
decl_stmt|,
name|del_cnt
decl_stmt|;
name|uint16_t
name|last_param_type
decl_stmt|;
name|add_cnt
operator|=
name|del_cnt
operator|=
literal|0
expr_stmt|;
name|last_param_type
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.asconf_send_queue
argument_list|,
argument|sctp_next
argument_list|,
argument|nchk
argument_list|)
block|{
if|if
condition|(
name|chk
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"is_addr_pending: No mbuf data?\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
name|acp
operator|=
name|mtod
argument_list|(
name|chk
operator|->
name|data
argument_list|,
expr|struct
name|sctp_asconf_chunk
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
expr_stmt|;
name|asconf_limit
operator|=
name|ntohs
argument_list|(
name|acp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ph
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"is_addr_pending: couldn't get lookup addr!\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|offset
operator|+=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"is_addr_pending: Empty ASCONF will be sent?\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
name|aph
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|param_length
decl_stmt|,
name|param_type
decl_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|param_length
operator|>
name|asconf_limit
condition|)
block|{
comment|/* parameter goes beyond end of chunk! */
break|break;
block|}
if|if
condition|(
name|param_length
operator|>
sizeof|sizeof
argument_list|(
name|aparam_buf
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"is_addr_pending: param length (%u) larger than buffer size!\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|param_length
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"is_addr_pending: param length(%u) too short\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
break|break;
block|}
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|offset
argument_list|,
name|param_length
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"is_addr_pending: couldn't get entire param\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|sctp_addr_match
argument_list|(
name|ph
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
operator|!=
literal|0
condition|)
block|{
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
name|add_cnt
operator|++
expr_stmt|;
break|break;
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
name|del_cnt
operator|++
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|last_param_type
operator|=
name|param_type
expr_stmt|;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|asconf_limit
condition|)
block|{
comment|/* no more data in the mbuf chain */
break|break;
block|}
comment|/* get pointer to next asconf param */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|chk
operator|->
name|data
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * we want to find the sequences which consist of ADD -> DEL -> ADD 	 * or DEL -> ADD 	 */
if|if
condition|(
name|add_cnt
operator|>
name|del_cnt
operator|||
operator|(
name|add_cnt
operator|==
name|del_cnt
operator|&&
name|last_param_type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr
modifier|*
name|sctp_find_valid_localaddr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|addr_locked
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
if|if
condition|(
name|addr_locked
operator|==
name|SCTP_ADDR_NOT_LOCKED
condition|)
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|addr_locked
operator|==
name|SCTP_ADDR_NOT_LOCKED
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|loopback_scope
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* Skip if loopback_scope not set */
continue|continue;
block|}
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* skip unspecifed addresses */
continue|continue;
block|}
if|if
condition|(
name|prison_check_ip4
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|&&
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* 					 * found a valid local v4 address to 					 * use 					 */
if|if
condition|(
name|addr_locked
operator|==
name|SCTP_ADDR_NOT_LOCKED
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
if|if
condition|(
name|sctp_ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_ADDR_IFA_UNUSEABLE
condition|)
block|{
continue|continue;
block|}
name|sin6
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 						 * we skip unspecifed 						 * addresses 						 */
continue|continue;
block|}
if|if
condition|(
name|prison_check_ip6
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|local_scope
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|scope
operator|.
name|site_scope
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|sctp_ifa
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* 					 * found a valid local v6 address to 					 * use 					 */
if|if
condition|(
name|addr_locked
operator|==
name|SCTP_ADDR_NOT_LOCKED
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
block|}
comment|/* no valid addresses found */
if|if
condition|(
name|addr_locked
operator|==
name|SCTP_ADDR_NOT_LOCKED
condition|)
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr
modifier|*
name|sctp_find_valid_localaddr_ep
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* is the address restricted ? */
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
operator|&&
operator|(
operator|!
name|sctp_is_addr_pending
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* found a valid local address to use */
return|return
operator|(
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|)
return|;
block|}
comment|/* no valid addresses found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * builds an ASCONF chunk from queued ASCONF params.  * returns NULL on error (no mbuf, no ASCONF params queued, etc).  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_compose_asconf
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
modifier|*
name|retlen
parameter_list|,
name|int
name|addr_locked
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_asconf
decl_stmt|,
modifier|*
name|m_asconf_chk
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|;
name|struct
name|sctp_asconf_chunk
modifier|*
name|acp
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_asconf_addr_param
modifier|*
name|aap
decl_stmt|;
name|uint32_t
name|p_length
decl_stmt|;
name|uint32_t
name|correlation_id
init|=
literal|1
decl_stmt|;
comment|/* 0 is reserved... */
name|caddr_t
name|ptr
decl_stmt|,
name|lookup_ptr
decl_stmt|;
name|uint8_t
name|lookup_used
init|=
literal|0
decl_stmt|;
comment|/* are there any asconf params to send? */
name|TAILQ_FOREACH
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|aa
operator|->
name|sent
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * get a chunk header mbuf and a cluster for the asconf params since 	 * it's simpler to fill in the asconf chunk header lookup address on 	 * the fly 	 */
name|m_asconf_chk
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_asconf_chk
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"compose_asconf: couldn't get chunk mbuf!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_asconf
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_NOWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_asconf
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"compose_asconf: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
name|sctp_m_freem
argument_list|(
name|m_asconf_chk
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|=
literal|0
expr_stmt|;
name|acp
operator|=
name|mtod
argument_list|(
name|m_asconf_chk
argument_list|,
expr|struct
name|sctp_asconf_chunk
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|acp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save pointers to lookup address and asconf params */
name|lookup_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|acp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* after the header */
name|ptr
operator|=
name|mtod
argument_list|(
name|m_asconf
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* beginning of cluster */
comment|/* fill in chunk header info */
name|acp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|acp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|acp
operator|->
name|serial_number
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_seq_out
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_seq_out
operator|++
expr_stmt|;
comment|/* add parameters... up to smallest MTU allowed */
name|TAILQ_FOREACH
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|aa
operator|->
name|sent
condition|)
continue|continue;
comment|/* get the parameter length */
name|p_length
operator|=
name|SCTP_SIZE32
argument_list|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
comment|/* will it fit in current chunk? */
if|if
condition|(
operator|(
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|+
name|p_length
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|)
operator|||
operator|(
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|+
name|p_length
operator|>
name|MCLBYTES
operator|)
condition|)
block|{
comment|/* won't fit, so we're done with this chunk */
break|break;
block|}
comment|/* assign (and store) a correlation id */
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|correlation_id
operator|=
name|correlation_id
operator|++
expr_stmt|;
comment|/* 		 * fill in address if we're doing a delete this is a simple 		 * way for us to fill in the correlation address, which 		 * should only be used by the peer if we're deleting our 		 * source address and adding a new address (e.g. renumbering 		 * case) 		 */
if|if
condition|(
name|lookup_used
operator|==
literal|0
operator|&&
operator|(
name|aa
operator|->
name|special_del
operator|==
literal|0
operator|)
operator|&&
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|lookup
decl_stmt|;
name|uint16_t
name|p_size
decl_stmt|,
name|addr_size
decl_stmt|;
name|lookup
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|lookup_ptr
expr_stmt|;
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
comment|/* copy IPv6 address */
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy IPv4 address */
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
name|lookup
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lookup
operator|->
name|addr
argument_list|,
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
expr_stmt|;
name|lookup_used
operator|=
literal|1
expr_stmt|;
block|}
comment|/* copy into current space */
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|aa
operator|->
name|ap
argument_list|,
name|p_length
argument_list|)
expr_stmt|;
comment|/* network elements and update lengths */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|aap
operator|=
operator|(
expr|struct
name|sctp_asconf_addr_param
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* correlation_id is transparent to peer, no htonl needed */
name|aph
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_length
argument_list|)
expr_stmt|;
comment|/* 		 * these params are removed off the pending list upon 		 * getting an ASCONF-ACK back from the peer, just set flag 		 */
name|aa
operator|->
name|sent
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check to see if the lookup addr has been populated yet */
if|if
condition|(
name|lookup_used
operator|==
literal|0
condition|)
block|{
comment|/* NOTE: if the address param is optional, can skip this... */
comment|/* add any valid (existing) address... */
name|struct
name|sctp_ipv6addr_param
modifier|*
name|lookup
decl_stmt|;
name|uint16_t
name|p_size
decl_stmt|,
name|addr_size
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|found_addr
decl_stmt|;
name|caddr_t
name|addr_ptr
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
name|found_addr
operator|=
name|sctp_find_valid_localaddr
argument_list|(
name|stcb
argument_list|,
name|addr_locked
argument_list|)
expr_stmt|;
else|else
name|found_addr
operator|=
name|sctp_find_valid_localaddr_ep
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|lookup
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|lookup_ptr
expr_stmt|;
if|if
condition|(
name|found_addr
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|found_addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
comment|/* copy IPv6 address */
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|addr_ptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|found_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* copy IPv4 address */
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|addr_ptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|found_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|p_size
operator|=
literal|0
expr_stmt|;
name|addr_size
operator|=
literal|0
expr_stmt|;
name|addr_ptr
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|lookup
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lookup
operator|->
name|addr
argument_list|,
name|addr_ptr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* uh oh... don't have any address?? */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"compose_asconf: no lookup addr!\n"
argument_list|)
expr_stmt|;
comment|/* XXX for now, we send a IPv4 address of 0.0.0.0 */
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_SIZE32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lookup
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* chain it all together */
name|SCTP_BUF_NEXT
argument_list|(
name|m_asconf_chk
argument_list|)
operator|=
name|m_asconf
expr_stmt|;
operator|*
name|retlen
operator|=
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
expr_stmt|;
name|acp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
operator|*
name|retlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|m_asconf_chk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * section to handle address changes before an association is up eg. changes  * during INIT/INIT-ACK/COOKIE-ECHO handshake  */
end_comment

begin_comment
comment|/*  * processes the (local) addresses in the INIT-ACK chunk  */
end_comment

begin_function
specifier|static
name|void
name|sctp_process_initack_addresses
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
name|tmp_param
decl_stmt|,
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|,
name|ptype
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|union
name|sctp_sockstore
name|store
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sctp_ipv6addr_param
name|addr6_store
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
name|struct
name|sctp_ipv4addr_param
name|addr4_store
decl_stmt|;
endif|#
directive|endif
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
literal|"processing init-ack addresses\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
comment|/* Un-needed check for SA */
return|return;
comment|/* convert to upper bound */
name|length
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|>
name|length
condition|)
block|{
return|return;
block|}
comment|/* go through the addresses in the init-ack */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
while|while
condition|(
name|ph
operator|!=
name|NULL
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|a6p
decl_stmt|;
comment|/* get the entire IPv6 address param */
name|a6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr6_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|a6p
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|sctp_sockstore
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin6
operator|.
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|store
operator|.
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|a6p
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|a4p
decl_stmt|;
comment|/* get the entire IPv4 address param */
name|a4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr4_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|a4p
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memset
argument_list|(
operator|&
name|store
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|sctp_sockstore
argument_list|)
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|store
operator|.
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|a4p
operator|->
name|addr
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
default|default:
goto|goto
name|next_addr
goto|;
block|}
comment|/* see if this address really (still) exists */
name|sctp_ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
operator|&
name|store
operator|.
name|sa
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address doesn't exist anymore */
name|int
name|status
decl_stmt|;
comment|/* are ASCONFs allowed ? */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_supported
condition|)
block|{
comment|/* queue an ASCONF DEL_IP_ADDRESS */
name|status
operator|=
name|sctp_asconf_queue_sa_delete
argument_list|(
name|stcb
argument_list|,
operator|&
name|store
operator|.
name|sa
argument_list|)
expr_stmt|;
comment|/* 				 * if queued ok, and in correct state, send 				 * out the ASCONF. 				 */
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_TIMER_BASED_ASCONF
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
else|#
directive|else
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
name|next_addr
label|:
comment|/* 		 * Sanity check:  Make sure the length isn't 0, otherwise 		 * we'll be stuck in this loop for a long time... 		 */
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"process_initack_addrs: bad len (%d) type=%xh\n"
argument_list|,
name|plen
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get next parameter */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|>
name|length
condition|)
return|return;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
block|}
comment|/* while */
block|}
end_function

begin_comment
comment|/* FIX ME: need to verify return result for v6 address type if v6 disabled */
end_comment

begin_comment
comment|/*  * checks to see if a specific address is in the initack address list returns  * 1 if found, 0 if not  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_addr_in_initack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
name|tmp_param
decl_stmt|,
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|,
name|ptype
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|a4p
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
name|addr4_store
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|a6p
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
name|addr6_store
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6_tmp
decl_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
break|break;
endif|#
directive|endif
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
literal|"find_initack_addr: starting search for "
argument_list|)
expr_stmt|;
name|SCTPDBG_ADDR
argument_list|(
name|SCTP_DEBUG_ASCONF2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
comment|/* convert to upper bound */
name|length
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|>
name|length
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"find_initack_addr: invalid offset?\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* go through the addresses in the init-ack */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
while|while
condition|(
name|ph
operator|!=
name|NULL
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ptype
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* get the entire IPv6 address param */
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* get the entire IPv6 address param */
name|a6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr6_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|a6p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* create a copy and clear scope */
name|memcpy
argument_list|(
operator|&
name|sin6_tmp
argument_list|,
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|&
name|sin6_tmp
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|a6p
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
ifdef|#
directive|ifdef
name|INET
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
break|break;
block|}
comment|/* get the entire IPv4 address param */
name|a4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr4_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|a4p
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|a4p
operator|->
name|addr
condition|)
block|{
comment|/* found it */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* get next parameter */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|>
name|length
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
block|}
comment|/* while */
comment|/* not found! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * makes sure that the current endpoint local addr list is consistent with  * the new association (eg. subset bound, asconf allowed) adds addresses as  * necessary  */
end_comment

begin_function
specifier|static
name|void
name|sctp_check_address_list_ep
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_addr
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* go through the endpoint list */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
comment|/* be paranoid and validate the laddr */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"check_addr_list_ep: laddr->ifa is NULL"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"check_addr_list_ep: laddr->ifa->ifa_addr is NULL"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* do i have it implicitly? */
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|,
name|init_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* check to see if in the init-ack */
if|if
condition|(
operator|!
name|sctp_addr_in_initack
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
condition|)
block|{
comment|/* try to add it */
name|sctp_addr_mgmt_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * makes sure that the current kernel address list is consistent with the new  * association (with all addrs bound) adds addresses as necessary  */
end_comment

begin_function
specifier|static
name|void
name|sctp_check_address_list_all
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_addr
parameter_list|,
name|uint16_t
name|local_scope
parameter_list|,
name|uint16_t
name|site_scope
parameter_list|,
name|uint16_t
name|ipv4_scope
parameter_list|,
name|uint16_t
name|loopback_scope
parameter_list|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifn
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
condition|)
block|{
name|vrf_id
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|vrf_id
expr_stmt|;
block|}
else|else
block|{
return|return;
block|}
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* go through all our known interfaces */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifn
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
if|if
condition|(
name|loopback_scope
operator|==
literal|0
operator|&&
name|SCTP_IFN_IS_IFT_LOOP
argument_list|(
name|sctp_ifn
argument_list|)
condition|)
block|{
comment|/* skip loopback interface */
continue|continue;
block|}
comment|/* go through each interface address */
name|LIST_FOREACH
argument_list|(
argument|sctp_ifa
argument_list|,
argument|&sctp_ifn->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
comment|/* do i have it implicitly? */
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
argument_list|,
name|init_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
switch|switch
condition|(
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|prison_check_ip4
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|ipv4_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* private address not in scope */
continue|continue;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|prison_check_ip6
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* check to see if in the init-ack */
if|if
condition|(
operator|!
name|sctp_addr_in_initack
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
operator|&
name|sctp_ifa
operator|->
name|address
operator|.
name|sa
argument_list|)
condition|)
block|{
comment|/* try to add it */
name|sctp_addr_mgmt_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|sctp_ifa
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|,
name|SCTP_ADDR_LOCKED
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end foreach ifa */
block|}
comment|/* end foreach ifn */
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * validates an init-ack chunk (from a cookie-echo) with current addresses  * adds addresses from the init-ack into our local address list, if needed  * queues asconf adds/deletes addresses as needed and makes appropriate list  * changes for source address selection m, offset: points to the start of the  * address list in an init-ack chunk length: total length of the address  * params only init_addr: address where my INIT-ACK was sent from  */
end_comment

begin_function
name|void
name|sctp_check_address_list
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_addr
parameter_list|,
name|uint16_t
name|local_scope
parameter_list|,
name|uint16_t
name|site_scope
parameter_list|,
name|uint16_t
name|ipv4_scope
parameter_list|,
name|uint16_t
name|loopback_scope
parameter_list|)
block|{
comment|/* process the local addresses in the initack */
name|sctp_process_initack_addresses
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* bound all case */
name|sctp_check_address_list_all
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|init_addr
argument_list|,
name|local_scope
argument_list|,
name|site_scope
argument_list|,
name|ipv4_scope
argument_list|,
name|loopback_scope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* subset bound case */
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* asconf's allowed */
name|sctp_check_address_list_ep
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|init_addr
argument_list|)
expr_stmt|;
block|}
comment|/* else, no asconfs allowed, so what we sent is what we get */
block|}
block|}
end_function

begin_comment
comment|/*  * sctp_bindx() support  */
end_comment

begin_function
name|uint32_t
name|sctp_addr_mgmt_ep_sa
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint32_t
name|type
parameter_list|,
name|uint32_t
name|vrf_id
parameter_list|,
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
parameter_list|)
block|{
name|struct
name|sctp_ifa
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|nladdr
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|==
literal|0
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|sctp_ifap
condition|)
block|{
name|ifa
operator|=
name|sctp_ifap
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* For an add the address MUST be on the system */
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|,
name|vrf_id
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* For a delete we need to find it in the inp */
name|ifa
operator|=
name|sctp_find_ifa_in_ep
argument_list|(
name|inp
argument_list|,
name|sa
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifa
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
name|sctp_add_local_addr_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|laddr_count
operator|<
literal|2
condition|)
block|{
comment|/* can't delete the last local address */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|==
name|laddr
operator|->
name|ifa
condition|)
block|{
comment|/* Mark in the delete */
name|laddr
operator|->
name|action
operator|=
name|type
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
condition|)
block|{
comment|/* 			 * There is no need to start the iterator if the inp 			 * has no associations. 			 */
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|,
argument|nladdr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sctp_del_local_addr_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_asconf_iterator
modifier|*
name|asc
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|SCTP_MALLOC
argument_list|(
name|asc
argument_list|,
expr|struct
name|sctp_asconf_iterator
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_iterator
argument_list|)
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
if|if
condition|(
name|asc
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|wi
operator|=
name|SCTP_ZONE_GET
argument_list|(
name|SCTP_BASE_INFO
argument_list|(
name|ipi_zone_laddr
argument_list|)
argument_list|,
expr|struct
name|sctp_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE
argument_list|(
name|asc
argument_list|,
name|SCTP_M_ASC_IT
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|LIST_INIT
argument_list|(
operator|&
name|asc
operator|->
name|list_of_work
argument_list|)
expr_stmt|;
name|asc
operator|->
name|cnt
operator|=
literal|1
expr_stmt|;
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|type
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|ifa
operator|->
name|refcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|asc
operator|->
name|list_of_work
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|sctp_initiate_iterator
argument_list|(
name|sctp_asconf_iterator_ep
argument_list|,
name|sctp_asconf_iterator_stcb
argument_list|,
name|sctp_asconf_iterator_ep_end
argument_list|,
name|SCTP_PCB_ANY_FLAGS
argument_list|,
name|SCTP_PCB_ANY_FEATURES
argument_list|,
name|SCTP_ASOC_ANY_STATE
argument_list|,
operator|(
name|void
operator|*
operator|)
name|asc
argument_list|,
literal|0
argument_list|,
name|sctp_asconf_iterator_end
argument_list|,
name|inp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"Failed to initiate iterator for addr_mgmt_ep_sa\n"
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|EFAULT
argument_list|)
expr_stmt|;
name|sctp_asconf_iterator_end
argument_list|(
name|asc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* invalid address! */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
argument_list|,
name|EADDRNOTAVAIL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sctp_asconf_send_nat_state_update
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifap
decl_stmt|;
name|struct
name|sctp_asconf_tag_param
modifier|*
name|vtag
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in
modifier|*
name|to
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|to6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|net
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: Missing net\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: Missing stcb\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Need to have in the asconf: - vtagparam(my_vtag/peer_vtag) - 	 * add(0.0.0.0) - del(0.0.0.0) - Any global addresses add(addr) 	 */
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: failed to get memory!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|aa
operator|->
name|special_del
operator|=
literal|0
expr_stmt|;
comment|/* fill in asconf address parameter fields */
comment|/* top level elements are "networked" during send */
name|aa
operator|->
name|ifa
operator|=
name|NULL
expr_stmt|;
name|aa
operator|->
name|sent
operator|=
literal|0
expr_stmt|;
comment|/* clear sent flag */
name|vtag
operator|=
operator|(
expr|struct
name|sctp_asconf_tag_param
operator|*
operator|)
operator|&
name|aa
operator|->
name|ap
operator|.
name|aph
expr_stmt|;
name|vtag
operator|->
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_NAT_VTAGS
expr_stmt|;
name|vtag
operator|->
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_tag_param
argument_list|)
expr_stmt|;
name|vtag
operator|->
name|local_vtag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|my_vtag
argument_list|)
expr_stmt|;
name|vtag
operator|->
name|remote_vtag
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: failed to get memory!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|aa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in asconf address parameter fields */
comment|/* ADD(0.0.0.0) */
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_ADD_IP_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
comment|/* No need to add an address, we are using 0.0.0.0 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_ADD_IP_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
comment|/* No need to add an address, we are using 0.0.0.0 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: unknown address family\n"
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
return|return;
block|}
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: failed to get memory!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|memset
argument_list|(
name|aa
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* fill in asconf address parameter fields */
comment|/* ADD(0.0.0.0) */
switch|switch
condition|(
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_ADD_IP_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addrv4_param
argument_list|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
comment|/* No need to add an address, we are using 0.0.0.0 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_DEL_IP_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_addr_param
argument_list|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
comment|/* No need to add an address, we are using 0.0.0.0 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_ASCONF1
argument_list|,
literal|"sctp_asconf_send_nat_state_update: unknown address family\n"
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|aa
argument_list|,
name|SCTP_M_ASC_ADDR
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Now we must hunt the addresses and add all global addresses */
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|struct
name|sctp_vrf
modifier|*
name|vrf
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_ifn
modifier|*
name|sctp_ifnp
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|vrf_id
operator|=
name|stcb
operator|->
name|sctp_ep
operator|->
name|def_vrf_id
expr_stmt|;
name|vrf
operator|=
name|sctp_find_vrf
argument_list|(
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|vrf
operator|==
name|NULL
condition|)
block|{
goto|goto
name|skip_rest
goto|;
block|}
name|SCTP_IPI_ADDR_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|sctp_ifnp
argument_list|,
argument|&vrf->ifnlist
argument_list|,
argument|next_ifn
argument_list|)
block|{
name|LIST_FOREACH
argument_list|(
argument|sctp_ifap
argument_list|,
argument|&sctp_ifnp->ifalist
argument_list|,
argument|next_ifa
argument_list|)
block|{
switch|switch
condition|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|to
operator|=
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|prison_check_ip4
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|to6
operator|=
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|prison_check_ip6
argument_list|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|ip_inp
operator|.
name|inp
operator|.
name|inp_cred
argument_list|,
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
operator|!=
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
default|default:
continue|continue;
block|}
name|sctp_asconf_queue_mgmt
argument_list|(
name|stcb
argument_list|,
name|sctp_ifap
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|)
expr_stmt|;
block|}
block|}
name|SCTP_IPI_ADDR_RUNLOCK
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|localifa_flags
operator|&
name|SCTP_BEING_DELETED
condition|)
comment|/* 				 * Address being deleted by the system, dont 				 * list. 				 */
continue|continue;
if|if
condition|(
name|laddr
operator|->
name|action
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* 				 * Address being deleted on this ep don't 				 * list. 				 */
continue|continue;
block|}
name|sctp_ifap
operator|=
name|laddr
operator|->
name|ifa
expr_stmt|;
switch|switch
condition|(
name|sctp_ifap
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
name|to
operator|=
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin
expr_stmt|;
if|if
condition|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|to6
operator|=
operator|&
name|sctp_ifap
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|to6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
break|break;
endif|#
directive|endif
default|default:
continue|continue;
block|}
name|sctp_asconf_queue_mgmt
argument_list|(
name|stcb
argument_list|,
name|sctp_ifap
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|)
expr_stmt|;
block|}
block|}
name|skip_rest
label|:
comment|/* Now we must send the asconf into the queue */
name|sctp_send_asconf
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_ADDR_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

