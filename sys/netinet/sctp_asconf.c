begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2006, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_asconf.c,v 1.24 2005/03/06 16:04:16 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_compat.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_sctp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_comment
comment|/*  * debug flags:  * SCTP_DEBUG_ASCONF1: protocol info, general info and errors  * SCTP_DEBUG_ASCONF2: detailed info  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|uint32_t
name|sctp_debug_on
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCTP_DEBUG */
end_comment

begin_function
specifier|static
name|int
name|sctp_asconf_get_source_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
comment|/* IPv4 source */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
name|bzero
argument_list|(
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
literal|0
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
return|return
literal|0
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
comment|/* IPv6 source */
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|bzero
argument_list|(
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
literal|0
expr_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
return|return
literal|0
return|;
block|}
endif|#
directive|endif
comment|/* INET6 */
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * draft-ietf-tsvwg-addip-sctp  *  * Address management only currently supported For the bound all case: the asoc  * local addr list is always a "DO NOT USE" list For the subset bound case:  * If ASCONFs are allowed: the endpoint local addr list is the usable address  * list the asoc local addr list is the "DO NOT USE" list If ASCONFs are not  * allowed: the endpoint local addr list is the default usable list the asoc  * local addr list is the usable address list  *  * An ASCONF parameter queue exists per asoc which holds the pending address  * operations.  Lists are updated upon receipt of ASCONF-ACK.  *  * Deleted addresses are always immediately removed from the lists as they will  * (shortly) no longer exist in the kernel.  We send ASCONFs as a courtesy,  * only if allowed.  */
end_comment

begin_comment
comment|/*  * ASCONF parameter processing response_required: set if a reply is required  * (eg. SUCCESS_REPORT) returns a mbuf to an "error" response parameter or  * NULL/"success" if ok FIX: allocating this many mbufs on the fly is pretty  * inefficient...  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_asconf_success_response
parameter_list|(
name|uint32_t
name|id
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|m_reply
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_reply
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_success_response: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
name|NULL
return|;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m_reply
argument_list|,
expr|struct
name|sctp_asconf_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|aph
operator|->
name|correlation_id
operator|=
name|id
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_SUCCESS_REPORT
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_reply
argument_list|)
operator|=
name|aph
operator|->
name|ph
operator|.
name|param_length
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
return|return
name|m_reply
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_asconf_error_response
parameter_list|(
name|uint32_t
name|id
parameter_list|,
name|uint16_t
name|cause
parameter_list|,
name|uint8_t
modifier|*
name|error_tlv
parameter_list|,
name|uint16_t
name|tlv_length
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_error_cause
modifier|*
name|error
decl_stmt|;
name|uint8_t
modifier|*
name|tlv
decl_stmt|;
name|m_reply
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
name|tlv_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
operator|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_reply
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_error_response: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
name|NULL
return|;
block|}
name|aph
operator|=
name|mtod
argument_list|(
name|m_reply
argument_list|,
expr|struct
name|sctp_asconf_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
expr|struct
name|sctp_error_cause
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|aph
operator|->
name|correlation_id
operator|=
name|id
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_ERROR_CAUSE_IND
argument_list|)
expr_stmt|;
name|error
operator|->
name|code
operator|=
name|htons
argument_list|(
name|cause
argument_list|)
expr_stmt|;
name|error
operator|->
name|length
operator|=
name|tlv_length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|error
operator|->
name|length
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|>
name|MLEN
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_error_response: tlv_length (%xh) too big\n"
argument_list|,
name|tlv_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_m_freem
argument_list|(
name|m_reply
argument_list|)
expr_stmt|;
comment|/* discard */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|error_tlv
operator|!=
name|NULL
condition|)
block|{
name|tlv
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|(
name|error
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|tlv
argument_list|,
name|error_tlv
argument_list|,
name|tlv_length
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_reply
argument_list|)
operator|=
name|aph
operator|->
name|ph
operator|.
name|param_length
expr_stmt|;
name|error
operator|->
name|length
operator|=
name|htons
argument_list|(
name|error
operator|->
name|length
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
return|return
name|m_reply
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_process_asconf_add_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|response_required
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_storage
name|sa_source
decl_stmt|,
name|sa_store
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|,
name|param_length
decl_stmt|,
name|aparam_length
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|aparam_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|param_type
operator|=
name|ntohs
argument_list|(
name|v4addr
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|v4addr
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
name|NULL
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
name|bzero
argument_list|(
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|v4addr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_add_ip: adding "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
break|break;
case|case
name|SCTP_IPV6_ADDRESS
case|:
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
name|NULL
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
name|bzero
argument_list|(
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|v6addr
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_add_ip: adding "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
else|#
directive|else
comment|/* IPv6 not enabled! */
comment|/* FIX ME: currently sends back an invalid param error */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_INVALID_PARAM
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_add_ip: v6 disabled- skipping "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
name|m_reply
return|;
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
name|m_reply
return|;
block|}
comment|/* end switch */
comment|/* if 0.0.0.0/::0, add the source address instead */
if|if
condition|(
name|zero_address
operator|&&
name|sctp_nat_friendly
condition|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_source
expr_stmt|;
name|sctp_asconf_get_source_ip
argument_list|(
name|m
argument_list|,
name|sa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_add_ip: using source addr "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
comment|/* add the address */
if|if
condition|(
name|sctp_add_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_ADDR_DYNAMIC_ADDED
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_add_ip: error adding address\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_RESOURCE_SHORTAGE
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_ADD_IP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_HEARTBEAT
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|m_reply
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_asconf_del_remote_addrs_except
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|src_net
decl_stmt|,
modifier|*
name|net
decl_stmt|;
comment|/* make sure the source address exists as a destination net */
name|src_net
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_net
operator|==
name|NULL
condition|)
block|{
comment|/* not found */
return|return
operator|-
literal|1
return|;
block|}
comment|/* delete all destination addresses except the source */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
name|net
operator|!=
name|src_net
condition|)
block|{
comment|/* delete this address */
name|sctp_remove_net
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_del_remote_addrs_except: deleting "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_DELETE_IP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_process_asconf_delete_ip
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|response_required
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_storage
name|sa_source
decl_stmt|,
name|sa_store
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|,
name|param_length
decl_stmt|,
name|aparam_length
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
comment|/* get the source IP address for src and 0.0.0.0/::0 delete checks */
name|sctp_asconf_get_source_ip
argument_list|(
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_source
argument_list|)
expr_stmt|;
name|aparam_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|param_type
operator|=
name|ntohs
argument_list|(
name|v4addr
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|v4addr
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
name|NULL
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
name|bzero
argument_list|(
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|v4addr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_delete_ip: deleting "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
break|break;
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
name|bzero
argument_list|(
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|v6addr
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_delete_ip: deleting "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
else|#
directive|else
comment|/* IPv6 not enabled!  No "action" needed; just ack it */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_delete_ip: v6 disabled- ignoring: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* just respond with a "success" ASCONF-ACK */
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
name|m_reply
return|;
block|}
comment|/* make sure the source address is not being deleted */
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|sa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_source
argument_list|)
condition|)
block|{
comment|/* trying to delete the source address! */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_delete_ip: tried to delete source addr\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_DELETING_SRC_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
name|m_reply
return|;
block|}
comment|/* if deleting 0.0.0.0/::0, delete all addresses except src addr */
if|if
condition|(
name|zero_address
operator|&&
name|sctp_nat_friendly
condition|)
block|{
name|result
operator|=
name|sctp_asconf_del_remote_addrs_except
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_source
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
block|{
comment|/* src address did not exist? */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_delete_ip: src addr does not exist?\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* what error to reply with?? */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_REQUEST_REFUSED
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
return|return
name|m_reply
return|;
block|}
comment|/* delete the address */
name|result
operator|=
name|sctp_del_remote_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|)
expr_stmt|;
comment|/* 	 * note if result == -2, the address doesn't exist in the asoc but 	 * since it's being deleted anyways, we just ack the delete -- but 	 * this probably means something has already gone awry 	 */
if|if
condition|(
name|result
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* only one address in the asoc */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_delete_ip: tried to delete last IP addr!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_DELETING_LAST_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_DELETE_IP
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
return|return
name|m_reply
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_process_asconf_set_primary
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|response_required
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_reply
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_storage
name|sa_source
decl_stmt|,
name|sa_store
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|v4addr
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|,
name|param_length
decl_stmt|,
name|aparam_length
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|zero_address
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|v6addr
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|aparam_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|v4addr
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|v6addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* INET6 */
name|param_type
operator|=
name|ntohs
argument_list|(
name|v4addr
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|v4addr
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_IPV4_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
name|NULL
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
name|bzero
argument_list|(
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|v4addr
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|INADDR_ANY
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_set_primary: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
break|break;
case|case
name|SCTP_IPV6_ADDRESS
case|:
if|if
condition|(
name|param_length
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
condition|)
block|{
comment|/* invalid param size */
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|sa_store
expr_stmt|;
name|bzero
argument_list|(
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|v6addr
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
name|zero_address
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_set_primary: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
else|#
directive|else
comment|/* IPv6 not enabled!  No "action" needed; just ack it */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_set_primary: v6 disabled- ignoring: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* just respond with a "success" ASCONF-ACK */
return|return
name|NULL
return|;
endif|#
directive|endif
comment|/* INET6 */
break|break;
default|default:
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
return|return
name|m_reply
return|;
block|}
comment|/* if 0.0.0.0/::0, use the source address instead */
if|if
condition|(
name|zero_address
operator|&&
name|sctp_nat_friendly
condition|)
block|{
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa_source
expr_stmt|;
name|sctp_asconf_get_source_ip
argument_list|(
name|m
argument_list|,
name|sa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_set_primary: using source addr "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
comment|/* set the primary address */
if|if
condition|(
name|sctp_set_primary_addr
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_set_primary: primary address set\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* notify upper layer */
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_ASCONF_SET_PRIMARY
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|response_required
condition|)
block|{
name|m_reply
operator|=
name|sctp_asconf_success_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* couldn't set the requested primary address! */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_asconf_set_primary: set primary failed!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* must have been an invalid address, so report */
name|m_reply
operator|=
name|sctp_asconf_error_response
argument_list|(
name|aph
operator|->
name|correlation_id
argument_list|,
name|SCTP_CAUSE_UNRESOLVABLE_ADDR
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|aph
argument_list|,
name|aparam_length
argument_list|)
expr_stmt|;
block|}
return|return
name|m_reply
return|;
block|}
end_function

begin_comment
comment|/*  * handles an ASCONF chunk.  * if all parameters are processed ok, send a plain (empty) ASCONF-ACK  */
end_comment

begin_function
name|void
name|sctp_handle_asconf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|struct
name|sctp_asconf_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|serial_num
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m_ack
decl_stmt|,
modifier|*
name|m_result
decl_stmt|,
modifier|*
name|m_tail
decl_stmt|;
name|struct
name|sctp_asconf_ack_chunk
modifier|*
name|ack_cp
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|,
modifier|*
name|ack_aph
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|p_addr
decl_stmt|;
name|unsigned
name|int
name|asconf_limit
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* did an error occur? */
comment|/* asconf param buffer */
specifier|static
name|uint8_t
name|aparam_buf
index|[
name|DEFAULT_PARAM_BUFFER
index|]
decl_stmt|;
comment|/* verify minimum length */
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: chunk too small = %xh\n"
argument_list|,
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|serial_num
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|serial_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_num
operator|==
name|asoc
operator|->
name|asconf_seq_in
condition|)
block|{
comment|/* got a duplicate ASCONF */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: got duplicate serial number = %xh\n"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* resend last ASCONF-ACK... */
name|sctp_send_asconf_ack
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|serial_num
operator|!=
operator|(
name|asoc
operator|->
name|asconf_seq_in
operator|+
literal|1
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: incorrect serial number = %xh (expected next = %xh)\n"
argument_list|,
name|serial_num
argument_list|,
name|asoc
operator|->
name|asconf_seq_in
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
comment|/* it's the expected "next" sequence number, so process it */
name|asoc
operator|->
name|asconf_seq_in
operator|=
name|serial_num
expr_stmt|;
comment|/* update sequence */
comment|/* get length of all the param's in the ASCONF */
name|asconf_limit
operator|=
name|offset
operator|+
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: asconf_limit=%u, sequence=%xh\n"
argument_list|,
name|asconf_limit
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
if|if
condition|(
name|asoc
operator|->
name|last_asconf_ack_sent
operator|!=
name|NULL
condition|)
block|{
comment|/* free last ASCONF-ACK message sent */
name|sctp_m_freem
argument_list|(
name|asoc
operator|->
name|last_asconf_ack_sent
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|last_asconf_ack_sent
operator|=
name|NULL
expr_stmt|;
block|}
name|m_ack
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_ack
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
name|m_tail
operator|=
name|m_ack
expr_stmt|;
comment|/* current reply chain's tail */
comment|/* fill in ASCONF-ACK header */
name|ack_cp
operator|=
name|mtod
argument_list|(
name|m_ack
argument_list|,
expr|struct
name|sctp_asconf_ack_chunk
operator|*
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ASCONF_ACK
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|ack_cp
operator|->
name|serial_number
operator|=
name|htonl
argument_list|(
name|serial_num
argument_list|)
expr_stmt|;
comment|/* set initial lengths (eg. just an ASCONF-ACK), ntohx at the end! */
name|SCTP_BUF_LEN
argument_list|(
name|m_ack
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
comment|/* skip the lookup address parameter */
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
expr_stmt|;
name|p_addr
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_addr
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: couldn't get lookup addr!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* respond with a missing/invalid mandatory parameter error */
return|return;
block|}
comment|/* param_length is already validated in process_control... */
name|offset
operator|+=
name|ntohs
argument_list|(
name|p_addr
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
comment|/* skip lookup addr */
comment|/* get pointer to first asconf param in ASCONF-ACK */
name|ack_aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m_ack
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|ack_aph
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Gak in asconf2\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* get pointer to first asconf param in ASCONF */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Empty ASCONF received?\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|send_reply
goto|;
block|}
comment|/* process through all parameters */
while|while
condition|(
name|aph
operator|!=
name|NULL
condition|)
block|{
name|unsigned
name|int
name|param_length
decl_stmt|,
name|param_type
decl_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|param_length
operator|>
name|asconf_limit
condition|)
block|{
comment|/* parameter goes beyond end of chunk! */
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
name|m_result
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|param_length
operator|>
sizeof|sizeof
argument_list|(
name|aparam_buf
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: param length (%u) larger than buffer size!\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param_length
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: param length (%u) too short\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
block|}
comment|/* get the entire parameter */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|param_length
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"Gag\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_m_freem
argument_list|(
name|m_ack
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
name|asoc
operator|->
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
name|m_result
operator|=
name|sctp_process_asconf_add_ip
argument_list|(
name|m
argument_list|,
name|aph
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
name|asoc
operator|->
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
name|m_result
operator|=
name|sctp_process_asconf_delete_ip
argument_list|(
name|m
argument_list|,
name|aph
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
comment|/* not valid in an ASCONF chunk */
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
name|asoc
operator|->
name|peer_supports_asconf
operator|=
literal|1
expr_stmt|;
name|m_result
operator|=
name|sctp_process_asconf_set_primary
argument_list|(
name|m
argument_list|,
name|aph
argument_list|,
name|stcb
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
comment|/* not valid in an ASCONF chunk */
break|break;
case|case
name|SCTP_ULP_ADAPTATION
case|:
comment|/* FIX */
break|break;
default|default:
if|if
condition|(
operator|(
name|param_type
operator|&
literal|0x8000
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Been told to STOP at this param */
name|asconf_limit
operator|=
name|offset
expr_stmt|;
comment|/* 				 * FIX FIX - We need to call 				 * sctp_arethere_unrecognized_parameters() 				 * to get a operr and send it for any 				 * param's with the 0x4000 bit set OR do it 				 * here ourselves... note we still must STOP 				 * if the 0x8000 bit is clear. 				 */
block|}
comment|/* unknown/invalid param type */
break|break;
block|}
comment|/* switch */
comment|/* add any (error) result to the reply mbuf chain */
if|if
condition|(
name|m_result
operator|!=
name|NULL
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|m_tail
argument_list|)
operator|=
name|m_result
expr_stmt|;
name|m_tail
operator|=
name|m_result
expr_stmt|;
comment|/* update lengths, make sure it's aligned too */
name|SCTP_BUF_LEN
argument_list|(
name|m_result
argument_list|)
operator|=
name|SCTP_SIZE32
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m_result
argument_list|)
argument_list|)
expr_stmt|;
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|+=
name|SCTP_BUF_LEN
argument_list|(
name|m_result
argument_list|)
expr_stmt|;
comment|/* set flag to force success reports */
name|error
operator|=
literal|1
expr_stmt|;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
comment|/* update remaining ASCONF message length to process */
if|if
condition|(
name|offset
operator|>=
name|asconf_limit
condition|)
block|{
comment|/* no more data in the mbuf chain */
break|break;
block|}
comment|/* get pointer to next asconf param */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
comment|/* can't get an asconf paramhdr */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf: can't get asconf param hdr!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* FIX ME - add error here... */
block|}
block|}
comment|/* while */
name|send_reply
label|:
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|htons
argument_list|(
name|ack_cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
expr_stmt|;
comment|/* save the ASCONF-ACK reply */
name|asoc
operator|->
name|last_asconf_ack_sent
operator|=
name|m_ack
expr_stmt|;
comment|/* see if last_control_chunk_from is set properly (use IP src addr) */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * this could happen if the source address was just newly 		 * added 		 */
name|struct
name|ip
modifier|*
name|iph
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|struct
name|sockaddr_storage
name|from_store
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|from
init|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from_store
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
name|printf
argument_list|(
literal|"handle_asconf: looking up net for IP source address\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* pullup already done, IP options already stripped */
name|iph
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip
operator|*
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|iph
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|iph
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
name|IPVERSION
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|from4
decl_stmt|;
name|from4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|from_store
expr_stmt|;
name|bzero
argument_list|(
name|from4
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from4
argument_list|)
argument_list|)
expr_stmt|;
name|from4
operator|->
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|from4
operator|->
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|from4
operator|->
name|sin_addr
operator|.
name|s_addr
operator|=
name|iph
operator|->
name|ip_src
operator|.
name|s_addr
expr_stmt|;
name|from4
operator|->
name|sin_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|iph
operator|->
name|ip_v
operator|==
operator|(
name|IPV6_VERSION
operator|>>
literal|4
operator|)
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|from6
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|from6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|from_store
expr_stmt|;
name|bzero
argument_list|(
name|from6
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|from6
argument_list|)
argument_list|)
expr_stmt|;
name|from6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|from6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|from6
operator|->
name|sin6_addr
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|from6
operator|->
name|sin6_port
operator|=
name|sh
operator|->
name|src_port
expr_stmt|;
comment|/* Get the scopes in properly to the sin6 addr's */
comment|/* we probably don't need these operations */
operator|(
name|void
operator|)
name|sa6_recoverscope
argument_list|(
name|from6
argument_list|)
expr_stmt|;
name|sa6_embedscope
argument_list|(
name|from6
argument_list|,
name|ip6_use_defzone
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unknown address type */
name|from
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|from
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"Looking for IP source: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|from
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* look up the from address */
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|=
name|sctp_findnet
argument_list|(
name|stcb
argument_list|,
name|from
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|last_control_chunk_from
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
operator|)
condition|)
name|printf
argument_list|(
literal|"handle_asconf: IP source address not found?!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
block|}
comment|/* and send it (a new one) out... */
name|sctp_send_asconf_ack
argument_list|(
name|stcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * does the address match? returns 0 if not, 1 if so  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_asconf_addr_match
parameter_list|(
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* IPv6 sa address */
comment|/* XXX scopeid */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_IPV6_ADDRESS
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* IPv4 sa address */
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
if|if
condition|(
operator|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_IPV4_ADDRESS
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup for non-responded/OP ERR'd ASCONF  */
end_comment

begin_function
name|void
name|sctp_asconf_cleanup
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
comment|/* mark peer as ASCONF incapable */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
comment|/* 	 * clear out any existing asconfs going out 	 */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|asconf_seq_out
operator|++
expr_stmt|;
comment|/* remove the old ASCONF on our outbound queue */
name|sctp_toss_old_asconf
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * process an ADD/DELETE IP ack from peer.  * addr  corresponding ifaddr to the address being added/deleted.  * type: SCTP_ADD_IP_ADDRESS or SCTP_DEL_IP_ADDRESS.  * flag: 1=success, 0=failure.  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_addr_mgmt_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|addr
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
comment|/* 	 * do the necessary asoc list work- if we get a failure indication, 	 * leave the address on the "do not use" asoc list if we get a 	 * success indication, remove the address from the list 	 */
comment|/* 	 * Note: this will only occur for ADD_IP_ADDRESS, since 	 * DEL_IP_ADDRESS is never actually added to the list... 	 */
if|if
condition|(
name|flag
condition|)
block|{
comment|/* success case, so remove from the list */
name|sctp_del_local_addr_assoc
argument_list|(
name|stcb
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
comment|/* else, leave it on the list */
block|}
end_function

begin_comment
comment|/*  * add an asconf add/delete IP address parameter to the queue.  * type = SCTP_ADD_IP_ADDRESS, SCTP_DEL_IP_ADDRESS, SCTP_SET_PRIM_ADDR.  * returns 0 if completed, non-zero if not completed.  * NOTE: if adding, but delete already scheduled (and not yet sent out),  * simply remove from queue.  Same for deleting an address already scheduled  * for add.  If a duplicate operation is found, ignore the new one.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_asconf_queue_add
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|,
modifier|*
name|aa_next
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
comment|/* see if peer supports ASCONF */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure the request isn't already in the queue */
for|for
control|(
name|aa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa_next
control|)
block|{
name|aa_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* address match? */
if|if
condition|(
name|sctp_asconf_addr_match
argument_list|(
name|aa
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* is the request already in queue (sent or not) */
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|type
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* is the negative request already in queue, and not sent */
if|if
condition|(
name|aa
operator|->
name|sent
operator|==
literal|0
operator|&&
comment|/* add requested, delete already queued */
operator|(
operator|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|&&
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|)
operator|||
comment|/* delete requested, add already queued */
operator|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|&&
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|)
operator|)
condition|)
block|{
comment|/* delete the existing entry in the queue */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* take the entry off the appropriate list */
name|sctp_asconf_addr_mgmt_ack
argument_list|(
name|stcb
argument_list|,
name|aa
operator|->
name|ifa
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* free the entry */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* for each aa */
comment|/* adding new request to the queue */
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
literal|"AsconfAddr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_queue_add: failed to get memory!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* fill in asconf address parameter fields */
comment|/* top level elements are "networked" during send */
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|type
expr_stmt|;
name|aa
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
comment|/* correlation_id filled in during send routine later... */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* IPv6 address */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* IPv4 address */
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
decl_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid family! */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|aa
operator|->
name|sent
operator|=
literal|0
expr_stmt|;
comment|/* clear sent flag */
comment|/* 	 * if we are deleting an address it should go out last otherwise, 	 * add it to front of the pending queue 	 */
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* add goes to the front of the queue */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF2
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_queue_add: appended asconf ADD_IP_ADDRESS: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
else|else
block|{
comment|/* delete and set primary goes to the back of the queue */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF2
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_queue_add: inserted asconf DEL_IP_ADDRESS: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"asconf_queue_add: inserted asconf SET_PRIM_ADDR: "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * add an asconf add/delete IP address parameter to the queue by addr.  * type = SCTP_ADD_IP_ADDRESS, SCTP_DEL_IP_ADDRESS, SCTP_SET_PRIM_ADDR.  * returns 0 if completed, non-zero if not completed.  * NOTE: if adding, but delete already scheduled (and not yet sent out),  * simply remove from queue.  Same for deleting an address already scheduled  * for add.  If a duplicate operation is found, ignore the new one.  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_asconf_queue_add_sa
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|,
modifier|*
name|aa_next
decl_stmt|;
comment|/* see if peer supports ASCONF */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure the request isn't already in the queue */
for|for
control|(
name|aa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa_next
control|)
block|{
name|aa_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* address match? */
if|if
condition|(
name|sctp_asconf_addr_match
argument_list|(
name|aa
argument_list|,
name|sa
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* is the request already in queue (sent or not) */
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|type
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* is the negative request already in queue, and not sent */
if|if
condition|(
name|aa
operator|->
name|sent
operator|==
literal|1
condition|)
continue|continue;
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
operator|&&
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
comment|/* add requested, delete already queued */
comment|/* delete the existing entry in the queue */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* free the entry */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
operator|&&
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* delete requested, add already queued */
comment|/* delete the existing entry in the queue */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
comment|/* take the entry off the appropriate list */
name|sctp_asconf_addr_mgmt_ack
argument_list|(
name|stcb
argument_list|,
name|aa
operator|->
name|ifa
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* free the entry */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* for each aa */
comment|/* adding new request to the queue */
name|SCTP_MALLOC
argument_list|(
name|aa
argument_list|,
expr|struct
name|sctp_asconf_addr
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aa
argument_list|)
argument_list|,
literal|"AsconfAddr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|==
name|NULL
condition|)
block|{
comment|/* didn't get memory */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_queue_add_sa: failed to get memory!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* fill in asconf address parameter fields */
comment|/* top level elements are "networked" during send */
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|=
name|type
expr_stmt|;
name|aa
operator|->
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|)
expr_stmt|;
comment|/* correlation_id filled in during send routine later... */
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* IPv6 address */
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV6_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* IPv4 address */
name|struct
name|sockaddr_in
modifier|*
name|sin
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|SCTP_IPV4_ADDRESS
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|)
expr_stmt|;
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
operator|&
name|sin
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid family! */
name|SCTP_FREE
argument_list|(
name|aa
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|aa
operator|->
name|sent
operator|=
literal|0
expr_stmt|;
comment|/* clear sent flag */
comment|/* 	 * if we are deleting an address it should go out last otherwise, 	 * add it to front of the pending queue 	 */
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
comment|/* add goes to the front of the queue */
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* delete and set primary goes to the back of the queue */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find a specific asconf param on our "sent" queue  */
end_comment

begin_function
specifier|static
name|struct
name|sctp_asconf_addr
modifier|*
name|sctp_asconf_find_param
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|uint32_t
name|correlation_id
parameter_list|)
block|{
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|correlation_id
operator|==
name|correlation_id
operator|&&
name|aa
operator|->
name|sent
operator|==
literal|1
condition|)
block|{
comment|/* found it */
return|return
operator|(
name|aa
operator|)
return|;
block|}
block|}
comment|/* didn't find it */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * process an SCTP_ERROR_CAUSE_IND for a ASCONF-ACK parameter and do  * notifications based on the error response  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_process_error
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
parameter_list|)
block|{
name|struct
name|sctp_error_cause
modifier|*
name|eh
decl_stmt|;
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|param_type
decl_stmt|;
name|uint16_t
name|error_code
decl_stmt|;
name|eh
operator|=
operator|(
expr|struct
name|sctp_error_cause
operator|*
operator|)
operator|(
name|aph
operator|+
literal|1
operator|)
expr_stmt|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|eh
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* validate lengths */
if|if
condition|(
name|htons
argument_list|(
name|eh
operator|->
name|length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_error_cause
argument_list|)
operator|>
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
condition|)
block|{
comment|/* invalid error cause length */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_process_error: cause element too long\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
if|if
condition|(
name|htons
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|>
name|htons
argument_list|(
name|eh
operator|->
name|length
argument_list|)
condition|)
block|{
comment|/* invalid included TLV length */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"asconf_process_error: included TLV too long\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
comment|/* which error code ? */
name|error_code
operator|=
name|ntohs
argument_list|(
name|eh
operator|->
name|code
argument_list|)
expr_stmt|;
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
comment|/* FIX: this should go back up the REMOTE_ERROR ULP notify */
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
name|SCTP_CAUSE_RESOURCE_SHORTAGE
case|:
comment|/* we allow ourselves to "try again" for this error */
break|break;
default|default:
comment|/* peer can't handle it... */
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * process an asconf queue param aparam: parameter to process, will be  * removed from the queue flag: 1=success, 0=failure  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_process_param_ack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_asconf_addr
modifier|*
name|aparam
parameter_list|,
name|uint32_t
name|flag
parameter_list|)
block|{
name|uint16_t
name|param_type
decl_stmt|;
comment|/* process this param */
name|param_type
operator|=
name|aparam
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ADD_IP_ADDRESS
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_param_ack: added IP address\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_asconf_addr_mgmt_ack
argument_list|(
name|stcb
argument_list|,
name|aparam
operator|->
name|ifa
argument_list|,
name|param_type
argument_list|,
name|flag
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_DEL_IP_ADDRESS
case|:
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"process_param_ack: deleted IP address\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* nothing really to do... lists already updated */
break|break;
case|case
name|SCTP_SET_PRIM_ADDR
case|:
comment|/* nothing to do... peer may start using this addr */
if|if
condition|(
name|flag
operator|==
literal|0
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
comment|/* should NEVER happen */
break|break;
block|}
comment|/* remove the param and free it */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|,
name|aparam
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|SCTP_FREE
argument_list|(
name|aparam
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * cleanup from a bad asconf ack parameter  */
end_comment

begin_function
specifier|static
name|void
name|sctp_asconf_ack_clear
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
comment|/* assume peer doesn't really know how to do asconfs */
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
operator|=
literal|0
expr_stmt|;
comment|/* XXX we could free the pending queue here */
block|}
end_function

begin_function
name|void
name|sctp_handle_asconf_ack
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|struct
name|sctp_asconf_ack_chunk
modifier|*
name|cp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|uint32_t
name|serial_num
decl_stmt|;
name|uint16_t
name|ack_length
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|,
modifier|*
name|aa_next
decl_stmt|;
name|uint32_t
name|last_error_id
init|=
literal|0
decl_stmt|;
comment|/* last error correlation id */
name|uint32_t
name|id
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|ap
decl_stmt|;
comment|/* asconf param buffer */
specifier|static
name|uint8_t
name|aparam_buf
index|[
name|DEFAULT_PARAM_BUFFER
index|]
decl_stmt|;
comment|/* verify minimum length */
if|if
condition|(
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf_ack: chunk too small = %xh\n"
argument_list|,
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
name|serial_num
operator|=
name|ntohl
argument_list|(
name|cp
operator|->
name|serial_number
argument_list|)
expr_stmt|;
comment|/* 	 * NOTE: we may want to handle this differently- currently, we will 	 * abort when we get an ack for the expected serial number + 1 (eg. 	 * we didn't send it), process an ack normally if it is the expected 	 * serial number, and re-send the previous ack for *ALL* other 	 * serial numbers 	 */
comment|/* 	 * if the serial number is the next expected, but I didn't send it, 	 * abort the asoc, since someone probably just hijacked us... 	 */
if|if
condition|(
name|serial_num
operator|==
operator|(
name|asoc
operator|->
name|asconf_seq_out
operator|+
literal|1
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf_ack: got unexpected next serial number! Aborting asoc!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_abort_an_association
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|SCTP_CAUSE_ILLEGAL_ASCONF_ACK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|serial_num
operator|!=
name|asoc
operator|->
name|asconf_seq_out
condition|)
block|{
comment|/* got a duplicate/unexpected ASCONF-ACK */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf_ack: got duplicate/unexpected serial number = %xh (expected = %xh)\n"
argument_list|,
name|serial_num
argument_list|,
name|asoc
operator|->
name|asconf_seq_out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_sent
operator|==
literal|0
condition|)
block|{
comment|/* got a unexpected ASCONF-ACK for serial not in flight */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"handle_asconf_ack: got serial number = %xh but not in flight\n"
argument_list|,
name|serial_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* nothing to do... duplicate ACK received */
return|return;
block|}
comment|/* stop our timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|SCTP_FROM_SCTP_ASCONF
operator|+
name|SCTP_LOC_3
argument_list|)
expr_stmt|;
comment|/* process the ASCONF-ACK contents */
name|ack_length
operator|=
name|ntohs
argument_list|(
name|cp
operator|->
name|ch
operator|.
name|chunk_length
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
name|offset
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_ack_chunk
argument_list|)
expr_stmt|;
comment|/* process through all parameters */
while|while
condition|(
name|ack_length
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
condition|)
block|{
name|unsigned
name|int
name|param_length
decl_stmt|,
name|param_type
decl_stmt|;
comment|/* get pointer to next asconf parameter */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_paramhdr
argument_list|)
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
comment|/* can't get an asconf paramhdr */
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|param_type
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|param_length
operator|=
name|ntohs
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|param_length
operator|>
name|ack_length
condition|)
block|{
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|param_length
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
condition|)
block|{
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* get the complete parameter... */
if|if
condition|(
name|param_length
operator|>
sizeof|sizeof
argument_list|(
name|aparam_buf
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"param length (%u) larger than buffer size!\n"
argument_list|,
name|param_length
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|param_length
argument_list|,
name|aparam_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|aph
operator|==
name|NULL
condition|)
block|{
name|sctp_asconf_ack_clear
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* correlation_id is transparent to peer, no ntohl needed */
name|id
operator|=
name|aph
operator|->
name|correlation_id
expr_stmt|;
switch|switch
condition|(
name|param_type
condition|)
block|{
case|case
name|SCTP_ERROR_CAUSE_IND
case|:
name|last_error_id
operator|=
name|id
expr_stmt|;
comment|/* find the corresponding asconf param in our queue */
name|ap
operator|=
name|sctp_asconf_find_param
argument_list|(
name|stcb
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
comment|/* hmm... can't find this in our queue! */
break|break;
block|}
comment|/* process the parameter, failed flag */
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|ap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* process the error response */
name|sctp_asconf_process_error
argument_list|(
name|stcb
argument_list|,
name|aph
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCTP_SUCCESS_REPORT
case|:
comment|/* find the corresponding asconf param in our queue */
name|ap
operator|=
name|sctp_asconf_find_param
argument_list|(
name|stcb
argument_list|,
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|==
name|NULL
condition|)
block|{
comment|/* hmm... can't find this in our queue! */
break|break;
block|}
comment|/* process the parameter, success flag */
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|ap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* switch */
comment|/* update remaining ASCONF-ACK message length to process */
name|ack_length
operator|-=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack_length
operator|<=
literal|0
condition|)
block|{
comment|/* no more data in the mbuf chain */
break|break;
block|}
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|param_length
argument_list|)
expr_stmt|;
block|}
comment|/* while */
comment|/* 	 * if there are any "sent" params still on the queue, these are 	 * implicitly "success", or "failed" (if we got an error back) ... 	 * so process these appropriately 	 *  	 * we assume that the correlation_id's are monotonically increasing 	 * beginning from 1 and that we don't have *that* many outstanding 	 * at any given time 	 */
if|if
condition|(
name|last_error_id
operator|==
literal|0
condition|)
name|last_error_id
operator|--
expr_stmt|;
comment|/* set to "max" value */
for|for
control|(
name|aa
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
init|;
name|aa
operator|!=
name|NULL
condition|;
name|aa
operator|=
name|aa_next
control|)
block|{
name|aa_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|aa
argument_list|,
name|next
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|->
name|sent
operator|==
literal|1
condition|)
block|{
comment|/* 			 * implicitly successful or failed if correlation_id 			 *< last_error_id, then success else, failure 			 */
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|correlation_id
operator|<
name|last_error_id
condition|)
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|aa
argument_list|,
name|SCTP_SUCCESS_REPORT
argument_list|)
expr_stmt|;
else|else
name|sctp_asconf_process_param_ack
argument_list|(
name|stcb
argument_list|,
name|aa
argument_list|,
name|SCTP_ERROR_CAUSE_IND
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * since we always process in order (FIFO queue) if 			 * we reach one that hasn't been sent, the rest 			 * should not have been sent either. so, we're 			 * done... 			 */
break|break;
block|}
block|}
comment|/* update the next sequence number to use */
name|asoc
operator|->
name|asconf_seq_out
operator|++
expr_stmt|;
comment|/* remove the old ASCONF on our outbound queue */
name|sctp_toss_old_asconf
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* clear the sent flag to allow new ASCONFs */
name|asoc
operator|->
name|asconf_sent
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
condition|)
block|{
comment|/* we have more params, so restart our timer */
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* is this an interface that we care about at all? */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_is_desired_interface_type
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
comment|/* check the interface type to see if it's one we care about */
switch|switch
condition|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_ISO88023
case|:
case|case
name|IFT_ISO88025
case|:
case|case
name|IFT_STARLAN
case|:
case|case
name|IFT_P10
case|:
case|case
name|IFT_P80
case|:
case|case
name|IFT_HY
case|:
case|case
name|IFT_FDDI
case|:
case|case
name|IFT_PPP
case|:
case|case
name|IFT_XETHER
case|:
case|case
name|IFT_SLIP
case|:
case|case
name|IFT_GIF
case|:
name|result
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|result
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|sctp_is_scopeid_in_nets
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
modifier|*
name|net6
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
block|{
comment|/* wrong family */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* not link local address */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* hunt through our destination nets list for this scope_id */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
operator|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
operator|)
operator|)
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|net6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|net6
operator|->
name|sin6_addr
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_same_scope
argument_list|(
name|sin6
argument_list|,
name|net6
argument_list|)
condition|)
block|{
comment|/* found one */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* didn't find one */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * address management functions  */
end_comment

begin_function
specifier|static
name|void
name|sctp_addr_mgmt_assoc
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
operator|&&
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* subset bound, no ASCONF allowed case, so ignore */
return|return;
block|}
comment|/* 	 * note: we know this is not the subset bound, no ASCONF case eg. 	 * this is boundall or subset bound w/ASCONF allowed 	 */
comment|/* first, make sure it's a good address family */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|&&
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
return|return;
block|}
comment|/* make sure we're "allowed" to add this type of addr */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ifa6
decl_stmt|;
comment|/* invalid if we're not a v6 endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* is the v6 addr really valid ? */
name|ifa6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ifa6
argument_list|)
operator|||
operator|(
name|ifa6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_DETACHED
operator||
name|IN6_IFF_ANYCAST
operator||
name|IN6_IFF_NOTREADY
operator|)
operator|)
condition|)
block|{
comment|/* can't use an invalid address */
return|return;
block|}
block|}
comment|/* put this address on the "pending/do not use yet" list */
comment|/* 	 * Note: we do this primarily for the subset bind case We don't have 	 * scoping flags at the EP level, so we must add link local/site 	 * local addresses to the EP, then need to "negate" them here. 	 * Recall that this routine is only called for the subset bound 	 * w/ASCONF allowed case. 	 */
comment|/* 	 * do a scope_id check against any link local addresses in the 	 * destination nets list to see if we should put this local address 	 * on the pending list or not eg. don't put on the list if we have a 	 * link local destination with the same scope_id 	 */
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
if|if
condition|(
name|sctp_is_scopeid_in_nets
argument_list|(
name|stcb
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sctp_add_local_addr_assoc
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check address scope if address is out of scope, don't queue 	 * anything... note: this would leave the address on both inp and 	 * asoc lists 	 */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* we skip unspecifed addresses */
return|return;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* is it the right link local scope? */
if|if
condition|(
name|sctp_is_scopeid_in_nets
argument_list|(
name|stcb
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
comment|/* invalid if we are a v6 only endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
return|return;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* we skip unspecifed addresses */
return|return;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|&&
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
return|return;
block|}
block|}
else|else
block|{
comment|/* else, not AF_INET or AF_INET6, so skip */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"addr_mgmt_assoc: not AF_INET or AF_INET6\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
comment|/* queue an asconf for this address add/delete */
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* does the peer do asconf? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
condition|)
block|{
comment|/* queue an asconf for this addr */
name|status
operator|=
name|sctp_asconf_queue_add
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* 			 * if queued ok, and in correct state, set the 			 * ASCONF timer if in non-open state, we will set 			 * this timer when the state does go open and do all 			 * the asconf's 			 */
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* this is the boundall, no ASCONF case */
if|#
directive|if
literal|0
comment|/* Peter: Fixe me? why the if 0? */
comment|/* 		 * assume kernel will delete this very shortly; add done 		 * above 		 */
block|if (type == SCTP_DEL_IP_ADDRESS) {
comment|/* if deleting, add this addr to the do not use list */
block|sctp_add_local_addr_assoc(stcb, ifa); 		}
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sctp_addr_mgmt_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|s
decl_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* make sure we're "allowed" to add this type of addr */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ifa6
decl_stmt|;
comment|/* invalid if we're not a v6 endpoint */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|==
literal|0
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* is the v6 addr really valid ? */
name|ifa6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ifa6
argument_list|)
operator|||
operator|(
name|ifa6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_DETACHED
operator||
name|IN6_IFF_ANYCAST
operator||
name|IN6_IFF_NOTREADY
operator|)
operator|)
condition|)
block|{
comment|/* can't use an invalid address */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* invalid if we are a v6 only endpoint */
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUND_V6
operator|)
operator|&&
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|/* invalid address family */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* is this endpoint subset bound ? */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* subset bound endpoint */
if|if
condition|(
name|sctp_is_feature_off
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* 			 * subset bound, but ASCONFs not allowed... if 			 * adding, nothing to do, since not allowed if 			 * deleting, remove address from endpoint peer will 			 * have to "timeout" this addr 			 */
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|sctp_del_local_addr_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
comment|/* no asconfs to queue for this inp... */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 			 * subset bound, ASCONFs allowed... if adding, add 			 * address to endpoint list if deleting, remove 			 * address from endpoint 			 */
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
block|{
name|sctp_add_local_addr_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sctp_del_local_addr_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
comment|/* drop through and notify all asocs */
block|}
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* process for all associations for this endpoint */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_addr_mgmt_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * restrict the use of this address  */
end_comment

begin_function
specifier|static
name|void
name|sctp_addr_mgmt_restrict_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* is this endpoint bound to all? */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Nothing to do for subset bound case. Allow sctp_bindx() 		 * to manage the address lists 		 */
return|return;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* process for all associations for this endpoint */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
comment|/* put this address on the "pending/do not use yet" list */
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|sctp_add_local_addr_assoc
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * this is only called for kernel initiated address changes eg. it will check  * the PCB_FLAGS_AUTO_ASCONF flag  */
end_comment

begin_function
specifier|static
name|void
name|sctp_addr_mgmt
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* make sure we care about this interface... */
if|if
condition|(
operator|!
name|sctp_is_desired_interface_type
argument_list|(
name|ifa
argument_list|)
condition|)
block|{
return|return;
block|}
name|sa
operator|=
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|&&
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
return|return;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|SCTP_ADD_IP_ADDRESS
condition|)
name|printf
argument_list|(
literal|"sctp_addr_mgmt: kernel adds "
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"sctp_addr_mgmt: kernel deletes "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* go through all our PCB's */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|&sctppcbinfo.listhead
argument_list|,
argument|sctp_list
argument_list|)
block|{
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_AUTO_ASCONF
argument_list|)
condition|)
block|{
name|sctp_addr_mgmt_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* this address is going away anyways... */
if|if
condition|(
name|type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
return|return;
comment|/* (temporarily) restrict this address */
name|sctp_addr_mgmt_restrict_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
comment|/* else, not allowing automatic asconf's, so ignore */
block|}
block|}
end_function

begin_comment
comment|/*  * add/delete IP address requests from kernel (via routing change) assumed  * that the address is non-broadcast, non-multicast all addresses are passed  * from any type of interface-- need to filter duplicate addresses may get  * requested  */
end_comment

begin_function
name|void
name|sctp_add_ip_address
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|sctp_addr_mgmt
argument_list|(
name|ifa
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp_delete_ip_address
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* process the delete */
name|sctp_addr_mgmt
argument_list|(
name|ifa
argument_list|,
name|SCTP_DEL_IP_ADDRESS
argument_list|)
expr_stmt|;
comment|/* 	 * need to remove this ifaddr from any cached routes and also any 	 * from any assoc "restricted/pending" lists 	 */
comment|/* make sure we care about this interface... */
if|if
condition|(
operator|!
name|sctp_is_desired_interface_type
argument_list|(
name|ifa
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* go through all our PCB's */
name|SCTP_INP_INFO_RLOCK
argument_list|()
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|&sctppcbinfo.listhead
argument_list|,
argument|sctp_list
argument_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|laddr_next
decl_stmt|;
comment|/* process for all associations for this endpoint */
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
comment|/* process through the nets list */
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* delete this address if cached */
name|rt
operator|=
name|net
operator|->
name|ro
operator|.
name|ro_rt
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
operator|&&
name|rt
operator|->
name|rt_ifa
operator|==
name|ifa
condition|)
block|{
comment|/* RTFREE(rt); */
name|net
operator|->
name|ro
operator|.
name|ro_rt
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* for each net */
comment|/* process through the asoc "pending" list */
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|sctp_local_addr_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|laddr_next
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
comment|/* remove if in use */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
name|laddr
operator|=
name|laddr_next
expr_stmt|;
block|}
comment|/* while */
block|}
comment|/* for each stcb */
comment|/* process through the inp bound addr list */
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|laddr
operator|!=
name|NULL
condition|)
block|{
name|laddr_next
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
comment|/* remove if in use */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sctp_remove_laddr
argument_list|(
name|laddr
argument_list|)
expr_stmt|;
block|}
name|laddr
operator|=
name|laddr_next
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_INFO_RUNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sa is the sockaddr to ask the peer to set primary to returns: 0 =  * completed, -1 = error  */
end_comment

begin_function
name|int32_t
name|sctp_set_primary_ip_address_sa
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
comment|/* NOTE: we currently don't check the validity of the address! */
comment|/* queue an ASCONF:SET_PRIM_ADDR to be sent */
if|if
condition|(
operator|!
name|sctp_asconf_queue_add_sa
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_SET_PRIM_ADDR
argument_list|)
condition|)
block|{
comment|/* set primary queuing succeeded */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"set_primary_ip_address_sa: queued on tcb=%p, "
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"set_primary_ip_address_sa: failed to add to queue on tcb=%p, "
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_set_primary_ip_address
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
comment|/* make sure we care about this interface... */
if|if
condition|(
operator|!
name|sctp_is_desired_interface_type
argument_list|(
name|ifa
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* go through all our PCB's */
name|LIST_FOREACH
argument_list|(
argument|inp
argument_list|,
argument|&sctppcbinfo.listhead
argument_list|,
argument|sctp_list
argument_list|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
comment|/* process for all associations for this endpoint */
name|LIST_FOREACH
argument_list|(
argument|stcb
argument_list|,
argument|&inp->sctp_asoc_list
argument_list|,
argument|sctp_tcblist
argument_list|)
block|{
comment|/* queue an ASCONF:SET_PRIM_ADDR to be sent */
if|if
condition|(
operator|!
name|sctp_asconf_queue_add
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|,
name|SCTP_SET_PRIM_ADDR
argument_list|)
condition|)
block|{
comment|/* set primary queuing succeeded */
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"set_primary_ip_address: queued on stcb=%p, "
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
block|}
block|}
comment|/* for each stcb */
block|}
comment|/* for each inp */
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr
modifier|*
name|sctp_find_valid_localaddr
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifn
argument_list|,
argument|&ifnet
argument_list|,
argument|if_list
argument_list|)
block|{
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
operator|==
literal|0
operator|&&
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
comment|/* Skip if loopback_scope not set */
continue|continue;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* skip unspecifed addresses */
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
operator|==
literal|0
operator|&&
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
continue|continue;
comment|/* found a valid local v4 address to use */
return|return
operator|(
name|ifa
operator|->
name|ifa_addr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ifa6
decl_stmt|;
name|ifa6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ifa6
argument_list|)
operator|||
operator|(
name|ifa6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_DETACHED
operator||
name|IN6_IFF_ANYCAST
operator||
name|IN6_IFF_NOTREADY
operator|)
operator|)
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* we skip unspecifed addresses */
continue|continue;
block|}
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|local_scope
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|site_scope
operator|==
literal|0
operator|&&
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
continue|continue;
comment|/* found a valid local v6 address to use */
return|return
operator|(
name|ifa
operator|->
name|ifa_addr
operator|)
return|;
block|}
block|}
block|}
comment|/* no valid addresses found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr
modifier|*
name|sctp_find_valid_localaddr_ep
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
comment|/* is the address restricted ? */
if|if
condition|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
continue|continue;
comment|/* found a valid local address to use */
return|return
operator|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|)
return|;
block|}
comment|/* no valid addresses found */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * builds an ASCONF chunk from queued ASCONF params returns NULL on error (no  * mbuf, no ASCONF params queued, etc)  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_compose_asconf
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
modifier|*
name|retlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m_asconf
decl_stmt|,
modifier|*
name|m_asconf_chk
decl_stmt|;
name|struct
name|sctp_asconf_addr
modifier|*
name|aa
decl_stmt|;
name|struct
name|sctp_asconf_chunk
modifier|*
name|acp
decl_stmt|;
name|struct
name|sctp_asconf_paramhdr
modifier|*
name|aph
decl_stmt|;
name|struct
name|sctp_asconf_addr_param
modifier|*
name|aap
decl_stmt|;
name|uint32_t
name|p_length
decl_stmt|;
name|uint32_t
name|correlation_id
init|=
literal|1
decl_stmt|;
comment|/* 0 is reserved... */
name|caddr_t
name|ptr
decl_stmt|,
name|lookup_ptr
decl_stmt|;
name|uint8_t
name|lookup_used
init|=
literal|0
decl_stmt|;
comment|/* are there any asconf params to send? */
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|asconf_queue
argument_list|)
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * get a chunk header mbuf and a cluster for the asconf params since 	 * it's simpler to fill in the asconf chunk header lookup address on 	 * the fly 	 */
name|m_asconf_chk
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_asconf_chk
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
name|printf
argument_list|(
literal|"compose_asconf: couldn't get chunk mbuf!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m_asconf
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|MCLBYTES
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m_asconf
operator|==
name|NULL
condition|)
block|{
comment|/* no mbuf's */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
name|printf
argument_list|(
literal|"compose_asconf: couldn't get mbuf!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_m_freem
argument_list|(
name|m_asconf_chk
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|=
literal|0
expr_stmt|;
name|acp
operator|=
name|mtod
argument_list|(
name|m_asconf_chk
argument_list|,
expr|struct
name|sctp_asconf_chunk
operator|*
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|acp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_asconf_chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* save pointers to lookup address and asconf params */
name|lookup_ptr
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|acp
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* after the header */
name|ptr
operator|=
name|mtod
argument_list|(
name|m_asconf
argument_list|,
name|caddr_t
argument_list|)
expr_stmt|;
comment|/* beginning of cluster */
comment|/* fill in chunk header info */
name|acp
operator|->
name|ch
operator|.
name|chunk_type
operator|=
name|SCTP_ASCONF
expr_stmt|;
name|acp
operator|->
name|ch
operator|.
name|chunk_flags
operator|=
literal|0
expr_stmt|;
name|acp
operator|->
name|serial_number
operator|=
name|htonl
argument_list|(
name|stcb
operator|->
name|asoc
operator|.
name|asconf_seq_out
argument_list|)
expr_stmt|;
comment|/* add parameters... up to smallest MTU allowed */
name|TAILQ_FOREACH
argument_list|(
argument|aa
argument_list|,
argument|&stcb->asoc.asconf_queue
argument_list|,
argument|next
argument_list|)
block|{
comment|/* get the parameter length */
name|p_length
operator|=
name|SCTP_SIZE32
argument_list|(
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
comment|/* will it fit in current chunk? */
if|if
condition|(
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|+
name|p_length
operator|>
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
condition|)
block|{
comment|/* won't fit, so we're done with this chunk */
break|break;
block|}
comment|/* assign (and store) a correlation id */
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|correlation_id
operator|=
name|correlation_id
operator|++
expr_stmt|;
comment|/* 		 * fill in address if we're doing a delete this is a simple 		 * way for us to fill in the correlation address, which 		 * should only be used by the peer if we're deleting our 		 * source address and adding a new address (e.g. renumbering 		 * case) 		 */
if|if
condition|(
name|lookup_used
operator|==
literal|0
operator|&&
name|aa
operator|->
name|ap
operator|.
name|aph
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_DEL_IP_ADDRESS
condition|)
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|lookup
decl_stmt|;
name|uint16_t
name|p_size
decl_stmt|,
name|addr_size
decl_stmt|;
name|lookup
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|lookup_ptr
expr_stmt|;
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
comment|/* copy IPv6 address */
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* copy IPv4 address */
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
name|lookup
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lookup
operator|->
name|addr
argument_list|,
operator|&
name|aa
operator|->
name|ap
operator|.
name|addrp
operator|.
name|addr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
expr_stmt|;
name|lookup_used
operator|=
literal|1
expr_stmt|;
block|}
comment|/* copy into current space */
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|aa
operator|->
name|ap
argument_list|,
name|p_length
argument_list|)
expr_stmt|;
comment|/* network elements and update lengths */
name|aph
operator|=
operator|(
expr|struct
name|sctp_asconf_paramhdr
operator|*
operator|)
name|ptr
expr_stmt|;
name|aap
operator|=
operator|(
expr|struct
name|sctp_asconf_addr_param
operator|*
operator|)
name|ptr
expr_stmt|;
comment|/* correlation_id is transparent to peer, no htonl needed */
name|aph
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|aph
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aph
operator|->
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_type
argument_list|)
expr_stmt|;
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|aap
operator|->
name|addrp
operator|.
name|ph
operator|.
name|param_length
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_length
argument_list|)
expr_stmt|;
name|ptr
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_length
argument_list|)
expr_stmt|;
comment|/* 		 * these params are removed off the pending list upon 		 * getting an ASCONF-ACK back from the peer, just set flag 		 */
name|aa
operator|->
name|sent
operator|=
literal|1
expr_stmt|;
block|}
comment|/* check to see if the lookup addr has been populated yet */
if|if
condition|(
name|lookup_used
operator|==
literal|0
condition|)
block|{
comment|/* NOTE: if the address param is optional, can skip this... */
comment|/* add any valid (existing) address... */
name|struct
name|sctp_ipv6addr_param
modifier|*
name|lookup
decl_stmt|;
name|uint16_t
name|p_size
decl_stmt|,
name|addr_size
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|found_addr
decl_stmt|;
name|caddr_t
name|addr_ptr
decl_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
name|found_addr
operator|=
name|sctp_find_valid_localaddr
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
else|else
name|found_addr
operator|=
name|sctp_find_valid_localaddr_ep
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|lookup
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|lookup_ptr
expr_stmt|;
if|if
condition|(
name|found_addr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|found_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* copy IPv6 address */
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|addr_ptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|found_addr
operator|)
operator|->
name|sin6_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* copy IPv4 address */
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|p_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
name|addr_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|addr_ptr
operator|=
operator|(
name|caddr_t
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|found_addr
operator|)
operator|->
name|sin_addr
expr_stmt|;
block|}
name|lookup
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lookup
operator|->
name|addr
argument_list|,
name|addr_ptr
argument_list|,
name|addr_size
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
name|p_size
argument_list|)
expr_stmt|;
name|lookup_used
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* uh oh... don't have any address?? */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
name|printf
argument_list|(
literal|"compose_asconf: no lookup addr!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* for now, we send a IPv4 address of 0.0.0.0 */
name|lookup
operator|->
name|ph
operator|.
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|lookup
operator|->
name|ph
operator|.
name|param_length
operator|=
name|htons
argument_list|(
name|SCTP_SIZE32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|lookup
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+=
name|SCTP_SIZE32
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|)
expr_stmt|;
name|lookup_used
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* chain it all together */
name|SCTP_BUF_NEXT
argument_list|(
name|m_asconf_chk
argument_list|)
operator|=
name|m_asconf
expr_stmt|;
operator|*
name|retlen
operator|=
name|acp
operator|->
name|ch
operator|.
name|chunk_length
operator|=
name|ntohs
argument_list|(
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf_chk
argument_list|)
operator|+
name|SCTP_BUF_LEN
argument_list|(
name|m_asconf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update "sent" flag */
name|stcb
operator|->
name|asoc
operator|.
name|asconf_sent
operator|++
expr_stmt|;
return|return
operator|(
name|m_asconf_chk
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * section to handle address changes before an association is up eg. changes  * during INIT/INIT-ACK/COOKIE-ECHO handshake  */
end_comment

begin_comment
comment|/*  * processes the (local) addresses in the INIT-ACK chunk  */
end_comment

begin_function
specifier|static
name|void
name|sctp_process_initack_addresses
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|unsigned
name|int
name|offset
parameter_list|,
name|unsigned
name|int
name|length
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
name|tmp_param
decl_stmt|,
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|,
name|ptype
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
name|addr_store
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF2
condition|)
block|{
name|printf
argument_list|(
literal|"processing init-ack addresses\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* convert to upper bound */
name|length
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|>
name|length
condition|)
block|{
return|return;
block|}
comment|/* init the addresses */
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
comment|/* go through the addresses in the init-ack */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
while|while
condition|(
name|ph
operator|!=
name|NULL
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
condition|)
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|a6p
decl_stmt|;
comment|/* get the entire IPv6 address param */
name|a6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|a6p
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|memcpy
argument_list|(
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|,
name|a6p
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
condition|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|a4p
decl_stmt|;
comment|/* get the entire IPv4 address param */
name|a4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|a4p
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|a4p
operator|->
name|addr
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|next_addr
goto|;
block|}
comment|/* see if this address really (still) exists */
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address doesn't exist anymore */
name|int
name|status
decl_stmt|;
comment|/* are ASCONFs allowed ? */
if|if
condition|(
operator|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|)
operator|&&
name|stcb
operator|->
name|asoc
operator|.
name|peer_supports_asconf
condition|)
block|{
comment|/* queue an ASCONF DEL_IP_ADDRESS */
name|status
operator|=
name|sctp_asconf_queue_add_sa
argument_list|(
name|stcb
argument_list|,
name|sa
argument_list|,
name|SCTP_DEL_IP_ADDRESS
argument_list|)
expr_stmt|;
comment|/* 				 * if queued ok, and in correct state, set 				 * the ASCONF timer 				 */
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
condition|)
block|{
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ASCONF
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* address still exists */
comment|/* 			 * if subset bound, ep addr's managed by default if 			 * not doing ASCONF, add the address to the assoc 			 */
if|if
condition|(
operator|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
operator|)
operator|==
literal|0
operator|&&
operator|(
name|sctp_is_feature_off
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF2
condition|)
block|{
name|printf
argument_list|(
literal|"process_initack_addrs: adding local addr to asoc\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
name|sctp_add_local_addr_assoc
argument_list|(
name|stcb
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
name|next_addr
label|:
comment|/* 		 * Sanity check:  Make sure the length isn't 0, otherwise 		 * we'll be stuck in this loop for a long time... 		 */
if|if
condition|(
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|printf
argument_list|(
literal|"process_initack_addrs: bad len (%d) type=%xh\n"
argument_list|,
name|plen
argument_list|,
name|ptype
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
comment|/* get next parameter */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|>
name|length
condition|)
return|return;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
block|}
comment|/* while */
block|}
end_function

begin_comment
comment|/* FIX ME: need to verify return result for v6 address type if v6 disabled */
end_comment

begin_comment
comment|/*  * checks to see if a specific address is in the initack address list returns  * 1 if found, 0 if not  */
end_comment

begin_function
specifier|static
name|uint32_t
name|sctp_addr_in_initack
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
name|tmp_param
decl_stmt|,
modifier|*
name|ph
decl_stmt|;
name|uint16_t
name|plen
decl_stmt|,
name|ptype
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
name|addr_store
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sctp_ipv4addr_param
modifier|*
name|a4p
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|,
name|sin6_tmp
decl_stmt|;
name|struct
name|sctp_ipv6addr_param
modifier|*
name|a6p
decl_stmt|;
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
ifdef|#
directive|ifdef
name|INET6
operator|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|)
operator|&&
endif|#
directive|endif
comment|/* INET6 */
operator|(
name|sa
operator|->
name|sa_family
operator|!=
name|AF_INET
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF2
condition|)
block|{
name|printf
argument_list|(
literal|"find_initack_addr: starting search for "
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
comment|/* convert to upper bound */
name|length
operator|+=
name|offset
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|)
operator|>
name|length
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"find_initack_addr: invalid offset?\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* go through the addresses in the init-ack */
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
while|while
condition|(
name|ph
operator|!=
name|NULL
condition|)
block|{
name|ptype
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_type
argument_list|)
expr_stmt|;
name|plen
operator|=
name|ntohs
argument_list|(
name|ph
operator|->
name|param_length
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV6_ADDRESS
operator|&&
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
comment|/* get the entire IPv6 address param */
name|a6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
operator|||
name|ph
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_SCOPE_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* create a copy and clear scope */
name|memcpy
argument_list|(
operator|&
name|sin6_tmp
argument_list|,
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|=
operator|&
name|sin6_tmp
expr_stmt|;
name|in6_clearscope
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|a6p
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* found it */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* INET6 */
if|if
condition|(
name|ptype
operator|==
name|SCTP_IPV4_ADDRESS
operator|&&
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* get the entire IPv4 address param */
name|a4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|addr_store
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
operator|||
name|ph
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
name|a4p
operator|->
name|addr
condition|)
block|{
comment|/* found it */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* get next parameter */
name|offset
operator|+=
name|SCTP_SIZE32
argument_list|(
name|plen
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
operator|>
name|length
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ph
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|tmp_param
argument_list|)
expr_stmt|;
block|}
comment|/* while */
comment|/* not found! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * makes sure that the current endpoint local addr list is consistent with  * the new association (eg. subset bound, asconf allowed) adds addresses as  * necessary  */
end_comment

begin_function
specifier|static
name|void
name|sctp_check_address_list_ep
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_addr
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
comment|/* go through the endpoint list */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->sctp_ep->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
comment|/* be paranoid and validate the laddr */
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"check_addr_list_ep: laddr->ifa is NULL"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_ASCONF1
condition|)
block|{
name|printf
argument_list|(
literal|"check_addr_list_ep: laddr->ifa->ifa_addr is NULL"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
continue|continue;
block|}
comment|/* do i have it implicitly? */
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|init_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* check to see if in the init-ack */
if|if
condition|(
operator|!
name|sctp_addr_in_initack
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
comment|/* try to add it */
name|sctp_addr_mgmt_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * makes sure that the current kernel address list is consistent with the new  * association (with all addrs bound) adds addresses as necessary  */
end_comment

begin_function
specifier|static
name|void
name|sctp_check_address_list_all
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_addr
parameter_list|,
name|uint16_t
name|local_scope
parameter_list|,
name|uint16_t
name|site_scope
parameter_list|,
name|uint16_t
name|ipv4_scope
parameter_list|,
name|uint16_t
name|loopback_scope
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
comment|/* go through all our known interfaces */
name|TAILQ_FOREACH
argument_list|(
argument|ifn
argument_list|,
argument|&ifnet
argument_list|,
argument|if_list
argument_list|)
block|{
if|if
condition|(
name|loopback_scope
operator|==
literal|0
operator|&&
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
comment|/* skip loopback interface */
continue|continue;
block|}
comment|/* go through each interface address */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
comment|/* do i have it implicitly? */
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|init_addr
argument_list|)
condition|)
block|{
continue|continue;
block|}
comment|/* check to see if in the init-ack */
if|if
condition|(
operator|!
name|sctp_addr_in_initack
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|)
condition|)
block|{
comment|/* try to add it */
name|sctp_addr_mgmt_assoc
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|ifa
argument_list|,
name|SCTP_ADD_IP_ADDRESS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end foreach ifa */
block|}
comment|/* end foreach ifn */
block|}
end_function

begin_comment
comment|/*  * validates an init-ack chunk (from a cookie-echo) with current addresses  * adds addresses from the init-ack into our local address list, if needed  * queues asconf adds/deletes addresses as needed and makes appropriate list  * changes for source address selection m, offset: points to the start of the  * address list in an init-ack chunk length: total length of the address  * params only init_addr: address where my INIT-ACK was sent from  */
end_comment

begin_function
name|void
name|sctp_check_address_list
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|length
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|init_addr
parameter_list|,
name|uint16_t
name|local_scope
parameter_list|,
name|uint16_t
name|site_scope
parameter_list|,
name|uint16_t
name|ipv4_scope
parameter_list|,
name|uint16_t
name|loopback_scope
parameter_list|)
block|{
comment|/* process the local addresses in the initack */
name|sctp_process_initack_addresses
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* bound all case */
name|sctp_check_address_list_all
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|init_addr
argument_list|,
name|local_scope
argument_list|,
name|site_scope
argument_list|,
name|ipv4_scope
argument_list|,
name|loopback_scope
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* subset bound case */
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* asconf's allowed */
name|sctp_check_address_list_ep
argument_list|(
name|stcb
argument_list|,
name|m
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|init_addr
argument_list|)
expr_stmt|;
block|}
comment|/* else, no asconfs allowed, so what we sent is what we get */
block|}
block|}
end_function

begin_comment
comment|/*  * sctp_bindx() support  */
end_comment

begin_function
name|uint32_t
name|sctp_addr_mgmt_ep_sa
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|uint16_t
name|type
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_len
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ifa
operator|=
name|sctp_find_ifa_by_addr
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ifa6
decl_stmt|;
name|ifa6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ifa6
argument_list|)
operator|||
operator|(
name|ifa6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_DETACHED
operator||
name|IN6_IFF_ANYCAST
operator||
name|IN6_IFF_NOTREADY
operator|)
operator|)
condition|)
block|{
comment|/* Can't bind a non-existent addr. */
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* INET6 */
comment|/* add this address */
name|sctp_addr_mgmt_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid address! */
return|return
operator|(
name|EADDRNOTAVAIL
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sctp_addr_change
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|wi
decl_stmt|;
name|wi
operator|=
operator|(
expr|struct
name|sctp_laddr
operator|*
operator|)
name|SCTP_ZONE_GET
argument_list|(
name|sctppcbinfo
operator|.
name|ipi_zone_laddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wi
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Gak, what can we do? We have lost an address change can 		 * you say HOSED? 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_PCB1
condition|)
block|{
name|printf
argument_list|(
literal|"Lost and address change ???\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SCTP_DEBUG */
return|return;
block|}
name|SCTP_INCR_LADDR_COUNT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|wi
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wi
argument_list|)
argument_list|)
expr_stmt|;
name|wi
operator|->
name|ifa
operator|=
name|ifa
expr_stmt|;
name|IFAREF
argument_list|(
name|ifa
argument_list|)
expr_stmt|;
name|wi
operator|->
name|action
operator|=
name|cmd
expr_stmt|;
name|SCTP_IPI_ADDR_LOCK
argument_list|()
expr_stmt|;
comment|/* 	 * Should this really be a tailq? As it is we will process the 	 * newest first :-0 	 */
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sctppcbinfo
operator|.
name|addr_wq
argument_list|,
name|wi
argument_list|,
name|sctp_nxt_addr
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_ADDR_WQ
argument_list|,
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_tcb
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|sctp_nets
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|SCTP_IPI_ADDR_UNLOCK
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

