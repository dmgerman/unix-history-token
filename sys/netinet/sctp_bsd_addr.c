begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2006, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* $KAME: sctp_output.c,v 1.46 2005/03/06 16:04:17 itojun Exp $	 */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_comment
comment|/* XXX  * This module needs to be rewritten with an eye towards getting  * rid of the user of ifa.. and use another list method George  * as told me of.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|uint32_t
name|sctp_debug_on
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|sctp_is_v4_ifa_addr_prefered
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|uint8_t
modifier|*
name|sin_loop
parameter_list|,
name|uint8_t
modifier|*
name|sin_local
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* 	 * Here we determine if its a prefered address. A prefered address 	 * means it is the same scope or higher scope then the destination. 	 * L = loopback, P = private, G = global 	 * ----------------------------------------- src    |      dest | 	 * result ----------------------------------------- L     | L | 	 * yes ----------------------------------------- P     | L |    yes 	 * ----------------------------------------- G     | L |    yes 	 * ----------------------------------------- L     | P |    no 	 * ----------------------------------------- P     | P |    yes 	 * ----------------------------------------- G     | P |    no 	 * ----------------------------------------- L     | G |    no 	 * ----------------------------------------- P     | G |    no 	 * ----------------------------------------- G     | G |    yes 	 * ----------------------------------------- 	 */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
comment|/* forget non-v4 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Ok the address may be ok */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|sin_local
operator|=
operator|*
name|sin_loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
operator|)
operator|||
operator|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
operator|*
name|sin_loop
operator|=
literal|1
expr_stmt|;
operator|*
name|sin_local
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
operator|*
name|sin_local
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loopscope
operator|&&
operator|*
name|sin_loop
condition|)
block|{
comment|/* Its a loopback address and we don't have loop scope */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ipv4_scope
operator|&&
operator|*
name|sin_local
condition|)
block|{
comment|/* 		 * Its a private address, and we don't have private address 		 * scope 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|(
name|ipv4_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|loopscope
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|*
name|sin_local
operator|)
condition|)
block|{
comment|/* its a global src and a private dest */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* its a prefered address */
return|return
operator|(
name|sin
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|sctp_is_v4_ifa_addr_acceptable
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|uint8_t
modifier|*
name|sin_loop
parameter_list|,
name|uint8_t
modifier|*
name|sin_local
parameter_list|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
comment|/* 	 * Here we determine if its a acceptable address. A acceptable 	 * address means it is the same scope or higher scope but we can 	 * allow for NAT which means its ok to have a global dest and a 	 * private src. 	 *  	 * L = loopback, P = private, G = global 	 * ----------------------------------------- src    |      dest | 	 * result ----------------------------------------- L     | L | 	 * yes ----------------------------------------- P     | L |    yes 	 * ----------------------------------------- G     | L |    yes 	 * ----------------------------------------- L     | P |    no 	 * ----------------------------------------- P     | P |    yes 	 * ----------------------------------------- G     | P |    yes - 	 * probably this won't work. 	 * ----------------------------------------- L     |       G       | 	 * no ----------------------------------------- P     |       G | 	 * yes ----------------------------------------- G     |       G | 	 * yes ----------------------------------------- 	 */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
comment|/* forget non-v4 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Ok the address may be ok */
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|*
name|sin_local
operator|=
operator|*
name|sin_loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
operator|)
operator|||
operator|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
operator|*
name|sin_loop
operator|=
literal|1
expr_stmt|;
operator|*
name|sin_local
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
operator|*
name|sin_local
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loopscope
operator|&&
operator|*
name|sin_loop
condition|)
block|{
comment|/* Its a loopback address and we don't have loop scope */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* its an acceptable address */
return|return
operator|(
name|sin
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This treats the address list on the ep as a restricted list (negative  * list). If a the passed address is listed, then the address is NOT allowed  * on the association.  */
end_comment

begin_function
name|int
name|sctp_is_addr_restricted
parameter_list|(
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|int
name|cnt
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* There are no restrictions, no TCB :-) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
name|cnt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT4
condition|)
block|{
name|printf
argument_list|(
literal|"There are %d addresses on the restricted list\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
block|}
name|cnt
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Help I have fallen and I can't get up!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT4
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"Restricted address[%d]:"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|addr
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Yes it is on the list */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_is_addr_in_ep
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Help I have fallen and I can't get up!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
comment|/* same pointer */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
comment|/* skip non compatible address comparison */
continue|continue;
block|}
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* Yes it is restricted */
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|in_addr
name|sctp_choose_v4_boundspecific_inp
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|)
block|{
name|struct
name|in_addr
name|ans
decl_stmt|;
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|uint8_t
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want that one. 	 */
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifn
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|ifn
condition|)
block|{
comment|/* is a prefered one on the interface we route out? */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
condition|)
block|{
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
comment|/* is an acceptable one on the interface we route out? */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
condition|)
block|{
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
block|}
comment|/* ok, what about a prefered address in the inp */
for|for
control|(
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
init|;
name|laddr
operator|&&
operator|(
name|laddr
operator|!=
name|inp
operator|->
name|next_addr_touse
operator|)
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
comment|/* ok, what about an acceptable address in the inp */
for|for
control|(
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
init|;
name|laddr
operator|&&
operator|(
name|laddr
operator|!=
name|inp
operator|->
name|next_addr_touse
operator|)
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
comment|/* 	 * no address bound can be a source for the destination we are in 	 * trouble 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Src address selection for EP, no acceptable src address found for address\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ans
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|in_addr
name|sctp_choose_v4_boundspecific_stcb
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|)
block|{
comment|/* 	 * Here we have two cases, bound all asconf allowed. bound all 	 * asconf not allowed. 	 *  	 */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|starting_point
decl_stmt|;
name|struct
name|in_addr
name|ans
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|uint8_t
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|,
name|start_at_beginning
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want that one. 	 */
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifn
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
comment|/* 		 * Here we use the list of addresses on the endpoint. Then 		 * the addresses listed on the "restricted" list is just 		 * that, address that have not been added and can't be used 		 * (unless the non_asoc_addr_ok is set). 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Have a STCB - asconf allowed, not bound all have a netgative list\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * first question, is the ifn we will emit on in our list, 		 * if so, we want that one. 		 */
if|if
condition|(
name|ifn
condition|)
block|{
comment|/* first try for an prefered address on the ep */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
condition|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
comment|/* next try for an acceptable address on the ep */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
condition|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
block|}
comment|/* 		 * if we can't find one like that then we must look at all 		 * addresses bound to pick one at first prefereable then 		 * secondly acceptable. 		 */
name|starting_point
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
expr_stmt|;
name|sctpv4_from_the_top
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctpv4_from_the_top
goto|;
block|}
comment|/* now try for any higher scope than the destination */
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|starting_point
expr_stmt|;
name|start_at_beginning
operator|=
literal|0
expr_stmt|;
name|sctpv4_from_the_top2
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctpv4_from_the_top2
goto|;
block|}
block|}
else|else
block|{
comment|/* 		 * Here we have an address list on the association, thats 		 * the only valid source addresses that we can use. 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Have a STCB - no asconf allowed, not bound all have a postive list\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * First look at all addresses for one that is on the 		 * interface we route out 		 */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 			 * first question, is laddr->ifa an address 			 * associated with the emit interface 			 */
if|if
condition|(
name|ifn
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* what about an acceptable one on the interface? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 			 * first question, is laddr->ifa an address 			 * associated with the emit interface 			 */
if|if
condition|(
name|ifn
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* ok, next one that is preferable in general */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
comment|/* last, what about one that is acceptable */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ans
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in
modifier|*
name|sctp_select_v4_nth_prefered_addr_from_ifn_boundall
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|int
name|cur_addr_num
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|uint8_t
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
if|if
condition|(
name|cur_addr_num
operator|==
name|num_eligible_addr
condition|)
block|{
return|return
operator|(
name|sin
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_v4_num_prefered_boundall
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|uint8_t
modifier|*
name|sin_loop
parameter_list|,
name|uint8_t
modifier|*
name|sin_local
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_prefered
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
name|sin_loop
argument_list|,
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num_eligible_addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|in_addr
name|sctp_choose_v4_boundall
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint8_t
name|ipv4_scope
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|)
block|{
name|int
name|cur_addr_num
init|=
literal|0
decl_stmt|,
name|num_prefered
init|=
literal|0
decl_stmt|;
name|uint8_t
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|in_addr
name|ans
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* 	 * For v4 we can use (in boundall) any address in the association. 	 * If non_asoc_addr_ok is set we can use any address (at least in 	 * theory). So we look for prefered addresses first. If we find one, 	 * we use it. Otherwise we next try to get an address on the 	 * interface, which we should be able to do (unless non_asoc_addr_ok 	 * is false and we are routed out that way). In these cases where we 	 * can't use the address of the interface we go through all the 	 * ifn's looking for an address we can use and fill that in. Punting 	 * means we send back address 0, which will probably cause problems 	 * actually since then IP will fill in the address of the route ifn, 	 * which means we probably already rejected it.. i.e. here comes an 	 * abort :-<. 	 */
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifn
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|cur_addr_num
operator|=
name|net
operator|->
name|indx_of_eligible_next_to_use
expr_stmt|;
block|}
if|if
condition|(
name|ifn
operator|==
name|NULL
condition|)
block|{
goto|goto
name|bound_all_v4_plan_c
goto|;
block|}
name|num_prefered
operator|=
name|sctp_count_v4_num_prefered_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Found %d prefered source addresses\n"
argument_list|,
name|num_prefered
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_prefered
operator|==
literal|0
condition|)
block|{
comment|/* 		 * no eligible addresses, we must use some other interface 		 * address if we can find one. 		 */
goto|goto
name|bound_all_v4_plan_b
goto|;
block|}
comment|/* 	 * Ok we have num_eligible_addr set with how many we can use, this 	 * may vary from call to call due to addresses being deprecated 	 * etc.. 	 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_prefered
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * select the nth address from the list (where cur_addr_num is the 	 * nth) and 0 is the first one, 1 is the second one etc... 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"cur_addr_num:%d\n"
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sin
operator|=
name|sctp_select_v4_nth_prefered_addr_from_ifn_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
comment|/* if sin is NULL something changed??, plan_a now */
if|if
condition|(
name|sin
condition|)
block|{
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
comment|/* 	 * plan_b: Look at the interface that we emit on and see if we can 	 * find an acceptable address. 	 */
name|bound_all_v4_plan_b
label|:
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
comment|/* 	 * plan_c: Look at all interfaces and find a prefered address. If we 	 * reache here we are in trouble I think. 	 */
name|bound_all_v4_plan_c
label|:
for|for
control|(
name|ifn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifnet
argument_list|)
init|;
name|ifn
operator|&&
operator|(
name|ifn
operator|!=
name|inp
operator|->
name|next_ifn_touse
operator|)
condition|;
name|ifn
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifn
argument_list|,
name|if_list
argument_list|)
control|)
block|{
if|if
condition|(
name|loopscope
operator|==
literal|0
operator|&&
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
if|if
condition|(
name|ifn
operator|==
name|rt
operator|->
name|rt_ifp
condition|)
comment|/* already looked at this guy */
continue|continue;
name|num_prefered
operator|=
name|sctp_count_v4_num_prefered_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Found ifn:%p %d prefered source addresses\n"
argument_list|,
name|ifn
argument_list|,
name|num_prefered
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_prefered
operator|==
literal|0
condition|)
block|{
comment|/* 			 * None on this interface. 			 */
continue|continue;
block|}
comment|/* 		 * Ok we have num_eligible_addr set with how many we can 		 * use, this may vary from call to call due to addresses 		 * being deprecated etc.. 		 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_prefered
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
name|sin
operator|=
name|sctp_select_v4_nth_prefered_addr_from_ifn_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
name|cur_addr_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
comment|/* 	 * plan_d: We are in deep trouble. No prefered address on any 	 * interface. And the emit interface does not even have an 	 * acceptable address. Take anything we can get! If this does not 	 * work we are probably going to emit a packet that will illicit an 	 * ABORT, falling through. 	 */
for|for
control|(
name|ifn
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifnet
argument_list|)
init|;
name|ifn
operator|&&
operator|(
name|ifn
operator|!=
name|inp
operator|->
name|next_ifn_touse
operator|)
condition|;
name|ifn
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifn
argument_list|,
name|if_list
argument_list|)
control|)
block|{
if|if
condition|(
name|loopscope
operator|==
literal|0
operator|&&
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
if|if
condition|(
name|ifn
operator|==
name|rt
operator|->
name|rt_ifp
condition|)
comment|/* already looked at this guy */
continue|continue;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin
operator|=
name|sctp_is_v4_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|ipv4_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|)
condition|)
block|{
comment|/* 					 * It is restricted for some 					 * reason.. probably not yet added. 					 */
continue|continue;
block|}
block|}
return|return
operator|(
name|sin
operator|->
name|sin_addr
operator|)
return|;
block|}
block|}
comment|/* 	 * Ok we can find NO address to source from that is not on our 	 * negative list. It is either the special ASCONF case where we are 	 * sourceing from a intf that has been ifconfig'd to a different 	 * address (i.e. it holds a ADD/DEL/SET-PRIM and the proper lookup 	 * address. OR we are hosed, and this baby is going to abort the 	 * association. 	 */
if|if
condition|(
name|non_asoc_addr_ok
condition|)
block|{
return|return
operator|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_addr
operator|)
operator|)
operator|->
name|sin_addr
operator|)
return|;
block|}
else|else
block|{
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ans
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* tcb may be NULL */
end_comment

begin_function
name|struct
name|in_addr
name|sctp_ipv4_source_address_selection
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|)
block|{
name|struct
name|in_addr
name|ans
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
name|uint8_t
name|ipv4_scope
decl_stmt|,
name|loopscope
decl_stmt|;
comment|/* 	 * Rules: - Find the route if needed, cache if I can. - Look at 	 * interface address in route, Is it in the bound list. If so we 	 * have the best source. - If not we must rotate amongst the 	 * addresses. 	 *  	 * Cavets and issues 	 *  	 * Do we need to pay attention to scope. We can have a private address 	 * or a global address we are sourcing or sending to. So if we draw 	 * it out source     *      dest   *  result 	 * ------------------------------------------ a   Private    * 	 * Global  *  NAT? ------------------------------------------ b 	 * Private    *     Private *  No problem 	 * ------------------------------------------ c   Global     * 	 * Private *  Huh, How will this work? 	 * ------------------------------------------ d   Global     * 	 * Global  *  No Problem ------------------------------------------ 	 *  	 * And then we add to that what happens if there are multiple addresses 	 * assigned to an interface. Remember the ifa on a ifn is a linked 	 * list of addresses. So one interface can have more than one IPv4 	 * address. What happens if we have both a private and a global 	 * address? Do we then use context of destination to sort out which 	 * one is best? And what about NAT's sending P->G may get you a NAT 	 * translation, or should you select the G thats on the interface in 	 * preference. 	 *  	 * Decisions: 	 *  	 * - count the number of addresses on the interface. - if its one, no 	 * problem except case<c>. For<a> we will assume a NAT out there. 	 * - if there are more than one, then we need to worry about scope P 	 * or G. We should prefer G -> G and P -> P if possible. Then as a 	 * secondary fall back to mixed types G->P being a last ditch one. - 	 * The above all works for bound all, but bound specific we need to 	 * use the same concept but instead only consider the bound 	 * addresses. If the bound set is NOT assigned to the interface then 	 * we must use rotation amongst them. 	 *  	 * Notes: For v4, we can always punt and let ip_output decide by 	 * sending back a source of 0.0.0.0 	 */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Need a route to cache. 		 *  		 */
name|rtalloc_ign
argument_list|(
name|ro
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* No route to host .. punt */
name|memset
argument_list|(
operator|&
name|ans
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
comment|/* Setup our scopes */
if|if
condition|(
name|stcb
condition|)
block|{
name|ipv4_scope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|ipv4_local_scope
expr_stmt|;
name|loopscope
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|loopback_scope
expr_stmt|;
block|}
else|else
block|{
comment|/* Scope based on outbound address */
if|if
condition|(
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
name|loopscope
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN4_ISLOOPBACK_ADDRESS
argument_list|(
operator|&
name|to
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|ipv4_scope
operator|=
literal|1
expr_stmt|;
name|loopscope
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ipv4_scope
operator|=
literal|0
expr_stmt|;
name|loopscope
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* 		 * When bound to all if the address list is set it is a 		 * negative list. Addresses being added by asconf. 		 */
return|return
operator|(
name|sctp_choose_v4_boundall
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|ipv4_scope
argument_list|,
name|loopscope
argument_list|,
name|non_asoc_addr_ok
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Three possiblities here: 	 *  	 * a) stcb is NULL, which means we operate only from the list of 	 * addresses (ifa's) bound to the assoc and we care not about the 	 * list. b) stcb is NOT-NULL, which means we have an assoc structure 	 * and auto-asconf is on. This means that the list of addresses is a 	 * NOT list. We use the list from the inp, but any listed address in 	 * our list is NOT yet added. However if the non_asoc_addr_ok is set 	 * we CAN use an address NOT available (i.e. being added). Its a 	 * negative list. c) stcb is NOT-NULL, which means we have an assoc 	 * structure and auto-asconf is off. This means that the list of 	 * addresses is the ONLY addresses I can use.. its positive. 	 *  	 * Note we collapse b& c into the same function just like in the v6 	 * address selection. 	 */
if|if
condition|(
name|stcb
condition|)
block|{
return|return
operator|(
name|sctp_choose_v4_boundspecific_stcb
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|ipv4_scope
argument_list|,
name|loopscope
argument_list|,
name|non_asoc_addr_ok
argument_list|)
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|sctp_choose_v4_boundspecific_inp
argument_list|(
name|inp
argument_list|,
name|ro
argument_list|,
name|ipv4_scope
argument_list|,
name|loopscope
argument_list|)
operator|)
return|;
block|}
comment|/* this should not be reached */
name|memset
argument_list|(
operator|&
name|ans
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in6
modifier|*
name|sctp_is_v6_ifa_addr_acceptable
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|int
name|loopscope
parameter_list|,
name|int
name|loc_scope
parameter_list|,
name|int
modifier|*
name|sin_loop
parameter_list|,
name|int
modifier|*
name|sin_local
parameter_list|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ifa6
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
block|{
comment|/* forget non-v6 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ifa6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
comment|/* ok to use deprecated addresses? */
if|if
condition|(
operator|!
name|ip6_use_deprecated
condition|)
block|{
if|if
condition|(
name|IFA6_IS_DEPRECATED
argument_list|(
name|ifa6
argument_list|)
condition|)
block|{
comment|/* can't use this type */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* are we ok, with the current state of this address? */
if|if
condition|(
name|ifa6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_DETACHED
operator||
name|IN6_IFF_NOTREADY
operator||
name|IN6_IFF_ANYCAST
operator|)
condition|)
block|{
comment|/* Can't use these types */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Ok the address may be ok */
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
operator|*
name|sin_local
operator|=
operator|*
name|sin_loop
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
operator|)
operator|||
operator|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
operator|*
name|sin_loop
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loopscope
operator|&&
operator|*
name|sin_loop
condition|)
block|{
comment|/* Its a loopback address and we don't have loop scope */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* we skip unspecifed addresses */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
operator|*
name|sin_local
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|loc_scope
operator|&&
operator|*
name|sin_local
condition|)
block|{
comment|/* 		 * Its a link local address, and we don't have link local 		 * scope 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|sin6
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in6
modifier|*
name|sctp_choose_v6_boundspecific_stcb
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint8_t
name|loc_scope
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|)
block|{
comment|/* 	 * Each endpoint has a list of local addresses associated with it. 	 * The address list is either a "negative list" i.e. those addresses 	 * that are NOT allowed to be used as a source OR a "postive list" 	 * i.e. those addresses that CAN be used. 	 *  	 * Its a negative list if asconf is allowed. What we do in this case is 	 * use the ep address list BUT we have to cross check it against the 	 * negative list. 	 *  	 * In the case where NO asconf is allowed, we have just a straight 	 * association level list that we must use to find a source address. 	 */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|,
modifier|*
name|starting_point
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|int
name|start_at_beginning
init|=
literal|0
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifn
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|sctp_is_feature_on
argument_list|(
name|inp
argument_list|,
name|SCTP_PCB_FLAGS_DO_ASCONF
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Have a STCB - asconf allowed, not bound all have a netgative list\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * first question, is the ifn we will emit on in our list, 		 * if so, we want that one. 		 */
if|if
condition|(
name|ifn
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
condition|)
block|{
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
return|return
operator|(
name|sin6
operator|)
return|;
block|}
block|}
block|}
name|starting_point
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
expr_stmt|;
comment|/* First try for matching scope */
name|sctp_from_the_top
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
comment|/* is it of matching scope ? */
if|if
condition|(
operator|(
name|loopscope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|loc_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_loop
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_local
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* all of global scope we are ok with it */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|loopscope
operator|&&
name|sin_loop
condition|)
comment|/* both on the loopback, thats ok */
return|return
operator|(
name|sin6
operator|)
return|;
if|if
condition|(
name|loc_scope
operator|&&
name|sin_local
condition|)
comment|/* both local scope */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctp_from_the_top
goto|;
block|}
comment|/* now try for any higher scope than the destination */
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|starting_point
expr_stmt|;
name|start_at_beginning
operator|=
literal|0
expr_stmt|;
name|sctp_from_the_top2
label|:
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|==
name|NULL
condition|)
block|{
name|start_at_beginning
operator|=
literal|1
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
expr_stmt|;
block|}
comment|/* search beginning with the last used address */
for|for
control|(
name|laddr
operator|=
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
init|;
name|laddr
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
operator|)
condition|)
block|{
comment|/* on the no-no list */
continue|continue;
block|}
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|start_at_beginning
operator|==
literal|0
condition|)
block|{
name|stcb
operator|->
name|asoc
operator|.
name|last_used_address
operator|=
name|NULL
expr_stmt|;
goto|goto
name|sctp_from_the_top2
goto|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Have a STCB - no asconf allowed, not bound all have a postive list\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* First try for interface output match */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 			 * first question, is laddr->ifa an address 			 * associated with the emit interface 			 */
if|if
condition|(
name|ifn
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|ifa
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|sctp_cmpaddr
argument_list|(
name|ifa
operator|->
name|ifa_addr
argument_list|,
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
argument_list|)
operator|==
literal|1
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
return|return
operator|(
name|sin6
operator|)
return|;
block|}
block|}
block|}
block|}
comment|/* Next try for matching scope */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|loopscope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|loc_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_loop
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_local
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* all of global scope we are ok with it */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|loopscope
operator|&&
name|sin_loop
condition|)
comment|/* both on the loopback, thats ok */
return|return
operator|(
name|sin6
operator|)
return|;
if|if
condition|(
name|loc_scope
operator|&&
name|sin_local
condition|)
comment|/* both local scope */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
comment|/* ok, now try for a higher scope in the source address */
comment|/* First try for matching scope */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&stcb->asoc.sctp_local_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin6
operator|)
return|;
block|}
block|}
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in6
modifier|*
name|sctp_choose_v6_boundspecific_inp
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint8_t
name|loc_scope
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|)
block|{
comment|/* 	 * Here we are bound specific and have only an inp. We must find an 	 * address that is bound that we can give out as a src address. We 	 * prefer two addresses of same scope if we can find them that way. 	 */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
comment|/* 	 * first question, is the ifn we will emit on in our list, if so, we 	 * want that one. 	 */
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifn
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|ifn
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_addr_in_ep
argument_list|(
name|inp
argument_list|,
name|ifa
argument_list|)
condition|)
block|{
return|return
operator|(
name|sin6
operator|)
return|;
block|}
block|}
block|}
for|for
control|(
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
init|;
name|laddr
operator|&&
operator|(
name|laddr
operator|!=
name|inp
operator|->
name|next_addr_touse
operator|)
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|loopscope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|loc_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_loop
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_local
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* all of global scope we are ok with it */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|loopscope
operator|&&
name|sin_loop
condition|)
comment|/* both on the loopback, thats ok */
return|return
operator|(
name|sin6
operator|)
return|;
if|if
condition|(
name|loc_scope
operator|&&
name|sin_local
condition|)
comment|/* both local scope */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
comment|/* 	 * if we reach here, we could not find two addresses of the same 	 * scope to give out. Lets look for any higher level scope for a 	 * source address. 	 */
for|for
control|(
name|laddr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_addr_list
argument_list|)
init|;
name|laddr
operator|&&
operator|(
name|laddr
operator|!=
name|inp
operator|->
name|next_addr_touse
operator|)
condition|;
name|laddr
operator|=
name|LIST_NEXT
argument_list|(
name|laddr
argument_list|,
name|sctp_nxt_addr
argument_list|)
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
comment|/* address has been removed */
continue|continue;
block|}
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
return|return
operator|(
name|sin6
operator|)
return|;
block|}
comment|/* no address bound can be a source for the destination */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Src address selection for EP, no acceptable src address found for address\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in6
modifier|*
name|sctp_select_v6_nth_addr_from_ifn_boundall
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|uint8_t
name|loc_scope
parameter_list|,
name|int
name|cur_addr_num
parameter_list|,
name|int
name|match_scope
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
if|if
condition|(
name|match_scope
condition|)
block|{
comment|/* Here we are asked to match scope if possible */
if|if
condition|(
name|loopscope
operator|&&
name|sin_loop
condition|)
comment|/* src and destination are loopback scope */
return|return
operator|(
name|sin6
operator|)
return|;
if|if
condition|(
name|loc_scope
operator|&&
name|sin_local
condition|)
comment|/* src and destination are local scope */
return|return
operator|(
name|sin6
operator|)
return|;
if|if
condition|(
operator|(
name|loopscope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|loc_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_loop
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sin_local
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* src and destination are global scope */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
continue|continue;
block|}
if|if
condition|(
name|num_eligible_addr
operator|==
name|cur_addr_num
condition|)
block|{
comment|/* this is it */
return|return
operator|(
name|sin6
operator|)
return|;
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_count_v6_num_eligible_boundall
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifn
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|uint8_t
name|loc_scope
parameter_list|)
block|{
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|num_eligible_addr
init|=
literal|0
decl_stmt|;
name|int
name|sin_loop
decl_stmt|,
name|sin_local
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
name|sin6
operator|=
name|sctp_is_v6_ifa_addr_acceptable
argument_list|(
name|ifa
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
operator|&
name|sin_loop
argument_list|,
operator|&
name|sin_local
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|stcb
condition|)
block|{
if|if
condition|(
operator|(
name|non_asoc_addr_ok
operator|==
literal|0
operator|)
operator|&&
name|sctp_is_addr_restricted
argument_list|(
name|stcb
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
argument_list|)
condition|)
block|{
comment|/* 				 * It is restricted for some reason.. 				 * probably not yet added. 				 */
continue|continue;
block|}
block|}
name|num_eligible_addr
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|num_eligible_addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sockaddr_in6
modifier|*
name|sctp_choose_v6_boundall
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|uint8_t
name|loc_scope
parameter_list|,
name|uint8_t
name|loopscope
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|)
block|{
comment|/* 	 * Ok, we are bound all SO any address is ok to use as long as it is 	 * NOT in the negative list. 	 */
name|int
name|num_eligible_addr
decl_stmt|;
name|int
name|cur_addr_num
init|=
literal|0
decl_stmt|;
name|int
name|started_at_beginning
init|=
literal|0
decl_stmt|;
name|int
name|match_scope_prefered
decl_stmt|;
comment|/* 	 * first question is, how many eligible addresses are there for the 	 * destination ifn that we are using that are within the proper 	 * scope? 	 */
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
name|ro
operator|->
name|ro_rt
expr_stmt|;
name|ifn
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
if|if
condition|(
name|net
condition|)
block|{
name|cur_addr_num
operator|=
name|net
operator|->
name|indx_of_eligible_next_to_use
expr_stmt|;
block|}
if|if
condition|(
name|cur_addr_num
operator|==
literal|0
condition|)
block|{
name|match_scope_prefered
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|match_scope_prefered
operator|=
literal|0
expr_stmt|;
block|}
name|num_eligible_addr
operator|=
name|sctp_count_v6_num_eligible_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Found %d eligible source addresses\n"
argument_list|,
name|num_eligible_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_eligible_addr
operator|==
literal|0
condition|)
block|{
comment|/* 		 * no eligible addresses, we must use some other interface 		 * address if we can find one. 		 */
goto|goto
name|bound_all_v6_plan_b
goto|;
block|}
comment|/* 	 * Ok we have num_eligible_addr set with how many we can use, this 	 * may vary from call to call due to addresses being deprecated 	 * etc.. 	 */
if|if
condition|(
name|cur_addr_num
operator|>=
name|num_eligible_addr
condition|)
block|{
name|cur_addr_num
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * select the nth address from the list (where cur_addr_num is the 	 * nth) and 0 is the first one, 1 is the second one etc... 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"cur_addr_num:%d match_scope_prefered:%d select it\n"
argument_list|,
name|cur_addr_num
argument_list|,
name|match_scope_prefered
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sin6
operator|=
name|sctp_select_v6_nth_addr_from_ifn_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
name|cur_addr_num
argument_list|,
name|match_scope_prefered
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_scope_prefered
operator|&&
operator|(
name|sin6
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* retry without the preference for matching scope */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"retry with no match_scope_prefered\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|sin6
operator|=
name|sctp_select_v6_nth_addr_from_ifn_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
name|cur_addr_num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sin6
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Selected address %d ifn:%p for the route\n"
argument_list|,
name|cur_addr_num
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|net
condition|)
block|{
comment|/* store so we get the next one */
if|if
condition|(
name|cur_addr_num
operator|<
literal|255
condition|)
name|net
operator|->
name|indx_of_eligible_next_to_use
operator|=
name|cur_addr_num
operator|+
literal|1
expr_stmt|;
else|else
name|net
operator|->
name|indx_of_eligible_next_to_use
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|sin6
operator|)
return|;
block|}
name|num_eligible_addr
operator|=
literal|0
expr_stmt|;
name|bound_all_v6_plan_b
label|:
comment|/* 	 * ok, if we reach here we either fell through due to something 	 * changing during an interupt (unlikely) or we have NO eligible 	 * source addresses for the ifn of the route (most likely). We must 	 * look at all the other interfaces EXCEPT rt->rt_ifp and do the 	 * same game. 	 */
if|if
condition|(
name|inp
operator|->
name|next_ifn_touse
operator|==
name|NULL
condition|)
block|{
name|started_at_beginning
operator|=
literal|1
expr_stmt|;
name|inp
operator|->
name|next_ifn_touse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifnet
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Start at first IFN:%p\n"
argument_list|,
name|inp
operator|->
name|next_ifn_touse
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|inp
operator|->
name|next_ifn_touse
operator|=
name|TAILQ_NEXT
argument_list|(
name|inp
operator|->
name|next_ifn_touse
argument_list|,
name|if_list
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Resume at IFN:%p\n"
argument_list|,
name|inp
operator|->
name|next_ifn_touse
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|next_ifn_touse
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"IFN Resets\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|started_at_beginning
operator|=
literal|1
expr_stmt|;
name|inp
operator|->
name|next_ifn_touse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ifnet
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|ifn
operator|=
name|inp
operator|->
name|next_ifn_touse
init|;
name|ifn
condition|;
name|ifn
operator|=
name|TAILQ_NEXT
argument_list|(
name|ifn
argument_list|,
name|if_list
argument_list|)
control|)
block|{
if|if
condition|(
name|loopscope
operator|==
literal|0
operator|&&
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
condition|)
block|{
comment|/* wrong base scope */
continue|continue;
block|}
if|if
condition|(
name|loc_scope
operator|&&
operator|(
name|ifn
operator|->
name|if_index
operator|!=
name|loc_scope
operator|)
condition|)
block|{
comment|/* 			 * by definition the scope (from to->sin6_scopeid) 			 * must match that of the interface. If not then we 			 * could pick a wrong scope for the address. 			 * Ususally we don't hit plan-b since the route 			 * handles this. However we can hit plan-b when we 			 * send to local-host so the route is the loopback 			 * interface, but the destination is a link local. 			 */
continue|continue;
block|}
if|if
condition|(
name|ifn
operator|==
name|rt
operator|->
name|rt_ifp
condition|)
block|{
comment|/* already looked at this guy */
continue|continue;
block|}
comment|/* 		 * Address rotation will only work when we are not rotating 		 * sourced interfaces and are using the interface of the 		 * route. We would need to have a per interface index in 		 * order to do proper rotation. 		 */
name|num_eligible_addr
operator|=
name|sctp_count_v6_num_eligible_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"IFN:%p has %d eligible\n"
argument_list|,
name|ifn
argument_list|,
name|num_eligible_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|num_eligible_addr
operator|==
literal|0
condition|)
block|{
comment|/* none we can use */
continue|continue;
block|}
comment|/* 		 * Ok we have num_eligible_addr set with how many we can 		 * use, this may vary from call to call due to addresses 		 * being deprecated etc.. 		 */
name|inp
operator|->
name|next_ifn_touse
operator|=
name|ifn
expr_stmt|;
comment|/* 		 * select the first one we can find with perference for 		 * matching scope. 		 */
name|sin6
operator|=
name|sctp_select_v6_nth_addr_from_ifn_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * can't find one with matching scope how about a 			 * source with higher scope 			 */
name|sin6
operator|=
name|sctp_select_v6_nth_addr_from_ifn_boundall
argument_list|(
name|ifn
argument_list|,
name|stcb
argument_list|,
name|non_asoc_addr_ok
argument_list|,
name|loopscope
argument_list|,
name|loc_scope
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
comment|/* Hmm, can't find one in the interface now */
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Selected the %d'th address of ifn:%p\n"
argument_list|,
name|cur_addr_num
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|sin6
operator|)
return|;
block|}
if|if
condition|(
name|started_at_beginning
operator|==
literal|0
condition|)
block|{
comment|/* 		 * we have not been through all of them yet, force us to go 		 * through them all. 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Force a recycle\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|inp
operator|->
name|next_ifn_touse
operator|=
name|NULL
expr_stmt|;
goto|goto
name|bound_all_v6_plan_b
goto|;
block|}
name|RTFREE
argument_list|(
name|ro
operator|->
name|ro_rt
argument_list|)
expr_stmt|;
name|ro
operator|->
name|ro_rt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* stcb and net may be NULL */
end_comment

begin_function
name|struct
name|in6_addr
name|sctp_ipv6_source_address_selection
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|,
name|int
name|non_asoc_addr_ok
parameter_list|)
block|{
name|struct
name|in6_addr
name|ans
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|rt_addr
decl_stmt|;
name|uint8_t
name|loc_scope
decl_stmt|,
name|loopscope
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|to
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ro
operator|->
name|ro_dst
decl_stmt|;
comment|/* 	 * This routine is tricky standard v6 src address selection cannot 	 * take into account what we have bound etc, so we can't use it. 	 *  	 * Instead here is what we must do: 1) Make sure we have a route, if we 	 * don't have a route we can never reach the peer. 2) Once we have a 	 * route, determine the scope of the route. Link local, loopback or 	 * global. 3) Next we divide into three types. Either we are bound 	 * all.. which means we want to use one of the addresses of the 	 * interface we are going out.<or> 4a) We have not stcb, which 	 * means we are using the specific addresses bound on an inp, in 	 * this case we are similar to the stcb case (4b below) accept the 	 * list is always a positive list.<or> 4b) We are bound specific 	 * with a stcb, which means we have a list of bound addresses and we 	 * must see if the ifn of the route is actually one of the bound 	 * addresses. If not, then we must rotate addresses amongst properly 	 * scoped bound addresses, if so we use the address of the 	 * interface. 5) Always, no matter which path we take through the 	 * above we must be sure the source address we use is allowed to be 	 * used. I.e. IN6_IFF_DETACHED, IN6_IFF_NOTREADY, and 	 * IN6_IFF_ANYCAST addresses cannot be used. 6) Addresses that are 	 * deprecated MAY be used if (!ip6_use_deprecated) { if 	 * (IFA6_IS_DEPRECATED(ifa6)) { skip the address } } 	 */
comment|/*** 1> determine route, if not already done */
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Need a route to cache. 		 */
name|int
name|scope_save
decl_stmt|;
name|scope_save
operator|=
name|to
operator|->
name|sin6_scope_id
expr_stmt|;
name|to
operator|->
name|sin6_scope_id
operator|=
literal|0
expr_stmt|;
name|rtalloc_ign
argument_list|(
name|ro
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|to
operator|->
name|sin6_scope_id
operator|=
name|scope_save
expr_stmt|;
block|}
if|if
condition|(
name|ro
operator|->
name|ro_rt
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * no route to host. this packet is going no-where. We 		 * probably should make sure we arrange to send back an 		 * error. 		 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"No route to host, this packet cannot be sent!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|ans
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ans
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ans
operator|)
return|;
block|}
comment|/*** 2a> determine scope for outbound address/route */
name|loc_scope
operator|=
name|loopscope
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We base our scope on the outbound packet scope and route, NOT the 	 * TCB (if there is one). This way in local scope we will only use a 	 * local scope src address when we send to a local address. 	 */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|to
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* 		 * If the route goes to the loopback address OR the address 		 * is a loopback address, we are loopback scope. 		 */
name|loc_scope
operator|=
literal|0
expr_stmt|;
name|loopscope
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|net
operator|!=
name|NULL
condition|)
block|{
comment|/* mark it as local */
name|net
operator|->
name|addr_is_local
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|to
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
name|to
operator|->
name|sin6_scope_id
condition|)
name|loc_scope
operator|=
name|to
operator|->
name|sin6_scope_id
expr_stmt|;
else|else
block|{
name|loc_scope
operator|=
literal|1
expr_stmt|;
block|}
name|loopscope
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * now, depending on which way we are bound we call the appropriate 	 * routine to do steps 3-6 	 */
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Destination address:"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|to
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|rt_addr
operator|=
name|sctp_choose_v6_boundall
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|loc_scope
argument_list|,
name|loopscope
argument_list|,
name|non_asoc_addr_ok
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stcb
condition|)
name|rt_addr
operator|=
name|sctp_choose_v6_boundspecific_stcb
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ro
argument_list|,
name|loc_scope
argument_list|,
name|loopscope
argument_list|,
name|non_asoc_addr_ok
argument_list|)
expr_stmt|;
else|else
comment|/* 			 * we can't have a non-asoc address since we have no 			 * association 			 */
name|rt_addr
operator|=
name|sctp_choose_v6_boundspecific_inp
argument_list|(
name|inp
argument_list|,
name|ro
argument_list|,
name|loc_scope
argument_list|,
name|loopscope
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt_addr
operator|==
name|NULL
condition|)
block|{
comment|/* no suitable address? */
name|struct
name|in6_addr
name|in6
decl_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"V6 packet will reach dead-end no suitable src address\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|in6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|in6
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_OUTPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Source address selected is:"
argument_list|)
expr_stmt|;
name|sctp_print_address
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|rt_addr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|rt_addr
operator|->
name|sin6_addr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp_is_address_in_scope
parameter_list|(
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|,
name|int
name|ipv4_addr_legal
parameter_list|,
name|int
name|ipv6_addr_legal
parameter_list|,
name|int
name|loopback_scope
parameter_list|,
name|int
name|ipv4_local_scope
parameter_list|,
name|int
name|local_scope
parameter_list|,
name|int
name|site_scope
parameter_list|)
block|{
if|if
condition|(
operator|(
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_ifp
operator|)
operator|&&
operator|(
name|ifa
operator|->
name|ifa_ifp
operator|->
name|if_type
operator|==
name|IFT_LOOP
operator|)
condition|)
block|{
comment|/* 		 * skip loopback if not in scope * 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
operator|)
operator|&&
name|ipv4_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
comment|/* not in scope , unspecified */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|ipv4_local_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN4_ISPRIVATE_ADDRESS
argument_list|(
operator|&
name|sin
operator|->
name|sin_addr
argument_list|)
operator|)
condition|)
block|{
comment|/* private address not in scope */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
operator|)
operator|&&
name|ipv6_addr_legal
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|in6_ifaddr
modifier|*
name|ifa6
decl_stmt|;
name|ifa6
operator|=
operator|(
expr|struct
name|in6_ifaddr
operator|*
operator|)
name|ifa
expr_stmt|;
comment|/* ok to use deprecated addresses? */
if|if
condition|(
operator|!
name|ip6_use_deprecated
condition|)
block|{
if|if
condition|(
name|ifa6
operator|->
name|ia6_flags
operator|&
name|IN6_IFF_DEPRECATED
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|ifa6
operator|->
name|ia6_flags
operator|&
operator|(
name|IN6_IFF_DETACHED
operator||
name|IN6_IFF_ANYCAST
operator||
name|IN6_IFF_NOTREADY
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* skip unspecifed addresses */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
comment|/* (local_scope == 0)&& */
operator|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|site_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|sctp_add_addr_to_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ifaddr
modifier|*
name|ifa
parameter_list|)
block|{
name|struct
name|sctp_paramhdr
modifier|*
name|parmh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mret
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv4addr_param
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_ipv6addr_param
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* unknown type */
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
name|len
condition|)
block|{
comment|/* easy side we just drop it on the end */
name|parmh
operator|=
operator|(
expr|struct
name|sctp_paramhdr
operator|*
operator|)
operator|(
name|SCTP_BUF_AT
argument_list|(
name|m
argument_list|,
name|SCTP_BUF_LEN
argument_list|(
name|m
argument_list|)
argument_list|)
operator|)
expr_stmt|;
name|mret
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
comment|/* Need more space */
name|mret
operator|=
name|m
expr_stmt|;
while|while
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mret
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
expr_stmt|;
block|}
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|=
name|sctp_get_mbuf_for_msg
argument_list|(
name|len
argument_list|,
literal|0
argument_list|,
name|M_DONTWAIT
argument_list|,
literal|1
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* We are hosed, can't add more addresses */
return|return
operator|(
name|m
operator|)
return|;
block|}
name|mret
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mret
argument_list|)
expr_stmt|;
name|parmh
operator|=
name|mtod
argument_list|(
name|mret
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* now add the parameter */
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|struct
name|sctp_ipv4addr_param
modifier|*
name|ipv4p
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|ipv4p
operator|=
operator|(
expr|struct
name|sctp_ipv4addr_param
operator|*
operator|)
name|parmh
expr_stmt|;
name|parmh
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV4_ADDRESS
argument_list|)
expr_stmt|;
name|parmh
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|ipv4p
operator|->
name|addr
operator|=
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|+=
name|len
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sctp_ipv6addr_param
modifier|*
name|ipv6p
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|ipv6p
operator|=
operator|(
expr|struct
name|sctp_ipv6addr_param
operator|*
operator|)
name|parmh
expr_stmt|;
name|parmh
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_IPV6_ADDRESS
argument_list|)
expr_stmt|;
name|parmh
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ipv6p
operator|->
name|addr
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|ipv6p
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* clear embedded scope in the address */
name|in6_clearscope
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ipv6p
operator|->
name|addr
argument_list|)
expr_stmt|;
name|SCTP_BUF_LEN
argument_list|(
name|mret
argument_list|)
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|m
operator|)
return|;
block|}
return|return
operator|(
name|mret
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|sctp_add_addresses_to_i_ia
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|sctp_scoping
modifier|*
name|scope
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m_at
parameter_list|,
name|int
name|cnt_inits_to
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifn
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ifn
argument_list|,
argument|&ifnet
argument_list|,
argument|if_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
operator|)
condition|)
block|{
comment|/* 				 * Skip loopback devices if loopback_scope 				 * not set 				 */
continue|continue;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|ifa
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cnt
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ifn
argument_list|,
argument|&ifnet
argument_list|,
argument|if_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|scope
operator|->
name|loopback_scope
operator|==
literal|0
operator|)
operator|&&
operator|(
name|ifn
operator|->
name|if_type
operator|==
name|IFT_LOOP
operator|)
condition|)
block|{
comment|/* 					 * Skip loopback devices if 					 * loopback_scope not set 					 */
continue|continue;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifn->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|ifa
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|m_at
operator|=
name|sctp_add_addr_to_mbuf
argument_list|(
name|m_at
argument_list|,
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|cnt
operator|=
name|cnt_inits_to
expr_stmt|;
comment|/* First, how many ? */
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|cnt
operator|++
expr_stmt|;
block|}
comment|/* 		 * To get through a NAT we only list addresses if we have 		 * more than one. That way if you just bind a single address 		 * we let the source of the init dictate our address. 		 */
if|if
condition|(
name|cnt
operator|>
literal|1
condition|)
block|{
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|==
name|NULL
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|sctp_is_address_in_scope
argument_list|(
name|laddr
operator|->
name|ifa
argument_list|,
name|scope
operator|->
name|ipv4_addr_legal
argument_list|,
name|scope
operator|->
name|ipv6_addr_legal
argument_list|,
name|scope
operator|->
name|loopback_scope
argument_list|,
name|scope
operator|->
name|ipv4_local_scope
argument_list|,
name|scope
operator|->
name|local_scope
argument_list|,
name|scope
operator|->
name|site_scope
argument_list|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
name|m_at
operator|=
name|sctp_add_addr_to_mbuf
argument_list|(
name|m_at
argument_list|,
name|laddr
operator|->
name|ifa
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|m_at
operator|)
return|;
block|}
end_function

end_unit

