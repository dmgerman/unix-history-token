begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1999, 2000 Matthew R. Green  * Copyright (c) 2001 - 2003 by Thomas Moestl<tmm@FreeBSD.org>  * Copyright (c) 2009 by Marius Strobl<marius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,  * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED  * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	from: NetBSD: psycho.c,v 1.39 2001/10/07 20:30:41 eeh Exp  *	from: FreeBSD: psycho.c 183152 2008-09-18 19:45:22Z marius  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Driver for `Fire' JBus to PCI Express and `Oberon' Uranus to PCI Express  * bridges  */
end_comment

begin_include
include|#
directive|include
file|"opt_fire.h"
end_include

begin_include
include|#
directive|include
file|"opt_ofw_pci.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/interrupt.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pciio.h>
end_include

begin_include
include|#
directive|include
file|<sys/pcpu.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/timetc.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_pci.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_common.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus_private.h>
end_include

begin_include
include|#
directive|include
file|<machine/fsr.h>
end_include

begin_include
include|#
directive|include
file|<machine/iommureg.h>
end_include

begin_include
include|#
directive|include
file|<machine/iommuvar.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/pci/ofw_pci.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/pci/firereg.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/pci/firevar.h>
end_include

begin_include
include|#
directive|include
file|"pcib_if.h"
end_include

begin_struct_decl
struct_decl|struct
name|fire_msiqarg
struct_decl|;
end_struct_decl

begin_function_decl
specifier|static
name|bus_space_tag_t
name|fire_alloc_bus_tag
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|fire_desc
modifier|*
name|fire_get_desc
parameter_list|(
name|device_t
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_dmamap_sync
parameter_list|(
name|bus_dma_tag_t
name|dt
name|__unused
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_dmasync_op_t
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fire_get_intrmap
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|ino
parameter_list|,
name|bus_addr_t
modifier|*
name|intrmapptr
parameter_list|,
name|bus_addr_t
modifier|*
name|intrclrptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_intr_assign
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_intr_clear
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_intr_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_intr_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fire_intr_register
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|ino
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|fire_msiq_common
parameter_list|(
name|struct
name|intr_vector
modifier|*
name|iv
parameter_list|,
name|struct
name|fire_msiqarg
modifier|*
name|fmqa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_msiq_filter
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_msiq_handler
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fire_set_intr
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|index
parameter_list|,
name|u_int
name|ino
parameter_list|,
name|driver_filter_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|timecounter_get_t
name|fire_get_timecount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Interrupt handlers */
end_comment

begin_decl_stmt
specifier|static
name|driver_filter_t
name|fire_dmc_pec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_filter_t
name|fire_pcie
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|driver_filter_t
name|fire_xcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Methods  */
end_comment

begin_decl_stmt
specifier|static
name|bus_activate_resource_t
name|fire_activate_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_alloc_msi_t
name|fire_alloc_msi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_alloc_msix_t
name|fire_alloc_msix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_alloc_resource_t
name|fire_alloc_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|fire_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_deactivate_resource_t
name|fire_deactivate_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_get_dma_tag_t
name|fire_get_dma_tag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ofw_bus_get_node_t
name|fire_get_node
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_map_msi_t
name|fire_map_msi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_maxslots_t
name|fire_maxslots
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_probe_t
name|fire_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_read_config_t
name|fire_read_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_read_ivar_t
name|fire_read_ivar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_release_msi_t
name|fire_release_msi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_release_msix_t
name|fire_release_msix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_release_resource_t
name|fire_release_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_route_interrupt_t
name|fire_route_interrupt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_setup_intr_t
name|fire_setup_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_teardown_intr_t
name|fire_teardown_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pcib_write_config_t
name|fire_write_config
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|fire_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|fire_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|fire_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_shutdown
argument_list|,
name|bus_generic_shutdown
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_suspend
argument_list|,
name|bus_generic_suspend
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_resume
argument_list|,
name|bus_generic_resume
argument_list|)
block|,
comment|/* Bus interface */
name|DEVMETHOD
argument_list|(
name|bus_print_child
argument_list|,
name|bus_generic_print_child
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_read_ivar
argument_list|,
name|fire_read_ivar
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|fire_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|fire_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|fire_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|fire_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|fire_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|fire_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_dma_tag
argument_list|,
name|fire_get_dma_tag
argument_list|)
block|,
comment|/* pcib interface */
name|DEVMETHOD
argument_list|(
name|pcib_maxslots
argument_list|,
name|fire_maxslots
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_read_config
argument_list|,
name|fire_read_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_write_config
argument_list|,
name|fire_write_config
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_route_interrupt
argument_list|,
name|fire_route_interrupt
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_alloc_msi
argument_list|,
name|fire_alloc_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_release_msi
argument_list|,
name|fire_release_msi
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_alloc_msix
argument_list|,
name|fire_alloc_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_release_msix
argument_list|,
name|fire_release_msix
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|pcib_map_msi
argument_list|,
name|fire_map_msi
argument_list|)
block|,
comment|/* ofw_bus interface */
name|DEVMETHOD
argument_list|(
name|ofw_bus_get_node
argument_list|,
name|fire_get_node
argument_list|)
block|,
name|KOBJMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|fire_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|pcib
argument_list|,
name|fire_driver
argument_list|,
name|fire_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|fire_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|EARLY_DRIVER_MODULE
argument_list|(
name|fire
argument_list|,
name|nexus
argument_list|,
name|fire_driver
argument_list|,
name|fire_devclass
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|BUS_PASS_BUS
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|fire
argument_list|,
name|nexus
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intr_controller
name|fire_ic
init|=
block|{
name|fire_intr_enable
block|,
name|fire_intr_disable
block|,
name|fire_intr_assign
block|,
name|fire_intr_clear
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fire_icarg
block|{
name|struct
name|fire_softc
modifier|*
name|fica_sc
decl_stmt|;
name|bus_addr_t
name|fica_map
decl_stmt|;
name|bus_addr_t
name|fica_clr
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|intr_controller
name|fire_msiqc_filter
init|=
block|{
name|fire_intr_enable
block|,
name|fire_intr_disable
block|,
name|fire_intr_assign
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|fire_msiqarg
block|{
name|struct
name|fire_icarg
name|fmqa_fica
decl_stmt|;
name|struct
name|mtx
name|fmqa_mtx
decl_stmt|;
name|struct
name|fo_msiq_record
modifier|*
name|fmqa_base
decl_stmt|;
name|uint64_t
name|fmqa_head
decl_stmt|;
name|uint64_t
name|fmqa_tail
decl_stmt|;
name|uint32_t
name|fmqa_msiq
decl_stmt|;
name|uint32_t
name|fmqa_msi
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FIRE_PERF_CNT_QLTY
value|100
end_define

begin_define
define|#
directive|define
name|FIRE_SPC_BARRIER
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|)
define|\
value|bus_barrier((sc)->sc_mem_res[(spc)], (offs), (len), (flags))
end_define

begin_define
define|#
directive|define
name|FIRE_SPC_READ_8
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|bus_read_8((sc)->sc_mem_res[(spc)], (offs))
end_define

begin_define
define|#
directive|define
name|FIRE_SPC_WRITE_8
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
define|\
value|bus_write_8((sc)->sc_mem_res[(spc)], (offs), (v))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|FIRE_DEBUG
end_ifndef

begin_define
define|#
directive|define
name|FIRE_SPC_SET
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|,
name|reg
parameter_list|,
name|v
parameter_list|)
define|\
value|FIRE_SPC_WRITE_8((spc), (sc), (offs), (v))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FIRE_SPC_SET
parameter_list|(
name|spc
parameter_list|,
name|sc
parameter_list|,
name|offs
parameter_list|,
name|reg
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	device_printf((sc)->sc_dev, reg " 0x%016llx -> 0x%016llx\n",	\ 	    (unsigned long long)FIRE_SPC_READ_8((spc), (sc), (offs)),	\ 	    (unsigned long long)(v));					\ 	FIRE_SPC_WRITE_8((spc), (sc), (offs), (v));			\ 	} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FIRE_PCI_BARRIER
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|)
define|\
value|FIRE_SPC_BARRIER(FIRE_PCI, (sc), (offs), len, flags)
end_define

begin_define
define|#
directive|define
name|FIRE_PCI_READ_8
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|FIRE_SPC_READ_8(FIRE_PCI, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|FIRE_PCI_WRITE_8
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
define|\
value|FIRE_SPC_WRITE_8(FIRE_PCI, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|FIRE_CTRL_BARRIER
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|len
parameter_list|,
name|flags
parameter_list|)
define|\
value|FIRE_SPC_BARRIER(FIRE_CTRL, (sc), (offs), len, flags)
end_define

begin_define
define|#
directive|define
name|FIRE_CTRL_READ_8
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|)
define|\
value|FIRE_SPC_READ_8(FIRE_CTRL, (sc), (offs))
end_define

begin_define
define|#
directive|define
name|FIRE_CTRL_WRITE_8
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
define|\
value|FIRE_SPC_WRITE_8(FIRE_CTRL, (sc), (offs), (v))
end_define

begin_define
define|#
directive|define
name|FIRE_PCI_SET
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
define|\
value|FIRE_SPC_SET(FIRE_PCI, (sc), (offs), # offs, (v))
end_define

begin_define
define|#
directive|define
name|FIRE_CTRL_SET
parameter_list|(
name|sc
parameter_list|,
name|offs
parameter_list|,
name|v
parameter_list|)
define|\
value|FIRE_SPC_SET(FIRE_CTRL, (sc), (offs), # offs, (v))
end_define

begin_struct
struct|struct
name|fire_desc
block|{
specifier|const
name|char
modifier|*
name|fd_string
decl_stmt|;
name|int
name|fd_mode
decl_stmt|;
specifier|const
name|char
modifier|*
name|fd_name
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|fire_desc
specifier|const
name|fire_compats
index|[]
init|=
block|{
block|{
literal|"pciex108e,80f0"
block|,
name|FIRE_MODE_FIRE
block|,
literal|"Fire"
block|}
block|,
if|#
directive|if
literal|0
block|{ "pciex108e,80f8",	FIRE_MODE_OBERON,	"Oberon" },
endif|#
directive|endif
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|struct
name|fire_desc
modifier|*
name|fire_get_desc
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|struct
name|fire_desc
modifier|*
name|desc
decl_stmt|;
specifier|const
name|char
modifier|*
name|compat
decl_stmt|;
name|compat
operator|=
name|ofw_bus_get_compat
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|compat
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|desc
operator|=
name|fire_compats
init|;
name|desc
operator|->
name|fd_string
operator|!=
name|NULL
condition|;
name|desc
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|desc
operator|->
name|fd_string
argument_list|,
name|compat
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|desc
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dtype
decl_stmt|;
name|dtype
operator|=
name|ofw_bus_get_type
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtype
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|dtype
argument_list|,
name|OFW_TYPE_PCIE
argument_list|)
operator|==
literal|0
operator|&&
name|fire_get_desc
argument_list|(
name|dev
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Sun Host-PCIe bridge"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_GENERIC
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
specifier|const
name|struct
name|fire_desc
modifier|*
name|desc
decl_stmt|;
name|struct
name|ofw_pci_msi_ranges
name|msi_ranges
decl_stmt|;
name|struct
name|ofw_pci_msi_addr_ranges
name|msi_addr_ranges
decl_stmt|;
name|struct
name|ofw_pci_msi_eq_to_devino
name|msi_eq_to_devino
decl_stmt|;
name|struct
name|fire_msiqarg
modifier|*
name|fmqa
decl_stmt|;
name|struct
name|timecounter
modifier|*
name|tc
decl_stmt|;
name|struct
name|ofw_pci_ranges
modifier|*
name|range
decl_stmt|;
name|uint64_t
name|ino_bitmap
decl_stmt|,
name|val
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|uint32_t
name|prop
decl_stmt|,
name|prop_array
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|mode
decl_stmt|;
name|u_int
name|lw
decl_stmt|;
name|uint16_t
name|mps
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|node
operator|=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|desc
operator|=
name|fire_get_desc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|desc
operator|->
name|fd_mode
expr_stmt|;
name|sc
operator|->
name|sc_dev
operator|=
name|dev
expr_stmt|;
name|sc
operator|->
name|sc_node
operator|=
name|node
expr_stmt|;
name|sc
operator|->
name|sc_mode
operator|=
name|mode
expr_stmt|;
name|sc
operator|->
name|sc_flags
operator|=
literal|0
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|,
literal|"msi_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|,
literal|"pcib_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* 	 * Fire and Oberon have two register banks: 	 * (0) per-PBM PCI Express configuration and status registers 	 * (1) (shared) Fire/Oberon controller configuration and status 	 *     registers 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRE_NREG
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
expr_stmt|;
name|sc
operator|->
name|sc_mem_res
index|[
name|i
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|j
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mem_res
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: could not allocate register bank %d"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"portid"
argument_list|,
operator|&
name|sc
operator|->
name|sc_ign
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine IGN"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"module-revision#"
argument_list|,
operator|&
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine revision"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"%s, module-revision %d, IGN %#x\n"
argument_list|,
name|desc
operator|->
name|fd_name
argument_list|,
name|prop
argument_list|,
name|sc
operator|->
name|sc_ign
argument_list|)
expr_stmt|;
comment|/* 	 * Hunt through all the interrupt mapping regs and register 	 * the interrupt controller for our interrupt vectors.  We do 	 * this early in order to be able to catch stray interrupts. 	 */
name|i
operator|=
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"ino-bitmap"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prop_array
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not get ino-bitmap"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ino_bitmap
operator|=
operator|(
operator|(
name|uint64_t
operator|)
name|prop_array
index|[
literal|1
index|]
operator|<<
literal|32
operator|)
operator||
name|prop_array
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|FO_MAX_INO
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ino_bitmap
operator|&
operator|(
literal|1ULL
operator|<<
name|i
operator|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|j
operator|=
name|fire_intr_register
argument_list|(
name|sc
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"could not register interrupt "
literal|"controller for INO %d (%d)\n"
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* JBC/UBC module initialization */
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_ERR_LOG_EN
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_ERR_STAT_CLR
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
comment|/* not enabled by OpenSolaris */
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_INT_EN
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_FIRE
condition|)
block|{
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FIRE_JBUS_PAR_CTRL
argument_list|,
name|FIRE_JBUS_PAR_CTRL_P_EN
argument_list|)
expr_stmt|;
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FIRE_JBC_FATAL_RST_EN
argument_list|,
operator|(
operator|(
literal|1ULL
operator|<<
name|FIRE_JBC_FATAL_RST_EN_SPARE_P_INT_SHFT
operator|)
operator|&
name|FIRE_JBC_FATAL_RST_EN_SPARE_P_INT_MASK
operator|)
operator||
name|FIRE_JBC_FATAL_RST_EN_MB_PEA_P_INT
operator||
name|FIRE_JBC_FATAL_RST_EN_CPE_P_INT
operator||
name|FIRE_JBC_FATAL_RST_EN_APE_P_INT
operator||
name|FIRE_JBC_FATAL_RST_EN_PIO_CPE_INT
operator||
name|FIRE_JBC_FATAL_RST_EN_JTCEEW_P_INT
operator||
name|FIRE_JBC_FATAL_RST_EN_JTCEEI_P_INT
operator||
name|FIRE_JBC_FATAL_RST_EN_JTCEER_P_INT
argument_list|)
expr_stmt|;
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FIRE_JBC_CORE_BLOCK_INT_EN
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
block|}
comment|/* TLU initialization */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_OEVENT_STAT_CLR
argument_list|,
name|FO_PCI_TLU_OEVENT_S_MASK
operator||
name|FO_PCI_TLU_OEVENT_P_MASK
argument_list|)
expr_stmt|;
comment|/* not enabled by OpenSolaris */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_OEVENT_INT_EN
argument_list|,
name|FO_PCI_TLU_OEVENT_S_MASK
operator||
name|FO_PCI_TLU_OEVENT_P_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_UERR_STAT_CLR
argument_list|,
name|FO_PCI_TLU_UERR_INT_S_MASK
operator||
name|FO_PCI_TLU_UERR_INT_P_MASK
argument_list|)
expr_stmt|;
comment|/* not enabled by OpenSolaris */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_UERR_INT_EN
argument_list|,
name|FO_PCI_TLU_UERR_INT_S_MASK
operator||
name|FO_PCI_TLU_UERR_INT_P_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CERR_STAT_CLR
argument_list|,
name|FO_PCI_TLU_CERR_INT_S_MASK
operator||
name|FO_PCI_TLU_CERR_INT_P_MASK
argument_list|)
expr_stmt|;
comment|/* not enabled by OpenSolaris */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CERR_INT_EN
argument_list|,
name|FO_PCI_TLU_CERR_INT_S_MASK
operator||
name|FO_PCI_TLU_CERR_INT_P_MASK
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CTRL
argument_list|)
operator||
operator|(
operator|(
name|FO_PCI_TLU_CTRL_L0S_TIM_DFLT
operator|<<
name|FO_PCI_TLU_CTRL_L0S_TIM_SHFT
operator|)
operator|&
name|FO_PCI_TLU_CTRL_L0S_TIM_MASK
operator|)
operator||
operator|(
operator|(
name|FO_PCI_TLU_CTRL_CFG_DFLT
operator|<<
name|FO_PCI_TLU_CTRL_CFG_SHFT
operator|)
operator|&
name|FO_PCI_TLU_CTRL_CFG_MASK
operator|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_OBERON
condition|)
name|val
operator|&=
operator|~
name|FO_PCI_TLU_CTRL_NWPR_EN
expr_stmt|;
name|val
operator||=
name|FO_PCI_TLU_CTRL_CFG_REMAIN_DETECT_QUIET
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CTRL
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_DEV_CTRL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_LNK_CTRL
argument_list|,
name|FO_PCI_TLU_LNK_CTRL_CLK
argument_list|)
expr_stmt|;
comment|/* DLU/LPU initialization */
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_OBERON
condition|)
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_INT_MASK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_RST
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_CFG
argument_list|,
name|FO_PCI_LPU_LNK_LYR_CFG_VC0_EN
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_FLW_CTRL_UPDT_CTRL
argument_list|,
name|FO_PCI_LPU_FLW_CTRL_UPDT_CTRL_FC0_NP_EN
operator||
name|FO_PCI_LPU_FLW_CTRL_UPDT_CTRL_FC0_P_EN
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_OBERON
condition|)
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_TXLNK_RPLY_TMR_THRS
argument_list|,
operator|(
name|OBERON_PCI_LPU_TXLNK_RPLY_TMR_THRS_DFLT
operator|<<
name|FO_PCI_LPU_TXLNK_RPLY_TMR_THRS_SHFT
operator|)
operator|&
name|FO_PCI_LPU_TXLNK_RPLY_TMR_THRS_MASK
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_LNK_STAT
argument_list|)
operator|&
name|FO_PCI_TLU_LNK_STAT_WDTH_MASK
operator|)
operator|>>
name|FO_PCI_TLU_LNK_STAT_WDTH_SHFT
condition|)
block|{
case|case
literal|1
case|:
name|lw
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|lw
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|lw
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|lw
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|lw
operator|=
literal|0
expr_stmt|;
block|}
name|mps
operator|=
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CTRL
argument_list|)
operator|&
name|FO_PCI_TLU_CTRL_CFG_MASK
operator|)
operator|>>
name|FO_PCI_TLU_CTRL_CFG_SHFT
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|fire_freq_nak_tmr_thrs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|fire_freq_nak_tmr_thrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mps
operator|>=
name|i
condition|)
empty_stmt|;
name|mps
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_TXLNK_FREQ_LAT_TMR_THRS
argument_list|,
operator|(
name|fire_freq_nak_tmr_thrs
index|[
name|mps
index|]
index|[
name|lw
index|]
operator|<<
name|FO_PCI_LPU_TXLNK_FREQ_LAT_TMR_THRS_SHFT
operator|)
operator|&
name|FO_PCI_LPU_TXLNK_FREQ_LAT_TMR_THRS_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_TXLNK_RPLY_TMR_THRS
argument_list|,
operator|(
name|fire_rply_tmr_thrs
index|[
name|mps
index|]
index|[
name|lw
index|]
operator|<<
name|FO_PCI_LPU_TXLNK_RPLY_TMR_THRS_SHFT
operator|)
operator|&
name|FO_PCI_LPU_TXLNK_RPLY_TMR_THRS_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR
argument_list|,
operator|(
operator|(
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR_TL_DFLT
operator|<<
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR_TL_SHFT
operator|)
operator|&
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR_TL_MASK
operator|)
operator||
operator|(
operator|(
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR_HD_DFLT
operator|<<
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR_HD_SHFT
operator|)
operator|&
name|FO_PCI_LPU_TXLNK_RTR_FIFO_PTR_HD_MASK
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LTSSM_CFG2
argument_list|,
operator|(
name|FO_PCI_LPU_LTSSM_CFG2_12_TO_DFLT
operator|<<
name|FO_PCI_LPU_LTSSM_CFG2_12_TO_SHFT
operator|)
operator|&
name|FO_PCI_LPU_LTSSM_CFG2_12_TO_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LTSSM_CFG3
argument_list|,
operator|(
name|FO_PCI_LPU_LTSSM_CFG3_2_TO_DFLT
operator|<<
name|FO_PCI_LPU_LTSSM_CFG3_2_TO_SHFT
operator|)
operator|&
name|FO_PCI_LPU_LTSSM_CFG3_2_TO_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LTSSM_CFG4
argument_list|,
operator|(
operator|(
name|FO_PCI_LPU_LTSSM_CFG4_DATA_RATE_DFLT
operator|<<
name|FO_PCI_LPU_LTSSM_CFG4_DATA_RATE_SHFT
operator|)
operator|&
name|FO_PCI_LPU_LTSSM_CFG4_DATA_RATE_MASK
operator|)
operator||
operator|(
operator|(
name|FO_PCI_LPU_LTSSM_CFG4_N_FTS_DFLT
operator|<<
name|FO_PCI_LPU_LTSSM_CFG4_N_FTS_SHFT
operator|)
operator|&
name|FO_PCI_LPU_LTSSM_CFG4_N_FTS_MASK
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LTSSM_CFG5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* ILU initialization */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ILU_ERR_STAT_CLR
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
comment|/* not enabled by OpenSolaris */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ILU_INT_EN
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
comment|/* IMU initialization */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_ERR_STAT_CLR
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_INT_EN
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_INT_EN
argument_list|)
operator|&
operator|~
operator|(
name|FO_PCI_IMU_ERR_INT_FATAL_MES_NOT_EN_S
operator||
name|FO_PCI_IMU_ERR_INT_NFATAL_MES_NOT_EN_S
operator||
name|FO_PCI_IMU_ERR_INT_COR_MES_NOT_EN_S
operator||
name|FO_PCI_IMU_ERR_INT_FATAL_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_NFATAL_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_COR_MES_NOT_EN_P
operator|)
argument_list|)
expr_stmt|;
comment|/* MMU initialization */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU_ERR_STAT_CLR
argument_list|,
name|FO_PCI_MMU_ERR_INT_S_MASK
operator||
name|FO_PCI_MMU_ERR_INT_P_MASK
argument_list|)
expr_stmt|;
comment|/* not enabled by OpenSolaris */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU_INT_EN
argument_list|,
name|FO_PCI_MMU_ERR_INT_S_MASK
operator||
name|FO_PCI_MMU_ERR_INT_P_MASK
argument_list|)
expr_stmt|;
comment|/* DMC initialization */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_DMC_CORE_BLOCK_INT_EN
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_DMC_DBG_SEL_PORTA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_DMC_DBG_SEL_PORTB
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* PEC initialization */
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_PEC_CORE_BLOCK_INT_EN
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
comment|/* Establish handlers for interesting interrupts. */
if|if
condition|(
operator|(
name|ino_bitmap
operator|&
operator|(
literal|1ULL
operator|<<
name|FO_DMC_PEC_INO
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fire_set_intr
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|,
name|FO_DMC_PEC_INO
argument_list|,
name|fire_dmc_pec
argument_list|,
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ino_bitmap
operator|&
operator|(
literal|1ULL
operator|<<
name|FO_XCB_INO
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fire_set_intr
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|,
name|FO_XCB_INO
argument_list|,
name|fire_xcb
argument_list|,
name|sc
argument_list|)
expr_stmt|;
comment|/* MSI/MSI-X support */
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"#msi"
argument_list|,
operator|&
name|sc
operator|->
name|sc_msi_count
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_msi_count
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine MSI count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msi-ranges"
argument_list|,
operator|&
name|msi_ranges
argument_list|,
sizeof|sizeof
argument_list|(
name|msi_ranges
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|sc
operator|->
name|sc_msi_first
operator|=
literal|0
expr_stmt|;
else|else
name|sc
operator|->
name|sc_msi_first
operator|=
name|msi_ranges
operator|.
name|first
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msi-data-mask"
argument_list|,
operator|&
name|sc
operator|->
name|sc_msi_data_mask
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_msi_data_mask
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine MSI data mask"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msix-data-width"
argument_list|,
operator|&
name|sc
operator|->
name|sc_msix_data_width
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_msix_data_width
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|sc
operator|->
name|sc_flags
operator||=
name|FIRE_MSIX
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msi-address-ranges"
argument_list|,
operator|&
name|msi_addr_ranges
argument_list|,
sizeof|sizeof
argument_list|(
name|msi_addr_ranges
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine MSI address ranges"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msi_addr32
operator|=
name|OFW_PCI_MSI_ADDR_RANGE_32
argument_list|(
operator|&
name|msi_addr_ranges
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msi_addr64
operator|=
name|OFW_PCI_MSI_ADDR_RANGE_64
argument_list|(
operator|&
name|msi_addr_ranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"#msi-eqs"
argument_list|,
operator|&
name|sc
operator|->
name|sc_msiq_count
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_msiq_count
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine MSI event queue count"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msi-eq-size"
argument_list|,
operator|&
name|sc
operator|->
name|sc_msiq_size
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_msiq_size
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine MSI event queue size"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msi-eq-to-devino"
argument_list|,
operator|&
name|msi_eq_to_devino
argument_list|,
sizeof|sizeof
argument_list|(
name|msi_eq_to_devino
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"msi-eq-devino"
argument_list|,
operator|&
name|msi_eq_to_devino
argument_list|,
sizeof|sizeof
argument_list|(
name|msi_eq_to_devino
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sc
operator|->
name|sc_msiq_first
operator|=
literal|0
expr_stmt|;
name|sc
operator|->
name|sc_msiq_ino_first
operator|=
name|FO_EQ_FIRST_INO
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_msiq_first
operator|=
name|msi_eq_to_devino
operator|.
name|eq_first
expr_stmt|;
name|sc
operator|->
name|sc_msiq_ino_first
operator|=
name|msi_eq_to_devino
operator|.
name|devino_first
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_msiq_ino_first
operator|<
name|FO_EQ_FIRST_INO
operator|||
name|sc
operator|->
name|sc_msiq_ino_first
operator|+
name|sc
operator|->
name|sc_msiq_count
operator|-
literal|1
operator|>
name|FO_EQ_LAST_INO
condition|)
name|panic
argument_list|(
literal|"%s: event queues exceed INO range"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msi_bitmap
operator|=
name|malloc
argument_list|(
name|roundup2
argument_list|(
name|sc
operator|->
name|sc_msi_count
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_msi_bitmap
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: could not malloc MSI bitmap"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msi_msiq_table
operator|=
name|malloc
argument_list|(
name|sc
operator|->
name|sc_msi_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sc
operator|->
name|sc_msi_msiq_table
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_msi_msiq_table
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: could not malloc MSI-MSI event queue table"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msiq_bitmap
operator|=
name|malloc
argument_list|(
name|roundup2
argument_list|(
name|sc
operator|->
name|sc_msiq_count
argument_list|,
name|NBBY
argument_list|)
operator|/
name|NBBY
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_msiq_bitmap
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: could not malloc MSI event queue bitmap"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|j
operator|=
name|FO_EQ_RECORD_SIZE
operator|*
name|FO_EQ_NRECORDS
operator|*
name|sc
operator|->
name|sc_msiq_count
expr_stmt|;
name|sc
operator|->
name|sc_msiq
operator|=
name|contigmalloc
argument_list|(
name|j
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|,
literal|0
argument_list|,
operator|~
literal|0UL
argument_list|,
name|FO_EQ_ALIGNMENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_msiq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: could not contigmalloc MSI event queue"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sc
operator|->
name|sc_msiq
argument_list|,
literal|0
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_BASE_ADDR
argument_list|,
name|FO_PCI_EQ_BASE_ADDR_BYPASS
operator||
operator|(
name|pmap_kextract
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|sc
operator|->
name|sc_msiq
argument_list|)
operator|&
name|FO_PCI_EQ_BASE_ADDR_MASK
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_msi_count
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|i
operator|+
name|sc
operator|->
name|sc_msi_first
operator|)
operator|<<
literal|3
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|j
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|j
argument_list|)
operator|&
operator|~
name|FO_PCI_MSI_MAP_V
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_msiq_count
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|i
operator|+
name|sc
operator|->
name|sc_msiq_ino_first
expr_stmt|;
if|if
condition|(
operator|(
name|ino_bitmap
operator|&
operator|(
literal|1ULL
operator|<<
name|j
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
block|}
name|fmqa
operator|=
name|intr_vectors
index|[
name|INTMAP_VEC
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|,
name|j
argument_list|)
index|]
operator|.
name|iv_icarg
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|fmqa
operator|->
name|fmqa_mtx
argument_list|,
literal|"msiq_mtx"
argument_list|,
name|NULL
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|fmqa
operator|->
name|fmqa_base
operator|=
operator|(
expr|struct
name|fo_msiq_record
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sc
operator|->
name|sc_msiq
operator|+
operator|(
name|FO_EQ_RECORD_SIZE
operator|*
name|FO_EQ_NRECORDS
operator|*
name|i
operator|)
operator|)
expr_stmt|;
name|j
operator|=
name|i
operator|+
name|sc
operator|->
name|sc_msiq_first
expr_stmt|;
name|fmqa
operator|->
name|fmqa_msiq
operator|=
name|j
expr_stmt|;
name|j
operator|<<=
literal|3
expr_stmt|;
name|fmqa
operator|->
name|fmqa_head
operator|=
name|FO_PCI_EQ_HD_BASE
operator|+
name|j
expr_stmt|;
name|fmqa
operator|->
name|fmqa_tail
operator|=
name|FO_PCI_EQ_TL_BASE
operator|+
name|j
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_BASE
operator|+
name|j
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_COVERR
operator||
name|FO_PCI_EQ_CTRL_CLR_E2I
operator||
name|FO_PCI_EQ_CTRL_CLR_DIS
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_tail
argument_list|,
operator|(
literal|0
operator|<<
name|FO_PCI_EQ_TL_SHFT
operator|)
operator|&
name|FO_PCI_EQ_TL_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_head
argument_list|,
operator|(
literal|0
operator|<<
name|FO_PCI_EQ_HD_SHFT
operator|)
operator|&
name|FO_PCI_EQ_HD_MASK
argument_list|)
expr_stmt|;
block|}
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_32_BIT_ADDR
argument_list|,
name|sc
operator|->
name|sc_msi_addr32
operator|&
name|FO_PCI_MSI_32_BIT_ADDR_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_64_BIT_ADDR
argument_list|,
name|sc
operator|->
name|sc_msi_addr64
operator|&
name|FO_PCI_MSI_64_BIT_ADDR_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * Establish a handler for interesting PCIe messages and disable 	 * unintersting ones. 	 */
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_msiq_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|j
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|sc_msiq_count
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: no spare event queue for PCIe messages"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|setbit
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
name|i
operator|=
name|INTMAP_VEC
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|,
name|j
operator|+
name|sc
operator|->
name|sc_msiq_ino_first
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_set_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
literal|2
argument_list|,
name|i
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: failed to add interrupt for PCIe messages"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|fire_set_intr
argument_list|(
name|sc
argument_list|,
literal|2
argument_list|,
name|INTINO
argument_list|(
name|i
argument_list|)
argument_list|,
name|fire_pcie
argument_list|,
name|intr_vectors
index|[
name|i
index|]
operator|.
name|iv_icarg
argument_list|)
expr_stmt|;
name|j
operator|+=
name|sc
operator|->
name|sc_msiq_first
expr_stmt|;
comment|/* 	 * "Please note that setting the EQNUM field to a value larger than 	 * 35 will yield unpredictable results." 	 */
if|if
condition|(
name|j
operator|>
literal|35
condition|)
name|panic
argument_list|(
literal|"%s: invalid queue for PCIe messages (%d)"
argument_list|,
name|__func__
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ERR_COR
argument_list|,
name|FO_PCI_ERR_PME_V
operator||
operator|(
operator|(
name|j
operator|<<
name|FO_PCI_ERR_PME_EQNUM_SHFT
operator|)
operator|&
name|FO_PCI_ERR_PME_EQNUM_MASK
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ERR_NONFATAL
argument_list|,
name|FO_PCI_ERR_PME_V
operator||
operator|(
operator|(
name|j
operator|<<
name|FO_PCI_ERR_PME_EQNUM_SHFT
operator|)
operator|&
name|FO_PCI_ERR_PME_EQNUM_MASK
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ERR_FATAL
argument_list|,
name|FO_PCI_ERR_PME_V
operator||
operator|(
operator|(
name|j
operator|<<
name|FO_PCI_ERR_PME_EQNUM_SHFT
operator|)
operator|&
name|FO_PCI_ERR_PME_EQNUM_MASK
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_PM_PME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_PCI_SET
argument_list|(
name|sc
argument_list|,
name|FO_PCI_PME_TO_ACK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_SET_BASE
operator|+
operator|(
name|j
operator|<<
literal|3
operator|)
argument_list|,
name|FO_PCI_EQ_CTRL_SET_EN
argument_list|)
expr_stmt|;
define|#
directive|define
name|TC_COUNTER_MAX_MASK
value|0xffffffff
comment|/* 	 * Setup JBC/UBC performance counter 0 in bus cycle counting 	 * mode as timecounter.  Unfortunately, at least with Fire all 	 * JBus-driven performance counters just don't advance in bus 	 * cycle counting mode. 	 */
if|if
condition|(
name|device_get_unit
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_PRF_CNT0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_PRF_CNT1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_PRF_CNT_SEL
argument_list|,
operator|(
name|FO_XBC_PRF_CNT_NONE
operator|<<
name|FO_XBC_PRF_CNT_CNT1_SHFT
operator|)
operator||
operator|(
name|FO_XBC_PRF_CNT_XB_CLK
operator|<<
name|FO_XBC_PRF_CNT_CNT0_SHFT
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIRE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FO_XBC_PRF_CNT0 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_XBC_PRF_CNT0
argument_list|)
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FO_XBC_PRF_CNT0 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_XBC_PRF_CNT0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|tc
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: could not malloc timecounter"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_get_timecount
operator|=
name|fire_get_timecount
expr_stmt|;
name|tc
operator|->
name|tc_poll_pps
operator|=
name|NULL
expr_stmt|;
name|tc
operator|->
name|tc_counter_mask
operator|=
name|TC_COUNTER_MAX_MASK
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|OF_peer
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|"clock-frequency"
argument_list|,
operator|&
name|prop
argument_list|,
sizeof|sizeof
argument_list|(
name|prop
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not determine clock frequency"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_frequency
operator|=
name|prop
expr_stmt|;
name|tc
operator|->
name|tc_name
operator|=
name|strdup
argument_list|(
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_quality
operator|=
operator|-
name|FIRE_PERF_CNT_QLTY
expr_stmt|;
name|tc
operator|->
name|tc_priv
operator|=
name|sc
expr_stmt|;
name|tc_init
argument_list|(
name|tc
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set up the IOMMU.  Both Fire and Oberon have one per PBM, but 	 * neither has a streaming buffer. 	 */
name|memcpy
argument_list|(
operator|&
name|sc
operator|->
name|sc_dma_methods
argument_list|,
operator|&
name|iommu_dma_methods
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
operator|->
name|sc_dma_methods
argument_list|)
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_is
operator|.
name|is_flags
operator|=
name|IOMMU_FIRE
operator||
name|IOMMU_PRESERVE_PROM
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_OBERON
condition|)
block|{
name|sc
operator|->
name|sc_is
operator|.
name|is_flags
operator||=
name|IOMMU_FLUSH_CACHE
expr_stmt|;
name|sc
operator|->
name|sc_is
operator|.
name|is_pmaxaddr
operator|=
name|IOMMU_MAXADDR
argument_list|(
name|OBERON_IOMMU_BITS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sc
operator|->
name|sc_dma_methods
operator|.
name|dm_dmamap_sync
operator|=
name|fire_dmamap_sync
expr_stmt|;
name|sc
operator|->
name|sc_is
operator|.
name|is_pmaxaddr
operator|=
name|IOMMU_MAXADDR
argument_list|(
name|FIRE_IOMMU_BITS
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|sc_is
operator|.
name|is_sb
index|[
literal|0
index|]
operator|=
name|sc
operator|->
name|sc_is
operator|.
name|is_sb
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Punch in our copies. */
name|sc
operator|->
name|sc_is
operator|.
name|is_bustag
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_mem_res
index|[
name|FIRE_PCI
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_is
operator|.
name|is_bushandle
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_mem_res
index|[
name|FIRE_PCI
index|]
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_is
operator|.
name|is_iommu
operator|=
name|FO_PCI_MMU
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU
operator|+
name|IMR_CTL
argument_list|)
expr_stmt|;
name|iommu_init
argument_list|(
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_is
argument_list|,
literal|7
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIRE_DEBUG
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"FO_PCI_MMU + IMR_CTL 0x%016llx -> 0x%016llx\n"
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|val
argument_list|,
operator|(
name|long
name|long
name|unsigned
operator|)
name|sc
operator|->
name|sc_is
operator|.
name|is_cr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize memory and I/O rmans. */
name|sc
operator|->
name|sc_pci_io_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_pci_io_rman
operator|.
name|rm_descr
operator|=
literal|"Fire PCI I/O Ports"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_pci_io_rman
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_pci_io_rman
argument_list|,
literal|0
argument_list|,
name|FO_IO_SIZE
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: failed to set up I/O rman"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pci_mem_rman
operator|.
name|rm_type
operator|=
name|RMAN_ARRAY
expr_stmt|;
name|sc
operator|->
name|sc_pci_mem_rman
operator|.
name|rm_descr
operator|=
literal|"Fire PCI Memory"
expr_stmt|;
if|if
condition|(
name|rman_init
argument_list|(
operator|&
name|sc
operator|->
name|sc_pci_mem_rman
argument_list|)
operator|!=
literal|0
operator|||
name|rman_manage_region
argument_list|(
operator|&
name|sc
operator|->
name|sc_pci_mem_rman
argument_list|,
literal|0
argument_list|,
name|FO_MEM_SIZE
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: failed to set up memory rman"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|i
operator|=
name|OF_getprop_alloc
argument_list|(
name|node
argument_list|,
literal|"ranges"
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|range
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|range
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that the expected ranges are present.  The 	 * OFW_PCI_CS_MEM64 one is not currently used though. 	 */
if|if
condition|(
name|i
operator|!=
name|FIRE_NRANGE
condition|)
name|panic
argument_list|(
literal|"%s: unsupported number of ranges"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Find the addresses of the various bus spaces. 	 * There should not be multiple ones of one kind. 	 * The physical start addresses of the ranges are the configuration, 	 * memory and I/O handles. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRE_NRANGE
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
name|OFW_PCI_RANGE_CS
argument_list|(
operator|&
name|range
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_pci_bh
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: duplicate range for space %d"
argument_list|,
name|__func__
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pci_bh
index|[
name|j
index|]
operator|=
name|OFW_PCI_RANGE_PHYS
argument_list|(
operator|&
name|range
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|range
argument_list|,
name|M_OFWPROP
argument_list|)
expr_stmt|;
comment|/* Allocate our tags. */
name|sc
operator|->
name|sc_pci_memt
operator|=
name|fire_alloc_bus_tag
argument_list|(
name|sc
argument_list|,
name|PCI_MEMORY_BUS_SPACE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pci_iot
operator|=
name|fire_alloc_bus_tag
argument_list|(
name|sc
argument_list|,
name|PCI_IO_BUS_SPACE
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pci_cfgt
operator|=
name|fire_alloc_bus_tag
argument_list|(
name|sc
argument_list|,
name|PCI_CONFIG_BUS_SPACE
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus_dma_tag_create
argument_list|(
name|bus_get_dma_tag
argument_list|(
name|dev
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
name|sc
operator|->
name|sc_is
operator|.
name|is_pmaxaddr
argument_list|,
operator|~
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sc
operator|->
name|sc_is
operator|.
name|is_pmaxaddr
argument_list|,
literal|0xff
argument_list|,
literal|0xffffffff
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|sc
operator|->
name|sc_pci_dmat
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: bus_dma_tag_create failed"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Customize the tag. */
name|sc
operator|->
name|sc_pci_dmat
operator|->
name|dt_cookie
operator|=
operator|&
name|sc
operator|->
name|sc_is
expr_stmt|;
name|sc
operator|->
name|sc_pci_dmat
operator|->
name|dt_mt
operator|=
operator|&
name|sc
operator|->
name|sc_dma_methods
expr_stmt|;
comment|/* 	 * Get the bus range from the firmware. 	 * NB: Neither Fire nor Oberon support PCI bus reenumeration. 	 */
name|i
operator|=
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"bus-range"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|prop_array
argument_list|,
sizeof|sizeof
argument_list|(
name|prop_array
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: could not get bus-range"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
sizeof|sizeof
argument_list|(
name|prop_array
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: broken bus-range (%d)"
argument_list|,
name|__func__
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_pci_secbus
operator|=
name|prop_array
index|[
literal|0
index|]
expr_stmt|;
name|sc
operator|->
name|sc_pci_subbus
operator|=
name|prop_array
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|bootverbose
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"bus range %u to %u; PCI bus %d\n"
argument_list|,
name|sc
operator|->
name|sc_pci_secbus
argument_list|,
name|sc
operator|->
name|sc_pci_subbus
argument_list|,
name|sc
operator|->
name|sc_pci_secbus
argument_list|)
expr_stmt|;
name|ofw_bus_setup_iinfo
argument_list|(
name|node
argument_list|,
operator|&
name|sc
operator|->
name|sc_pci_iinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|ofw_pci_intr_t
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|FIRE_SYSCTL_ADD_UINT
parameter_list|(
name|name
parameter_list|,
name|arg
parameter_list|,
name|desc
parameter_list|)
define|\
value|SYSCTL_ADD_UINT(device_get_sysctl_ctx(dev),			\ 	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)), OID_AUTO,	\ 	    (name), CTLFLAG_RD, (arg), 0, (desc))
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"ilu_err"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_ilu_err
argument_list|,
literal|"ILU unknown errors"
argument_list|)
expr_stmt|;
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"jbc_ce_async"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_jbc_ce_async
argument_list|,
literal|"JBC correctable errors"
argument_list|)
expr_stmt|;
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"jbc_unsol_int"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_jbc_unsol_int
argument_list|,
literal|"JBC unsolicited interrupt ACK/NACK errors"
argument_list|)
expr_stmt|;
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"jbc_unsol_rd"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_jbc_unsol_rd
argument_list|,
literal|"JBC unsolicited read response errors"
argument_list|)
expr_stmt|;
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"mmu_err"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_mmu_err
argument_list|,
literal|"MMU errors"
argument_list|)
expr_stmt|;
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"tlu_ce"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_tlu_ce
argument_list|,
literal|"DLU/TLU correctable errors"
argument_list|)
expr_stmt|;
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"tlu_oe_non_fatal"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_tlu_oe_non_fatal
argument_list|,
literal|"DLU/TLU other event non-fatal errors summary"
argument_list|)
operator|,
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"tlu_oe_rx_err"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_tlu_oe_rx_err
argument_list|,
literal|"DLU/TLU receive other event errors"
argument_list|)
operator|,
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"tlu_oe_tx_err"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_tlu_oe_tx_err
argument_list|,
literal|"DLU/TLU transmit other event errors"
argument_list|)
operator|,
name|FIRE_SYSCTL_ADD_UINT
argument_list|(
literal|"ubc_dmardue"
argument_list|,
operator|&
name|sc
operator|->
name|sc_stats_ubc_dmardue
argument_list|,
literal|"UBC DMARDUE erros"
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FIRE_SYSCTL_ADD_UINT
name|device_add_child
argument_list|(
name|dev
argument_list|,
literal|"pci"
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_set_intr
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|index
parameter_list|,
name|u_int
name|ino
parameter_list|,
name|driver_filter_t
name|handler
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|u_long
name|vec
decl_stmt|;
name|int
name|rid
decl_stmt|;
name|rid
operator|=
name|index
expr_stmt|;
name|sc
operator|->
name|sc_irq_res
index|[
name|index
index|]
operator|=
name|bus_alloc_resource_any
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|SYS_RES_IRQ
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_irq_res
index|[
name|index
index|]
operator|==
name|NULL
operator|||
name|INTINO
argument_list|(
name|vec
operator|=
name|rman_get_start
argument_list|(
name|sc
operator|->
name|sc_irq_res
index|[
name|index
index|]
argument_list|)
argument_list|)
operator|!=
name|ino
operator|||
name|INTIGN
argument_list|(
name|vec
argument_list|)
operator|!=
name|sc
operator|->
name|sc_ign
operator|||
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_ic
operator|!=
operator|&
name|fire_ic
operator|||
name|bus_setup_intr
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
name|sc
operator|->
name|sc_irq_res
index|[
name|index
index|]
argument_list|,
name|INTR_TYPE_MISC
operator||
name|INTR_FAST
argument_list|,
name|handler
argument_list|,
name|NULL
argument_list|,
name|arg
argument_list|,
operator|&
name|sc
operator|->
name|sc_ihand
index|[
name|index
index|]
argument_list|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: failed to set up interrupt %d"
argument_list|,
name|__func__
argument_list|,
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_intr_register
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|ino
parameter_list|)
block|{
name|struct
name|fire_icarg
modifier|*
name|fica
decl_stmt|;
name|bus_addr_t
name|intrclr
decl_stmt|,
name|intrmap
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|fire_get_intrmap
argument_list|(
name|sc
argument_list|,
name|ino
argument_list|,
operator|&
name|intrmap
argument_list|,
operator|&
name|intrclr
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|fica
operator|=
name|malloc
argument_list|(
operator|(
name|ino
operator|>=
name|FO_EQ_FIRST_INO
operator|&&
name|ino
operator|<=
name|FO_EQ_LAST_INO
operator|)
condition|?
sizeof|sizeof
argument_list|(
expr|struct
name|fire_msiqarg
argument_list|)
else|:
sizeof|sizeof
argument_list|(
expr|struct
name|fire_icarg
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|fica
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|fica
operator|->
name|fica_sc
operator|=
name|sc
expr_stmt|;
name|fica
operator|->
name|fica_map
operator|=
name|intrmap
expr_stmt|;
name|fica
operator|->
name|fica_clr
operator|=
name|intrclr
expr_stmt|;
name|error
operator|=
operator|(
name|intr_controller_register
argument_list|(
name|INTMAP_VEC
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|,
name|ino
argument_list|)
argument_list|,
operator|&
name|fire_ic
argument_list|,
name|fica
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|fica
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_get_intrmap
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|u_int
name|ino
parameter_list|,
name|bus_addr_t
modifier|*
name|intrmapptr
parameter_list|,
name|bus_addr_t
modifier|*
name|intrclrptr
parameter_list|)
block|{
if|if
condition|(
name|ino
operator|>
name|FO_MAX_INO
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"out of range INO %d requested\n"
argument_list|,
name|ino
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ino
operator|<<=
literal|3
expr_stmt|;
if|if
condition|(
name|intrmapptr
operator|!=
name|NULL
condition|)
operator|*
name|intrmapptr
operator|=
name|FO_PCI_INT_MAP_BASE
operator|+
name|ino
expr_stmt|;
if|if
condition|(
name|intrclrptr
operator|!=
name|NULL
condition|)
operator|*
name|intrclrptr
operator|=
name|FO_PCI_INT_CLR_BASE
operator|+
name|ino
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interrupt handlers  */
end_comment

begin_function
specifier|static
name|int
name|fire_dmc_pec
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|cestat
decl_stmt|,
name|dmcstat
decl_stmt|,
name|ilustat
decl_stmt|,
name|imustat
decl_stmt|,
name|mcstat
decl_stmt|,
name|mmustat
decl_stmt|,
name|mmutfar
decl_stmt|;
name|uint64_t
name|mmutfsr
decl_stmt|,
name|oestat
decl_stmt|,
name|pecstat
decl_stmt|,
name|uestat
decl_stmt|,
name|val
decl_stmt|;
name|u_int
name|fatal
decl_stmt|,
name|oenfatal
decl_stmt|;
name|fatal
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|sc_dev
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
name|mcstat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MULTI_CORE_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcstat
operator|&
name|FO_PCI_MULTI_CORE_ERR_STAT_DMC
operator|)
operator|!=
literal|0
condition|)
block|{
name|dmcstat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_DMC_CORE_BLOCK_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dmcstat
operator|&
name|FO_PCI_DMC_CORE_BLOCK_INT_EN_IMU
operator|)
operator|!=
literal|0
condition|)
block|{
name|imustat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"IMU error %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|imustat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|imustat
operator|&
name|FO_PCI_IMU_ERR_INT_EQ_NOT_EN_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_SCS_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"SCS error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|imustat
operator|&
name|FO_PCI_IMU_ERR_INT_EQ_OVER_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_EQS_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"EQS error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|imustat
operator|&
operator|(
name|FO_PCI_IMU_ERR_INT_MSI_MAL_ERR_P
operator||
name|FO_PCI_IMU_ERR_INT_MSI_PAR_ERR_P
operator||
name|FO_PCI_IMU_ERR_INT_PMEACK_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_PMPME_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_FATAL_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_NFATAL_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_COR_MES_NOT_EN_P
operator||
name|FO_PCI_IMU_ERR_INT_MSI_NOT_EN_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_IMU_RDS_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"RDS error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|dmcstat
operator|&
name|FO_PCI_DMC_CORE_BLOCK_INT_EN_MMU
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|mmustat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU_INT_STAT
argument_list|)
expr_stmt|;
name|mmutfar
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU_TRANS_FAULT_ADDR
argument_list|)
expr_stmt|;
name|mmutfsr
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU_TRANS_FAULT_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mmustat
operator|&
operator|(
name|FO_PCI_MMU_ERR_INT_TBW_DPE_P
operator||
name|FO_PCI_MMU_ERR_INT_TBW_ERR_P
operator||
name|FO_PCI_MMU_ERR_INT_TBW_UDE_P
operator||
name|FO_PCI_MMU_ERR_INT_TBW_DME_P
operator||
name|FO_PCI_MMU_ERR_INT_TTC_CAE_P
operator||
name|FIRE_PCI_MMU_ERR_INT_TTC_DPE_P
operator||
name|OBERON_PCI_MMU_ERR_INT_TTC_DUE_P
operator||
name|FO_PCI_MMU_ERR_INT_TRN_ERR_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_stats_mmu_err
operator|++
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MMU_ERR_STAT_CLR
argument_list|,
name|mmustat
argument_list|)
expr_stmt|;
block|}
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"MMU error %#llx: TFAR %#llx TFSR %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mmustat
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mmutfar
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mmutfsr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|mcstat
operator|&
name|FO_PCI_MULTI_CORE_ERR_STAT_PEC
operator|)
operator|!=
literal|0
condition|)
block|{
name|pecstat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_PEC_CORE_BLOCK_INT_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pecstat
operator|&
name|FO_PCI_PEC_CORE_BLOCK_INT_STAT_UERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|uestat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_UERR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DLU/TLU uncorrectable error %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|uestat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uestat
operator|&
operator|(
name|FO_PCI_TLU_UERR_INT_UR_P
operator||
name|OBERON_PCI_TLU_UERR_INT_POIS_P
operator||
name|FO_PCI_TLU_UERR_INT_MFP_P
operator||
name|FO_PCI_TLU_UERR_INT_ROF_P
operator||
name|FO_PCI_TLU_UERR_INT_UC_P
operator||
name|FIRE_PCI_TLU_UERR_INT_PP_P
operator||
name|OBERON_PCI_TLU_UERR_INT_POIS_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_RX_UERR_HDR1_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"receive header log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_RX_UERR_HDR2_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"receive header log 2 %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uestat
operator|&
name|FO_PCI_TLU_UERR_INT_CTO_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_TX_UERR_HDR1_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"transmit header log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_TX_UERR_HDR2_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"transmit header log 2 %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uestat
operator|&
name|FO_PCI_TLU_UERR_INT_DLP_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"link layer interrupt and status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|uestat
operator|&
name|FO_PCI_TLU_UERR_INT_TE_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_PHY_LYR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"phy layer interrupt and status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pecstat
operator|&
name|FO_PCI_PEC_CORE_BLOCK_INT_STAT_CERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats_tlu_ce
operator|++
expr_stmt|;
name|cestat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CERR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DLU/TLU correctable error %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cestat
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"link layer interrupt and status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cestat
operator|&
name|FO_PCI_TLU_CERR_INT_RE_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_INT_STAT
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_PHY_LYR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"phy layer interrupt and status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_CERR_STAT_CLR
argument_list|,
name|cestat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|pecstat
operator|&
name|FO_PCI_PEC_CORE_BLOCK_INT_STAT_OEVENT
operator|)
operator|!=
literal|0
condition|)
block|{
name|oenfatal
operator|=
literal|0
expr_stmt|;
name|oestat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_OEVENT_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DLU/TLU other event %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|oestat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_MFC_P
operator||
name|FO_PCI_TLU_OEVENT_MRC_P
operator||
name|FO_PCI_TLU_OEVENT_WUC_P
operator||
name|FO_PCI_TLU_OEVENT_RUC_P
operator||
name|FO_PCI_TLU_OEVENT_CRS_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_RX_OEVENT_HDR1_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"receive header log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_RX_OEVENT_HDR2_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"receive header log 2 %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_MFC_P
operator||
name|FO_PCI_TLU_OEVENT_MRC_P
operator||
name|FO_PCI_TLU_OEVENT_WUC_P
operator||
name|FO_PCI_TLU_OEVENT_RUC_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_stats_tlu_oe_rx_err
operator|++
expr_stmt|;
name|oenfatal
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_MFC_P
operator||
name|FO_PCI_TLU_OEVENT_CTO_P
operator||
name|FO_PCI_TLU_OEVENT_WUC_P
operator||
name|FO_PCI_TLU_OEVENT_RUC_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_TX_OEVENT_HDR1_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"transmit header log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_TX_OEVENT_HDR2_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"transmit header log 2 %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_MFC_P
operator||
name|FO_PCI_TLU_OEVENT_CTO_P
operator||
name|FO_PCI_TLU_OEVENT_WUC_P
operator||
name|FO_PCI_TLU_OEVENT_RUC_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_stats_tlu_oe_tx_err
operator|++
expr_stmt|;
name|oenfatal
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_ERO_P
operator||
name|FO_PCI_TLU_OEVENT_EMP_P
operator||
name|FO_PCI_TLU_OEVENT_EPE_P
operator||
name|FIRE_PCI_TLU_OEVENT_ERP_P
operator||
name|OBERON_PCI_TLU_OEVENT_ERBU_P
operator||
name|FIRE_PCI_TLU_OEVENT_EIP_P
operator||
name|OBERON_PCI_TLU_OEVENT_EIUE_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"link layer interrupt and status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_IIP_P
operator||
name|FO_PCI_TLU_OEVENT_EDP_P
operator||
name|FIRE_PCI_TLU_OEVENT_EHP_P
operator||
name|OBERON_PCI_TLU_OEVENT_TLUEITMO_S
operator||
name|FO_PCI_TLU_OEVENT_ERU_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|oestat
operator|&
operator|(
name|FO_PCI_TLU_OEVENT_NFP_P
operator||
name|FO_PCI_TLU_OEVENT_LWC_P
operator||
name|FO_PCI_TLU_OEVENT_LIN_P
operator||
name|FO_PCI_TLU_OEVENT_LRS_P
operator||
name|FO_PCI_TLU_OEVENT_LDN_P
operator||
name|FO_PCI_TLU_OEVENT_LUP_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|oenfatal
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|oenfatal
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_stats_tlu_oe_non_fatal
operator|++
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_TLU_OEVENT_STAT_CLR
argument_list|,
name|oestat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oestat
operator|&
name|FO_PCI_TLU_OEVENT_LIN_P
operator|)
operator|!=
literal|0
condition|)
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_INT_STAT
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_LPU_LNK_LYR_INT_STAT
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pecstat
operator|&
name|FO_PCI_PEC_CORE_BLOCK_INT_STAT_ILU
operator|)
operator|!=
literal|0
condition|)
block|{
name|ilustat
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ILU_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"ILU error %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ilustat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ilustat
operator|&
operator|(
name|FIRE_PCI_ILU_ERR_INT_IHB_PE_P
operator||
name|FIRE_PCI_ILU_ERR_INT_IHB_PE_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|sc
operator|->
name|sc_stats_ilu_err
operator|++
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_ILU_INT_STAT
argument_list|,
name|ilustat
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fatal
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: fatal DMC/PEC error"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_xcb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|errstat
decl_stmt|,
name|intstat
decl_stmt|,
name|val
decl_stmt|;
name|u_int
name|fatal
decl_stmt|;
name|fatal
operator|=
literal|0
expr_stmt|;
name|sc
operator|=
name|arg
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|sc_dev
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_OBERON
condition|)
block|{
name|intstat
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_XBC_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"UBC error: interrupt status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
operator|~
operator|(
name|OBERON_UBC_ERR_INT_DMARDUEB_P
operator||
name|OBERON_UBC_ERR_INT_DMARDUEA_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_stats_ubc_dmardue
operator|++
expr_stmt|;
if|if
condition|(
name|fatal
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: fatal UBC core block error"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_ERR_STAT_CLR
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|errstat
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBC_CORE_BLOCK_ERR_STAT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errstat
operator|&
operator|(
name|FIRE_JBC_CORE_BLOCK_ERR_STAT_MERGE
operator||
name|FIRE_JBC_CORE_BLOCK_ERR_STAT_JBCINT
operator||
name|FIRE_JBC_CORE_BLOCK_ERR_STAT_DMCINT
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|intstat
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_XBC_INT_STAT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"JBC interrupt status %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|intstat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|FIRE_JBC_ERR_INT_EBUS_TO_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBC_CSR_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"CSR error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|FIRE_JBC_ERR_INT_UNSOL_RD_P
operator||
name|FIRE_JBC_ERR_INT_UNSOL_INT_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|intstat
operator|&
name|FIRE_JBC_ERR_INT_UNSOL_RD_P
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_stats_jbc_unsol_rd
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|intstat
operator|&
name|FIRE_JBC_ERR_INT_UNSOL_INT_P
operator|)
operator|!=
literal|0
condition|)
name|sc
operator|->
name|sc_stats_jbc_unsol_int
operator|++
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_DMCINT_IDC_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DMCINT IDC error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|FIRE_JBC_ERR_INT_MB_PER_P
operator||
name|FIRE_JBC_ERR_INT_MB_PEW_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_MERGE_TRANS_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"merge transaction error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
name|FIRE_JBC_ERR_INT_IJP_P
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBCINT_OTRANS_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"JBCINT out transaction error log "
literal|"%#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBCINT_OTRANS_ERR_LOG2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"JBCINT out transaction error log 2 "
literal|"%#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|FIRE_JBC_ERR_INT_UE_ASYN_P
operator||
name|FIRE_JBC_ERR_INT_CE_ASYN_P
operator||
name|FIRE_JBC_ERR_INT_JTE_P
operator||
name|FIRE_JBC_ERR_INT_JBE_P
operator||
name|FIRE_JBC_ERR_INT_JUE_P
operator||
name|FIRE_JBC_ERR_INT_ICISE_P
operator||
name|FIRE_JBC_ERR_INT_WR_DPE_P
operator||
name|FIRE_JBC_ERR_INT_RD_DPE_P
operator||
name|FIRE_JBC_ERR_INT_ILL_BMW_P
operator||
name|FIRE_JBC_ERR_INT_ILL_BMR_P
operator||
name|FIRE_JBC_ERR_INT_BJC_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|FIRE_JBC_ERR_INT_UE_ASYN_P
operator||
name|FIRE_JBC_ERR_INT_JTE_P
operator||
name|FIRE_JBC_ERR_INT_JBE_P
operator||
name|FIRE_JBC_ERR_INT_JUE_P
operator||
name|FIRE_JBC_ERR_INT_ICISE_P
operator||
name|FIRE_JBC_ERR_INT_WR_DPE_P
operator||
name|FIRE_JBC_ERR_INT_RD_DPE_P
operator||
name|FIRE_JBC_ERR_INT_ILL_BMW_P
operator||
name|FIRE_JBC_ERR_INT_ILL_BMR_P
operator||
name|FIRE_JBC_ERR_INT_BJC_P
operator|)
operator|)
operator|!=
literal|0
condition|)
name|fatal
operator|=
literal|1
expr_stmt|;
else|else
name|sc
operator|->
name|sc_stats_jbc_ce_async
operator|++
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBCINT_ITRANS_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"JBCINT in transaction error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBCINT_ITRANS_ERR_LOG2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"JBCINT in transaction error log 2 "
literal|"%#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|FIRE_JBC_ERR_INT_PIO_UNMAP_RD_P
operator||
name|FIRE_JBC_ERR_INT_ILL_ACC_RD_P
operator||
name|FIRE_JBC_ERR_INT_PIO_UNMAP_P
operator||
name|FIRE_JBC_ERR_INT_PIO_DPE_P
operator||
name|FIRE_JBC_ERR_INT_PIO_CPE_P
operator||
name|FIRE_JBC_ERR_INT_ILL_ACC_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_JBC_CSR_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"DMCINT ODCD error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|intstat
operator|&
operator|(
name|FIRE_JBC_ERR_INT_MB_PEA_P
operator||
name|FIRE_JBC_ERR_INT_CPE_P
operator||
name|FIRE_JBC_ERR_INT_APE_P
operator||
name|FIRE_JBC_ERR_INT_PIO_CPE_P
operator||
name|FIRE_JBC_ERR_INT_JTCEEW_P
operator||
name|FIRE_JBC_ERR_INT_JTCEEI_P
operator||
name|FIRE_JBC_ERR_INT_JTCEER_P
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|fatal
operator|=
literal|1
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_FATAL_ERR_LOG
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fatal error log %#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
name|val
operator|=
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FIRE_FATAL_ERR_LOG2
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"fatal error log 2 "
literal|"%#llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fatal
operator|!=
literal|0
condition|)
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: fatal JBC core block error"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|FIRE_CTRL_SET
argument_list|(
name|sc
argument_list|,
name|FO_XBC_ERR_STAT_CLR
argument_list|,
operator|~
literal|0ULL
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|mtx_unlock_spin
argument_list|(
operator|&
name|sc
operator|->
name|sc_pcib_mtx
argument_list|)
expr_stmt|;
name|panic
argument_list|(
literal|"%s: unknown JCB core block error status %#llx"
argument_list|,
name|device_get_nameunit
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|errstat
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_pcie
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|fire_msiqarg
modifier|*
name|fmqa
decl_stmt|;
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fo_msiq_record
modifier|*
name|qrec
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|word0
decl_stmt|;
name|u_int
name|head
decl_stmt|,
name|msg
decl_stmt|,
name|msiq
decl_stmt|;
name|fmqa
operator|=
name|arg
expr_stmt|;
name|sc
operator|=
name|fmqa
operator|->
name|fmqa_fica
operator|.
name|fica_sc
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|sc_dev
expr_stmt|;
name|msiq
operator|=
name|fmqa
operator|->
name|fmqa_msiq
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|fmqa
operator|->
name|fmqa_mtx
argument_list|)
expr_stmt|;
name|head
operator|=
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_head
argument_list|)
operator|&
name|FO_PCI_EQ_HD_MASK
operator|)
operator|>>
name|FO_PCI_EQ_HD_SHFT
expr_stmt|;
name|qrec
operator|=
operator|&
name|fmqa
operator|->
name|fmqa_base
index|[
name|head
index|]
expr_stmt|;
name|word0
operator|=
name|qrec
operator|->
name|fomqr_word0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|KASSERT
argument_list|(
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_FMT_TYPE_MSG
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: received non-PCIe message in event queue %d "
literal|"(word0 %#llx)"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|,
name|msiq
operator|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|word0
operator|)
argument_list|)
expr_stmt|;
name|msg
operator|=
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_DATA0_MASK
operator|)
operator|>>
name|FO_MQR_WORD0_DATA0_SHFT
expr_stmt|;
define|#
directive|define
name|PCIE_MSG_CODE_ERR_COR
value|0x30
define|#
directive|define
name|PCIE_MSG_CODE_ERR_NONFATAL
value|0x31
define|#
directive|define
name|PCIE_MSG_CODE_ERR_FATAL
value|0x33
if|if
condition|(
name|msg
operator|==
name|PCIE_MSG_CODE_ERR_COR
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"correctable PCIe error\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msg
operator|==
name|PCIE_MSG_CODE_ERR_NONFATAL
operator|||
name|msg
operator|==
name|PCIE_MSG_CODE_ERR_FATAL
condition|)
name|panic
argument_list|(
literal|"%s: %sfatal PCIe error"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|msg
operator|==
name|PCIE_MSG_CODE_ERR_NONFATAL
condition|?
literal|"non-"
else|:
literal|""
argument_list|)
expr_stmt|;
else|else
name|panic
argument_list|(
literal|"%s: received unknown PCIe message %#x"
argument_list|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|qrec
operator|->
name|fomqr_word0
operator|&=
operator|~
name|FO_MQR_WORD0_FMT_TYPE_MASK
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|sc_msiq_size
expr_stmt|;
name|qrec
operator|=
operator|&
name|fmqa
operator|->
name|fmqa_base
index|[
name|head
index|]
expr_stmt|;
name|word0
operator|=
name|qrec
operator|->
name|fomqr_word0
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_FMT_TYPE_MASK
operator|)
operator|==
literal|0
argument_list|)
condition|)
break|break;
block|}
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_head
argument_list|,
operator|(
name|head
operator|&
name|FO_PCI_EQ_HD_MASK
operator|)
operator|<<
name|FO_PCI_EQ_HD_SHFT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_tail
argument_list|)
operator|&
name|FO_PCI_EQ_TL_OVERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"event queue %d overflow\n"
argument_list|,
name|msiq
argument_list|)
expr_stmt|;
name|msiq
operator|<<=
literal|3
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_BASE
operator|+
name|msiq
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_BASE
operator|+
name|msiq
argument_list|)
operator||
name|FO_PCI_EQ_CTRL_CLR_COVERR
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|fmqa
operator|->
name|fmqa_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|FILTER_HANDLED
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_maxslots
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|fire_read_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|bus
parameter_list|,
name|u_int
name|slot
parameter_list|,
name|u_int
name|func
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_handle_t
name|bh
decl_stmt|;
name|u_long
name|offset
init|=
literal|0
decl_stmt|;
name|uint32_t
name|r
decl_stmt|,
name|wrd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint16_t
name|shrt
decl_stmt|;
name|uint8_t
name|byte
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|<
name|sc
operator|->
name|sc_pci_secbus
operator|||
name|bus
operator|>
name|sc
operator|->
name|sc_pci_subbus
operator|||
name|slot
operator|>
name|PCI_SLOTMAX
operator|||
name|func
operator|>
name|PCI_FUNCMAX
operator|||
name|reg
operator|>
name|PCIE_REGMAX
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|offset
operator|=
name|FO_CONF_OFF
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bh
operator|=
name|sc
operator|->
name|sc_pci_bh
index|[
name|OFW_PCI_CS_CONFIG
index|]
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|i
operator|=
name|bus_space_peek_1
argument_list|(
name|sc
operator|->
name|sc_pci_cfgt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
operator|&
name|byte
argument_list|)
expr_stmt|;
name|r
operator|=
name|byte
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|i
operator|=
name|bus_space_peek_2
argument_list|(
name|sc
operator|->
name|sc_pci_cfgt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
operator|&
name|shrt
argument_list|)
expr_stmt|;
name|r
operator|=
name|shrt
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|i
operator|=
name|bus_space_peek_4
argument_list|(
name|sc
operator|->
name|sc_pci_cfgt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
operator|&
name|wrd
argument_list|)
expr_stmt|;
name|r
operator|=
name|wrd
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: bad width"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|i
condition|)
block|{
ifdef|#
directive|ifdef
name|FIRE_DEBUG
name|printf
argument_list|(
literal|"%s: read data error reading: %d.%d.%d: 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_write_config
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|u_int
name|bus
parameter_list|,
name|u_int
name|slot
parameter_list|,
name|u_int
name|func
parameter_list|,
name|u_int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|,
name|int
name|width
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_handle_t
name|bh
decl_stmt|;
name|u_long
name|offset
init|=
literal|0
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|bus
operator|<
name|sc
operator|->
name|sc_pci_secbus
operator|||
name|bus
operator|>
name|sc
operator|->
name|sc_pci_subbus
operator|||
name|slot
operator|>
name|PCI_SLOTMAX
operator|||
name|func
operator|>
name|PCI_FUNCMAX
operator|||
name|reg
operator|>
name|PCIE_REGMAX
condition|)
return|return;
name|offset
operator|=
name|FO_CONF_OFF
argument_list|(
name|bus
argument_list|,
name|slot
argument_list|,
name|func
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|bh
operator|=
name|sc
operator|->
name|sc_pci_bh
index|[
name|OFW_PCI_CS_CONFIG
index|]
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|bus_space_write_1
argument_list|(
name|sc
operator|->
name|sc_pci_cfgt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bus_space_write_2
argument_list|(
name|sc
operator|->
name|sc_pci_cfgt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|bus_space_write_4
argument_list|(
name|sc
operator|->
name|sc_pci_cfgt
argument_list|,
name|bh
argument_list|,
name|offset
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"%s: bad width"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fire_route_interrupt
parameter_list|(
name|device_t
name|bridge
parameter_list|,
name|device_t
name|dev
parameter_list|,
name|int
name|pin
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|ofw_pci_register
name|reg
decl_stmt|;
name|ofw_pci_intr_t
name|pintr
decl_stmt|,
name|mintr
decl_stmt|;
name|uint8_t
name|maskbuf
index|[
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|pintr
argument_list|)
index|]
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bridge
argument_list|)
expr_stmt|;
name|pintr
operator|=
name|pin
expr_stmt|;
if|if
condition|(
name|ofw_bus_lookup_imap
argument_list|(
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
argument_list|,
operator|&
name|sc
operator|->
name|sc_pci_iinfo
argument_list|,
operator|&
name|reg
argument_list|,
sizeof|sizeof
argument_list|(
name|reg
argument_list|)
argument_list|,
operator|&
name|pintr
argument_list|,
sizeof|sizeof
argument_list|(
name|pintr
argument_list|)
argument_list|,
operator|&
name|mintr
argument_list|,
sizeof|sizeof
argument_list|(
name|mintr
argument_list|)
argument_list|,
name|maskbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|mintr
operator|)
return|;
name|device_printf
argument_list|(
name|bridge
argument_list|,
literal|"could not route pin %d for device %d.%d\n"
argument_list|,
name|pin
argument_list|,
name|pci_get_slot
argument_list|(
name|dev
argument_list|)
argument_list|,
name|pci_get_function
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|PCI_INVALID_IRQ
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_read_ivar
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|which
parameter_list|,
name|uintptr_t
modifier|*
name|result
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|which
condition|)
block|{
case|case
name|PCIB_IVAR_DOMAIN
case|:
operator|*
name|result
operator|=
name|device_get_unit
argument_list|(
name|dev
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|PCIB_IVAR_BUS
case|:
operator|*
name|result
operator|=
name|sc
operator|->
name|sc_pci_secbus
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|VIS_BLOCKSIZE
value|64
end_define

begin_function
specifier|static
name|void
name|fire_dmamap_sync
parameter_list|(
name|bus_dma_tag_t
name|dt
name|__unused
parameter_list|,
name|bus_dmamap_t
name|map
parameter_list|,
name|bus_dmasync_op_t
name|op
parameter_list|)
block|{
specifier|static
name|u_char
name|buf
index|[
name|VIS_BLOCKSIZE
index|]
name|__aligned
argument_list|(
name|VIS_BLOCKSIZE
argument_list|)
decl_stmt|;
name|register_t
name|reg
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|map
operator|->
name|dm_flags
operator|&
name|DMF_LOADED
operator|)
operator|==
literal|0
operator|||
operator|(
name|op
operator|&
operator|~
name|BUS_DMASYNC_POSTWRITE
operator|)
operator|==
literal|0
condition|)
return|return;
name|s
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
name|reg
operator|=
name|rd
argument_list|(
name|fprs
argument_list|)
expr_stmt|;
name|wr
argument_list|(
name|fprs
argument_list|,
name|reg
operator||
name|FPRS_FEF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
asm|__asm __volatile("stda %%f0, [%0] %1"
block|: :
literal|"r"
operator|(
name|buf
operator|)
operator|,
literal|"n"
operator|(
name|ASI_BLK_COMMIT_S
operator|)
block|)
function|;
end_function

begin_expr_stmt
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wr
argument_list|(
name|fprs
argument_list|,
name|reg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|intr_restore
argument_list|(
name|s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
unit|}  static
name|void
name|fire_intr_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intr_vector
modifier|*
name|iv
decl_stmt|;
name|struct
name|fire_icarg
modifier|*
name|fica
decl_stmt|;
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|uint64_t
name|mr
decl_stmt|;
name|u_int
name|ctrl
decl_stmt|,
name|i
decl_stmt|;
name|iv
operator|=
name|arg
expr_stmt|;
name|fica
operator|=
name|iv
operator|->
name|iv_icarg
expr_stmt|;
name|sc
operator|=
name|fica
operator|->
name|fica_sc
expr_stmt|;
name|mr
operator|=
name|FO_PCI_IMAP_V
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_mode
operator|==
name|FIRE_MODE_OBERON
condition|)
name|mr
operator||=
operator|(
name|iv
operator|->
name|iv_mid
operator|<<
name|OBERON_PCI_IMAP_T_DESTID_SHFT
operator|)
operator|&
name|OBERON_PCI_IMAP_T_DESTID_MASK
expr_stmt|;
else|else
name|mr
operator||=
operator|(
name|iv
operator|->
name|iv_mid
operator|<<
name|FIRE_PCI_IMAP_T_JPID_SHFT
operator|)
operator|&
name|FIRE_PCI_IMAP_T_JPID_MASK
expr_stmt|;
comment|/* 	 * Given that all mondos for the same target are required to use the 	 * same interrupt controller we just use the CPU ID for indexing the 	 * latter. 	 */
name|ctrl
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mp_ncpus
condition|;
operator|++
name|i
control|)
block|{
name|pc
operator|=
name|pcpu_find
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|==
name|NULL
operator|||
name|iv
operator|->
name|iv_mid
operator|!=
name|pc
operator|->
name|pc_mid
condition|)
continue|continue;
name|ctrl
operator|=
name|pc
operator|->
name|pc_cpuid
operator|%
literal|4
expr_stmt|;
break|break;
block|}
name|mr
operator||=
operator|(
literal|1ULL
operator|<<
name|ctrl
operator|)
operator|<<
name|FO_PCI_IMAP_INT_CTRL_NUM_SHFT
operator|&
name|FO_PCI_IMAP_INT_CTRL_NUM_MASK
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_map
argument_list|,
name|mr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_intr_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intr_vector
modifier|*
name|iv
decl_stmt|;
name|struct
name|fire_icarg
modifier|*
name|fica
decl_stmt|;
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|iv
operator|=
name|arg
expr_stmt|;
name|fica
operator|=
name|iv
operator|->
name|iv_icarg
expr_stmt|;
name|sc
operator|=
name|fica
operator|->
name|fica_sc
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_map
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_map
argument_list|)
operator|&
operator|~
name|FO_PCI_IMAP_V
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_intr_assign
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intr_vector
modifier|*
name|iv
decl_stmt|;
name|struct
name|fire_icarg
modifier|*
name|fica
decl_stmt|;
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|uint64_t
name|mr
decl_stmt|;
name|iv
operator|=
name|arg
expr_stmt|;
name|fica
operator|=
name|iv
operator|->
name|iv_icarg
expr_stmt|;
name|sc
operator|=
name|fica
operator|->
name|fica_sc
expr_stmt|;
name|mr
operator|=
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_map
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mr
operator|&
name|FO_PCI_IMAP_V
operator|)
operator|!=
literal|0
condition|)
block|{
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_map
argument_list|,
name|mr
operator|&
operator|~
name|FO_PCI_IMAP_V
argument_list|)
expr_stmt|;
name|FIRE_PCI_BARRIER
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_map
argument_list|,
literal|8
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fica
operator|->
name|fica_clr
argument_list|)
operator|!=
name|INTCLR_IDLE
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|mr
operator|&
name|FO_PCI_IMAP_V
operator|)
operator|!=
literal|0
condition|)
name|fire_intr_enable
argument_list|(
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_intr_clear
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|intr_vector
modifier|*
name|iv
decl_stmt|;
name|struct
name|fire_icarg
modifier|*
name|fica
decl_stmt|;
name|iv
operator|=
name|arg
expr_stmt|;
name|fica
operator|=
name|iv
operator|->
name|iv_icarg
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|fica
operator|->
name|fica_sc
argument_list|,
name|fica
operator|->
name|fica_clr
argument_list|,
name|INTCLR_IDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given that the event queue implementation matches our current MD and MI  * interrupt frameworks like square pegs fit into round holes we are generous  * and use one event queue per MSI for now, which limits us to 35 MSIs/MSI-Xs  * per Host-PCIe-bridge (we use one event queue for the PCIe error messages).  * This seems tolerable as long as most devices just use one MSI/MSI-X anyway.  * Adding knowledge about MSIs/MSI-Xs to the MD interrupt code should allow us  * to decouple the 1:1 mapping at the cost of no longer being able to bind  * MSIs/MSI-Xs to specific CPUs as we currently have no reliable way to  * quiesce a device while we move its MSIs/MSI-Xs to another event queue.  */
end_comment

begin_function
specifier|static
name|int
name|fire_alloc_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
name|int
name|maxcount
name|__unused
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|msiqrun
decl_stmt|;
if|if
condition|(
name|powerof2
argument_list|(
name|count
argument_list|)
operator|==
literal|0
operator|||
name|count
operator|>
literal|32
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
name|msiqrun
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_msiq_count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
name|count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|i
operator|+
name|count
condition|)
block|{
name|msiqrun
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|sc_msiq_count
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
name|count
operator|<
name|sc
operator|->
name|sc_msi_count
condition|;
name|i
operator|+=
name|count
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|i
operator|+
name|count
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|isclr
argument_list|(
name|sc
operator|->
name|sc_msi_bitmap
argument_list|,
name|j
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|i
operator|+
name|count
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|msiqrun
operator|+
name|j
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_msi_bitmap
argument_list|,
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msi_msiq_table
index|[
name|i
operator|+
name|j
index|]
operator|=
name|msiqrun
operator|+
name|j
expr_stmt|;
name|irqs
index|[
name|j
index|]
operator|=
name|sc
operator|->
name|sc_msi_first
operator|+
name|i
operator|+
name|j
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_release_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|count
parameter_list|,
name|int
modifier|*
name|irqs
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|sc
operator|->
name|sc_msi_msiq_table
index|[
name|irqs
index|[
name|i
index|]
operator|-
name|sc
operator|->
name|sc_msi_first
index|]
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_msi_bitmap
argument_list|,
name|irqs
index|[
name|i
index|]
operator|-
name|sc
operator|->
name|sc_msi_first
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_alloc_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
modifier|*
name|irq
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|msiq
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|FIRE_MSIX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
name|msiq
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_msiq_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msiq
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|sc
operator|->
name|sc_msiq_count
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|sc
operator|->
name|sc_msi_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|sc
operator|->
name|sc_msi_bitmap
argument_list|,
name|i
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|setbit
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|msiq
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|sc
operator|->
name|sc_msi_bitmap
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_msi_msiq_table
index|[
name|i
index|]
operator|=
name|msiq
expr_stmt|;
operator|*
name|irq
operator|=
name|sc
operator|->
name|sc_msi_first
operator|+
name|i
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_release_msix
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|irq
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|FIRE_MSIX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|mtx_lock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_msiq_bitmap
argument_list|,
name|sc
operator|->
name|sc_msi_msiq_table
index|[
name|irq
operator|-
name|sc
operator|->
name|sc_msi_first
index|]
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|sc
operator|->
name|sc_msi_bitmap
argument_list|,
name|irq
operator|-
name|sc
operator|->
name|sc_msi_first
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|sc
operator|->
name|sc_msi_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_map_msi
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|irq
parameter_list|,
name|uint64_t
modifier|*
name|addr
parameter_list|,
name|uint32_t
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|pci_devinfo
modifier|*
name|dinfo
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dinfo
operator|=
name|device_get_ivars
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|irq
operator|&
operator|~
name|sc
operator|->
name|sc_msi_data_mask
operator|)
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid MSI 0x%x\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sc
operator|->
name|sc_flags
operator|&
name|FIRE_MSIX
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|fls
argument_list|(
name|irq
argument_list|)
operator|>
name|sc
operator|->
name|sc_msix_data_width
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid MSI-X 0x%x\n"
argument_list|,
name|irq
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_alloc
operator|>
literal|0
operator|&&
operator|(
name|dinfo
operator|->
name|cfg
operator|.
name|msi
operator|.
name|msi_ctrl
operator|&
name|PCIM_MSICTRL_64BIT
operator|)
operator|==
literal|0
condition|)
operator|*
name|addr
operator|=
name|sc
operator|->
name|sc_msi_addr32
expr_stmt|;
else|else
operator|*
name|addr
operator|=
name|sc
operator|->
name|sc_msi_addr64
expr_stmt|;
operator|*
name|data
operator|=
name|irq
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_msiq_handler
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|intr_vector
modifier|*
name|iv
decl_stmt|;
name|struct
name|fire_msiqarg
modifier|*
name|fmqa
decl_stmt|;
name|iv
operator|=
name|cookie
expr_stmt|;
name|fmqa
operator|=
name|iv
operator|->
name|iv_icarg
expr_stmt|;
comment|/* 	 * Note that since fire_intr_clear() will clear the event queue 	 * interrupt after the handler associated with the MSI [sic] has 	 * been executed we have to protect the access to the event queue as 	 * otherwise nested event queue interrupts cause corruption of the 	 * event queue on MP machines.  Obviously especially when abandoning 	 * the 1:1 mapping it would be better to not clear the event queue 	 * interrupt after each handler invocation but only once when the 	 * outstanding MSIs have been processed but unfortunately that 	 * doesn't work well and leads to interrupt storms with controllers/ 	 * drivers which don't mask interrupts while the handler is executed. 	 * Maybe delaying clearing the MSI until after the handler has been 	 * executed could be used to work around this but that's not the 	 * intended usage and might in turn cause lost MSIs. 	 */
name|mtx_lock_spin
argument_list|(
operator|&
name|fmqa
operator|->
name|fmqa_mtx
argument_list|)
expr_stmt|;
name|fire_msiq_common
argument_list|(
name|iv
argument_list|,
name|fmqa
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|fmqa
operator|->
name|fmqa_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fire_msiq_filter
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|intr_vector
modifier|*
name|iv
decl_stmt|;
name|struct
name|fire_msiqarg
modifier|*
name|fmqa
decl_stmt|;
name|iv
operator|=
name|cookie
expr_stmt|;
name|fmqa
operator|=
name|iv
operator|->
name|iv_icarg
expr_stmt|;
comment|/* 	 * For filters we don't use fire_intr_clear() since it would clear 	 * the event queue interrupt while we're still processing the event 	 * queue as filters and associated post-filter handler are executed 	 * directly, which in turn would lead to lost MSIs.  So we clear the 	 * event queue interrupt only once after processing the event queue. 	 * Given that this still guarantees the filters to not be executed 	 * concurrently and no other CPU can clear the event queue interrupt 	 * while the event queue is still processed, we don't even need to 	 * interlock the access to the event queue in this case. 	 */
name|critical_enter
argument_list|()
expr_stmt|;
name|fire_msiq_common
argument_list|(
name|iv
argument_list|,
name|fmqa
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|fmqa
operator|->
name|fmqa_fica
operator|.
name|fica_sc
argument_list|,
name|fmqa
operator|->
name|fmqa_fica
operator|.
name|fica_clr
argument_list|,
name|INTCLR_IDLE
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fire_msiq_common
parameter_list|(
name|struct
name|intr_vector
modifier|*
name|iv
parameter_list|,
name|struct
name|fire_msiqarg
modifier|*
name|fmqa
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|fo_msiq_record
modifier|*
name|qrec
decl_stmt|;
name|device_t
name|dev
decl_stmt|;
name|uint64_t
name|word0
decl_stmt|;
name|u_int
name|head
decl_stmt|,
name|msi
decl_stmt|,
name|msiq
decl_stmt|;
name|sc
operator|=
name|fmqa
operator|->
name|fmqa_fica
operator|.
name|fica_sc
expr_stmt|;
name|dev
operator|=
name|sc
operator|->
name|sc_dev
expr_stmt|;
name|msiq
operator|=
name|fmqa
operator|->
name|fmqa_msiq
expr_stmt|;
name|head
operator|=
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_head
argument_list|)
operator|&
name|FO_PCI_EQ_HD_MASK
operator|)
operator|>>
name|FO_PCI_EQ_HD_SHFT
expr_stmt|;
name|qrec
operator|=
operator|&
name|fmqa
operator|->
name|fmqa_base
index|[
name|head
index|]
expr_stmt|;
name|word0
operator|=
name|qrec
operator|->
name|fomqr_word0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|KASSERT
argument_list|(
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_FMT_TYPE_MSI64
operator|)
operator|!=
literal|0
operator|||
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_FMT_TYPE_MSI32
operator|)
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: received non-MSI/MSI-X message in event queue %d "
literal|"(word0 %#llx)"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|,
name|msiq
operator|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|word0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_FMT_TYPE_MASK
operator|)
operator|==
literal|0
argument_list|)
condition|)
break|break;
name|msi
operator|=
operator|(
name|word0
operator|&
name|FO_MQR_WORD0_DATA0_MASK
operator|)
operator|>>
name|FO_MQR_WORD0_DATA0_SHFT
expr_stmt|;
comment|/* 		 * Sanity check the MSI/MSI-X as long as we use a 1:1 mapping. 		 */
name|KASSERT
argument_list|(
name|msi
operator|==
name|fmqa
operator|->
name|fmqa_msi
argument_list|,
operator|(
literal|"%s: received non-matching MSI/MSI-X in event queue %d "
literal|"(%d versus %d)"
operator|,
name|device_get_nameunit
argument_list|(
name|dev
argument_list|)
operator|,
name|msiq
operator|,
name|msi
operator|,
name|fmqa
operator|->
name|fmqa_msi
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_CLR_BASE
operator|+
operator|(
name|msi
operator|<<
literal|3
operator|)
argument_list|,
name|FO_PCI_MSI_CLR_EQWR_N
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
name|intr_event_handle
argument_list|(
name|iv
operator|->
name|iv_event
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
argument_list|)
condition|)
name|printf
argument_list|(
literal|"stray MSI/MSI-X in event queue %d\n"
argument_list|,
name|msiq
argument_list|)
expr_stmt|;
name|qrec
operator|->
name|fomqr_word0
operator|&=
operator|~
name|FO_MQR_WORD0_FMT_TYPE_MASK
expr_stmt|;
name|head
operator|=
operator|(
name|head
operator|+
literal|1
operator|)
operator|%
name|sc
operator|->
name|sc_msiq_size
expr_stmt|;
name|qrec
operator|=
operator|&
name|fmqa
operator|->
name|fmqa_base
index|[
name|head
index|]
expr_stmt|;
name|word0
operator|=
name|qrec
operator|->
name|fomqr_word0
expr_stmt|;
block|}
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_head
argument_list|,
operator|(
name|head
operator|&
name|FO_PCI_EQ_HD_MASK
operator|)
operator|<<
name|FO_PCI_EQ_HD_SHFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|fmqa
operator|->
name|fmqa_tail
argument_list|)
operator|&
name|FO_PCI_EQ_TL_OVERR
operator|)
operator|!=
literal|0
argument_list|)
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"event queue %d overflow\n"
argument_list|,
name|msiq
argument_list|)
expr_stmt|;
name|msiq
operator|<<=
literal|3
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_BASE
operator|+
name|msiq
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_BASE
operator|+
name|msiq
argument_list|)
operator||
name|FO_PCI_EQ_CTRL_CLR_COVERR
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|fire_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|ires
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|u_long
name|vec
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|msi
decl_stmt|,
name|msiq
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * XXX this assumes that a device only has one INTx, while in fact 	 * Cassini+ and Saturn can use all four the firmware has assigned 	 * to them, but so does pci(4). 	 */
if|if
condition|(
name|rman_get_rid
argument_list|(
name|ires
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msi
operator|=
name|rman_get_start
argument_list|(
name|ires
argument_list|)
expr_stmt|;
name|msiq
operator|=
name|sc
operator|->
name|sc_msi_msiq_table
index|[
name|msi
operator|-
name|sc
operator|->
name|sc_msi_first
index|]
expr_stmt|;
name|vec
operator|=
name|INTMAP_VEC
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|,
name|sc
operator|->
name|sc_msiq_ino_first
operator|+
name|msiq
argument_list|)
expr_stmt|;
name|msiq
operator|+=
name|sc
operator|->
name|sc_msiq_first
expr_stmt|;
if|if
condition|(
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_ic
operator|!=
operator|&
name|fire_ic
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid interrupt controller for vector 0x%lx\n"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * The MD interrupt code needs the vector rather than the MSI. 		 */
name|rman_set_start
argument_list|(
name|ires
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|rman_set_end
argument_list|(
name|ires
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|ires
argument_list|,
name|flags
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
expr_stmt|;
name|rman_set_start
argument_list|(
name|ires
argument_list|,
name|msi
argument_list|)
expr_stmt|;
name|rman_set_end
argument_list|(
name|ires
argument_list|,
name|msi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 		 * XXX inject our event queue handler. 		 */
if|if
condition|(
name|filt
operator|!=
name|NULL
condition|)
block|{
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_func
operator|=
name|fire_msiq_filter
expr_stmt|;
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_ic
operator|=
operator|&
name|fire_msiqc_filter
expr_stmt|;
block|}
else|else
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_func
operator|=
name|fire_msiq_handler
expr_stmt|;
comment|/* Record the MSI/MSI-X as long as we we use a 1:1 mapping. */
operator|(
operator|(
expr|struct
name|fire_msiqarg
operator|*
operator|)
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_icarg
operator|)
operator|->
name|fmqa_msi
operator|=
name|msi
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_SET_BASE
operator|+
operator|(
name|msiq
operator|<<
literal|3
operator|)
argument_list|,
name|FO_PCI_EQ_CTRL_SET_EN
argument_list|)
expr_stmt|;
name|msi
operator|<<=
literal|3
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|msi
argument_list|,
operator|(
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|msi
argument_list|)
operator|&
operator|~
name|FO_PCI_MSI_MAP_EQNUM_MASK
operator|)
operator||
operator|(
operator|(
name|msiq
operator|<<
name|FO_PCI_MSI_MAP_EQNUM_SHFT
operator|)
operator|&
name|FO_PCI_MSI_MAP_EQNUM_MASK
operator|)
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_CLR_BASE
operator|+
name|msi
argument_list|,
name|FO_PCI_MSI_CLR_EQWR_N
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|msi
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|msi
argument_list|)
operator||
name|FO_PCI_MSI_MAP_V
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Make sure the vector is fully specified and we registered 	 * our interrupt controller for it. 	 */
name|vec
operator|=
name|rman_get_start
argument_list|(
name|ires
argument_list|)
expr_stmt|;
if|if
condition|(
name|INTIGN
argument_list|(
name|vec
argument_list|)
operator|!=
name|sc
operator|->
name|sc_ign
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid interrupt vector 0x%lx\n"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_ic
operator|!=
operator|&
name|fire_ic
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid interrupt controller for vector 0x%lx\n"
argument_list|,
name|vec
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|ires
argument_list|,
name|flags
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
parameter_list|,
name|struct
name|resource
modifier|*
name|ires
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|u_long
name|vec
decl_stmt|;
name|int
name|error
decl_stmt|;
name|u_int
name|msi
decl_stmt|,
name|msiq
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|rman_get_rid
argument_list|(
name|ires
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|msi
operator|=
name|rman_get_start
argument_list|(
name|ires
argument_list|)
expr_stmt|;
name|msiq
operator|=
name|sc
operator|->
name|sc_msi_msiq_table
index|[
name|msi
operator|-
name|sc
operator|->
name|sc_msi_first
index|]
expr_stmt|;
name|vec
operator|=
name|INTMAP_VEC
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|,
name|msiq
operator|+
name|sc
operator|->
name|sc_msiq_ino_first
argument_list|)
expr_stmt|;
name|msiq
operator|+=
name|sc
operator|->
name|sc_msiq_first
expr_stmt|;
name|msi
operator|<<=
literal|3
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|msi
argument_list|,
name|FIRE_PCI_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_MSI_MAP_BASE
operator|+
name|msi
argument_list|)
operator|&
operator|~
name|FO_PCI_MSI_MAP_V
argument_list|)
expr_stmt|;
name|msiq
operator|<<=
literal|3
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_BASE
operator|+
name|msiq
argument_list|,
name|FO_PCI_EQ_CTRL_CLR_COVERR
operator||
name|FO_PCI_EQ_CTRL_CLR_E2I
operator||
name|FO_PCI_EQ_CTRL_CLR_DIS
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_TL_BASE
operator|+
name|msiq
argument_list|,
operator|(
literal|0
operator|<<
name|FO_PCI_EQ_TL_SHFT
operator|)
operator|&
name|FO_PCI_EQ_TL_MASK
argument_list|)
expr_stmt|;
name|FIRE_PCI_WRITE_8
argument_list|(
name|sc
argument_list|,
name|FO_PCI_EQ_HD_BASE
operator|+
name|msiq
argument_list|,
operator|(
literal|0
operator|<<
name|FO_PCI_EQ_HD_SHFT
operator|)
operator|&
name|FO_PCI_EQ_HD_MASK
argument_list|)
expr_stmt|;
name|intr_vectors
index|[
name|vec
index|]
operator|.
name|iv_ic
operator|=
operator|&
name|fire_ic
expr_stmt|;
comment|/* 		 * The MD interrupt code needs the vector rather than the MSI. 		 */
name|rman_set_start
argument_list|(
name|ires
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|rman_set_end
argument_list|(
name|ires
argument_list|,
name|vec
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|ires
argument_list|,
name|cookie
argument_list|)
expr_stmt|;
name|msi
operator|>>=
literal|3
expr_stmt|;
name|rman_set_start
argument_list|(
name|ires
argument_list|,
name|msi
argument_list|)
expr_stmt|;
name|rman_set_end
argument_list|(
name|ires
argument_list|,
name|msi
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|child
argument_list|,
name|ires
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|fire_alloc_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|resource
modifier|*
name|rv
decl_stmt|;
name|struct
name|rman
modifier|*
name|rm
decl_stmt|;
name|bus_space_tag_t
name|bt
decl_stmt|;
name|bus_space_handle_t
name|bh
decl_stmt|;
name|int
name|needactivate
init|=
name|flags
operator|&
name|RF_ACTIVE
decl_stmt|;
name|flags
operator|&=
operator|~
name|RF_ACTIVE
expr_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
block|{
comment|/* 		 * XXX: Don't accept blank ranges for now, only single 		 * interrupts.  The other case should not happen with 		 * the MI PCI code... 		 * XXX: This may return a resource that is out of the 		 * range that was specified.  Is this correct...? 		 */
if|if
condition|(
name|start
operator|!=
name|end
condition|)
name|panic
argument_list|(
literal|"%s: XXX: interrupt range"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|rid
operator|==
literal|0
condition|)
name|start
operator|=
name|end
operator|=
name|INTMAP_VEC
argument_list|(
name|sc
operator|->
name|sc_ign
argument_list|,
name|end
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_ALLOC_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_MEMORY
case|:
name|rm
operator|=
operator|&
name|sc
operator|->
name|sc_pci_mem_rman
expr_stmt|;
name|bt
operator|=
name|sc
operator|->
name|sc_pci_memt
expr_stmt|;
name|bh
operator|=
name|sc
operator|->
name|sc_pci_bh
index|[
name|OFW_PCI_CS_MEM32
index|]
expr_stmt|;
break|break;
case|case
name|SYS_RES_IOPORT
case|:
name|rm
operator|=
operator|&
name|sc
operator|->
name|sc_pci_io_rman
expr_stmt|;
name|bt
operator|=
name|sc
operator|->
name|sc_pci_iot
expr_stmt|;
name|bh
operator|=
name|sc
operator|->
name|sc_pci_bh
index|[
name|OFW_PCI_CS_IO
index|]
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* NOTREACHED */
block|}
name|rv
operator|=
name|rman_reserve_resource
argument_list|(
name|rm
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|rman_set_rid
argument_list|(
name|rv
argument_list|,
operator|*
name|rid
argument_list|)
expr_stmt|;
name|bh
operator|+=
name|rman_get_start
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rman_set_bustag
argument_list|(
name|rv
argument_list|,
name|bt
argument_list|)
expr_stmt|;
name|rman_set_bushandle
argument_list|(
name|rv
argument_list|,
name|bh
argument_list|)
expr_stmt|;
if|if
condition|(
name|needactivate
condition|)
block|{
if|if
condition|(
name|bus_activate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
operator|*
name|rid
argument_list|,
name|rv
argument_list|)
condition|)
block|{
name|rman_release_resource
argument_list|(
name|rv
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_activate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
return|return
operator|(
name|BUS_ACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
block|{
comment|/* 		 * Need to memory-map the device space, as some drivers 		 * depend on the virtual address being set and usable. 		 */
name|error
operator|=
name|sparc64_bus_mem_map
argument_list|(
name|rman_get_bustag
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_bushandle
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rman_set_virtual
argument_list|(
name|r
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rman_activate_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_deactivate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
return|return
operator|(
name|BUS_DEACTIVATE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
block|{
name|sparc64_bus_mem_unmap
argument_list|(
name|rman_get_virtual
argument_list|(
name|r
argument_list|)
argument_list|,
name|rman_get_size
argument_list|(
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|rman_set_virtual
argument_list|(
name|r
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rman_deactivate_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fire_release_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|r
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
return|return
operator|(
name|BUS_RELEASE_RESOURCE
argument_list|(
name|device_get_parent
argument_list|(
name|bus
argument_list|)
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
operator|)
return|;
if|if
condition|(
name|rman_get_flags
argument_list|(
name|r
argument_list|)
operator|&
name|RF_ACTIVE
condition|)
block|{
name|error
operator|=
name|bus_deactivate_resource
argument_list|(
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|rman_release_resource
argument_list|(
name|r
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_dma_tag_t
name|fire_get_dma_tag
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|->
name|sc_pci_dmat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|phandle_t
name|fire_get_node
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|bus
argument_list|)
expr_stmt|;
comment|/* We only have one child, the PCI bus, which needs our own node. */
return|return
operator|(
name|sc
operator|->
name|sc_node
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bus_space_tag_t
name|fire_alloc_bus_tag
parameter_list|(
name|struct
name|fire_softc
modifier|*
name|sc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|bus_space_tag_t
name|bt
decl_stmt|;
name|bt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|bus_space_tag
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bt
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"%s: out of memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bst_cookie
operator|=
name|sc
expr_stmt|;
name|bt
operator|->
name|bst_parent
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_mem_res
index|[
name|FIRE_PCI
index|]
argument_list|)
expr_stmt|;
name|bt
operator|->
name|bst_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|bt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|fire_get_timecount
parameter_list|(
name|struct
name|timecounter
modifier|*
name|tc
parameter_list|)
block|{
name|struct
name|fire_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|tc
operator|->
name|tc_priv
expr_stmt|;
return|return
operator|(
name|FIRE_CTRL_READ_8
argument_list|(
name|sc
argument_list|,
name|FO_XBC_PRF_CNT0
argument_list|)
operator|&
name|TC_COUNTER_MAX_MASK
operator|)
return|;
block|}
end_function

end_unit

