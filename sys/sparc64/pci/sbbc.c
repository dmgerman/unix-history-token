begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: sbbc.c,v 1.7 2009/11/09 17:53:39 nicm Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2008 Mark Kettenis  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2010 Marius Strobl<marius@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/clock.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/ofw_bus.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/resource.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcireg.h>
end_include

begin_include
include|#
directive|include
file|<dev/pci/pcivar.h>
end_include

begin_include
include|#
directive|include
file|<dev/uart/uart.h>
end_include

begin_include
include|#
directive|include
file|<dev/uart/uart_cpu.h>
end_include

begin_include
include|#
directive|include
file|<dev/uart/uart_bus.h>
end_include

begin_include
include|#
directive|include
file|"clock_if.h"
end_include

begin_include
include|#
directive|include
file|"uart_if.h"
end_include

begin_define
define|#
directive|define
name|SBBC_PCI_BAR
value|PCIR_BAR(0)
end_define

begin_define
define|#
directive|define
name|SBBC_PCI_VENDOR
value|0x108e
end_define

begin_define
define|#
directive|define
name|SBBC_PCI_PRODUCT
value|0xc416
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_OFFSET
value|0x800000
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_SIZE
value|0x6230
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_OFFSET
value|0x8e0000
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_SIZE
value|0x20
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_OFFSET
value|0x900000
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_SIZE
value|0x20000
end_define

begin_comment
comment|/* 128KB SRAM */
end_comment

begin_define
define|#
directive|define
name|SBBC_PCI_INT_STATUS
value|0x2320
end_define

begin_define
define|#
directive|define
name|SBBC_PCI_INT_ENABLE
value|0x2330
end_define

begin_define
define|#
directive|define
name|SBBC_PCI_ENABLE_INT_A
value|0x11
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_INTERRUPT
value|0x13
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_INTERRUPT_ON
value|0x01
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_CONS_IN
value|0x00000001
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_CONS_OUT
value|0x00000002
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_CONS_BRK
value|0x00000004
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_CONS_SPACE_IN
value|0x00000008
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_CONS_SPACE_OUT
value|0x00000010
end_define

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_SCSOLIE
value|"SCSOLIE"
end_define

begin_comment
comment|/* SC -> OS int. enable */
end_comment

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_SCSOLIR
value|"SCSOLIR"
end_define

begin_comment
comment|/* SC -> OS int. reason */
end_comment

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_SOLCONS
value|"SOLCONS"
end_define

begin_comment
comment|/* OS console buffer */
end_comment

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_SOLSCIE
value|"SOLSCIE"
end_define

begin_comment
comment|/* OS -> SC int. enable */
end_comment

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_SOLSCIR
value|"SOLSCIR"
end_define

begin_comment
comment|/* OS -> SC int. reason */
end_comment

begin_define
define|#
directive|define
name|SBBC_TAG_KEY_TODDATA
value|"TODDATA"
end_define

begin_comment
comment|/* OS TOD struct */
end_comment

begin_define
define|#
directive|define
name|SBBC_TAG_OFF
parameter_list|(
name|x
parameter_list|)
value|offsetof(struct sbbc_sram_tag, x)
end_define

begin_struct
struct|struct
name|sbbc_sram_tag
block|{
name|char
name|tag_key
index|[
name|SBBC_TAG_KEY_SIZE
index|]
decl_stmt|;
name|uint32_t
name|tag_size
decl_stmt|;
name|uint32_t
name|tag_offset
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|SBBC_TOC_MAGIC
value|"TOCSRAM"
end_define

begin_define
define|#
directive|define
name|SBBC_TOC_MAGIC_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|SBBC_TOC_TAGS_MAX
value|32
end_define

begin_define
define|#
directive|define
name|SBBC_TOC_OFF
parameter_list|(
name|x
parameter_list|)
value|offsetof(struct sbbc_sram_toc, x)
end_define

begin_struct
struct|struct
name|sbbc_sram_toc
block|{
name|char
name|toc_magic
index|[
name|SBBC_TOC_MAGIC_SIZE
index|]
decl_stmt|;
name|uint8_t
name|toc_reserved
decl_stmt|;
name|uint8_t
name|toc_type
decl_stmt|;
name|uint16_t
name|toc_version
decl_stmt|;
name|uint32_t
name|toc_ntags
decl_stmt|;
name|struct
name|sbbc_sram_tag
name|toc_tag
index|[
name|SBBC_TOC_TAGS_MAX
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|SBBC_TOD_MAGIC
value|0x54443100
end_define

begin_comment
comment|/* "TD1" */
end_comment

begin_define
define|#
directive|define
name|SBBC_TOD_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|SBBC_TOD_OFF
parameter_list|(
name|x
parameter_list|)
value|offsetof(struct sbbc_sram_tod, x)
end_define

begin_struct
struct|struct
name|sbbc_sram_tod
block|{
name|uint32_t
name|tod_magic
decl_stmt|;
name|uint32_t
name|tod_version
decl_stmt|;
name|uint64_t
name|tod_time
decl_stmt|;
name|uint64_t
name|tod_skew
decl_stmt|;
name|uint32_t
name|tod_reserved
decl_stmt|;
name|uint32_t
name|tod_heartbeat
decl_stmt|;
name|uint32_t
name|tod_timeout
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_define
define|#
directive|define
name|SBBC_CONS_MAGIC
value|0x434f4e00
end_define

begin_comment
comment|/* "CON" */
end_comment

begin_define
define|#
directive|define
name|SBBC_CONS_VERSION
value|1
end_define

begin_define
define|#
directive|define
name|SBBC_CONS_OFF
parameter_list|(
name|x
parameter_list|)
value|offsetof(struct sbbc_sram_cons, x)
end_define

begin_struct
struct|struct
name|sbbc_sram_cons
block|{
name|uint32_t
name|cons_magic
decl_stmt|;
name|uint32_t
name|cons_version
decl_stmt|;
name|uint32_t
name|cons_size
decl_stmt|;
name|uint32_t
name|cons_in_begin
decl_stmt|;
name|uint32_t
name|cons_in_end
decl_stmt|;
name|uint32_t
name|cons_in_rdptr
decl_stmt|;
name|uint32_t
name|cons_in_wrptr
decl_stmt|;
name|uint32_t
name|cons_out_begin
decl_stmt|;
name|uint32_t
name|cons_out_end
decl_stmt|;
name|uint32_t
name|cons_out_rdptr
decl_stmt|;
name|uint32_t
name|cons_out_wrptr
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_struct
struct|struct
name|sbbc_softc
block|{
name|struct
name|resource
modifier|*
name|sc_res
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SBBC_READ_N
parameter_list|(
name|wdth
parameter_list|,
name|offs
parameter_list|)
define|\
value|bus_space_read_ ## wdth((bst), (bsh), (offs))
end_define

begin_define
define|#
directive|define
name|SBBC_WRITE_N
parameter_list|(
name|wdth
parameter_list|,
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|bus_space_write_ ## wdth((bst), (bsh), (offs), (val))
end_define

begin_define
define|#
directive|define
name|SBBC_READ_1
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_N(1, (offs))
end_define

begin_define
define|#
directive|define
name|SBBC_READ_2
parameter_list|(
name|offs
parameter_list|)
define|\
value|bswap16(SBBC_READ_N(2, (offs)))
end_define

begin_define
define|#
directive|define
name|SBBC_READ_4
parameter_list|(
name|offs
parameter_list|)
define|\
value|bswap32(SBBC_READ_N(4, (offs)))
end_define

begin_define
define|#
directive|define
name|SBBC_READ_8
parameter_list|(
name|offs
parameter_list|)
define|\
value|bswap64(SBBC_READ_N(8, (offs)))
end_define

begin_define
define|#
directive|define
name|SBBC_WRITE_1
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_N(1, (offs), (val))
end_define

begin_define
define|#
directive|define
name|SBBC_WRITE_2
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_N(2, (offs), bswap16(val))
end_define

begin_define
define|#
directive|define
name|SBBC_WRITE_4
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_N(4, (offs), bswap32(val))
end_define

begin_define
define|#
directive|define
name|SBBC_WRITE_8
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_N(8, (offs), bswap64(val))
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_READ_1
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_1((offs) + SBBC_REGS_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_READ_2
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_2((offs) + SBBC_REGS_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_READ_4
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_4((offs) + SBBC_REGS_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_READ_8
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_8((offs) + SBBC_REGS_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_WRITE_1
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_1((offs) + SBBC_REGS_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_WRITE_2
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_2((offs) + SBBC_REGS_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_WRITE_4
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_4((offs) + SBBC_REGS_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_REGS_WRITE_8
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_8((offs) + SBBC_REGS_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_READ_1
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_1((offs) + SBBC_EPLD_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_READ_2
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_2((offs) + SBBC_EPLD_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_READ_4
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_4((offs) + SBBC_EPLD_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_READ_8
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_8((offs) + SBBC_EPLD_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_WRITE_1
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_1((offs) + SBBC_EPLD_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_WRITE_2
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_2((offs) + SBBC_EPLD_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_WRITE_4
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_4((offs) + SBBC_EPLD_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_EPLD_WRITE_8
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_8((offs) + SBBC_EPLD_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_READ_1
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_1((offs) + SBBC_SRAM_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_READ_2
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_2((offs) + SBBC_SRAM_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_READ_4
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_4((offs) + SBBC_SRAM_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_READ_8
parameter_list|(
name|offs
parameter_list|)
define|\
value|SBBC_READ_8((offs) + SBBC_SRAM_OFFSET)
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_WRITE_1
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_1((offs) + SBBC_SRAM_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_WRITE_2
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_2((offs) + SBBC_SRAM_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_WRITE_4
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_4((offs) + SBBC_SRAM_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SBBC_SRAM_WRITE_8
parameter_list|(
name|offs
parameter_list|,
name|val
parameter_list|)
define|\
value|SBBC_WRITE_8((offs) + SBBC_SRAM_OFFSET, (val))
end_define

begin_define
define|#
directive|define
name|SUNW_SETCONSINPUT
value|"SUNW,set-console-input"
end_define

begin_define
define|#
directive|define
name|SUNW_SETCONSINPUT_CLNT
value|"CON_CLNT"
end_define

begin_define
define|#
directive|define
name|SUNW_SETCONSINPUT_OBP
value|"CON_OBP"
end_define

begin_decl_stmt
specifier|static
name|u_int
name|sbbc_console
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|sbbc_scsolie
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|sbbc_scsolir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|sbbc_solcons
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|sbbc_solscie
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|sbbc_solscir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|sbbc_toddata
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * internal helpers  */
end_comment

begin_function_decl
specifier|static
name|int
name|sbbc_parse_toc
parameter_list|(
name|bus_space_tag_t
name|bst
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|sbbc_send_intr
parameter_list|(
name|bus_space_tag_t
name|bst
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|sbbc_serengeti_set_console_input
parameter_list|(
name|char
modifier|*
name|new
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * SBBC PCI interface  */
end_comment

begin_decl_stmt
specifier|static
name|bus_activate_resource_t
name|sbbc_bus_activate_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_adjust_resource_t
name|sbbc_bus_adjust_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_deactivate_resource_t
name|sbbc_bus_deactivate_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_alloc_resource_t
name|sbbc_bus_alloc_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_release_resource_t
name|sbbc_bus_release_resource
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_get_resource_list_t
name|sbbc_bus_get_resource_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_setup_intr_t
name|sbbc_bus_setup_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bus_teardown_intr_t
name|sbbc_bus_teardown_intr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_attach_t
name|sbbc_pci_attach
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_probe_t
name|sbbc_pci_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_gettime_t
name|sbbc_tod_gettime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|clock_settime_t
name|sbbc_tod_settime
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|sbbc_pci_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sbbc_pci_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|sbbc_pci_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_alloc_resource
argument_list|,
name|sbbc_bus_alloc_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_activate_resource
argument_list|,
name|sbbc_bus_activate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_deactivate_resource
argument_list|,
name|sbbc_bus_deactivate_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_adjust_resource
argument_list|,
name|sbbc_bus_adjust_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_release_resource
argument_list|,
name|sbbc_bus_release_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_setup_intr
argument_list|,
name|sbbc_bus_setup_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_teardown_intr
argument_list|,
name|sbbc_bus_teardown_intr
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource
argument_list|,
name|bus_generic_rl_get_resource
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|bus_get_resource_list
argument_list|,
name|sbbc_bus_get_resource_list
argument_list|)
block|,
comment|/* clock interface */
name|DEVMETHOD
argument_list|(
name|clock_gettime
argument_list|,
name|sbbc_tod_gettime
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|clock_settime
argument_list|,
name|sbbc_tod_settime
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|devclass_t
name|sbbc_devclass
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|sbbc
argument_list|,
name|sbbc_driver
argument_list|,
name|sbbc_pci_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sbbc_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|sbbc
argument_list|,
name|pci
argument_list|,
name|sbbc_driver
argument_list|,
name|sbbc_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sbbc_pci_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
if|if
condition|(
name|pci_get_vendor
argument_list|(
name|dev
argument_list|)
operator|==
name|SBBC_PCI_VENDOR
operator|&&
name|pci_get_device
argument_list|(
name|dev
argument_list|)
operator|==
name|SBBC_PCI_PRODUCT
condition|)
block|{
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Sun BootBus controller"
argument_list|)
expr_stmt|;
return|return
operator|(
name|BUS_PROBE_DEFAULT
operator|)
return|;
block|}
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_pci_attach
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|sbbc_softc
modifier|*
name|sc
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|device_t
name|child
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|int
name|error
decl_stmt|,
name|rid
decl_stmt|;
name|uint32_t
name|val
decl_stmt|;
comment|/* Nothing to to if we're not the chosen one. */
if|if
condition|(
operator|(
name|node
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to find /chosen\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"iosram"
argument_list|,
operator|&
name|node
argument_list|,
sizeof|sizeof
argument_list|(
name|node
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to get iosram\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|node
operator|!=
name|ofw_bus_get_node
argument_list|(
name|dev
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|rid
operator|=
name|SBBC_PCI_BAR
expr_stmt|;
name|sc
operator|->
name|sc_res
operator|=
name|bus_alloc_resource_any
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
operator|&
name|rid
argument_list|,
name|RF_ACTIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_res
operator|==
name|NULL
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to allocate resources\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbbc_console
operator|!=
literal|0
condition|)
block|{
comment|/* Once again the interrupt pin isn't set. */
if|if
condition|(
name|pci_get_intpin
argument_list|(
name|dev
argument_list|)
operator|==
literal|0
condition|)
name|pci_set_intpin
argument_list|(
name|dev
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|child
operator|=
name|device_add_child
argument_list|(
name|dev
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to add UART device\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|bus_generic_attach
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to attach UART device\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|sbbc_parse_toc
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"failed to parse TOC\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sbbc_console
operator|!=
literal|0
condition|)
block|{
name|bus_release_resource
argument_list|(
name|dev
argument_list|,
name|SYS_RES_MEMORY
argument_list|,
name|rid
argument_list|,
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|sbbc_toddata
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|val
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_toddata
operator|+
name|SBBC_TOD_OFF
argument_list|(
name|tod_magic
argument_list|)
argument_list|)
operator|)
operator|!=
name|SBBC_TOD_MAGIC
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid TOD magic %#x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_toddata
operator|+
name|SBBC_TOD_OFF
argument_list|(
name|tod_version
argument_list|)
argument_list|)
operator|)
operator|<
name|SBBC_TOD_VERSION
condition|)
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"invalid TOD version %#x\n"
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|clock_register
argument_list|(
name|dev
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
comment|/* 1 sec. resolution */
if|if
condition|(
name|bootverbose
condition|)
block|{
name|sbbc_tod_gettime
argument_list|(
name|dev
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|dev
argument_list|,
literal|"current time: %ld.%09ld\n"
argument_list|,
operator|(
name|long
operator|)
name|ts
operator|.
name|tv_sec
argument_list|,
name|ts
operator|.
name|tv_nsec
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that the bus methods don't pass-through the uart(4) requests but act  * as if they would come from sbbc(4) in order to avoid complications with  * pci(4) (actually, uart(4) isn't a real child but rather a function of  * sbbc(4) anyway).  */
end_comment

begin_function
specifier|static
name|struct
name|resource
modifier|*
name|sbbc_bus_alloc_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rid
parameter_list|,
name|u_long
name|start
parameter_list|,
name|u_long
name|end
parameter_list|,
name|u_long
name|count
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|sbbc_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SYS_RES_IRQ
case|:
return|return
operator|(
name|bus_generic_alloc_resource
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|count
argument_list|,
name|flags
argument_list|)
operator|)
return|;
case|case
name|SYS_RES_MEMORY
case|:
return|return
operator|(
name|sc
operator|->
name|sc_res
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_bus_activate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|bus_generic_activate_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_bus_deactivate_resource
parameter_list|(
name|device_t
name|bus
parameter_list|,
name|device_t
name|child
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_MEMORY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|bus_generic_deactivate_resource
argument_list|(
name|bus
argument_list|,
name|child
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_bus_adjust_resource
parameter_list|(
name|device_t
name|bus
name|__unused
parameter_list|,
name|device_t
name|child
name|__unused
parameter_list|,
name|int
name|type
name|__unused
parameter_list|,
name|struct
name|resource
modifier|*
name|res
name|__unused
parameter_list|,
name|u_long
name|start
name|__unused
parameter_list|,
name|u_long
name|end
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_bus_release_resource
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
name|__unused
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rid
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|SYS_RES_IRQ
condition|)
return|return
operator|(
name|bus_generic_release_resource
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|,
name|type
argument_list|,
name|rid
argument_list|,
name|res
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|resource_list
modifier|*
name|sbbc_bus_get_resource_list
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_get_resource_list
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_bus_setup_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
name|__unused
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|int
name|flags
parameter_list|,
name|driver_filter_t
modifier|*
name|filt
parameter_list|,
name|driver_intr_t
modifier|*
name|intr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_setup_intr
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|,
name|res
argument_list|,
name|flags
argument_list|,
name|filt
argument_list|,
name|intr
argument_list|,
name|arg
argument_list|,
name|cookiep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_bus_teardown_intr
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|device_t
name|child
name|__unused
parameter_list|,
name|struct
name|resource
modifier|*
name|res
parameter_list|,
name|void
modifier|*
name|cookie
parameter_list|)
block|{
return|return
operator|(
name|bus_generic_teardown_intr
argument_list|(
name|dev
argument_list|,
name|dev
argument_list|,
name|res
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * internal helpers  */
end_comment

begin_function
specifier|static
name|int
name|sbbc_parse_toc
parameter_list|(
name|bus_space_tag_t
name|bst
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX
argument_list|(
name|SBBC_TAG_KEY_SIZE
argument_list|,
name|SBBC_TOC_MAGIC_SIZE
argument_list|)
index|]
decl_stmt|;
name|bus_size_t
name|tag
decl_stmt|;
name|phandle_t
name|node
decl_stmt|;
name|uint32_t
name|off
decl_stmt|,
name|sram_toc
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|tags
decl_stmt|;
if|if
condition|(
operator|(
name|node
operator|=
name|OF_finddevice
argument_list|(
literal|"/chosen"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* SRAM TOC offset defaults to 0. */
if|if
condition|(
name|OF_getprop
argument_list|(
name|node
argument_list|,
literal|"iosram-toc"
argument_list|,
operator|&
name|sram_toc
argument_list|,
sizeof|sizeof
argument_list|(
name|sram_toc
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
name|sram_toc
operator|=
literal|0
expr_stmt|;
name|bus_space_read_region_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|SBBC_SRAM_OFFSET
operator|+
name|sram_toc
operator|+
name|SBBC_TOC_OFF
argument_list|(
name|toc_magic
argument_list|)
argument_list|,
name|buf
argument_list|,
name|SBBC_TOC_MAGIC_SIZE
argument_list|)
expr_stmt|;
name|buf
index|[
name|SBBC_TOC_MAGIC_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TOC_MAGIC
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|tags
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sram_toc
operator|+
name|SBBC_TOC_OFF
argument_list|(
name|toc_ntags
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tags
condition|;
name|i
operator|++
control|)
block|{
name|tag
operator|=
name|sram_toc
operator|+
name|SBBC_TOC_OFF
argument_list|(
name|toc_tag
argument_list|)
operator|+
name|i
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sbbc_sram_tag
argument_list|)
expr_stmt|;
name|bus_space_read_region_1
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|SBBC_SRAM_OFFSET
operator|+
name|tag
operator|+
name|SBBC_TAG_OFF
argument_list|(
name|tag_key
argument_list|)
argument_list|,
name|buf
argument_list|,
name|SBBC_TAG_KEY_SIZE
argument_list|)
expr_stmt|;
name|buf
index|[
name|SBBC_TAG_KEY_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|off
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|tag
operator|+
name|SBBC_TAG_OFF
argument_list|(
name|tag_offset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TAG_KEY_SCSOLIE
argument_list|)
operator|==
literal|0
condition|)
name|sbbc_scsolie
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TAG_KEY_SCSOLIR
argument_list|)
operator|==
literal|0
condition|)
name|sbbc_scsolir
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TAG_KEY_SOLCONS
argument_list|)
operator|==
literal|0
condition|)
name|sbbc_solcons
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TAG_KEY_SOLSCIE
argument_list|)
operator|==
literal|0
condition|)
name|sbbc_solscie
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TAG_KEY_SOLSCIR
argument_list|)
operator|==
literal|0
condition|)
name|sbbc_solscir
operator|=
name|off
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|SBBC_TAG_KEY_TODDATA
argument_list|)
operator|==
literal|0
condition|)
name|sbbc_toddata
operator|=
name|off
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sbbc_serengeti_set_console_input
parameter_list|(
name|char
modifier|*
name|new
parameter_list|)
block|{
struct|struct
block|{
name|cell_t
name|name
decl_stmt|;
name|cell_t
name|nargs
decl_stmt|;
name|cell_t
name|nreturns
decl_stmt|;
name|cell_t
name|new
decl_stmt|;
name|cell_t
name|old
decl_stmt|;
block|}
name|args
init|=
block|{
operator|(
name|cell_t
operator|)
name|SUNW_SETCONSINPUT
block|,
literal|1
block|,
literal|1
block|, 	}
struct|;
name|args
operator|.
name|new
operator|=
operator|(
name|cell_t
operator|)
name|new
expr_stmt|;
if|if
condition|(
name|ofw_entry
argument_list|(
operator|&
name|args
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|args
operator|.
name|old
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|sbbc_send_intr
parameter_list|(
name|bus_space_tag_t
name|bst
parameter_list|,
name|bus_space_handle_t
name|bsh
parameter_list|)
block|{
name|SBBC_EPLD_WRITE_1
argument_list|(
name|SBBC_EPLD_INTERRUPT
argument_list|,
name|SBBC_EPLD_INTERRUPT_ON
argument_list|)
expr_stmt|;
name|bus_space_barrier
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|,
name|SBBC_EPLD_OFFSET
operator|+
name|SBBC_EPLD_INTERRUPT
argument_list|,
literal|1
argument_list|,
name|BUS_SPACE_BARRIER_READ
operator||
name|BUS_SPACE_BARRIER_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TOD interface  */
end_comment

begin_function
specifier|static
name|int
name|sbbc_tod_gettime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|sbbc_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tv_sec
operator|=
name|SBBC_SRAM_READ_8
argument_list|(
name|sbbc_toddata
operator|+
name|SBBC_TOD_OFF
argument_list|(
name|tod_time
argument_list|)
argument_list|)
operator|+
name|SBBC_SRAM_READ_8
argument_list|(
name|sbbc_toddata
operator|+
name|SBBC_TOD_OFF
argument_list|(
name|tod_skew
argument_list|)
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tv_nsec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_tod_settime
parameter_list|(
name|device_t
name|dev
parameter_list|,
name|struct
name|timespec
modifier|*
name|ts
parameter_list|)
block|{
name|struct
name|sbbc_softc
modifier|*
name|sc
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|bst
operator|=
name|rman_get_bustag
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|bsh
operator|=
name|rman_get_bushandle
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_8
argument_list|(
name|sbbc_toddata
operator|+
name|SBBC_TOD_OFF
argument_list|(
name|tod_skew
argument_list|)
argument_list|,
name|ts
operator|->
name|tv_sec
operator|-
name|SBBC_SRAM_READ_8
argument_list|(
name|sbbc_toddata
operator|+
name|SBBC_TOD_OFF
argument_list|(
name|tod_time
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * UART bus front-end  */
end_comment

begin_decl_stmt
specifier|static
name|device_probe_t
name|sbbc_uart_sbbc_probe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|device_method_t
name|sbbc_uart_sbbc_methods
index|[]
init|=
block|{
comment|/* Device interface */
name|DEVMETHOD
argument_list|(
name|device_probe
argument_list|,
name|sbbc_uart_sbbc_probe
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_attach
argument_list|,
name|uart_bus_attach
argument_list|)
block|,
name|DEVMETHOD
argument_list|(
name|device_detach
argument_list|,
name|uart_bus_detach
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DEFINE_CLASS_0
argument_list|(
name|uart
argument_list|,
name|sbbc_uart_driver
argument_list|,
name|sbbc_uart_sbbc_methods
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|uart_softc
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DRIVER_MODULE
argument_list|(
name|uart
argument_list|,
name|sbbc
argument_list|,
name|sbbc_uart_driver
argument_list|,
name|uart_devclass
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sbbc_uart_sbbc_probe
parameter_list|(
name|device_t
name|dev
parameter_list|)
block|{
name|struct
name|uart_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
name|device_get_softc
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_class
operator|=
operator|&
name|uart_sbbc_class
expr_stmt|;
name|device_set_desc
argument_list|(
name|dev
argument_list|,
literal|"Serengeti console"
argument_list|)
expr_stmt|;
return|return
operator|(
name|uart_bus_probe
argument_list|(
name|dev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|SBBC_PCI_BAR
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Low-level UART interface  */
end_comment

begin_function_decl
specifier|static
name|int
name|sbbc_uart_probe
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbbc_uart_init
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|,
name|int
name|baudrate
parameter_list|,
name|int
name|databits
parameter_list|,
name|int
name|stopbits
parameter_list|,
name|int
name|parity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbbc_uart_term
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sbbc_uart_putc
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|,
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_rxready
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_getc
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|,
name|struct
name|mtx
modifier|*
name|hwmtx
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|uart_ops
name|sbbc_uart_ops
init|=
block|{
operator|.
name|probe
operator|=
name|sbbc_uart_probe
block|,
operator|.
name|init
operator|=
name|sbbc_uart_init
block|,
operator|.
name|term
operator|=
name|sbbc_uart_term
block|,
operator|.
name|putc
operator|=
name|sbbc_uart_putc
block|,
operator|.
name|rxready
operator|=
name|sbbc_uart_rxready
block|,
operator|.
name|getc
operator|=
name|sbbc_uart_getc
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|sbbc_uart_probe
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|)
block|{
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|error
decl_stmt|;
name|sbbc_console
operator|=
literal|1
expr_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|error
operator|=
name|sbbc_parse_toc
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|sbbc_scsolie
operator|==
literal|0
operator|||
name|sbbc_scsolir
operator|==
literal|0
operator|||
name|sbbc_solcons
operator|==
literal|0
operator|||
name|sbbc_solscie
operator|==
literal|0
operator|||
name|sbbc_solscir
operator|==
literal|0
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_magic
argument_list|)
argument_list|)
operator|!=
name|SBBC_CONS_MAGIC
operator|||
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_version
argument_list|)
argument_list|)
operator|<
name|SBBC_CONS_VERSION
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbbc_uart_init
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|,
name|int
name|baudrate
name|__unused
parameter_list|,
name|int
name|databits
name|__unused
parameter_list|,
name|int
name|stopbits
name|__unused
parameter_list|,
name|int
name|parity
name|__unused
parameter_list|)
block|{
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
comment|/* Enable output to and space in from the SC interrupts. */
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solscie
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solscie
argument_list|)
operator||
name|SBBC_SRAM_CONS_OUT
operator||
name|SBBC_SRAM_CONS_SPACE_IN
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
comment|/* Take over the console input. */
name|sbbc_serengeti_set_console_input
argument_list|(
name|SUNW_SETCONSINPUT_CLNT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbbc_uart_term
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
name|__unused
parameter_list|)
block|{
comment|/* Give back the console input. */
name|sbbc_serengeti_set_console_input
argument_list|(
name|SUNW_SETCONSINPUT_OBP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sbbc_uart_putc
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|uint32_t
name|wrptr
decl_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|wrptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_wrptr
argument_list|)
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_1
argument_list|(
name|sbbc_solcons
operator|+
name|wrptr
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wrptr
operator|==
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_end
argument_list|)
argument_list|)
condition|)
name|wrptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_begin
argument_list|)
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_wrptr
argument_list|)
argument_list|,
name|wrptr
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solscir
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solscir
argument_list|)
operator||
name|SBBC_SRAM_CONS_OUT
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|sbbc_send_intr
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_rxready
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|)
block|{
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
if|if
condition|(
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_rdptr
argument_list|)
argument_list|)
operator|==
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_wrptr
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_getc
parameter_list|(
name|struct
name|uart_bas
modifier|*
name|bas
parameter_list|,
name|struct
name|mtx
modifier|*
name|hwmtx
parameter_list|)
block|{
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|c
decl_stmt|;
name|uint32_t
name|rdptr
decl_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|uart_lock
argument_list|(
name|hwmtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|sbbc_uart_rxready
argument_list|(
name|bas
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uart_unlock
argument_list|(
name|hwmtx
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|4
argument_list|)
expr_stmt|;
name|uart_lock
argument_list|(
name|hwmtx
argument_list|)
expr_stmt|;
block|}
name|rdptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_rdptr
argument_list|)
argument_list|)
expr_stmt|;
name|c
operator|=
name|SBBC_SRAM_READ_1
argument_list|(
name|sbbc_solcons
operator|+
name|rdptr
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|rdptr
operator|==
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_end
argument_list|)
argument_list|)
condition|)
name|rdptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_begin
argument_list|)
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_rdptr
argument_list|)
argument_list|,
name|rdptr
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solscir
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solscir
argument_list|)
operator||
name|SBBC_SRAM_CONS_SPACE_IN
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|sbbc_send_intr
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
name|uart_unlock
argument_list|(
name|hwmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * High-level UART interface  */
end_comment

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_attach
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_detach
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_flush
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_getsig
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_ioctl
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|request
parameter_list|,
name|intptr_t
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_ipend
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_param
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|baudrate
parameter_list|,
name|int
name|databits
parameter_list|,
name|int
name|stopbits
parameter_list|,
name|int
name|parity
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_probe
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_receive
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_setsig
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|sbbc_uart_bus_transmit
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|kobj_method_t
name|sbbc_uart_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|uart_attach
argument_list|,
name|sbbc_uart_bus_attach
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_detach
argument_list|,
name|sbbc_uart_bus_detach
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_flush
argument_list|,
name|sbbc_uart_bus_flush
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_getsig
argument_list|,
name|sbbc_uart_bus_getsig
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_ioctl
argument_list|,
name|sbbc_uart_bus_ioctl
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_ipend
argument_list|,
name|sbbc_uart_bus_ipend
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_param
argument_list|,
name|sbbc_uart_bus_param
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_probe
argument_list|,
name|sbbc_uart_bus_probe
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_receive
argument_list|,
name|sbbc_uart_bus_receive
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_setsig
argument_list|,
name|sbbc_uart_bus_setsig
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|uart_transmit
argument_list|,
name|sbbc_uart_bus_transmit
argument_list|)
block|,
name|DEVMETHOD_END
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uart_class
name|uart_sbbc_class
init|=
block|{
literal|"sbbc"
block|,
name|sbbc_uart_methods
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|uart_softc
argument_list|)
block|,
operator|.
name|uc_ops
operator|=
operator|&
name|sbbc_uart_ops
block|,
operator|.
name|uc_range
operator|=
literal|1
block|,
operator|.
name|uc_rclk
operator|=
literal|0x5bbc
comment|/* arbitrary */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SIGCHG
parameter_list|(
name|c
parameter_list|,
name|i
parameter_list|,
name|s
parameter_list|,
name|d
parameter_list|)
define|\
value|if ((c) != 0) {							\ 		i |= (((i)& (s)) != 0) ? (s) : (s) | (d);		\ 	} else {							\ 		i = (((i)& (s)) != 0) ? ((i)& ~(s)) | (d) : (i);	\ 	}
end_define

begin_function
specifier|static
name|int
name|sbbc_uart_bus_attach
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uart_bas
modifier|*
name|bas
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|uint32_t
name|wrptr
decl_stmt|;
name|bas
operator|=
operator|&
name|sc
operator|->
name|sc_bas
expr_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|sc
operator|->
name|sc_rxfifosz
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_end
argument_list|)
argument_list|)
operator|-
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_begin
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|sc
operator|->
name|sc_txfifosz
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_end
argument_list|)
argument_list|)
operator|-
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_begin
argument_list|)
argument_list|)
operator|-
literal|1
expr_stmt|;
name|uart_lock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
comment|/* 	 * Let the current output drain before enabling interrupts.  Not 	 * doing so tends to cause lost output when turning them on. 	 */
name|wrptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_wrptr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_rdptr
argument_list|)
argument_list|)
operator|!=
name|wrptr
condition|)
empty_stmt|;
name|cpu_spinwait
argument_list|()
expr_stmt|;
comment|/* Clear and acknowledge possibly outstanding interrupts. */
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_scsolir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_REGS_WRITE_4
argument_list|(
name|SBBC_PCI_INT_STATUS
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_scsolir
argument_list|)
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
comment|/* Enable PCI interrupts. */
name|SBBC_REGS_WRITE_4
argument_list|(
name|SBBC_PCI_INT_ENABLE
argument_list|,
name|SBBC_PCI_ENABLE_INT_A
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
comment|/* Enable input from and output to SC as well as break interrupts. */
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_scsolie
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_scsolie
argument_list|)
operator||
name|SBBC_SRAM_CONS_IN
operator||
name|SBBC_SRAM_CONS_BRK
operator||
name|SBBC_SRAM_CONS_SPACE_OUT
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|uart_unlock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_detach
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
comment|/* Give back the console input. */
name|sbbc_serengeti_set_console_input
argument_list|(
name|SUNW_SETCONSINPUT_OBP
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_flush
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|struct
name|uart_bas
modifier|*
name|bas
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|bas
operator|=
operator|&
name|sc
operator|->
name|sc_bas
expr_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
if|if
condition|(
operator|(
name|what
operator|&
name|UART_FLUSH_TRANSMITTER
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
operator|(
name|what
operator|&
name|UART_FLUSH_RECEIVER
operator|)
operator|!=
literal|0
condition|)
block|{
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_rdptr
argument_list|)
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_wrptr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_getsig
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|dummy
decl_stmt|,
name|new
decl_stmt|,
name|old
decl_stmt|,
name|sig
decl_stmt|;
do|do
block|{
name|old
operator|=
name|sc
operator|->
name|sc_hwsig
expr_stmt|;
name|sig
operator|=
name|old
expr_stmt|;
name|dummy
operator|=
literal|0
expr_stmt|;
name|SIGCHG
argument_list|(
name|dummy
argument_list|,
name|sig
argument_list|,
name|SER_CTS
argument_list|,
name|SER_DCTS
argument_list|)
expr_stmt|;
name|SIGCHG
argument_list|(
name|dummy
argument_list|,
name|sig
argument_list|,
name|SER_DCD
argument_list|,
name|SER_DDCD
argument_list|)
expr_stmt|;
name|SIGCHG
argument_list|(
name|dummy
argument_list|,
name|sig
argument_list|,
name|SER_DSR
argument_list|,
name|SER_DDSR
argument_list|)
expr_stmt|;
name|new
operator|=
name|sig
operator|&
operator|~
name|SER_MASK_DELTA
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_32
argument_list|(
operator|&
name|sc
operator|->
name|sc_hwsig
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
condition|)
do|;
return|return
operator|(
name|sig
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_ioctl
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|request
parameter_list|,
name|intptr_t
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|uart_lock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|UART_IOCTL_BAUD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|data
operator|=
literal|9600
expr_stmt|;
comment|/* arbitrary */
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|uart_unlock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_ipend
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uart_bas
modifier|*
name|bas
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|ipend
decl_stmt|;
name|uint32_t
name|reason
decl_stmt|,
name|status
decl_stmt|;
name|bas
operator|=
operator|&
name|sc
operator|->
name|sc_bas
expr_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|uart_lock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
name|status
operator|=
name|SBBC_REGS_READ_4
argument_list|(
name|SBBC_PCI_INT_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|uart_unlock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Unfortunately, we can't use compare and swap for non-cachable 	 * memory. 	 */
name|reason
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_scsolir
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_scsolir
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
comment|/* Acknowledge the interrupt. */
name|SBBC_REGS_WRITE_4
argument_list|(
name|SBBC_PCI_INT_STATUS
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|uart_unlock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
name|ipend
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|&
name|SBBC_SRAM_CONS_IN
operator|)
operator|!=
literal|0
condition|)
name|ipend
operator||=
name|SER_INT_RXREADY
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|&
name|SBBC_SRAM_CONS_BRK
operator|)
operator|!=
literal|0
condition|)
name|ipend
operator||=
name|SER_INT_BREAK
expr_stmt|;
if|if
condition|(
operator|(
name|reason
operator|&
name|SBBC_SRAM_CONS_SPACE_OUT
operator|)
operator|!=
literal|0
operator|&&
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_rdptr
argument_list|)
argument_list|)
operator|==
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_wrptr
argument_list|)
argument_list|)
condition|)
name|ipend
operator||=
name|SER_INT_TXIDLE
expr_stmt|;
return|return
operator|(
name|ipend
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_param
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
name|__unused
parameter_list|,
name|int
name|baudrate
name|__unused
parameter_list|,
name|int
name|databits
name|__unused
parameter_list|,
name|int
name|stopbits
name|__unused
parameter_list|,
name|int
name|parity
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_probe
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
name|__unused
parameter_list|)
block|{
if|if
condition|(
name|sbbc_console
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_receive
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uart_bas
modifier|*
name|bas
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|c
decl_stmt|;
name|uint32_t
name|end
decl_stmt|,
name|rdptr
decl_stmt|,
name|wrptr
decl_stmt|;
name|bas
operator|=
operator|&
name|sc
operator|->
name|sc_bas
expr_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|uart_lock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
name|end
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_end
argument_list|)
argument_list|)
expr_stmt|;
name|rdptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_rdptr
argument_list|)
argument_list|)
expr_stmt|;
name|wrptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_wrptr
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|rdptr
operator|!=
name|wrptr
condition|)
block|{
if|if
condition|(
name|uart_rx_full
argument_list|(
name|sc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc
operator|->
name|sc_rxbuf
index|[
name|sc
operator|->
name|sc_rxput
index|]
operator|=
name|UART_STAT_OVERRUN
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|SBBC_SRAM_READ_1
argument_list|(
name|sbbc_solcons
operator|+
name|rdptr
argument_list|)
expr_stmt|;
name|uart_rx_put
argument_list|(
name|sc
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|rdptr
operator|==
name|end
condition|)
name|rdptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_in_rdptr
argument_list|)
argument_list|,
name|rdptr
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solscir
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solscir
argument_list|)
operator||
name|SBBC_SRAM_CONS_SPACE_IN
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|sbbc_send_intr
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
name|uart_unlock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_setsig
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|struct
name|uart_bas
modifier|*
name|bas
decl_stmt|;
name|uint32_t
name|new
decl_stmt|,
name|old
decl_stmt|;
name|bas
operator|=
operator|&
name|sc
operator|->
name|sc_bas
expr_stmt|;
do|do
block|{
name|old
operator|=
name|sc
operator|->
name|sc_hwsig
expr_stmt|;
name|new
operator|=
name|old
expr_stmt|;
if|if
condition|(
operator|(
name|sig
operator|&
name|SER_DDTR
operator|)
operator|!=
literal|0
condition|)
block|{
name|SIGCHG
argument_list|(
name|sig
operator|&
name|SER_DTR
argument_list|,
name|new
argument_list|,
name|SER_DTR
argument_list|,
name|SER_DDTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|sig
operator|&
name|SER_DRTS
operator|)
operator|!=
literal|0
condition|)
block|{
name|SIGCHG
argument_list|(
name|sig
operator|&
name|SER_RTS
argument_list|,
name|new
argument_list|,
name|SER_RTS
argument_list|,
name|SER_DRTS
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|!
name|atomic_cmpset_32
argument_list|(
operator|&
name|sc
operator|->
name|sc_hwsig
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sbbc_uart_bus_transmit
parameter_list|(
name|struct
name|uart_softc
modifier|*
name|sc
parameter_list|)
block|{
name|struct
name|uart_bas
modifier|*
name|bas
decl_stmt|;
name|bus_space_tag_t
name|bst
decl_stmt|;
name|bus_space_handle_t
name|bsh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|end
decl_stmt|,
name|wrptr
decl_stmt|;
name|bas
operator|=
operator|&
name|sc
operator|->
name|sc_bas
expr_stmt|;
name|bst
operator|=
name|bas
operator|->
name|bst
expr_stmt|;
name|bsh
operator|=
name|bas
operator|->
name|bsh
expr_stmt|;
name|uart_lock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
name|end
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_end
argument_list|)
argument_list|)
expr_stmt|;
name|wrptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_wrptr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sc
operator|->
name|sc_txdatasz
condition|;
name|i
operator|++
control|)
block|{
name|SBBC_SRAM_WRITE_1
argument_list|(
name|sbbc_solcons
operator|+
name|wrptr
argument_list|,
name|sc
operator|->
name|sc_txbuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|wrptr
operator|==
name|end
condition|)
name|wrptr
operator|=
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_begin
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solcons
operator|+
name|SBBC_CONS_OFF
argument_list|(
name|cons_out_wrptr
argument_list|)
argument_list|,
name|wrptr
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|SBBC_SRAM_WRITE_4
argument_list|(
name|sbbc_solscir
argument_list|,
name|SBBC_SRAM_READ_4
argument_list|(
name|sbbc_solscir
argument_list|)
operator||
name|SBBC_SRAM_CONS_OUT
argument_list|)
expr_stmt|;
name|uart_barrier
argument_list|(
name|bas
argument_list|)
expr_stmt|;
name|sbbc_send_intr
argument_list|(
name|bst
argument_list|,
name|bsh
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_txbusy
operator|=
literal|1
expr_stmt|;
name|uart_unlock
argument_list|(
name|sc
operator|->
name|sc_hwmtx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

