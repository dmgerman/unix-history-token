begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the University of  *      California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      from:   @(#)pmap.c      7.7 (Berkeley)  5/12/91  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Manages physical address maps.  *  * In addition to hardware address maps, this module is called upon to  * provide software-use-only maps which may or may not be stored in the  * same form as hardware maps.  These pseudo-maps are used to store  * intermediate results from copy operations to and from address spaces.  *  * Since the information managed by this module is also stored by the  * logical address mapping module, this module may throw away valid virtual  * to physical mappings at almost any time.  However, invalidations of  * mappings must be done as requested.  *  * In order to cope with hardware architectures which make virtual to  * physical map invalidates expensive, this module may delay invalidate  * reduced protection operations until such time as they are actually  * necessary.  This module is given full information as to which processors  * are currently using which maps, and to when physical maps must be made  * correct.  */
end_comment

begin_include
include|#
directive|include
file|"opt_msgbuf.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_zone.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pv.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/tsb.h>
end_include

begin_define
define|#
directive|define
name|PMAP_DEBUG
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PMAP_SHPGPERPROC
end_ifndef

begin_define
define|#
directive|define
name|PMAP_SHPGPERPROC
value|200
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|mem_region
block|{
name|vm_offset_t
name|mr_start
decl_stmt|;
name|vm_offset_t
name|mr_size
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ofw_map
block|{
name|vm_offset_t
name|om_start
decl_stmt|;
name|vm_offset_t
name|om_size
decl_stmt|;
name|u_long
name|om_tte
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Virtual and physical address of message buffer.  */
end_comment

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|msgbuf_phys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Physical addresses of first and last available physical page.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|avail_start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|avail_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|pmap_pagedaemon_waken
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map of physical memory reagions.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|phys_avail
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|mem_region
name|mra
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_map
name|translations
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|translations_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * First and last available kernel virtual addresses.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The locked kernel page the kernel binary was loaded into. This will need  * to become a list later.  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|kernel_page
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel pmap.  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean_t
name|pmap_initialized
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Convert a tte data field into a page mask */
end_comment

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_page_masks
index|[]
init|=
block|{
name|PAGE_MASK_8K
block|,
name|PAGE_MASK_64K
block|,
name|PAGE_MASK_512K
block|,
name|PAGE_MASK_4M
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PMAP_TD_GET_MASK
parameter_list|(
name|d
parameter_list|)
value|pmap_page_masks[TD_GET_SIZE((d))]
end_define

begin_comment
comment|/*  * Allocate physical memory for use in pmap_bootstrap.  */
end_comment

begin_function_decl
specifier|static
name|vm_offset_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * If user pmap is processed with pmap_remove and with pmap_remove and the  * resident count drops to 0, there are no more pages to remove, so we  * need not continue.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_DONE
parameter_list|(
name|pm
parameter_list|)
define|\
value|((pm) != kernel_pmap&& (pm)->pm_stats.resident_count == 0)
end_define

begin_comment
comment|/*  * The threshold (in bytes) above which tsb_foreach() is used in pmap_remove()  * and pmap_protect() instead of trying each virtual address.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_TSB_THRESH
value|((TSB_SIZE / 2) * PAGE_SIZE)
end_define

begin_comment
comment|/* Callbacks for tsb_foreach. */
end_comment

begin_decl_stmt
specifier|static
name|tsb_callback_t
name|pmap_remove_tte
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|tsb_callback_t
name|pmap_protect_tte
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|pmap_enter_nupdate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pmap_enter_nreplace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pmap_enter_nnew
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pmap_ncache_enter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pmap_ncache_enter_nc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|pmap_niflush
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"Statistics"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_enter_nupdate
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_enter_nupdate
argument_list|,
literal|0
argument_list|,
literal|"Number of pmap_enter() updates"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_enter_nreplace
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_enter_nreplace
argument_list|,
literal|0
argument_list|,
literal|"Number of pmap_enter() replacements"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_enter_nnew
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_enter_nnew
argument_list|,
literal|0
argument_list|,
literal|"Number of pmap_enter() additions"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_ncache_enter
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_ncache_enter
argument_list|,
literal|0
argument_list|,
literal|"Number of pmap_cache_enter() calls"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_ncache_enter_nc
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_ncache_enter_nc
argument_list|,
literal|0
argument_list|,
literal|"Number of pmap_cache_enter() nc"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_niflush
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmap_niflush
argument_list|,
literal|0
argument_list|,
literal|"Number of pmap I$ flushes"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PMAP_STATS_INC
parameter_list|(
name|var
parameter_list|)
value|atomic_add_long(&var, 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_STATS_INC
parameter_list|(
name|var
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Quick sort callout for comparing memory regions.  */
end_comment

begin_function_decl
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|mem_region
modifier|*
name|mra
decl_stmt|;
specifier|const
name|struct
name|mem_region
modifier|*
name|mrb
decl_stmt|;
name|mra
operator|=
name|a
expr_stmt|;
name|mrb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|mra
operator|->
name|mr_start
operator|<
name|mrb
operator|->
name|mr_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|mra
operator|->
name|mr_start
operator|>
name|mrb
operator|->
name|mr_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_map
modifier|*
name|oma
decl_stmt|;
specifier|const
name|struct
name|ofw_map
modifier|*
name|omb
decl_stmt|;
name|oma
operator|=
name|a
expr_stmt|;
name|omb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|oma
operator|->
name|om_start
operator|<
name|omb
operator|->
name|om_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|oma
operator|->
name|om_start
operator|>
name|omb
operator|->
name|om_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|vm_offset_t
name|ekva
parameter_list|)
block|{
name|struct
name|pmap
modifier|*
name|pm
decl_stmt|;
name|struct
name|tte
name|tte
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_size_t
name|physsz
decl_stmt|;
name|ihandle_t
name|pmem
decl_stmt|;
name|ihandle_t
name|vmem
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* 	 * Set the start and end of kva.  The kernel is loaded at the first 	 * available 4 meg super page, so round up to the end of the page. 	 */
name|virtual_avail
operator|=
name|roundup2
argument_list|(
name|ekva
argument_list|,
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
name|virtual_end
operator|=
name|VM_MAX_KERNEL_ADDRESS
expr_stmt|;
comment|/* Look up the page the kernel binary was loaded into. */
name|kernel_page
operator|=
name|TD_GET_PA
argument_list|(
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|TLB_SLOT_KERNEL
argument_list|)
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what physical memory is available from the prom and 	 * initialize the phys_avail array.  This must be done before 	 * pmap_bootstrap_alloc is called. 	 */
if|if
condition|(
operator|(
name|pmem
operator|=
name|OF_finddevice
argument_list|(
literal|"/memory"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: finddevice /memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|pmem
argument_list|,
literal|"available"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getproplen /memory/available"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|phys_avail
argument_list|)
operator|<
name|sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: phys_avail too small"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|mra
argument_list|)
operator|<
name|sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: mra too small"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mra
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmem
argument_list|,
literal|"available"
argument_list|,
name|mra
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getprop /memory/available"
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|mra
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: physical memory"
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|mra
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mra
argument_list|)
argument_list|,
name|mr_cmp
argument_list|)
expr_stmt|;
name|physsz
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"start=%#lx size=%#lx"
argument_list|,
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
name|phys_avail
index|[
name|j
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|physsz
operator|+=
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
block|}
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate the kernel tsb and lock it in the tlb. 	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|KVA_PAGES
operator|*
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|&
name|PAGE_MASK_4M
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: tsb unaligned\n"
argument_list|)
expr_stmt|;
name|tsb_kernel_phys
operator|=
name|pa
expr_stmt|;
name|tsb_kernel
operator|=
operator|(
expr|struct
name|tte
operator|*
operator|)
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|KVA_PAGES
operator|*
name|PAGE_SIZE_4M
expr_stmt|;
name|pmap_map_tsb
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|tsb_kernel
argument_list|,
name|KVA_PAGES
operator|*
name|PAGE_SIZE_4M
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a kernel stack with guard page for thread0 and map it into 	 * the kernel tsb. 	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|kstack0_phys
operator|=
name|pa
expr_stmt|;
name|kstack0
operator|=
name|virtual_avail
operator|+
operator|(
name|KSTACK_GUARD_PAGES
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|virtual_avail
operator|+=
operator|(
name|KSTACK_PAGES
operator|+
name|KSTACK_GUARD_PAGES
operator|)
operator|*
name|PAGE_SIZE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|kstack0_phys
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|va
operator|=
name|kstack0
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
comment|/* tlb_page_demap(TLB_DTLB, kernel_pmap, va); */
block|}
comment|/* 	 * Allocate the message buffer. 	 */
name|msgbuf_phys
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|MSGBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Add the prom mappings to the kernel tsb. 	 */
if|if
condition|(
operator|(
name|vmem
operator|=
name|OF_finddevice
argument_list|(
literal|"/virtual-memory"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: finddevice /virtual-memory"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|vmem
argument_list|,
literal|"translations"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getproplen translations"
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|translations
argument_list|)
operator|<
name|sz
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: translations too small"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|vmem
argument_list|,
literal|"translations"
argument_list|,
name|translations
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"pmap_bootstrap: getprop /virtual-memory/translations"
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
expr_stmt|;
name|translations_size
operator|=
name|sz
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_bootstrap: translations"
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
argument_list|,
name|om_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"translation: start=%#lx size=%#lx tte=%#lx pa=%#lx"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|,
name|TD_GET_PA
argument_list|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|<
literal|0xf0000000
condition|)
comment|/* XXX!!! */
continue|continue;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_size
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
block|{
name|va
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|+
name|off
expr_stmt|;
name|tte
operator|.
name|tte_data
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
operator|+
name|off
expr_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"mapping: va=%#lx tp=%p tte=%#lx pa=%#lx"
argument_list|,
name|va
argument_list|,
name|tp
argument_list|,
name|tte
operator|.
name|tte_data
argument_list|,
name|TD_GET_PA
argument_list|(
name|tte
operator|.
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|tte
expr_stmt|;
block|}
block|}
comment|/* 	 * Calculate the first and last available physical addresses. 	 */
name|avail_start
operator|=
name|phys_avail
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
name|avail_end
operator|=
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
name|Maxmem
operator|=
name|sparc64_btop
argument_list|(
name|avail_end
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate virtual address space for the message buffer. 	 */
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|round_page
argument_list|(
name|MSGBUF_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
name|pm
operator|=
name|kernel_pmap
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|pm
operator|->
name|pm_context
index|[
name|i
index|]
operator|=
name|TLB_CTX_KERNEL
expr_stmt|;
name|pm
operator|->
name|pm_active
operator|=
operator|~
literal|0
expr_stmt|;
name|pm
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_map_tsb
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|tte
name|tte
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Map the 4mb tsb pages. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KVA_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|tsb_kernel
operator|+
name|i
operator|*
name|PAGE_SIZE_4M
expr_stmt|;
name|pa
operator|=
name|tsb_kernel_phys
operator|+
name|i
operator|*
name|PAGE_SIZE_4M
expr_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator|=
name|TD_V
operator||
name|TD_4M
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|tlb_store_slot
argument_list|(
name|TLB_DTLB
argument_list|,
name|va
argument_list|,
name|TLB_CTX_KERNEL
argument_list|,
name|tte
argument_list|,
name|TLB_SLOT_TSB_KERNEL_MIN
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Load the tsb registers. 	 */
name|stxa
argument_list|(
name|AA_DMMU_TSB
argument_list|,
name|ASI_DMMU
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|tsb_kernel
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|AA_IMMU_TSB
argument_list|,
name|ASI_IMMU
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|tsb_kernel
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|flush
argument_list|(
name|tsb_kernel
argument_list|)
expr_stmt|;
comment|/* 	 * Set the secondary context to be the kernel context (needed for 	 * fp block operations in the kernel and the cache code). 	 */
name|stxa
argument_list|(
name|AA_DMMU_SCXR
argument_list|,
name|ASI_DMMU
argument_list|,
name|TLB_CTX_KERNEL
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a physical page of memory directly from the phys_avail map.  * Can only be called from pmap_bootstrap before avail start and end are  * calculated.  */
end_comment

begin_function
specifier|static
name|vm_offset_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|round_page
argument_list|(
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
operator|<
name|size
condition|)
continue|continue;
name|pa
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
index|]
operator|+=
name|size
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
name|panic
argument_list|(
literal|"pmap_bootstrap_alloc"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_context_rollover
parameter_list|(
name|void
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_context_rollover"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_V
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|data
operator|&
name|TD_P
operator|)
operator|==
literal|0
condition|)
block|{
name|stxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|ldxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_V
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|data
operator|&
name|TD_P
operator|)
operator|==
literal|0
condition|)
block|{
name|stxa
argument_list|(
name|TLB_DAR_SLOT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ASI_ITLB_DATA_ACCESS_REG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
block|}
block|}
name|PCPU_SET
argument_list|(
name|tlb_ctx
argument_list|,
name|PCPU_GET
argument_list|(
name|tlb_ctx_min
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int
name|pmap_context_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|context
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|sched_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|context
operator|=
name|PCPU_GET
argument_list|(
name|tlb_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|+
literal|1
operator|==
name|PCPU_GET
argument_list|(
name|tlb_ctx_max
argument_list|)
condition|)
name|pmap_context_rollover
argument_list|()
expr_stmt|;
else|else
name|PCPU_SET
argument_list|(
name|tlb_ctx
argument_list|,
name|context
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|context
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap module.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|vm_offset_t
name|phys_start
parameter_list|,
name|vm_offset_t
name|phys_end
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vm_page_array_size
condition|;
name|i
operator|++
control|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
operator|&
name|vm_page_array
index|[
name|i
index|]
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|translations_size
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
expr_stmt|;
name|size
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_size
expr_stmt|;
if|if
condition|(
name|addr
operator|<
literal|0xf0000000
condition|)
comment|/* XXX */
continue|continue;
name|result
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
name|size
argument_list|,
name|TRUE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
operator|||
name|addr
operator|!=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
condition|)
name|panic
argument_list|(
literal|"pmap_init: vm_map_find"
argument_list|)
expr_stmt|;
block|}
name|pvzone
operator|=
operator|&
name|pvzone_store
expr_stmt|;
name|pvinit
operator|=
operator|(
expr|struct
name|pv_entry
operator|*
operator|)
name|kmem_alloc
argument_list|(
name|kernel_map
argument_list|,
name|vm_page_array_size
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|)
expr_stmt|;
name|zbootinit
argument_list|(
name|pvzone
argument_list|,
literal|"PV ENTRY"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pv_entry
argument_list|)
argument_list|,
name|pvinit
argument_list|,
name|vm_page_array_size
argument_list|)
expr_stmt|;
name|pmap_initialized
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the address space (zone) for the pv_entries.  Set a  * high water mark so that the system can recover from excessive  * numbers of pv entries.  */
end_comment

begin_function
name|void
name|pmap_init2
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|shpgperproc
decl_stmt|;
name|shpgperproc
operator|=
name|PMAP_SHPGPERPROC
expr_stmt|;
name|TUNABLE_INT_FETCH
argument_list|(
literal|"vm.pmap.shpgperproc"
argument_list|,
operator|&
name|shpgperproc
argument_list|)
expr_stmt|;
name|pv_entry_max
operator|=
name|shpgperproc
operator|*
name|maxproc
operator|+
name|vm_page_array_size
expr_stmt|;
name|pv_entry_high_water
operator|=
literal|9
operator|*
operator|(
name|pv_entry_max
operator|/
literal|10
operator|)
expr_stmt|;
name|zinitna
argument_list|(
name|pvzone
argument_list|,
operator|&
name|pvzone_obj
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|pv_entry_max
argument_list|,
name|ZONE_INTERRUPT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given  * map/virtual_address pair.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|u_long
name|d
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
return|return
operator|(
name|pmap_kextract
argument_list|(
name|va
argument_list|)
operator|)
return|;
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
block|{
name|d
operator|=
name|tp
operator|->
name|tte_data
expr_stmt|;
return|return
operator|(
name|TD_GET_PA
argument_list|(
name|d
argument_list|)
operator||
operator|(
name|va
operator|&
name|PMAP_TD_GET_MASK
argument_list|(
name|d
argument_list|)
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given kernel virtual  * address.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|u_long
name|d
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|KERNBASE
operator|&&
name|va
operator|<
name|KERNBASE
operator|+
name|PAGE_SIZE_4M
condition|)
return|return
operator|(
name|kernel_page
operator|+
operator|(
name|va
operator|&
name|PAGE_MASK_4M
operator|)
operator|)
return|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|d
operator|=
name|tp
operator|->
name|tte_data
expr_stmt|;
if|if
condition|(
operator|(
name|d
operator|&
name|TD_V
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|TD_GET_PA
argument_list|(
name|d
argument_list|)
operator||
operator|(
name|va
operator|&
name|PMAP_TD_GET_MASK
argument_list|(
name|d
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_cache_enter
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_cache_enter: m=%p va=%#lx"
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
literal|0
init|;
name|i
operator|<
name|DCACHE_COLORS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
condition|)
name|c
operator|+=
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|i
index|]
expr_stmt|;
block|}
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_cache_enter: cacheable"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_nc
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|1
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_cache_enter: already uncacheable"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_cache_enter: marking uncacheable"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_cache_enter: non-managed page"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|pv
argument_list|,
argument|&m->md.pv_list
argument_list|,
argument|pv_list
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_CV
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|TLB_DTLB
operator||
name|TLB_ITLB
argument_list|,
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
block|}
block|}
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|dcache_inval_phys
argument_list|(
name|pa
argument_list|,
name|pa
operator|+
name|PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_cache_remove
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_cache_remove: m=%p va=%#lx c=%d"
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"pmap_cache_remove: no mappings %d<= 0"
operator|,
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  */
end_comment

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|struct
name|tte
name|tte
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_REF
operator||
name|TD_SW
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kenter: va=%#lx pa=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_V
operator|)
operator|!=
literal|0
condition|)
name|tlb_page_demap
argument_list|(
name|TLB_DTLB
argument_list|,
name|TLB_CTX_KERNEL
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|tte
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space. This additionally  * takes a flag argument wich is or'ed to the TTE data. This is used by  * bus_space_map().  * NOTE: if the mapping is non-cacheable, it's the caller's responsibility  * to flush entries that might still be in the cache, if applicable.  */
end_comment

begin_function
name|void
name|pmap_kenter_flags
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_offset_t
name|pa
parameter_list|,
name|u_long
name|flags
parameter_list|)
block|{
name|struct
name|tte
name|tte
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_REF
operator||
name|TD_P
operator||
name|flags
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kenter_flags: va=%#lx pa=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_V
operator|)
operator|!=
literal|0
condition|)
name|tlb_page_demap
argument_list|(
name|TLB_DTLB
argument_list|,
name|TLB_CTX_KERNEL
argument_list|,
name|va
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
name|tte
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a temporary mapping for a physical address.  This is only intended  * to be used for panic dumps.  */
end_comment

begin_function
name|void
modifier|*
name|pmap_kenter_temporary
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|TODO
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a wired page from kernel virtual address space.  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kremove: va=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_V
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
literal|0
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|TLB_DTLB
argument_list|,
name|TLB_CTX_KERNEL
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a range of physical addresses into kernel virtual address space.  *  * The value passed in *virt is a suggested virtual address for the mapping.  * Architectures which can support a direct-mapped physical to virtual region  * can return the appropriate address within that region, leaving '*virt'  * unchanged.  We cannot and therefore do not; *virt is updated with the  * first usable address after the mapped region.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_offset_t
name|pa_start
parameter_list|,
name|vm_offset_t
name|pa_end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|sva
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|pa
operator|=
name|pa_start
expr_stmt|;
name|sva
operator|=
operator|*
name|virt
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
init|;
name|pa
operator|<
name|pa_end
condition|;
name|pa
operator|+=
name|PAGE_SIZE
operator|,
name|va
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|sva
operator|+
operator|(
name|pa_end
operator|-
name|pa_start
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
operator|*
name|virt
operator|=
name|va
expr_stmt|;
return|return
operator|(
name|sva
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a list of wired pages into kernel virtual address space.  This is  * intended for temporary mappings which do not need page modification or  * references recorded.  Existing mappings in the region are overwritten.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|va
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kenter
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|sva
operator|+
operator|(
name|count
operator|*
name|PAGE_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * As above, but take an additional flags argument and call  * pmap_kenter_flags().  */
end_comment

begin_function
name|void
name|pmap_qenter_flags
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|,
name|u_long
name|fl
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|va
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kenter_flags
argument_list|(
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
index|[
name|i
index|]
argument_list|)
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|sva
operator|+
operator|(
name|count
operator|*
name|PAGE_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove page mappings from kernel virtual address space.  Intended for  * temporary mappings entered by pmap_qenter.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|int
name|i
decl_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
operator|,
name|va
operator|+=
name|PAGE_SIZE
control|)
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|sva
operator|+
operator|(
name|count
operator|*
name|PAGE_SIZE
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create the uarea for a new process.  * This routine directly affects the fork perf for a process.  */
end_comment

begin_function
name|void
name|pmap_new_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|UAREA_PAGES
index|]
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_offset_t
name|up
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * Allocate object for the upages. 	 */
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
if|if
condition|(
name|upobj
operator|==
name|NULL
condition|)
block|{
name|upobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|UAREA_PAGES
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_upages_obj
operator|=
name|upobj
expr_stmt|;
block|}
comment|/* 	 * Get a kernel virtual address for the U area for this process. 	 */
name|up
operator|=
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_uarea
expr_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
block|{
name|up
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
name|UAREA_PAGES
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|up
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_new_proc: upage allocation failed"
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_uarea
operator|=
operator|(
expr|struct
name|user
operator|*
operator|)
name|up
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAREA_PAGES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Get a uarea page. 		 */
name|m
operator|=
name|vm_page_grab
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
name|ma
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
comment|/* 		 * Wire the page. 		 */
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
comment|/* 	 * Enter the pages into the kernel address space. 	 */
name|pmap_qenter
argument_list|(
name|up
argument_list|,
name|ma
argument_list|,
name|UAREA_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispose the uarea for a process that has exited.  * This routine directly impacts the exit perf of a process.  */
end_comment

begin_function
name|void
name|pmap_dispose_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_offset_t
name|up
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
name|up
operator|=
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_uarea
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAREA_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_dispose_proc: upage already missing?"
argument_list|)
expr_stmt|;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
name|up
argument_list|,
name|UAREA_PAGES
argument_list|)
expr_stmt|;
comment|/* 	 * If the process got swapped out some of its UPAGES might have gotten 	 * swapped.  Just get rid of the object to clean up the swap use 	 * proactively.  NOTE! might block waiting for paging I/O to complete. 	 */
if|if
condition|(
name|upobj
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
name|p
operator|->
name|p_upages_obj
operator|=
name|NULL
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|upobj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allow the uarea for a process to be prejudicially paged out.  */
end_comment

begin_function
name|void
name|pmap_swapout_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_offset_t
name|up
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
name|up
operator|=
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_uarea
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAREA_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_swapout_proc: upage already missing?"
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
name|up
argument_list|,
name|UAREA_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bring the uarea for a specified process back in.  */
end_comment

begin_function
name|void
name|pmap_swapin_proc
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|UAREA_PAGES
index|]
decl_stmt|;
name|vm_object_t
name|upobj
decl_stmt|;
name|vm_offset_t
name|up
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|upobj
operator|=
name|p
operator|->
name|p_upages_obj
expr_stmt|;
name|up
operator|=
operator|(
name|vm_offset_t
operator|)
name|p
operator|->
name|p_uarea
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UAREA_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_grab
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|upobj
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
name|panic
argument_list|(
literal|"pmap_swapin_proc: cannot get upage"
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|upobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|ma
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
name|pmap_qenter
argument_list|(
name|up
argument_list|,
name|ma
argument_list|,
name|UAREA_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create the kernel stack and pcb for a new thread.  * This routine directly affects the fork perf for a process and  * create performance for a thread.  */
end_comment

begin_function
name|void
name|pmap_new_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|KSTACK_PAGES
index|]
decl_stmt|;
name|vm_object_t
name|ksobj
decl_stmt|;
name|vm_offset_t
name|ks
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|u_int
name|i
decl_stmt|;
comment|/* 	 * Allocate object for the kstack, 	 */
name|ksobj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
if|if
condition|(
name|ksobj
operator|==
name|NULL
condition|)
block|{
name|ksobj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|KSTACK_PAGES
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_kstack_obj
operator|=
name|ksobj
expr_stmt|;
block|}
comment|/* 	 * Get a kernel virtual address for the kstack for this thread. 	 */
name|ks
operator|=
name|td
operator|->
name|td_kstack
expr_stmt|;
if|if
condition|(
name|ks
operator|==
literal|0
condition|)
block|{
name|ks
operator|=
name|kmem_alloc_nofault
argument_list|(
name|kernel_map
argument_list|,
operator|(
name|KSTACK_PAGES
operator|+
name|KSTACK_GUARD_PAGES
operator|)
operator|*
name|PAGE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ks
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_new_thread: kstack allocation failed"
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|TLB_DTLB
argument_list|,
name|kernel_pmap
argument_list|,
name|ks
argument_list|)
expr_stmt|;
name|ks
operator|+=
name|KSTACK_GUARD_PAGES
operator|*
name|PAGE_SIZE
expr_stmt|;
name|td
operator|->
name|td_kstack
operator|=
name|ks
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * Get a kernel stack page. 		 */
name|m
operator|=
name|vm_page_grab
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
name|ma
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
comment|/* 		 * Wire the page. 		 */
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_ZERO
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
comment|/* 	 * Enter the page into the kernel address space. 	 */
name|pmap_qenter
argument_list|(
name|ks
argument_list|,
name|ma
argument_list|,
name|KSTACK_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispose the kernel stack for a thread that has exited.  * This routine directly impacts the exit perf of a process and thread.  */
end_comment

begin_function
name|void
name|pmap_dispose_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vm_object_t
name|ksobj
decl_stmt|;
name|vm_offset_t
name|ks
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ksobj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
name|ks
operator|=
name|td
operator|->
name|td_kstack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_dispose_proc: kstack already missing?"
argument_list|)
expr_stmt|;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vm_page_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
name|ks
argument_list|,
name|KSTACK_PAGES
argument_list|)
expr_stmt|;
comment|/* 	 * If the thread got swapped out some of its KSTACK might have gotten 	 * swapped.  Just get rid of the object to clean up the swap use 	 * proactively.  NOTE! might block waiting for paging I/O to complete. 	 */
if|if
condition|(
name|ksobj
operator|->
name|type
operator|==
name|OBJT_SWAP
condition|)
block|{
name|td
operator|->
name|td_kstack_obj
operator|=
name|NULL
expr_stmt|;
name|vm_object_deallocate
argument_list|(
name|ksobj
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allow the kernel stack for a thread to be prejudicially paged out.  */
end_comment

begin_function
name|void
name|pmap_swapout_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vm_object_t
name|ksobj
decl_stmt|;
name|vm_offset_t
name|ks
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ksobj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
name|ks
operator|=
operator|(
name|vm_offset_t
operator|)
name|td
operator|->
name|td_kstack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"pmap_swapout_thread: kstack already missing?"
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_unwire
argument_list|(
name|m
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
name|ks
argument_list|,
name|KSTACK_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bring the kernel stack for a specified thread back in.  */
end_comment

begin_function
name|void
name|pmap_swapin_thread
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|KSTACK_PAGES
index|]
decl_stmt|;
name|vm_object_t
name|ksobj
decl_stmt|;
name|vm_offset_t
name|ks
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ksobj
operator|=
name|td
operator|->
name|td_kstack_obj
expr_stmt|;
name|ks
operator|=
name|td
operator|->
name|td_kstack
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_grab
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|valid
operator|!=
name|VM_PAGE_BITS_ALL
condition|)
block|{
name|rv
operator|=
name|vm_pager_get_pages
argument_list|(
name|ksobj
argument_list|,
operator|&
name|m
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
name|VM_PAGER_OK
condition|)
name|panic
argument_list|(
literal|"pmap_swapin_proc: cannot get kstack"
argument_list|)
expr_stmt|;
name|m
operator|=
name|vm_page_lookup
argument_list|(
name|ksobj
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
block|}
name|ma
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
name|vm_page_wire
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_wakeup
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
block|}
name|pmap_qenter
argument_list|(
name|ks
argument_list|,
name|ma
argument_list|,
name|KSTACK_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap associated with process 0.  */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|pm
operator|->
name|pm_context
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|pm
operator|->
name|pm_tsb
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|pm_tsb_obj
operator|=
name|NULL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pm
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure, uch as one in a  * vmspace structure.  */
end_comment

begin_function
name|void
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|TSB_PAGES
index|]
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Allocate kva space for the tsb. 	 */
if|if
condition|(
name|pm
operator|->
name|pm_tsb
operator|==
name|NULL
condition|)
block|{
name|pm
operator|->
name|pm_tsb
operator|=
operator|(
expr|struct
name|tte
operator|*
operator|)
name|kmem_alloc_pageable
argument_list|(
name|kernel_map
argument_list|,
name|TSB_BSIZE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate an object for it. 	 */
if|if
condition|(
name|pm
operator|->
name|pm_tsb_obj
operator|==
name|NULL
condition|)
name|pm
operator|->
name|pm_tsb_obj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_DEFAULT
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSB_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|vm_page_grab
argument_list|(
name|pm
operator|->
name|pm_tsb_obj
argument_list|,
name|i
argument_list|,
name|VM_ALLOC_RETRY
operator||
name|VM_ALLOC_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_ZERO
operator|)
operator|==
literal|0
condition|)
name|pmap_zero_page
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|++
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|++
expr_stmt|;
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_BUSY
argument_list|)
expr_stmt|;
name|m
operator|->
name|valid
operator|=
name|VM_PAGE_BITS_ALL
expr_stmt|;
name|ma
index|[
name|i
index|]
operator|=
name|m
expr_stmt|;
block|}
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pm
operator|->
name|pm_tsb
argument_list|,
name|ma
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|pm
operator|->
name|pm_context
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|pm
operator|->
name|pm_active
operator|=
literal|0
expr_stmt|;
name|pm
operator|->
name|pm_count
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pm
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_pinit2
parameter_list|(
name|pmap_t
name|pmap
parameter_list|)
block|{
comment|/* XXX: Remove this stub when no longer called */
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_release: ctx=%#x tsb=%p"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
argument_list|,
name|pm
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|obj
operator|=
name|pm
operator|->
name|pm_tsb_obj
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|ref_count
operator|==
literal|1
argument_list|,
operator|(
literal|"pmap_release: tsbobj ref count != 1"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|)
argument_list|,
operator|(
literal|"pmap_release: leaking pv entries"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap_resident_count
argument_list|(
name|pm
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: resident pages %ld != 0"
operator|,
name|pmap_resident_count
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|m
argument_list|,
argument|&obj->memq
argument_list|,
argument|listq
argument_list|)
block|{
if|if
condition|(
name|vm_page_sleep_busy
argument_list|(
name|m
argument_list|,
name|FALSE
argument_list|,
literal|"pmaprl"
argument_list|)
condition|)
continue|continue;
name|vm_page_busy
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|hold_count
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: freeing held tsb page"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|cnt
operator|.
name|v_wire_count
operator|--
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pm
operator|->
name|pm_tsb
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the number of kernel page table entries.  Unneeded.  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Retire the given physical map from service.  Pmaps are always allocated  * as part of a larger structure, so this never happens.  */
end_comment

begin_function
name|void
name|pmap_destroy
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|panic
argument_list|(
literal|"pmap_destroy: unimplemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a reference to the specified pmap.  */
end_comment

begin_function
name|void
name|pmap_reference
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
if|if
condition|(
name|pm
operator|!=
name|NULL
condition|)
name|pm
operator|->
name|pm_count
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This routine is very drastic, but can save the system  * in a pinch.  */
end_comment

begin_function
name|void
name|pmap_collect
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|warningdone
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|pmap_pagedaemon_waken
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|warningdone
operator|++
operator|<
literal|5
condition|)
name|printf
argument_list|(
literal|"pmap_collect: collecting pv entries -- suggest"
literal|"increasing PMAP_SHPGPERPROC\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vm_page_array_size
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
operator|&
name|vm_page_array
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|wire_count
operator|||
name|m
operator|->
name|hold_count
operator|||
name|m
operator|->
name|busy
operator|||
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_BUSY
operator||
name|PG_UNMANAGED
operator|)
operator|)
condition|)
continue|continue;
name|pv_remove_all
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|pmap_pagedaemon_waken
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_remove_tte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|struct
name|pmap
modifier|*
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TD_GET_PA
argument_list|(
name|tp
operator|->
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
operator|&&
name|pmap_track_modified
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|pv_remove
argument_list|(
name|pm
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pmap_cache_remove
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_V
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PMAP_REMOVE_DONE
argument_list|(
name|pm
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the given range of addresses from the specified map.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_remove: ctx=%#lx start=%#lx end=%#lx"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMAP_REMOVE_DONE
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
if|if
condition|(
name|end
operator|-
name|start
operator|>
name|PMAP_TSB_THRESH
condition|)
block|{
name|tsb_foreach
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|pmap_remove_tte
argument_list|)
expr_stmt|;
name|tlb_context_demap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|start
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|pmap_remove_tte
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
condition|)
break|break;
block|}
block|}
name|tlb_range_demap
argument_list|(
name|pm
argument_list|,
name|start
argument_list|,
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_protect_tte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|struct
name|pmap
modifier|*
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|data
operator|=
name|tp
operator|->
name|tte_data
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TD_GET_PA
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
block|{
name|vm_page_flag_set
argument_list|(
name|m
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
name|data
operator|&=
operator|~
name|TD_REF
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
operator|&&
name|pmap_track_modified
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|data
operator|&=
operator|~
operator|(
name|TD_W
operator||
name|TD_SW
operator|)
expr_stmt|;
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_protect: new=%#lx old=%#lx"
argument_list|,
name|data
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the physical protection on the specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_protect: ctx=%#lx sva=%#lx eva=%#lx prot=%#lx"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_protect: non current pmap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
if|if
condition|(
name|eva
operator|-
name|sva
operator|>
name|PMAP_TSB_THRESH
condition|)
block|{
name|tsb_foreach
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pmap_protect_tte
argument_list|)
expr_stmt|;
name|tlb_context_demap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pmap_protect_tte
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|tlb_range_demap
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  */
end_comment

begin_function
name|void
name|pmap_enter
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|tte
name|otte
decl_stmt|;
name|struct
name|tte
name|tte
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|pa
decl_stmt|;
name|vm_page_t
name|om
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|CTR6
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter: ctx=%p m=%p va=%#lx pa=%#lx prot=%#x wired=%d"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_CP
expr_stmt|;
comment|/* 	 * If there is an existing mapping, and the physical address has not 	 * changed, must be protection or wiring change. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|otte
operator|=
operator|*
name|tp
expr_stmt|;
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TD_GET_PA
argument_list|(
name|otte
operator|.
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TD_GET_PA
argument_list|(
name|otte
operator|.
name|tte_data
argument_list|)
operator|==
name|pa
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter: update"
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_enter_nupdate
argument_list|)
expr_stmt|;
comment|/* 			 * Wiring change, just update stats. 			 */
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|==
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_CV
operator|)
operator|!=
literal|0
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_CV
expr_stmt|;
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_REF
expr_stmt|;
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_enter: unmanaged pv page"
operator|)
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator||=
name|TD_PV
expr_stmt|;
block|}
comment|/* 			 * If we're turning off write protection, sense modify 			 * status and remove the old mapping. 			 */
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|&&
operator|(
name|otte
operator|.
name|tte_data
operator|&
operator|(
name|TD_W
operator||
name|TD_SW
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pmap_track_modified
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|tlb_tte_demap
argument_list|(
name|otte
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter: replace"
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_enter_nreplace
argument_list|)
expr_stmt|;
comment|/* 			 * Mapping has changed, invalidate old range. 			 */
if|if
condition|(
operator|!
name|wired
operator|&&
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
comment|/* 			 * Enter on the pv list if part of our managed memory. 			 */
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_enter: unmanaged pv page"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_flag_set
argument_list|(
name|om
argument_list|,
name|PG_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|otte
operator|.
name|tte_data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
operator|&&
name|pmap_track_modified
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
condition|)
name|vm_page_dirty
argument_list|(
name|om
argument_list|)
expr_stmt|;
name|pv_remove
argument_list|(
name|pm
argument_list|,
name|om
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|pv_insert
argument_list|(
name|pm
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator||=
name|TD_PV
expr_stmt|;
name|pmap_cache_remove
argument_list|(
name|om
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmap_cache_enter
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
operator|!=
literal|0
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_CV
expr_stmt|;
block|}
name|tlb_tte_demap
argument_list|(
name|otte
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter: new"
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_enter_nnew
argument_list|)
expr_stmt|;
comment|/* 		 * Enter on the pv list if part of our managed memory. 		 */
if|if
condition|(
name|pmap_initialized
operator|&&
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|pv_insert
argument_list|(
name|pm
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator||=
name|TD_PV
expr_stmt|;
if|if
condition|(
name|pmap_cache_enter
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
operator|!=
literal|0
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_CV
expr_stmt|;
block|}
comment|/* 		 * Increment counters. 		 */
if|if
condition|(
name|wired
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
block|}
comment|/* 	 * Now validate mapping with desired protection/wiring. 	 */
if|if
condition|(
name|wired
condition|)
block|{
name|tte
operator|.
name|tte_data
operator||=
name|TD_REF
operator||
name|TD_WIRED
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_W
expr_stmt|;
block|}
if|if
condition|(
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|==
name|TLB_CTX_KERNEL
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_P
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_SW
expr_stmt|;
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
block|{
name|tte
operator|.
name|tte_data
operator||=
name|TD_EXEC
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_niflush
argument_list|)
expr_stmt|;
name|icache_inval_phys
argument_list|(
name|pa
argument_list|,
name|pa
operator|+
name|PAGE_SIZE
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
operator|*
name|tp
operator|=
name|tte
expr_stmt|;
else|else
name|tsb_tte_enter
argument_list|(
name|pm
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_object_init_pt: non current pmap"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
end_function

begin_function
name|void
name|pmap_prefault
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_map_entry_t
name|entry
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_prefault: non current pmap"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
end_function

begin_comment
comment|/*  * Change the wiring attribute for a map/virtual-address pair.  * The mapping must already exist in the pmap.  */
end_comment

begin_function
name|void
name|pmap_change_wiring
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|boolean_t
name|wired
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|==
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|tp
operator|->
name|tte_data
operator||=
name|TD_WIRED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|&=
operator|~
name|TD_WIRED
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_copy_tte
parameter_list|(
name|pmap_t
name|src_pmap
parameter_list|,
name|pmap_t
name|dst_pmap
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
name|tte
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
if|if
condition|(
name|tsb_tte_lookup
argument_list|(
name|dst_pmap
argument_list|,
name|va
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|tte
operator|.
name|tte_data
operator|=
name|tp
operator|->
name|tte_data
operator|&
operator|~
operator|(
name|TD_PV
operator||
name|TD_REF
operator||
name|TD_SW
operator||
name|TD_CV
operator||
name|TD_W
operator|)
expr_stmt|;
name|tte
operator|.
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TD_GET_PA
argument_list|(
name|tp
operator|->
name|tte_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
operator|(
name|PG_FICTITIOUS
operator||
name|PG_UNMANAGED
operator|)
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_enter: unmanaged pv page"
operator|)
argument_list|)
expr_stmt|;
name|pv_insert
argument_list|(
name|dst_pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tte
operator|.
name|tte_data
operator||=
name|TD_PV
expr_stmt|;
if|if
condition|(
name|pmap_cache_enter
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
operator|!=
literal|0
condition|)
name|tte
operator|.
name|tte_data
operator||=
name|TD_CV
expr_stmt|;
block|}
name|tsb_tte_enter
argument_list|(
name|dst_pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|tte
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|dst_addr
operator|!=
name|src_addr
condition|)
return|return;
if|if
condition|(
name|len
operator|>
name|PMAP_TSB_THRESH
condition|)
block|{
name|tsb_foreach
argument_list|(
name|src_pmap
argument_list|,
name|dst_pmap
argument_list|,
name|src_addr
argument_list|,
name|src_addr
operator|+
name|len
argument_list|,
name|pmap_copy_tte
argument_list|)
expr_stmt|;
name|tlb_context_demap
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|src_addr
init|;
name|va
operator|<
name|src_addr
operator|+
name|len
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|src_pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pmap_copy_tte
argument_list|(
name|src_pmap
argument_list|,
name|dst_pmap
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|tlb_range_demap
argument_list|(
name|dst_pmap
argument_list|,
name|src_addr
argument_list|,
name|src_addr
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Zero a page of physical memory by temporarily mapping it into the tlb.  */
end_comment

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|CTR1
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_zero_page: pa=%#lx"
argument_list|,
name|pa
argument_list|)
expr_stmt|;
name|dcache_inval_phys
argument_list|(
name|pa
argument_list|,
name|pa
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|aszero
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|pa
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_zero_page_area: pa=%#lx off=%#x size=%#x"
argument_list|,
name|pa
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|+
name|size
operator|<=
name|PAGE_SIZE
argument_list|,
operator|(
literal|"pmap_zero_page_area: bad off/size"
operator|)
argument_list|)
expr_stmt|;
name|dcache_inval_phys
argument_list|(
name|pa
operator|+
name|off
argument_list|,
name|pa
operator|+
name|off
operator|+
name|size
argument_list|)
expr_stmt|;
name|aszero
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|pa
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy a page of physical memory by temporarily mapping it into the tlb.  */
end_comment

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_offset_t
name|src
parameter_list|,
name|vm_offset_t
name|dst
parameter_list|)
block|{
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_copy_page: src=%#lx dst=%#lx"
argument_list|,
name|src
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|dcache_inval_phys
argument_list|(
name|dst
argument_list|,
name|dst
operator|+
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|ascopy
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|src
argument_list|,
name|dst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make the specified page pageable (or not).  Unneeded.  */
end_comment

begin_function
name|void
name|pmap_pageable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|boolean_t
name|pageable
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
return|return
operator|(
name|pv_page_exists
argument_list|(
name|pm
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space, this aids process exit  * speeds.  This is much faster than pmap_remove n the case of running down  * an entire address space.  Only works for the current pmap.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|pv_entry_t
name|npv
decl_stmt|;
name|pv_entry_t
name|pv
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
operator|&
name|curproc
operator|->
name|p_vmspace
operator|->
name|vm_pmap
operator|||
name|pm
operator|==
name|kernel_pmap
argument_list|,
operator|(
literal|"pmap_remove_pages: non current pmap"
operator|)
argument_list|)
expr_stmt|;
name|npv
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|pv
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|pm
operator|->
name|pm_pvlist
argument_list|)
init|;
name|pv
operator|!=
name|NULL
condition|;
name|pv
operator|=
name|npv
control|)
block|{
name|npv
operator|=
name|TAILQ_NEXT
argument_list|(
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
if|if
condition|(
name|pv
operator|->
name|pv_va
operator|>=
name|eva
operator|||
name|pv
operator|->
name|pv_va
operator|<
name|sva
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pv
operator|->
name|pv_pmap
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * We cannot remove wired pages at this time. 		 */
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
continue|continue;
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_V
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|pv
operator|->
name|pv_m
expr_stmt|;
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pv_list_count
operator|--
expr_stmt|;
name|pmap_cache_remove
argument_list|(
name|m
argument_list|,
name|pv
operator|->
name|pv_va
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pv
operator|->
name|pv_pmap
operator|->
name|pm_pvlist
argument_list|,
name|pv
argument_list|,
name|pv_plist
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|,
name|pv
argument_list|,
name|pv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|pv_list
argument_list|)
condition|)
name|vm_page_flag_clear
argument_list|(
name|m
argument_list|,
name|PG_MAPPED
operator||
name|PG_WRITEABLE
argument_list|)
expr_stmt|;
name|pv_free
argument_list|(
name|pv
argument_list|)
expr_stmt|;
block|}
name|tlb_context_demap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lower the permission for all mappings to a given page.  */
end_comment

begin_function
name|void
name|pmap_page_protect
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
condition|)
name|pv_bit_clear
argument_list|(
name|m
argument_list|,
name|TD_W
operator||
name|TD_SW
argument_list|)
expr_stmt|;
else|else
name|pv_remove_all
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_phys_address
parameter_list|(
name|int
name|ppn
parameter_list|)
block|{
return|return
operator|(
name|sparc64_ptob
argument_list|(
name|ppn
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_ts_referenced:  *  *	Return a count of reference bits for a page, clearing those bits.  *	It is not necessary for every reference bit to be cleared, but it  *	is necessary that 0 only be returned when there are truly no  *	reference bits set.  *  *	XXX: The exact number of bits to check and clear is a matter that  *	should be tested and standardized at some point in the future for  *	optimal aging of shared pages.  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|pv_bit_count
argument_list|(
name|m
argument_list|,
name|TD_REF
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return
name|FALSE
return|;
return|return
operator|(
name|pv_bit_test
argument_list|(
name|m
argument_list|,
name|TD_W
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return;
name|pv_bit_clear
argument_list|(
name|m
argument_list|,
name|TD_W
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_clear_reference
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
if|if
condition|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
condition|)
return|return;
name|pv_bit_clear
argument_list|(
name|m
argument_list|,
name|TD_REF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|TODO
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Activate a user pmap.  The pmap must be activated before its address space  * can be accessed in any way.  */
end_comment

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|vm_offset_t
name|tsb
decl_stmt|;
name|u_long
name|context
decl_stmt|;
name|pmap_t
name|pm
decl_stmt|;
comment|/* 	 * Load all the data we need up front to encourage the compiler to 	 * not issue any loads while we have interrupts disable below. 	 */
name|vm
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|pm
operator|=
operator|&
name|vm
operator|->
name|vm_pmap
expr_stmt|;
name|tsb
operator|=
operator|(
name|vm_offset_t
operator|)
name|pm
operator|->
name|pm_tsb
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_active
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_activate: pmap already active?"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_activate: activating nucleus context?"
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
literal|0
argument_list|,
name|PSTATE_MMU
argument_list|)
expr_stmt|;
name|mov
argument_list|(
name|tsb
argument_list|,
name|TSB_REG
argument_list|)
expr_stmt|;
name|wrpr
argument_list|(
name|pstate
argument_list|,
literal|0
argument_list|,
name|PSTATE_KERNEL
argument_list|)
expr_stmt|;
name|context
operator|=
name|pmap_context_alloc
argument_list|()
expr_stmt|;
name|pm
operator|->
name|pm_context
index|[
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
index|]
operator|=
name|context
expr_stmt|;
name|pm
operator|->
name|pm_active
operator||=
name|PCPU_GET
argument_list|(
name|cpumask
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|vmspace
argument_list|,
name|vm
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_PCXR
argument_list|,
name|ASI_DMMU
argument_list|,
name|context
argument_list|)
expr_stmt|;
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_addr_hint
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|va
operator|)
return|;
block|}
end_function

end_unit

