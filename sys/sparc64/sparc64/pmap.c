begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1991 Regents of the University of California.  * All rights reserved.  * Copyright (c) 1994 John S. Dyson  * All rights reserved.  * Copyright (c) 1994 David Greenman  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * the Systems Programming Group of the University of Utah Computer  * Science Department and William Jolitz of UUNET Technologies Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *      from:   @(#)pmap.c      7.7 (Berkeley)  5/12/91  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Manages physical address maps.  *  * Since the information managed by this module is also stored by the  * logical address mapping module, this module may throw away valid virtual  * to physical mappings at almost any time.  However, invalidations of  * mappings must be done as requested.  *  * In order to cope with hardware architectures which make virtual to  * physical map invalidates expensive, this module may delay invalidate  * reduced protection operations until such time as they are actually  * necessary.  This module is given full information as to which processors  * are currently using which maps, and to when physical maps must be made  * correct.  */
end_comment

begin_include
include|#
directive|include
file|"opt_kstack_pages.h"
end_include

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<dev/ofw/openfirm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_page.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_map.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_object.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_extern.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pageout.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_pager.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_phys.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/instr.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/metadata.h>
end_include

begin_include
include|#
directive|include
file|<machine/ofw_mem.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/tlb.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/tsb.h>
end_include

begin_include
include|#
directive|include
file|<machine/ver.h>
end_include

begin_comment
comment|/*  * Virtual address of message buffer  */
end_comment

begin_decl_stmt
name|struct
name|msgbuf
modifier|*
name|msgbufp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Map of physical memory reagions  */
end_comment

begin_decl_stmt
name|vm_paddr_t
name|phys_avail
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_mem_region
name|mra
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|ofw_mem_region
name|sparc64_memreg
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sparc64_nmemreg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ofw_map
name|translations
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|translations_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_idle_map
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_temp_map_1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|vm_offset_t
name|pmap_temp_map_2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * First and last available kernel virtual addresses  */
end_comment

begin_decl_stmt
name|vm_offset_t
name|virtual_avail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|virtual_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|kernel_vm_end
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vm_offset_t
name|vm_max_kernel_address
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel pmap  */
end_comment

begin_decl_stmt
name|struct
name|pmap
name|kernel_pmap_store
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|rwlock_padalign
name|tte_list_global_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Allocate physical memory for use in pmap_bootstrap.  */
end_comment

begin_function_decl
specifier|static
name|vm_paddr_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|,
name|uint32_t
name|colors
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_bootstrap_set_tte
parameter_list|(
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_cache_remove
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_protect_tte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm1
parameter_list|,
name|struct
name|pmap
modifier|*
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmap_unwire_tte
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|pmap_t
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmap_init_qpages
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  *  * The page queues and pmap must be locked.  */
end_comment

begin_function_decl
specifier|static
name|int
name|pmap_enter_locked
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_direct_patch_tsb_phys_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_direct_patch_tsb_phys_end_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_patch_asi_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_patch_quad_ldd_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_patch_tsb_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_patch_tsb_2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_patch_tsb_mask_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_miss_patch_tsb_mask_2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_prot_patch_asi_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_prot_patch_quad_ldd_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_prot_patch_tsb_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_prot_patch_tsb_2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_prot_patch_tsb_mask_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_dmmu_prot_patch_tsb_mask_2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_immu_miss_patch_asi_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_immu_miss_patch_quad_ldd_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_immu_miss_patch_tsb_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_immu_miss_patch_tsb_2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_immu_miss_patch_tsb_mask_1
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|tl1_immu_miss_patch_tsb_mask_2
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If user pmap is processed with pmap_remove and with pmap_remove and the  * resident count drops to 0, there are no more pages to remove, so we  * need not continue.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_REMOVE_DONE
parameter_list|(
name|pm
parameter_list|)
define|\
value|((pm) != kernel_pmap&& (pm)->pm_stats.resident_count == 0)
end_define

begin_comment
comment|/*  * The threshold (in bytes) above which tsb_foreach() is used in pmap_remove()  * and pmap_protect() instead of trying each virtual address.  */
end_comment

begin_define
define|#
directive|define
name|PMAP_TSB_THRESH
value|((TSB_SIZE / 2) * PAGE_SIZE)
end_define

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|pmap_stats
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nenter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nenter_update
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nenter_replace
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nenter_new
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nkenter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nkenter_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nkenter_stupid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nkremove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nqenter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nqremove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter_c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter_cc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter_coc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter_nc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_enter_cnc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_remove
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_remove_c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_remove_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_remove_cc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_remove_coc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncache_remove_nc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_nc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_area
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_area_c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_area_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nzero_page_area_nc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_nc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_dc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_doc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_sc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_ncopy_page_soc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nnew_thread
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PMAP_STATS_VAR
argument_list|(
name|pmap_nnew_thread_oc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
specifier|inline
name|u_long
name|dtlb_get_data
parameter_list|(
name|u_int
name|tlb
parameter_list|,
name|u_int
name|slot
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Quick sort callout for comparing memory regions  */
end_comment

begin_function_decl
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|mr_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_mem_region
modifier|*
name|mra
decl_stmt|;
specifier|const
name|struct
name|ofw_mem_region
modifier|*
name|mrb
decl_stmt|;
name|mra
operator|=
name|a
expr_stmt|;
name|mrb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|mra
operator|->
name|mr_start
operator|<
name|mrb
operator|->
name|mr_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|mra
operator|->
name|mr_start
operator|>
name|mrb
operator|->
name|mr_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|om_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|ofw_map
modifier|*
name|oma
decl_stmt|;
specifier|const
name|struct
name|ofw_map
modifier|*
name|omb
decl_stmt|;
name|oma
operator|=
name|a
expr_stmt|;
name|omb
operator|=
name|b
expr_stmt|;
if|if
condition|(
name|oma
operator|->
name|om_start
operator|<
name|omb
operator|->
name|om_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|oma
operator|->
name|om_start
operator|>
name|omb
operator|->
name|om_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|u_long
name|dtlb_get_data
parameter_list|(
name|u_int
name|tlb
parameter_list|,
name|u_int
name|slot
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|register_t
name|s
decl_stmt|;
name|slot
operator|=
name|TLB_DAR_SLOT
argument_list|(
name|tlb
argument_list|,
name|slot
argument_list|)
expr_stmt|;
comment|/* 	 * We read ASI_DTLB_DATA_ACCESS_REG twice back-to-back in order to 	 * work around errata of USIII and beyond. 	 */
name|s
operator|=
name|intr_disable
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ldxa
argument_list|(
name|slot
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
name|data
operator|=
name|ldxa
argument_list|(
name|slot
argument_list|,
name|ASI_DTLB_DATA_ACCESS_REG
argument_list|)
expr_stmt|;
name|intr_restore
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Bootstrap the system enough to run with virtual memory.  */
end_comment

begin_function
name|void
name|pmap_bootstrap
parameter_list|(
name|u_int
name|cpu_impl
parameter_list|)
block|{
name|struct
name|pmap
modifier|*
name|pm
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|off
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_size_t
name|physsz
decl_stmt|;
name|vm_size_t
name|virtsz
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|u_long
name|vpn
decl_stmt|;
name|phandle_t
name|pmem
decl_stmt|;
name|phandle_t
name|vmem
decl_stmt|;
name|u_int
name|dtlb_slots_avail
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|sz
decl_stmt|;
name|uint32_t
name|asi
decl_stmt|;
name|uint32_t
name|colors
decl_stmt|;
name|uint32_t
name|ldd
decl_stmt|;
comment|/* 	 * Set the kernel context. 	 */
name|pmap_set_kctx
argument_list|()
expr_stmt|;
name|colors
operator|=
name|dcache_color_ignore
operator|!=
literal|0
condition|?
literal|1
else|:
name|DCACHE_COLORS
expr_stmt|;
comment|/* 	 * Find out what physical memory is available from the PROM and 	 * initialize the phys_avail array.  This must be done before 	 * pmap_bootstrap_alloc is called. 	 */
if|if
condition|(
operator|(
name|pmem
operator|=
name|OF_finddevice
argument_list|(
literal|"/memory"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: finddevice /memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|pmem
argument_list|,
literal|"available"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: getproplen /memory/available"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|phys_avail
argument_list|)
operator|<
name|sz
condition|)
name|OF_panic
argument_list|(
literal|"%s: phys_avail too small"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|mra
argument_list|)
operator|<
name|sz
condition|)
name|OF_panic
argument_list|(
literal|"%s: mra too small"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|mra
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmem
argument_list|,
literal|"available"
argument_list|,
name|mra
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: getprop /memory/available"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|mra
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|OF_printf
argument_list|(
literal|"pmap_bootstrap: physical memory\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qsort
argument_list|(
name|mra
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mra
argument_list|)
argument_list|,
name|mr_cmp
argument_list|)
expr_stmt|;
name|physsz
operator|=
literal|0
expr_stmt|;
name|getenv_quad
argument_list|(
literal|"hw.physmem"
argument_list|,
operator|&
name|physmem
argument_list|)
expr_stmt|;
name|physmem
operator|=
name|btoc
argument_list|(
name|physmem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
operator|,
name|j
operator|+=
literal|2
control|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|OF_printf
argument_list|(
literal|"start=%#lx size=%#lx\n"
argument_list|,
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
argument_list|,
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|physmem
operator|!=
literal|0
operator|&&
name|btoc
argument_list|(
name|physsz
operator|+
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
argument_list|)
operator|>=
name|physmem
condition|)
block|{
if|if
condition|(
name|btoc
argument_list|(
name|physsz
argument_list|)
operator|<
name|physmem
condition|)
block|{
name|phys_avail
index|[
name|j
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
operator|(
name|ctob
argument_list|(
name|physmem
argument_list|)
operator|-
name|physsz
operator|)
expr_stmt|;
name|physsz
operator|=
name|ctob
argument_list|(
name|physmem
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|phys_avail
index|[
name|j
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
expr_stmt|;
name|phys_avail
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|mra
index|[
name|i
index|]
operator|.
name|mr_start
operator|+
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
name|physsz
operator|+=
name|mra
index|[
name|i
index|]
operator|.
name|mr_size
expr_stmt|;
block|}
name|physmem
operator|=
name|btoc
argument_list|(
name|physsz
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate the size of kernel virtual memory, and the size and mask 	 * for the kernel TSB based on the phsyical memory size but limited 	 * by the amount of dTLB slots available for locked entries if we have 	 * to lock the TSB in the TLB (given that for spitfire-class CPUs all 	 * of the dt64 slots can hold locked entries but there is no large 	 * dTLB for unlocked ones, we don't use more than half of it for the 	 * TSB). 	 * Note that for reasons unknown OpenSolaris doesn't take advantage of 	 * ASI_ATOMIC_QUAD_LDD_PHYS on UltraSPARC-III.  However, given that no 	 * public documentation is available for these, the latter just might 	 * not support it, yet. 	 */
if|if
condition|(
name|cpu_impl
operator|==
name|CPU_IMPL_SPARC64V
operator|||
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCIIIp
condition|)
block|{
name|tsb_kernel_ldd_phys
operator|=
literal|1
expr_stmt|;
name|virtsz
operator|=
name|roundup
argument_list|(
literal|5
operator|/
literal|3
operator|*
name|physsz
argument_list|,
name|PAGE_SIZE_4M
operator|<<
operator|(
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dtlb_slots_avail
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtlb_slots
condition|;
name|i
operator|++
control|)
block|{
name|data
operator|=
name|dtlb_get_data
argument_list|(
name|cpu_impl
operator|==
name|CPU_IMPL_ULTRASPARCIII
condition|?
name|TLB_DAR_T16
else|:
name|TLB_DAR_T32
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|TD_V
operator||
name|TD_L
operator|)
operator|)
operator|!=
operator|(
name|TD_V
operator||
name|TD_L
operator|)
condition|)
name|dtlb_slots_avail
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SMP
name|dtlb_slots_avail
operator|-=
name|PCPU_PAGES
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCI
operator|&&
name|cpu_impl
operator|<
name|CPU_IMPL_ULTRASPARCIII
condition|)
name|dtlb_slots_avail
operator|/=
literal|2
expr_stmt|;
name|virtsz
operator|=
name|roundup
argument_list|(
name|physsz
argument_list|,
name|PAGE_SIZE_4M
operator|<<
operator|(
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|virtsz
operator|=
name|MIN
argument_list|(
name|virtsz
argument_list|,
operator|(
name|dtlb_slots_avail
operator|*
name|PAGE_SIZE_4M
operator|)
operator|<<
operator|(
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
argument_list|)
expr_stmt|;
block|}
name|vm_max_kernel_address
operator|=
name|VM_MIN_KERNEL_ADDRESS
operator|+
name|virtsz
expr_stmt|;
name|tsb_kernel_size
operator|=
name|virtsz
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|TTE_SHIFT
operator|)
expr_stmt|;
name|tsb_kernel_mask
operator|=
operator|(
name|tsb_kernel_size
operator|>>
name|TTE_SHIFT
operator|)
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Allocate the kernel TSB and lock it in the TLB if necessary. 	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|tsb_kernel_size
argument_list|,
name|colors
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|&
name|PAGE_MASK_4M
condition|)
name|OF_panic
argument_list|(
literal|"%s: TSB unaligned"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|tsb_kernel_phys
operator|=
name|pa
expr_stmt|;
if|if
condition|(
name|tsb_kernel_ldd_phys
operator|==
literal|0
condition|)
block|{
name|tsb_kernel
operator|=
operator|(
expr|struct
name|tte
operator|*
operator|)
operator|(
name|VM_MIN_KERNEL_ADDRESS
operator|-
name|tsb_kernel_size
operator|)
expr_stmt|;
name|pmap_map_tsb
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|tsb_kernel
argument_list|,
name|tsb_kernel_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tsb_kernel
operator|=
operator|(
expr|struct
name|tte
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|tsb_kernel_phys
argument_list|)
expr_stmt|;
name|aszero
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|tsb_kernel_phys
argument_list|,
name|tsb_kernel_size
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate and map the dynamic per-CPU area for the BSP. 	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|DPCPU_SIZE
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|dpcpu0
operator|=
operator|(
name|void
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate and map the message buffer. 	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|msgbufsize
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|msgbufp
operator|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
comment|/* 	 * Patch the TSB addresses and mask as well as the ASIs used to load 	 * it into the trap table. 	 */
define|#
directive|define
name|LDDA_R_I_R
parameter_list|(
name|rd
parameter_list|,
name|imm_asi
parameter_list|,
name|rs1
parameter_list|,
name|rs2
parameter_list|)
define|\
value|(EIF_OP(IOP_LDST) | EIF_F3_RD(rd) | EIF_F3_OP3(INS3_LDDA) |	\ 	    EIF_F3_RS1(rs1) | EIF_F3_I(0) | EIF_F3_IMM_ASI(imm_asi) |	\ 	    EIF_F3_RS2(rs2))
define|#
directive|define
name|OR_R_I_R
parameter_list|(
name|rd
parameter_list|,
name|imm13
parameter_list|,
name|rs1
parameter_list|)
define|\
value|(EIF_OP(IOP_MISC) | EIF_F3_RD(rd) | EIF_F3_OP3(INS2_OR) |	\ 	    EIF_F3_RS1(rs1) | EIF_F3_I(1) | EIF_IMM(imm13, 13))
define|#
directive|define
name|SETHI
parameter_list|(
name|rd
parameter_list|,
name|imm22
parameter_list|)
define|\
value|(EIF_OP(IOP_FORM2) | EIF_F2_RD(rd) | EIF_F2_OP2(INS0_SETHI) |	\ 	    EIF_IMM((imm22)>> 10, 22))
define|#
directive|define
name|WR_R_I
parameter_list|(
name|rd
parameter_list|,
name|imm13
parameter_list|,
name|rs1
parameter_list|)
define|\
value|(EIF_OP(IOP_MISC) | EIF_F3_RD(rd) | EIF_F3_OP3(INS2_WR) |	\ 	    EIF_F3_RS1(rs1) | EIF_F3_I(1) | EIF_IMM(imm13, 13))
define|#
directive|define
name|PATCH_ASI
parameter_list|(
name|addr
parameter_list|,
name|asi
parameter_list|)
value|do {					\ 	if (addr[0] != WR_R_I(IF_F3_RD(addr[0]), 0x0,			\ 	    IF_F3_RS1(addr[0])))					\ 		OF_panic("%s: patched instructions have changed",	\ 		    __func__);						\ 	addr[0] |= EIF_IMM((asi), 13);					\ 	flush(addr);							\ } while (0)
define|#
directive|define
name|PATCH_LDD
parameter_list|(
name|addr
parameter_list|,
name|asi
parameter_list|)
value|do {					\ 	if (addr[0] != LDDA_R_I_R(IF_F3_RD(addr[0]), 0x0,		\ 	    IF_F3_RS1(addr[0]), IF_F3_RS2(addr[0])))			\ 		OF_panic("%s: patched instructions have changed",	\ 		    __func__);						\ 	addr[0] |= EIF_F3_IMM_ASI(asi);					\ 	flush(addr);							\ } while (0)
define|#
directive|define
name|PATCH_TSB
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
value|do {					\ 	if (addr[0] != SETHI(IF_F2_RD(addr[0]), 0x0) ||			\ 	    addr[1] != OR_R_I_R(IF_F3_RD(addr[1]), 0x0,			\ 	    IF_F3_RS1(addr[1]))	||					\ 	    addr[3] != SETHI(IF_F2_RD(addr[3]), 0x0))			\ 		OF_panic("%s: patched instructions have changed",	\ 		    __func__);						\ 	addr[0] |= EIF_IMM((val)>> 42, 22);				\ 	addr[1] |= EIF_IMM((val)>> 32, 10);				\ 	addr[3] |= EIF_IMM((val)>> 10, 22);				\ 	flush(addr);							\ 	flush(addr + 1);						\ 	flush(addr + 3);						\ } while (0)
define|#
directive|define
name|PATCH_TSB_MASK
parameter_list|(
name|addr
parameter_list|,
name|val
parameter_list|)
value|do {					\ 	if (addr[0] != SETHI(IF_F2_RD(addr[0]), 0x0) ||			\ 	    addr[1] != OR_R_I_R(IF_F3_RD(addr[1]), 0x0,			\ 	    IF_F3_RS1(addr[1])))					\ 		OF_panic("%s: patched instructions have changed",	\ 		    __func__);						\ 	addr[0] |= EIF_IMM((val)>> 10, 22);				\ 	addr[1] |= EIF_IMM((val), 10);					\ 	flush(addr);							\ 	flush(addr + 1);						\ } while (0)
if|if
condition|(
name|tsb_kernel_ldd_phys
operator|==
literal|0
condition|)
block|{
name|asi
operator|=
name|ASI_N
expr_stmt|;
name|ldd
operator|=
name|ASI_NUCLEUS_QUAD_LDD
expr_stmt|;
name|off
operator|=
operator|(
name|vm_offset_t
operator|)
name|tsb_kernel
expr_stmt|;
block|}
else|else
block|{
name|asi
operator|=
name|ASI_PHYS_USE_EC
expr_stmt|;
name|ldd
operator|=
name|ASI_ATOMIC_QUAD_LDD_PHYS
expr_stmt|;
name|off
operator|=
operator|(
name|vm_offset_t
operator|)
name|tsb_kernel_phys
expr_stmt|;
block|}
name|PATCH_TSB
argument_list|(
name|tl1_dmmu_miss_direct_patch_tsb_phys_1
argument_list|,
name|tsb_kernel_phys
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_dmmu_miss_direct_patch_tsb_phys_end_1
argument_list|,
name|tsb_kernel_phys
operator|+
name|tsb_kernel_size
operator|-
literal|1
argument_list|)
expr_stmt|;
name|PATCH_ASI
argument_list|(
name|tl1_dmmu_miss_patch_asi_1
argument_list|,
name|asi
argument_list|)
expr_stmt|;
name|PATCH_LDD
argument_list|(
name|tl1_dmmu_miss_patch_quad_ldd_1
argument_list|,
name|ldd
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_dmmu_miss_patch_tsb_1
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_dmmu_miss_patch_tsb_2
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|PATCH_TSB_MASK
argument_list|(
name|tl1_dmmu_miss_patch_tsb_mask_1
argument_list|,
name|tsb_kernel_mask
argument_list|)
expr_stmt|;
name|PATCH_TSB_MASK
argument_list|(
name|tl1_dmmu_miss_patch_tsb_mask_2
argument_list|,
name|tsb_kernel_mask
argument_list|)
expr_stmt|;
name|PATCH_ASI
argument_list|(
name|tl1_dmmu_prot_patch_asi_1
argument_list|,
name|asi
argument_list|)
expr_stmt|;
name|PATCH_LDD
argument_list|(
name|tl1_dmmu_prot_patch_quad_ldd_1
argument_list|,
name|ldd
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_dmmu_prot_patch_tsb_1
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_dmmu_prot_patch_tsb_2
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|PATCH_TSB_MASK
argument_list|(
name|tl1_dmmu_prot_patch_tsb_mask_1
argument_list|,
name|tsb_kernel_mask
argument_list|)
expr_stmt|;
name|PATCH_TSB_MASK
argument_list|(
name|tl1_dmmu_prot_patch_tsb_mask_2
argument_list|,
name|tsb_kernel_mask
argument_list|)
expr_stmt|;
name|PATCH_ASI
argument_list|(
name|tl1_immu_miss_patch_asi_1
argument_list|,
name|asi
argument_list|)
expr_stmt|;
name|PATCH_LDD
argument_list|(
name|tl1_immu_miss_patch_quad_ldd_1
argument_list|,
name|ldd
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_immu_miss_patch_tsb_1
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|PATCH_TSB
argument_list|(
name|tl1_immu_miss_patch_tsb_2
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|PATCH_TSB_MASK
argument_list|(
name|tl1_immu_miss_patch_tsb_mask_1
argument_list|,
name|tsb_kernel_mask
argument_list|)
expr_stmt|;
name|PATCH_TSB_MASK
argument_list|(
name|tl1_immu_miss_patch_tsb_mask_2
argument_list|,
name|tsb_kernel_mask
argument_list|)
expr_stmt|;
comment|/* 	 * Enter fake 8k pages for the 4MB kernel pages, so that 	 * pmap_kextract() will work for them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kernel_tlb_slots
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|kernel_tlbs
index|[
name|i
index|]
operator|.
name|te_pa
expr_stmt|;
name|va
operator|=
name|kernel_tlbs
index|[
name|i
index|]
operator|.
name|te_va
expr_stmt|;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|PAGE_SIZE_4M
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
block|{
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
operator|+
name|off
argument_list|)
expr_stmt|;
name|vpn
operator|=
name|TV_VPN
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
operator|+
name|off
argument_list|)
operator||
name|TD_REF
operator||
name|TD_SW
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|pmap_bootstrap_set_tte
argument_list|(
name|tp
argument_list|,
name|vpn
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the start and end of KVA.  The kernel is loaded starting 	 * at the first available 4MB super page, so we advance to the 	 * end of the last one used for it. 	 */
name|virtual_avail
operator|=
name|KERNBASE
operator|+
name|kernel_tlb_slots
operator|*
name|PAGE_SIZE_4M
expr_stmt|;
name|virtual_end
operator|=
name|vm_max_kernel_address
expr_stmt|;
name|kernel_vm_end
operator|=
name|vm_max_kernel_address
expr_stmt|;
comment|/* 	 * Allocate kva space for temporary mappings. 	 */
name|pmap_idle_map
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
operator|*
name|colors
expr_stmt|;
name|pmap_temp_map_1
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
operator|*
name|colors
expr_stmt|;
name|pmap_temp_map_2
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|PAGE_SIZE
operator|*
name|colors
expr_stmt|;
comment|/* 	 * Allocate a kernel stack with guard page for thread0 and map it 	 * into the kernel TSB.  We must ensure that the virtual address is 	 * colored properly for corresponding CPUs, since we're allocating 	 * from phys_avail so the memory won't have an associated vm_page_t. 	 */
name|pa
operator|=
name|pmap_bootstrap_alloc
argument_list|(
name|KSTACK_PAGES
operator|*
name|PAGE_SIZE
argument_list|,
name|colors
argument_list|)
expr_stmt|;
name|kstack0_phys
operator|=
name|pa
expr_stmt|;
name|virtual_avail
operator|+=
name|roundup
argument_list|(
name|KSTACK_GUARD_PAGES
argument_list|,
name|colors
argument_list|)
operator|*
name|PAGE_SIZE
expr_stmt|;
name|kstack0
operator|=
name|virtual_avail
expr_stmt|;
name|virtual_avail
operator|+=
name|roundup
argument_list|(
name|KSTACK_PAGES
argument_list|,
name|colors
argument_list|)
operator|*
name|PAGE_SIZE
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|==
literal|0
condition|)
name|KASSERT
argument_list|(
name|DCACHE_COLOR
argument_list|(
name|kstack0
argument_list|)
operator|==
name|DCACHE_COLOR
argument_list|(
name|kstack0_phys
argument_list|)
argument_list|,
operator|(
literal|"pmap_bootstrap: kstack0 miscolored"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|KSTACK_PAGES
condition|;
name|i
operator|++
control|)
block|{
name|pa
operator|=
name|kstack0_phys
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|va
operator|=
name|kstack0
operator|+
name|i
operator|*
name|PAGE_SIZE
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_REF
operator||
name|TD_SW
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|pmap_bootstrap_set_tte
argument_list|(
name|tp
argument_list|,
name|vpn
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Calculate the last available physical address. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|2
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
empty_stmt|;
name|Maxmem
operator|=
name|sparc64_btop
argument_list|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Add the PROM mappings to the kernel TSB. 	 */
if|if
condition|(
operator|(
name|vmem
operator|=
name|OF_finddevice
argument_list|(
literal|"/virtual-memory"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: finddevice /virtual-memory"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|vmem
argument_list|,
literal|"translations"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: getproplen translations"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|translations
argument_list|)
operator|<
name|sz
condition|)
name|OF_panic
argument_list|(
literal|"%s: translations too small"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|vmem
argument_list|,
literal|"translations"
argument_list|,
name|translations
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: getprop /virtual-memory/translations"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sz
operator|/=
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
expr_stmt|;
name|translations_size
operator|=
name|sz
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|OF_printf
argument_list|(
literal|"pmap_bootstrap: translations\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|qsort
argument_list|(
name|translations
argument_list|,
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|translations
argument_list|)
argument_list|,
name|om_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sz
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
name|OF_printf
argument_list|(
literal|"translation: start=%#lx size=%#lx tte=%#lx\n"
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_start
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_size
argument_list|,
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
operator|&
name|TD_V
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|<
name|VM_MIN_PROM_ADDRESS
operator|||
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|>
name|VM_MAX_PROM_ADDRESS
condition|)
continue|continue;
for|for
control|(
name|off
operator|=
literal|0
init|;
name|off
operator|<
name|translations
index|[
name|i
index|]
operator|.
name|om_size
condition|;
name|off
operator|+=
name|PAGE_SIZE
control|)
block|{
name|va
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
operator|+
name|off
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
operator|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
operator|&
operator|~
operator|(
operator|(
name|TD_SOFT2_MASK
operator|<<
name|TD_SOFT2_SHIFT
operator|)
operator||
operator|(
name|cpu_impl
operator|>=
name|CPU_IMPL_ULTRASPARCI
operator|&&
name|cpu_impl
operator|<
name|CPU_IMPL_ULTRASPARCIII
condition|?
operator|(
name|TD_DIAG_SF_MASK
operator|<<
name|TD_DIAG_SF_SHIFT
operator|)
else|:
operator|(
name|TD_RSVD_CH_MASK
operator|<<
name|TD_RSVD_CH_SHIFT
operator|)
operator|)
operator||
operator|(
name|TD_SOFT_MASK
operator|<<
name|TD_SOFT_SHIFT
operator|)
operator|)
operator|)
operator||
name|TD_EXEC
operator|)
operator|+
name|off
expr_stmt|;
name|pmap_bootstrap_set_tte
argument_list|(
name|tp
argument_list|,
name|vpn
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Get the available physical memory ranges from /memory/reg.  These 	 * are only used for kernel dumps, but it may not be wise to do PROM 	 * calls in that situation. 	 */
if|if
condition|(
operator|(
name|sz
operator|=
name|OF_getproplen
argument_list|(
name|pmem
argument_list|,
literal|"reg"
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: getproplen /memory/reg"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|sparc64_memreg
argument_list|)
operator|<
name|sz
condition|)
name|OF_panic
argument_list|(
literal|"%s: sparc64_memreg too small"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|OF_getprop
argument_list|(
name|pmem
argument_list|,
literal|"reg"
argument_list|,
name|sparc64_memreg
argument_list|,
name|sz
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|OF_panic
argument_list|(
literal|"%s: getprop /memory/reg"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|sparc64_nmemreg
operator|=
name|sz
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|sparc64_memreg
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the kernel pmap (which is statically allocated). 	 */
name|pm
operator|=
name|kernel_pmap
expr_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pm
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|pm
operator|->
name|pm_context
index|[
name|i
index|]
operator|=
name|TLB_CTX_KERNEL
expr_stmt|;
name|CPU_FILL
argument_list|(
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the global tte list lock, which is more commonly 	 * known as the pmap pv global lock. 	 */
name|rw_init
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
literal|"pmap pv global"
argument_list|)
expr_stmt|;
comment|/* 	 * Flush all non-locked TLB entries possibly left over by the 	 * firmware. 	 */
name|tlb_flush_nonlocked
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_init_qpages
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
condition|)
return|return;
name|CPU_FOREACH
argument_list|(
argument|i
argument_list|)
block|{
name|pc
operator|=
name|pcpu_find
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|pc
operator|->
name|pc_qmap_addr
operator|=
name|kva_alloc
argument_list|(
name|PAGE_SIZE
operator|*
name|DCACHE_COLORS
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|->
name|pc_qmap_addr
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_init_qpages: unable to allocate KVA"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|qpages_init
argument_list|,
name|SI_SUB_CPU
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|pmap_init_qpages
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Map the 4MB kernel TSB pages.  */
end_comment

begin_function
name|void
name|pmap_map_tsb
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tsb_kernel_size
condition|;
name|i
operator|+=
name|PAGE_SIZE_4M
control|)
block|{
name|va
operator|=
operator|(
name|vm_offset_t
operator|)
name|tsb_kernel
operator|+
name|i
expr_stmt|;
name|pa
operator|=
name|tsb_kernel_phys
operator|+
name|i
expr_stmt|;
name|data
operator|=
name|TD_V
operator||
name|TD_4M
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_L
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_TAR
argument_list|,
name|ASI_DMMU
argument_list|,
name|TLB_TAR_VA
argument_list|(
name|va
argument_list|)
operator||
name|TLB_TAR_CTX
argument_list|(
name|TLB_CTX_KERNEL
argument_list|)
argument_list|)
expr_stmt|;
name|stxa_sync
argument_list|(
literal|0
argument_list|,
name|ASI_DTLB_DATA_IN_REG
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the secondary context to be the kernel context (needed for FP block  * operations in the kernel).  */
end_comment

begin_function
name|void
name|pmap_set_kctx
parameter_list|(
name|void
parameter_list|)
block|{
name|stxa
argument_list|(
name|AA_DMMU_SCXR
argument_list|,
name|ASI_DMMU
argument_list|,
operator|(
name|ldxa
argument_list|(
name|AA_DMMU_SCXR
argument_list|,
name|ASI_DMMU
argument_list|)
operator|&
name|TLB_CXR_PGSZ_MASK
operator|)
operator||
name|TLB_CTX_KERNEL
argument_list|)
expr_stmt|;
name|flush
argument_list|(
name|KERNBASE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a physical page of memory directly from the phys_avail map.  * Can only be called from pmap_bootstrap before avail start and end are  * calculated.  */
end_comment

begin_function
specifier|static
name|vm_paddr_t
name|pmap_bootstrap_alloc
parameter_list|(
name|vm_size_t
name|size
parameter_list|,
name|uint32_t
name|colors
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|PAGE_SIZE
operator|*
name|colors
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|0
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|phys_avail
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|phys_avail
index|[
name|i
index|]
operator|<
name|size
condition|)
continue|continue;
name|pa
operator|=
name|phys_avail
index|[
name|i
index|]
expr_stmt|;
name|phys_avail
index|[
name|i
index|]
operator|+=
name|size
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
name|OF_panic
argument_list|(
literal|"%s: no suitable region found"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set a TTE.  This function is intended as a helper when tsb_kernel is  * direct-mapped but we haven't taken over the trap table, yet, as it's the  * case when we are taking advantage of ASI_ATOMIC_QUAD_LDD_PHYS to access  * the kernel TSB.  */
end_comment

begin_function
name|void
name|pmap_bootstrap_set_tte
parameter_list|(
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|u_long
name|vpn
parameter_list|,
name|u_long
name|data
parameter_list|)
block|{
if|if
condition|(
name|tsb_kernel_ldd_phys
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|tte_vpn
operator|=
name|vpn
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|data
expr_stmt|;
block|}
else|else
block|{
name|stxa
argument_list|(
operator|(
name|vm_paddr_t
operator|)
name|tp
operator|+
name|offsetof
argument_list|(
expr|struct
name|tte
argument_list|,
name|tte_vpn
argument_list|)
argument_list|,
name|ASI_PHYS_USE_EC
argument_list|,
name|vpn
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
operator|(
name|vm_paddr_t
operator|)
name|tp
operator|+
name|offsetof
argument_list|(
expr|struct
name|tte
argument_list|,
name|tte_data
argument_list|)
argument_list|,
name|ASI_PHYS_USE_EC
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initialize a vm_page's machine-dependent fields.  */
end_comment

begin_function
name|void
name|pmap_page_init
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|color
operator|=
name|DCACHE_COLOR
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pmap
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap module.  */
end_comment

begin_function
name|void
name|pmap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
name|vm_size_t
name|size
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|translations_size
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
expr_stmt|;
name|size
operator|=
name|translations
index|[
name|i
index|]
operator|.
name|om_size
expr_stmt|;
if|if
condition|(
operator|(
name|translations
index|[
name|i
index|]
operator|.
name|om_tte
operator|&
name|TD_V
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|addr
operator|<
name|VM_MIN_PROM_ADDRESS
operator|||
name|addr
operator|>
name|VM_MAX_PROM_ADDRESS
condition|)
continue|continue;
name|result
operator|=
name|vm_map_find
argument_list|(
name|kernel_map
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
name|VMFS_NO_SPACE
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|VM_PROT_ALL
argument_list|,
name|MAP_NOFAULT
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|KERN_SUCCESS
operator|||
name|addr
operator|!=
name|translations
index|[
name|i
index|]
operator|.
name|om_start
condition|)
name|panic
argument_list|(
literal|"pmap_init: vm_map_find"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given  * map/virtual_address pair.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_extract
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
return|return
operator|(
name|pmap_kextract
argument_list|(
name|va
argument_list|)
operator|)
return|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
name|pa
operator|=
literal|0
expr_stmt|;
else|else
name|pa
operator|=
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
operator||
operator|(
name|va
operator|&
name|TTE_GET_PAGE_MASK
argument_list|(
name|tp
argument_list|)
operator|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|pa
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Atomically extract and hold the physical page with the given  * pmap and virtual address pair if that mapping permits the given  * protection.  */
end_comment

begin_function
name|vm_page_t
name|pmap_extract_and_hold
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|m
operator|=
name|NULL
expr_stmt|;
name|pa
operator|=
literal|0
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|retry
label|:
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
block|{
if|if
condition|(
name|va
operator|>=
name|VM_MIN_DIRECT_ADDRESS
condition|)
block|{
name|tp
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TLB_DIRECT_TO_PHYS
argument_list|(
name|va
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vm_page_pa_tryrelock
argument_list|(
name|pm
argument_list|,
name|TLB_DIRECT_TO_PHYS
argument_list|(
name|va
argument_list|)
argument_list|,
operator|&
name|pa
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_V
operator|)
operator|==
literal|0
condition|)
name|tp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|!=
name|NULL
operator|&&
operator|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_SW
operator|)
operator|||
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|vm_page_pa_tryrelock
argument_list|(
name|pm
argument_list|,
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
argument_list|,
operator|&
name|pa
argument_list|)
condition|)
goto|goto
name|retry
goto|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_hold
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|PA_UNLOCK_COND
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract the physical page address associated with the given kernel virtual  * address.  */
end_comment

begin_function
name|vm_paddr_t
name|pmap_kextract
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|va
operator|>=
name|VM_MIN_DIRECT_ADDRESS
condition|)
return|return
operator|(
name|TLB_DIRECT_TO_PHYS
argument_list|(
name|va
argument_list|)
operator|)
return|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_V
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
operator||
operator|(
name|va
operator|&
name|TTE_GET_PAGE_MASK
argument_list|(
name|tp
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|pmap_cache_enter
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|int
name|color
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_cache_enter: fake page"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Find the color for this virtual address and note the added mapping. 	 */
name|color
operator|=
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|color
index|]
operator|++
expr_stmt|;
comment|/* 	 * If all existing mappings have the same color, the mapping is 	 * cacheable. 	 */
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|color
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_OTHER_COLOR
argument_list|(
name|color
argument_list|)
index|]
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_cache_enter: cacheable, mappings of other color"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_c
argument_list|)
expr_stmt|;
else|else
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_oc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If there are no mappings of the other color, and the page still has 	 * the wrong color, this must be a new mapping.  Change the color to 	 * match the new mapping, which is cacheable.  We must flush the page 	 * from the cache now. 	 */
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_OTHER_COLOR
argument_list|(
name|color
argument_list|)
index|]
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|color
index|]
operator|==
literal|1
argument_list|,
operator|(
literal|"pmap_cache_enter: changing color, not new mapping"
operator|)
argument_list|)
expr_stmt|;
name|dcache_page_inval
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|color
operator|=
name|color
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_cc
argument_list|)
expr_stmt|;
else|else
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_coc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the mapping is already non-cacheable, just return. 	 */
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_nc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_enter_cnc
argument_list|)
expr_stmt|;
comment|/* 	 * Mark all mappings as uncacheable, flush any lines with the other 	 * color out of the dcache, and set the color to none (-1). 	 */
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_CV
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|TTE_GET_PMAP
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dcache_page_inval
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|color
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pmap_cache_remove
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|int
name|color
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_cache_remove: m=%p va=%#lx c=%d"
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_cache_remove: fake page"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_remove
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
condition|)
return|return;
name|KASSERT
argument_list|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
operator|>
literal|0
argument_list|,
operator|(
literal|"pmap_cache_remove: no mappings %d<= 0"
operator|,
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
index|]
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the color for this virtual address and note the removal of 	 * the mapping. 	 */
name|color
operator|=
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|color
index|]
operator|--
expr_stmt|;
comment|/* 	 * If the page is cacheable, just return and keep the same color, even 	 * if there are no longer any mappings. 	 */
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_remove_c
argument_list|)
expr_stmt|;
else|else
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_remove_oc
argument_list|)
expr_stmt|;
return|return;
block|}
name|KASSERT
argument_list|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|DCACHE_OTHER_COLOR
argument_list|(
name|color
argument_list|)
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_cache_remove: uncacheable, no mappings of other color"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not cacheable (color is -1), and the number of 	 * mappings for this color is not zero, just return.  There are 	 * mappings of the other color still, so remain non-cacheable. 	 */
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|colors
index|[
name|color
index|]
operator|!=
literal|0
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_remove_nc
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * The number of mappings for this color is now zero.  Recache the 	 * other colored mappings, and change the page color to the other 	 * color.  There should be no lines in the data cache for this page, 	 * so flushing should not be needed. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
name|atomic_set_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_CV
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|TTE_GET_PMAP
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|m
operator|->
name|md
operator|.
name|color
operator|=
name|DCACHE_OTHER_COLOR
argument_list|(
name|color
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
condition|)
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_remove_cc
argument_list|)
expr_stmt|;
else|else
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncache_remove_coc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  */
end_comment

begin_function
name|void
name|pmap_kenter
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_offset_t
name|ova
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_page_t
name|om
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nkenter
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kenter: va=%#lx pa=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|DCACHE_COLOR
argument_list|(
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|)
operator|!=
name|DCACHE_COLOR
argument_list|(
name|va
argument_list|)
condition|)
block|{
name|CTR5
argument_list|(
name|KTR_SPARE2
argument_list|,
literal|"pmap_kenter: off color va=%#lx pa=%#lx o=%p ot=%d pi=%#lx"
argument_list|,
name|va
argument_list|,
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
argument_list|,
name|m
operator|->
name|object
argument_list|,
name|m
operator|->
name|object
condition|?
name|m
operator|->
name|object
operator|->
name|type
else|:
operator|-
literal|1
argument_list|,
name|m
operator|->
name|pindex
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nkenter_oc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_V
operator|)
operator|!=
literal|0
condition|)
block|{
name|om
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|ova
operator|=
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|om
operator|&&
name|va
operator|==
name|ova
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nkenter_stupid
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|om
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
name|pmap_cache_remove
argument_list|(
name|om
argument_list|,
name|ova
argument_list|)
expr_stmt|;
if|if
condition|(
name|va
operator|!=
name|ova
condition|)
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|ova
argument_list|)
expr_stmt|;
block|}
name|data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
operator||
name|TD_REF
operator||
name|TD_SW
operator||
name|TD_CP
operator||
name|TD_P
operator||
name|TD_W
expr_stmt|;
if|if
condition|(
name|pmap_cache_enter
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
operator|!=
literal|0
condition|)
name|data
operator||=
name|TD_CV
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|data
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a wired page into kernel virtual address space.  This additionally  * takes a flag argument which is or'ed to the TTE data.  This is used by  * sparc64_bus_mem_map().  * NOTE: if the mapping is non-cacheable, it's the caller's responsibility  * to flush entries that might still be in the cache, if applicable.  */
end_comment

begin_function
name|void
name|pmap_kenter_flags
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|vm_paddr_t
name|pa
parameter_list|,
name|u_long
name|flags
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kenter_flags: va=%#lx pa=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_REF
operator||
name|TD_P
operator||
name|flags
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a wired page from kernel virtual address space.  */
end_comment

begin_function
name|void
name|pmap_kremove
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nkremove
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kremove: va=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_V
operator|)
operator|==
literal|0
condition|)
return|return;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
name|pmap_cache_remove
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|TTE_ZERO
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Inverse of pmap_kenter_flags, used by bus_space_unmap().  */
end_comment

begin_function
name|void
name|pmap_kremove_flags
parameter_list|(
name|vm_offset_t
name|va
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_kremove_flags: va=%#lx tp=%p data=%#lx"
argument_list|,
name|va
argument_list|,
name|tp
argument_list|,
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
name|TTE_ZERO
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map a range of physical addresses into kernel virtual address space.  *  * The value passed in *virt is a suggested virtual address for the mapping.  * Architectures which can support a direct-mapped physical to virtual region  * can return the appropriate address within that region, leaving '*virt'  * unchanged.  */
end_comment

begin_function
name|vm_offset_t
name|pmap_map
parameter_list|(
name|vm_offset_t
modifier|*
name|virt
parameter_list|,
name|vm_paddr_t
name|start
parameter_list|,
name|vm_paddr_t
name|end
parameter_list|,
name|int
name|prot
parameter_list|)
block|{
return|return
operator|(
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|start
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map a list of wired pages into kernel virtual address space.  This is  * intended for temporary mappings which do not need page modification or  * references recorded.  Existing mappings in the region are overwritten.  */
end_comment

begin_function
name|void
name|pmap_qenter
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|vm_page_t
modifier|*
name|m
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nqenter
argument_list|)
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kenter
argument_list|(
name|va
argument_list|,
operator|*
name|m
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|m
operator|++
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove page mappings from kernel virtual address space.  Intended for  * temporary mappings entered by pmap_qenter.  */
end_comment

begin_function
name|void
name|pmap_qremove
parameter_list|(
name|vm_offset_t
name|sva
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nqremove
argument_list|)
expr_stmt|;
name|va
operator|=
name|sva
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|pmap_kremove
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|va
operator|+=
name|PAGE_SIZE
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|sva
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize the pmap associated with process 0.  */
end_comment

begin_function
name|void
name|pmap_pinit0
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|PMAP_LOCK_INIT
argument_list|(
name|pm
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|pm
operator|->
name|pm_context
index|[
name|i
index|]
operator|=
name|TLB_CTX_KERNEL
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_tsb
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|pm_tsb_obj
operator|=
name|NULL
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pm
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize a preallocated and zeroed pmap structure, such as one in a  * vmspace structure.  */
end_comment

begin_function
name|int
name|pmap_pinit
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|vm_page_t
name|ma
index|[
name|TSB_PAGES
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Allocate KVA space for the TSB. 	 */
if|if
condition|(
name|pm
operator|->
name|pm_tsb
operator|==
name|NULL
condition|)
block|{
name|pm
operator|->
name|pm_tsb
operator|=
operator|(
expr|struct
name|tte
operator|*
operator|)
name|kva_alloc
argument_list|(
name|TSB_BSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_tsb
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Allocate an object for it. 	 */
if|if
condition|(
name|pm
operator|->
name|pm_tsb_obj
operator|==
name|NULL
condition|)
name|pm
operator|->
name|pm_tsb_obj
operator|=
name|vm_object_allocate
argument_list|(
name|OBJT_PHYS
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXCPU
condition|;
name|i
operator|++
control|)
name|pm
operator|->
name|pm_context
index|[
name|i
index|]
operator|=
operator|-
literal|1
expr_stmt|;
name|CPU_ZERO
argument_list|(
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|pm
operator|->
name|pm_tsb_obj
argument_list|)
expr_stmt|;
name|vm_page_grab_pages
argument_list|(
name|pm
operator|->
name|pm_tsb_obj
argument_list|,
literal|0
argument_list|,
name|VM_ALLOC_NORMAL
operator||
name|VM_ALLOC_NOBUSY
operator||
name|VM_ALLOC_WIRED
operator||
name|VM_ALLOC_ZERO
argument_list|,
name|ma
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
name|VM_OBJECT_WUNLOCK
argument_list|(
name|pm
operator|->
name|pm_tsb_obj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TSB_PAGES
condition|;
name|i
operator|++
control|)
name|ma
index|[
name|i
index|]
operator|->
name|md
operator|.
name|pmap
operator|=
name|pm
expr_stmt|;
name|pmap_qenter
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pm
operator|->
name|pm_tsb
argument_list|,
name|ma
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|pm
operator|->
name|pm_stats
argument_list|,
sizeof|sizeof
argument_list|(
name|pm
operator|->
name|pm_stats
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release any resources held by the given physical map.  * Called when a pmap initialized by pmap_pinit is being released.  * Should only be called if the map contains no valid mappings.  */
end_comment

begin_function
name|void
name|pmap_release
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{
name|vm_object_t
name|obj
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|struct
name|pcpu
modifier|*
name|pc
decl_stmt|;
endif|#
directive|endif
name|CTR2
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_release: ctx=%#x tsb=%p"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|curcpu
index|]
argument_list|,
name|pm
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmap_resident_count
argument_list|(
name|pm
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_release: resident pages %ld != 0"
operator|,
name|pmap_resident_count
argument_list|(
name|pm
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * After the pmap was freed, it might be reallocated to a new process. 	 * When switching, this might lead us to wrongly assume that we need 	 * not switch contexts because old and new pmap pointer are equal. 	 * Therefore, make sure that this pmap is not referenced by any PCPU 	 * pointer any more.  This could happen in two cases: 	 * - A process that referenced the pmap is currently exiting on a CPU. 	 *   However, it is guaranteed to not switch in any more after setting 	 *   its state to PRS_ZOMBIE. 	 * - A process that referenced this pmap ran on a CPU, but we switched 	 *   to a kernel thread, leaving the pmap pointer unchanged. 	 */
ifdef|#
directive|ifdef
name|SMP
name|sched_pin
argument_list|()
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|pc
argument_list|,
argument|&cpuhead
argument_list|,
argument|pc_allcpu
argument_list|)
name|atomic_cmpset_rel_ptr
argument_list|(
operator|(
name|uintptr_t
operator|*
operator|)
operator|&
name|pc
operator|->
name|pc_pmap
argument_list|,
operator|(
name|uintptr_t
operator|)
name|pm
argument_list|,
operator|(
name|uintptr_t
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|sched_unpin
argument_list|()
expr_stmt|;
else|#
directive|else
name|critical_enter
argument_list|()
expr_stmt|;
if|if
condition|(
name|PCPU_GET
argument_list|(
name|pmap
argument_list|)
operator|==
name|pm
condition|)
name|PCPU_SET
argument_list|(
name|pmap
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|pmap_qremove
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|pm
operator|->
name|pm_tsb
argument_list|,
name|TSB_PAGES
argument_list|)
expr_stmt|;
name|obj
operator|=
name|pm
operator|->
name|pm_tsb_obj
expr_stmt|;
name|VM_OBJECT_WLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|obj
operator|->
name|ref_count
operator|==
literal|1
argument_list|,
operator|(
literal|"pmap_release: tsbobj ref count != 1"
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|obj
operator|->
name|memq
argument_list|)
condition|)
block|{
name|m
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|obj
operator|->
name|memq
argument_list|)
expr_stmt|;
name|m
operator|->
name|md
operator|.
name|pmap
operator|=
name|NULL
expr_stmt|;
name|m
operator|->
name|wire_count
operator|--
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|vm_cnt
operator|.
name|v_wire_count
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|vm_page_free_zero
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|VM_OBJECT_WUNLOCK
argument_list|(
name|obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Grow the number of kernel page table entries.  Unneeded.  */
end_comment

begin_function
name|void
name|pmap_growkernel
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|panic
argument_list|(
literal|"pmap_growkernel: can't grow kernel"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_remove_tte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|struct
name|pmap
modifier|*
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|data
operator|=
name|atomic_readandclear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_FAKE
operator|)
operator|==
literal|0
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TD_PA
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|)
condition|)
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
block|}
name|pmap_cache_remove
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|TTE_ZERO
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMAP_REMOVE_DONE
argument_list|(
name|pm
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the given range of addresses from the specified map.  */
end_comment

begin_function
name|void
name|pmap_remove
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|CTR3
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_remove: ctx=%#lx start=%#lx end=%#lx"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|curcpu
index|]
argument_list|,
name|start
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMAP_REMOVE_DONE
argument_list|(
name|pm
argument_list|)
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|-
name|start
operator|>
name|PMAP_TSB_THRESH
condition|)
block|{
name|tsb_foreach
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|pmap_remove_tte
argument_list|)
expr_stmt|;
name|tlb_context_demap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|start
init|;
name|va
operator|<
name|end
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|!
name|pmap_remove_tte
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
condition|)
break|break;
name|tlb_range_demap
argument_list|(
name|pm
argument_list|,
name|start
argument_list|,
name|end
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_remove_all
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|pmap
modifier|*
name|pm
decl_stmt|;
name|struct
name|tte
modifier|*
name|tpn
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_all: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|)
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tpn
control|)
block|{
name|tpn
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|pm
operator|=
name|TTE_GET_PMAP
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|va
operator|=
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_REFERENCED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|&=
operator|~
name|TD_V
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|resident_count
operator|--
expr_stmt|;
name|pmap_cache_remove
argument_list|(
name|m
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|TTE_ZERO
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_protect_tte
parameter_list|(
name|struct
name|pmap
modifier|*
name|pm
parameter_list|,
name|struct
name|pmap
modifier|*
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|u_long
name|data
decl_stmt|;
name|vm_page_t
name|m
decl_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pm
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|data
operator|=
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_SW
operator||
name|TD_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
operator|(
name|TD_PV
operator||
name|TD_W
operator|)
operator|)
operator|==
operator|(
name|TD_PV
operator||
name|TD_W
operator|)
condition|)
block|{
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TD_PA
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the physical protection on the specified range of this map as requested.  */
end_comment

begin_function
name|void
name|pmap_protect
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|CTR4
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_protect: ctx=%#lx sva=%#lx eva=%#lx prot=%#lx"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|curcpu
index|]
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|prot
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_READ
operator|)
operator|==
name|VM_PROT_NONE
condition|)
block|{
name|pmap_remove
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_WRITE
condition|)
return|return;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|eva
operator|-
name|sva
operator|>
name|PMAP_TSB_THRESH
condition|)
block|{
name|tsb_foreach
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pmap_protect_tte
argument_list|)
expr_stmt|;
name|tlb_context_demap
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pmap_protect_tte
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|pm
argument_list|,
name|sva
argument_list|,
name|eva
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  */
end_comment

begin_function
name|int
name|pmap_enter
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|rv
operator|=
name|pmap_enter_locked
argument_list|(
name|pm
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
argument_list|,
name|flags
argument_list|,
name|psind
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Map the given physical page at the specified virtual address in the  * target pmap with the protection requested.  If specified the page  * will be wired down.  *  * The page queues and pmap must be locked.  */
end_comment

begin_function
specifier|static
name|int
name|pmap_enter_locked
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|,
name|u_int
name|flags
parameter_list|,
name|int8_t
name|psind
name|__unused
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_page_t
name|real
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|boolean_t
name|wired
decl_stmt|;
name|rw_assert
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|,
name|RA_WLOCKED
argument_list|)
expr_stmt|;
name|PMAP_LOCK_ASSERT
argument_list|(
name|pm
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
operator|&&
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
condition|)
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nenter
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|wired
operator|=
operator|(
name|flags
operator|&
name|PMAP_ENTER_WIRED
operator|)
operator|!=
literal|0
expr_stmt|;
comment|/* 	 * If this is a fake page from the device_pager, but it covers actual 	 * physical memory, convert to the real backing page. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|!=
literal|0
condition|)
block|{
name|real
operator|=
name|vm_phys_paddr_to_vm_page
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|real
operator|!=
name|NULL
condition|)
name|m
operator|=
name|real
expr_stmt|;
block|}
name|CTR6
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_locked: ctx=%p m=%p va=%#lx pa=%#lx prot=%#x wired=%d"
argument_list|,
name|pm
operator|->
name|pm_context
index|[
name|curcpu
index|]
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|pa
argument_list|,
name|prot
argument_list|,
name|wired
argument_list|)
expr_stmt|;
comment|/* 	 * If there is an existing mapping, and the physical address has not 	 * changed, must be protection or wiring change. 	 */
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
operator|==
name|pa
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_locked: update"
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nenter_update
argument_list|)
expr_stmt|;
comment|/* 		 * Wiring change, just update stats. 		 */
if|if
condition|(
name|wired
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|tte_data
operator||=
name|TD_WIRED
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|tte_data
operator|&=
operator|~
name|TD_WIRED
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
block|}
block|}
comment|/* 		 * Save the old bits and clear the ones we're interested in. 		 */
name|data
operator|=
name|tp
operator|->
name|tte_data
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|&=
operator|~
operator|(
name|TD_EXEC
operator||
name|TD_SW
operator||
name|TD_W
operator|)
expr_stmt|;
comment|/* 		 * If we're turning off write permissions, sense modify status. 		 */
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|tp
operator|->
name|tte_data
operator||=
name|TD_SW
expr_stmt|;
if|if
condition|(
name|wired
condition|)
name|tp
operator|->
name|tte_data
operator||=
name|TD_W
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * If we're turning on execute permissions, flush the icache. 		 */
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_EXECUTE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|data
operator|&
name|TD_EXEC
operator|)
operator|==
literal|0
condition|)
name|icache_page_inval
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator||=
name|TD_EXEC
expr_stmt|;
block|}
comment|/* 		 * Delete the old mapping. 		 */
name|tlb_page_demap
argument_list|(
name|pm
argument_list|,
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If there is an existing mapping, but its for a different 		 * physical address, delete the old mapping. 		 */
if|if
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_locked: replace"
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nenter_replace
argument_list|)
expr_stmt|;
name|pmap_remove_tte
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CTR0
argument_list|(
name|KTR_PMAP
argument_list|,
literal|"pmap_enter_locked: new"
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nenter_new
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Now set up the data and install the new mapping. 		 */
name|data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|kernel_pmap
condition|)
name|data
operator||=
name|TD_P
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
block|{
name|data
operator||=
name|TD_SW
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
condition|)
name|vm_page_aflag_set
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prot
operator|&
name|VM_PROT_EXECUTE
condition|)
block|{
name|data
operator||=
name|TD_EXEC
expr_stmt|;
name|icache_page_inval
argument_list|(
name|pa
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If its wired update stats.  We also don't need reference or 		 * modify tracking for wired mappings, so set the bits now. 		 */
if|if
condition|(
name|wired
condition|)
block|{
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|++
expr_stmt|;
name|data
operator||=
name|TD_REF
operator||
name|TD_WIRED
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|VM_PROT_WRITE
operator|)
operator|!=
literal|0
condition|)
name|data
operator||=
name|TD_W
expr_stmt|;
block|}
name|tsb_tte_enter
argument_list|(
name|pm
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|TS_8K
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|KERN_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Maps a sequence of resident pages belonging to the same object.  * The sequence begins with the given page m_start.  This page is  * mapped at the given virtual address start.  Each subsequent page is  * mapped at a virtual address that is offset from start by the same  * amount as the page is offset from m_start within the object.  The  * last page in the sequence is the page with the largest offset from  * m_start that can be mapped at a virtual address less than the given  * virtual address end.  Not every virtual page between start and end  * is mapped; only those for which a resident page exists with the  * corresponding offset from m_start are mapped.  */
end_comment

begin_function
name|void
name|pmap_enter_object
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|,
name|vm_page_t
name|m_start
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|vm_pindex_t
name|diff
decl_stmt|,
name|psize
decl_stmt|;
name|VM_OBJECT_ASSERT_LOCKED
argument_list|(
name|m_start
operator|->
name|object
argument_list|)
expr_stmt|;
name|psize
operator|=
name|atop
argument_list|(
name|end
operator|-
name|start
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_start
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
operator|&&
operator|(
name|diff
operator|=
name|m
operator|->
name|pindex
operator|-
name|m_start
operator|->
name|pindex
operator|)
operator|<
name|psize
condition|)
block|{
name|pmap_enter_locked
argument_list|(
name|pm
argument_list|,
name|start
operator|+
name|ptoa
argument_list|(
name|diff
argument_list|)
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|=
name|TAILQ_NEXT
argument_list|(
name|m
argument_list|,
name|listq
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_enter_quick
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_page_t
name|m
parameter_list|,
name|vm_prot_t
name|prot
parameter_list|)
block|{
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pmap_enter_locked
argument_list|(
name|pm
argument_list|,
name|va
argument_list|,
name|m
argument_list|,
name|prot
operator|&
operator|(
name|VM_PROT_READ
operator||
name|VM_PROT_EXECUTE
operator|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_object_init_pt
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_object_t
name|object
parameter_list|,
name|vm_pindex_t
name|pindex
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|object
operator|->
name|type
operator|==
name|OBJT_DEVICE
operator|||
name|object
operator|->
name|type
operator|==
name|OBJT_SG
argument_list|,
operator|(
literal|"pmap_object_init_pt: non-device object"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_unwire_tte
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|pmap_t
name|pm2
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|PMAP_LOCK_ASSERT
argument_list|(
name|pm
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_WIRED
operator|)
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"pmap_unwire_tte: tp %p is missing TD_WIRED"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_WIRED
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_stats
operator|.
name|wired_count
operator|--
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear the wired attribute from the mappings for the specified range of  * addresses in the given pmap.  Every valid mapping within that range must  * have the wired attribute set.  In contrast, invalid mappings cannot have  * the wired attribute set, so they are ignored.  *  * The wired attribute of the translation table entry is not a hardware  * feature, so there is no need to invalidate any TLB entries.  */
end_comment

begin_function
name|void
name|pmap_unwire
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|eva
operator|-
name|sva
operator|>
name|PMAP_TSB_THRESH
condition|)
name|tsb_foreach
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|sva
argument_list|,
name|eva
argument_list|,
name|pmap_unwire_tte
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|va
operator|=
name|sva
init|;
name|va
operator|<
name|eva
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|pm
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pmap_unwire_tte
argument_list|(
name|pm
argument_list|,
name|NULL
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
name|PMAP_UNLOCK
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmap_copy_tte
parameter_list|(
name|pmap_t
name|src_pmap
parameter_list|,
name|pmap_t
name|dst_pmap
parameter_list|,
name|struct
name|tte
modifier|*
name|tp
parameter_list|,
name|vm_offset_t
name|va
parameter_list|)
block|{
name|vm_page_t
name|m
decl_stmt|;
name|u_long
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_FAKE
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|tsb_tte_lookup
argument_list|(
name|dst_pmap
argument_list|,
name|va
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|data
operator|=
name|tp
operator|->
name|tte_data
operator|&
operator|~
operator|(
name|TD_PV
operator||
name|TD_REF
operator||
name|TD_SW
operator||
name|TD_CV
operator||
name|TD_W
operator|)
expr_stmt|;
name|m
operator|=
name|PHYS_TO_VM_PAGE
argument_list|(
name|TTE_GET_PA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
name|tsb_tte_enter
argument_list|(
name|dst_pmap
argument_list|,
name|m
argument_list|,
name|va
argument_list|,
name|TS_8K
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_copy
parameter_list|(
name|pmap_t
name|dst_pmap
parameter_list|,
name|pmap_t
name|src_pmap
parameter_list|,
name|vm_offset_t
name|dst_addr
parameter_list|,
name|vm_size_t
name|len
parameter_list|,
name|vm_offset_t
name|src_addr
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
if|if
condition|(
name|dst_addr
operator|!=
name|src_addr
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_pmap
operator|<
name|src_pmap
condition|)
block|{
name|PMAP_LOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_LOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
name|PMAP_TSB_THRESH
condition|)
block|{
name|tsb_foreach
argument_list|(
name|src_pmap
argument_list|,
name|dst_pmap
argument_list|,
name|src_addr
argument_list|,
name|src_addr
operator|+
name|len
argument_list|,
name|pmap_copy_tte
argument_list|)
expr_stmt|;
name|tlb_context_demap
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|va
operator|=
name|src_addr
init|;
name|va
operator|<
name|src_addr
operator|+
name|len
condition|;
name|va
operator|+=
name|PAGE_SIZE
control|)
if|if
condition|(
operator|(
name|tp
operator|=
name|tsb_tte_lookup
argument_list|(
name|src_pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|pmap_copy_tte
argument_list|(
name|src_pmap
argument_list|,
name|dst_pmap
argument_list|,
name|tp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|tlb_range_demap
argument_list|(
name|dst_pmap
argument_list|,
name|src_addr
argument_list|,
name|src_addr
operator|+
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|src_pmap
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|dst_pmap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_zero_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_zero_page: fake page"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
operator|||
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_c
argument_list|)
expr_stmt|;
name|va
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|cpu_block_zero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_nc
argument_list|)
expr_stmt|;
name|aszero
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|pa
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_oc
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|va
operator|=
name|pmap_temp_map_1
operator|+
operator|(
name|m
operator|->
name|md
operator|.
name|color
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|cpu_block_zero
argument_list|(
operator|(
name|void
operator|*
operator|)
name|va
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_zero_page_area
parameter_list|(
name|vm_page_t
name|m
parameter_list|,
name|int
name|off
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|vm_offset_t
name|va
decl_stmt|;
name|vm_paddr_t
name|pa
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_zero_page_area: fake page"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|off
operator|+
name|size
operator|<=
name|PAGE_SIZE
argument_list|,
operator|(
literal|"pmap_zero_page_area: bad off/size"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_area
argument_list|)
expr_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
operator|||
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|pa
argument_list|)
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_area_c
argument_list|)
expr_stmt|;
name|va
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|m
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_area_nc
argument_list|)
expr_stmt|;
name|aszero
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|pa
operator|+
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_nzero_page_area_oc
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|va
operator|=
name|pmap_temp_map_1
operator|+
operator|(
name|m
operator|->
name|md
operator|.
name|color
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|va
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|va
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|va
operator|+
name|off
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|pmap_copy_page
parameter_list|(
name|vm_page_t
name|msrc
parameter_list|,
name|vm_page_t
name|mdst
parameter_list|)
block|{
name|vm_offset_t
name|vdst
decl_stmt|;
name|vm_offset_t
name|vsrc
decl_stmt|;
name|vm_paddr_t
name|pdst
decl_stmt|;
name|vm_paddr_t
name|psrc
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|mdst
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_copy_page: fake dst page"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|msrc
operator|->
name|flags
operator|&
name|PG_FICTITIOUS
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_copy_page: fake src page"
operator|)
argument_list|)
expr_stmt|;
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page
argument_list|)
expr_stmt|;
name|pdst
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|mdst
argument_list|)
expr_stmt|;
name|psrc
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|msrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
operator|||
operator|(
name|msrc
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|psrc
argument_list|)
operator|&&
name|mdst
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|pdst
argument_list|)
operator|)
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_c
argument_list|)
expr_stmt|;
name|vdst
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pdst
argument_list|)
expr_stmt|;
name|vsrc
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|psrc
argument_list|)
expr_stmt|;
name|cpu_block_copy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vsrc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msrc
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
operator|&&
name|mdst
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_nc
argument_list|)
expr_stmt|;
name|ascopy
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|psrc
argument_list|,
name|pdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|msrc
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|mdst
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|pdst
argument_list|)
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_dc
argument_list|)
expr_stmt|;
name|vdst
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pdst
argument_list|)
expr_stmt|;
name|ascopyfrom
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|psrc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_doc
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|vdst
operator|=
name|pmap_temp_map_1
operator|+
operator|(
name|mdst
operator|->
name|md
operator|.
name|color
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|vdst
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pdst
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|vdst
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|ascopyfrom
argument_list|(
name|ASI_PHYS_USE_EC
argument_list|,
name|psrc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|vdst
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mdst
operator|->
name|md
operator|.
name|color
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|msrc
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|psrc
argument_list|)
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_sc
argument_list|)
expr_stmt|;
name|vsrc
operator|=
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|psrc
argument_list|)
expr_stmt|;
name|ascopyto
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vsrc
argument_list|,
name|ASI_PHYS_USE_EC
argument_list|,
name|pdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_soc
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|vsrc
operator|=
name|pmap_temp_map_1
operator|+
operator|(
name|msrc
operator|->
name|md
operator|.
name|color
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|vsrc
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|psrc
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|vsrc
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|ascopyto
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vsrc
argument_list|,
name|ASI_PHYS_USE_EC
argument_list|,
name|pdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|vsrc
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|PMAP_STATS_INC
argument_list|(
name|pmap_ncopy_page_oc
argument_list|)
expr_stmt|;
name|PMAP_LOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
name|vdst
operator|=
name|pmap_temp_map_1
operator|+
operator|(
name|mdst
operator|->
name|md
operator|.
name|color
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|vdst
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pdst
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|vdst
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|vsrc
operator|=
name|pmap_temp_map_2
operator|+
operator|(
name|msrc
operator|->
name|md
operator|.
name|color
operator|*
name|PAGE_SIZE
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|vsrc
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|psrc
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|vsrc
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
name|cpu_block_copy
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vsrc
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vdst
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|vdst
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|kernel_pmap
argument_list|,
name|vsrc
argument_list|)
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|kernel_pmap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|vm_offset_t
name|pmap_quick_enter_page
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|vm_paddr_t
name|pa
decl_stmt|;
name|vm_offset_t
name|qaddr
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|pa
operator|=
name|VM_PAGE_TO_PHYS
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|dcache_color_ignore
operator|!=
literal|0
operator|||
name|m
operator|->
name|md
operator|.
name|color
operator|==
name|DCACHE_COLOR
argument_list|(
name|pa
argument_list|)
condition|)
return|return
operator|(
name|TLB_PHYS_TO_DIRECT
argument_list|(
name|pa
argument_list|)
operator|)
return|;
name|critical_enter
argument_list|()
expr_stmt|;
name|qaddr
operator|=
name|PCPU_GET
argument_list|(
name|qmap_addr
argument_list|)
expr_stmt|;
name|qaddr
operator|+=
operator|(
name|PAGE_SIZE
operator|*
operator|(
operator|(
name|DCACHE_COLORS
operator|+
name|DCACHE_COLOR
argument_list|(
name|pa
argument_list|)
operator|-
name|DCACHE_COLOR
argument_list|(
name|qaddr
argument_list|)
operator|)
operator|%
name|DCACHE_COLORS
operator|)
operator|)
expr_stmt|;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|qaddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|tte_data
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_quick_enter_page: PTE busy"
operator|)
argument_list|)
expr_stmt|;
name|tp
operator|->
name|tte_data
operator|=
name|TD_V
operator||
name|TD_8K
operator||
name|TD_PA
argument_list|(
name|pa
argument_list|)
operator||
name|TD_CP
operator||
name|TD_CV
operator||
name|TD_W
expr_stmt|;
name|tp
operator|->
name|tte_vpn
operator|=
name|TV_VPN
argument_list|(
name|qaddr
argument_list|,
name|TS_8K
argument_list|)
expr_stmt|;
return|return
operator|(
name|qaddr
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmap_quick_remove_page
parameter_list|(
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|vm_offset_t
name|qaddr
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|addr
operator|>=
name|VM_MIN_DIRECT_ADDRESS
condition|)
return|return;
name|tp
operator|=
name|tsb_kvtotte
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|qaddr
operator|=
name|PCPU_GET
argument_list|(
name|qmap_addr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|addr
operator|>=
name|qaddr
operator|)
operator|&&
operator|(
name|addr
operator|<
operator|(
name|qaddr
operator|+
operator|(
name|PAGE_SIZE
operator|*
name|DCACHE_COLORS
operator|)
operator|)
operator|)
argument_list|,
operator|(
literal|"pmap_quick_remove_page: invalid address"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tp
operator|->
name|tte_data
operator|!=
literal|0
argument_list|,
operator|(
literal|"pmap_quick_remove_page: PTE not in use"
operator|)
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DEMAP_VA
argument_list|(
name|addr
argument_list|)
operator||
name|TLB_DEMAP_NUCLEUS
operator||
name|TLB_DEMAP_PAGE
argument_list|,
name|ASI_DMMU_DEMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|TLB_DEMAP_VA
argument_list|(
name|addr
argument_list|)
operator||
name|TLB_DEMAP_NUCLEUS
operator||
name|TLB_DEMAP_PAGE
argument_list|,
name|ASI_IMMU_DEMAP
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flush
argument_list|(
name|KERNBASE
argument_list|)
expr_stmt|;
name|TTE_ZERO
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|unmapped_buf_allowed
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|pmap_copy_pages
parameter_list|(
name|vm_page_t
name|ma
index|[]
parameter_list|,
name|vm_offset_t
name|a_offset
parameter_list|,
name|vm_page_t
name|mb
index|[]
parameter_list|,
name|vm_offset_t
name|b_offset
parameter_list|,
name|int
name|xfersize
parameter_list|)
block|{
name|panic
argument_list|(
literal|"pmap_copy_pages: not implemented"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns true if the pmap's pv is one of the first  * 16 pvs linked to from this page.  This count may  * be changed upwards or downwards in the future; it  * is only necessary that true be returned for a small  * subset of pmaps for proper page aging.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_exists_quick
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|int
name|loops
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_page_exists_quick: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|loops
operator|=
literal|0
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|TTE_GET_PMAP
argument_list|(
name|tp
argument_list|)
operator|==
name|pm
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|++
name|loops
operator|>=
literal|16
condition|)
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of managed mappings to the given physical page  * that are wired.  */
end_comment

begin_function
name|int
name|pmap_page_wired_mappings
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
operator|(
name|TD_PV
operator||
name|TD_WIRED
operator|)
operator|)
operator|==
operator|(
name|TD_PV
operator||
name|TD_WIRED
operator|)
condition|)
name|count
operator|++
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove all pages from specified address space, this aids process exit  * speeds.  This is much faster than pmap_remove in the case of running down  * an entire address space.  Only works for the current pmap.  */
end_comment

begin_function
name|void
name|pmap_remove_pages
parameter_list|(
name|pmap_t
name|pm
parameter_list|)
block|{  }
end_function

begin_comment
comment|/*  * Returns TRUE if the given page has a managed mapping.  */
end_comment

begin_function
name|boolean_t
name|pmap_page_is_mapped
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a count of reference bits for a page, clearing those bits.  * It is not necessary for every reference bit to be cleared, but it  * is necessary that 0 only be returned when there are truly no  * reference bits set.  *  * As an optimization, update the page's dirty field if a modified bit is  * found while counting reference bits.  This opportunistic update can be  * performed at low cost and can eliminate the need for some future calls  * to pmap_is_modified().  However, since this function stops after  * finding PMAP_TS_REFERENCED_MAX reference bits, it may not detect some  * dirty pages.  Those dirty pages will only be detected by a future call  * to pmap_is_modified().  */
end_comment

begin_function
name|int
name|pmap_ts_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tpf
decl_stmt|;
name|struct
name|tte
modifier|*
name|tpn
decl_stmt|;
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|int
name|count
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_ts_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|tpf
operator|=
name|tp
expr_stmt|;
do|do
block|{
name|tpn
operator|=
name|TAILQ_NEXT
argument_list|(
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|m
operator|->
name|md
operator|.
name|tte_list
argument_list|,
name|tp
argument_list|,
name|tte_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|data
operator|=
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_REF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
operator|&&
operator|++
name|count
operator|>=
name|PMAP_TS_REFERENCED_MAX
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|tp
operator|=
name|tpn
operator|)
operator|!=
name|NULL
operator|&&
name|tp
operator|!=
name|tpf
condition|)
do|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|pmap_is_modified
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_modified: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * concurrently set while the object is locked.  Thus, if PGA_WRITEABLE 	 * is clear, no TTEs can have TD_W set. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *	pmap_is_prefaultable:  *  *	Return whether or not the specified virtual address is elgible  *	for prefault.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_prefaultable
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|)
block|{
name|boolean_t
name|rv
decl_stmt|;
name|PMAP_LOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
name|rv
operator|=
name|tsb_tte_lookup
argument_list|(
name|pmap
argument_list|,
name|addr
argument_list|)
operator|==
name|NULL
expr_stmt|;
name|PMAP_UNLOCK
argument_list|(
name|pmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return whether or not the specified physical page was referenced  * in any physical maps.  */
end_comment

begin_function
name|boolean_t
name|pmap_is_referenced
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_is_referenced: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|rv
operator|=
name|FALSE
expr_stmt|;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_REF
operator|)
operator|!=
literal|0
condition|)
block|{
name|rv
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function is advisory.  */
end_comment

begin_function
name|void
name|pmap_advise
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|sva
parameter_list|,
name|vm_offset_t
name|eva
parameter_list|,
name|int
name|advice
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|pmap_clear_modify
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
argument_list|,
operator|(
literal|"pmap_clear_modify: page %p is exclusive busied"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not PGA_WRITEABLE, then no TTEs can have TD_W set. 	 * If the object containing the page is locked and the page is not 	 * exclusive busied, then PGA_WRITEABLE cannot be concurrently set. 	 */
if|if
condition|(
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|data
operator|=
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
name|tlb_page_demap
argument_list|(
name|TTE_GET_PMAP
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_remove_write
parameter_list|(
name|vm_page_t
name|m
parameter_list|)
block|{
name|struct
name|tte
modifier|*
name|tp
decl_stmt|;
name|u_long
name|data
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|oflags
operator|&
name|VPO_UNMANAGED
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"pmap_remove_write: page %p is not managed"
operator|,
name|m
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the page is not exclusive busied, then PGA_WRITEABLE cannot be 	 * set by another thread while the object is locked.  Thus, 	 * if PGA_WRITEABLE is clear, no page table entries need updating. 	 */
name|VM_OBJECT_ASSERT_WLOCKED
argument_list|(
name|m
operator|->
name|object
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vm_page_xbusied
argument_list|(
name|m
argument_list|)
operator|&&
operator|(
name|m
operator|->
name|aflags
operator|&
name|PGA_WRITEABLE
operator|)
operator|==
literal|0
condition|)
return|return;
name|rw_wlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|tp
argument_list|,
argument|&m->md.tte_list
argument_list|,
argument|tte_link
argument_list|)
block|{
if|if
condition|(
operator|(
name|tp
operator|->
name|tte_data
operator|&
name|TD_PV
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|data
operator|=
name|atomic_clear_long
argument_list|(
operator|&
name|tp
operator|->
name|tte_data
argument_list|,
name|TD_SW
operator||
name|TD_W
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|data
operator|&
name|TD_W
operator|)
operator|!=
literal|0
condition|)
block|{
name|vm_page_dirty
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tlb_page_demap
argument_list|(
name|TTE_GET_PMAP
argument_list|(
name|tp
argument_list|)
argument_list|,
name|TTE_GET_VA
argument_list|(
name|tp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|vm_page_aflag_clear
argument_list|(
name|m
argument_list|,
name|PGA_WRITEABLE
argument_list|)
expr_stmt|;
name|rw_wunlock
argument_list|(
operator|&
name|tte_list_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|pmap_mincore
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|addr
parameter_list|,
name|vm_paddr_t
modifier|*
name|locked_pa
parameter_list|)
block|{
comment|/* TODO; */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Activate a user pmap.  The pmap must be activated before its address space  * can be accessed in any way.  */
end_comment

begin_function
name|void
name|pmap_activate
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|)
block|{
name|struct
name|vmspace
modifier|*
name|vm
decl_stmt|;
name|struct
name|pmap
modifier|*
name|pm
decl_stmt|;
name|int
name|context
decl_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|vm
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_vmspace
expr_stmt|;
name|pm
operator|=
name|vmspace_pmap
argument_list|(
name|vm
argument_list|)
expr_stmt|;
name|context
operator|=
name|PCPU_GET
argument_list|(
name|tlb_ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|context
operator|==
name|PCPU_GET
argument_list|(
name|tlb_ctx_max
argument_list|)
condition|)
block|{
name|tlb_flush_user
argument_list|()
expr_stmt|;
name|context
operator|=
name|PCPU_GET
argument_list|(
name|tlb_ctx_min
argument_list|)
expr_stmt|;
block|}
name|PCPU_SET
argument_list|(
name|tlb_ctx
argument_list|,
name|context
operator|+
literal|1
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_context
index|[
name|curcpu
index|]
operator|=
name|context
expr_stmt|;
ifdef|#
directive|ifdef
name|SMP
name|CPU_SET_ATOMIC
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|atomic_store_acq_ptr
argument_list|(
operator|(
name|uintptr_t
operator|*
operator|)
name|PCPU_PTR
argument_list|(
name|pmap
argument_list|)
argument_list|,
operator|(
name|uintptr_t
operator|)
name|pm
argument_list|)
expr_stmt|;
else|#
directive|else
name|CPU_SET
argument_list|(
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
argument_list|,
operator|&
name|pm
operator|->
name|pm_active
argument_list|)
expr_stmt|;
name|PCPU_SET
argument_list|(
name|pmap
argument_list|,
name|pm
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|stxa
argument_list|(
name|AA_DMMU_TSB
argument_list|,
name|ASI_DMMU
argument_list|,
name|pm
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|AA_IMMU_TSB
argument_list|,
name|ASI_IMMU
argument_list|,
name|pm
operator|->
name|pm_tsb
argument_list|)
expr_stmt|;
name|stxa
argument_list|(
name|AA_DMMU_PCXR
argument_list|,
name|ASI_DMMU
argument_list|,
operator|(
name|ldxa
argument_list|(
name|AA_DMMU_PCXR
argument_list|,
name|ASI_DMMU
argument_list|)
operator|&
name|TLB_CXR_PGSZ_MASK
operator|)
operator||
name|context
argument_list|)
expr_stmt|;
name|flush
argument_list|(
name|KERNBASE
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmap_sync_icache
parameter_list|(
name|pmap_t
name|pm
parameter_list|,
name|vm_offset_t
name|va
parameter_list|,
name|vm_size_t
name|sz
parameter_list|)
block|{  }
end_function

begin_comment
comment|/*  * Increase the starting virtual address of the given mapping if a  * different alignment might result in more superpage mappings.  */
end_comment

begin_function
name|void
name|pmap_align_superpage
parameter_list|(
name|vm_object_t
name|object
parameter_list|,
name|vm_ooffset_t
name|offset
parameter_list|,
name|vm_offset_t
modifier|*
name|addr
parameter_list|,
name|vm_size_t
name|size
parameter_list|)
block|{  }
end_function

end_unit

