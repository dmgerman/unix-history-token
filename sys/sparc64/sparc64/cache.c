begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996  *	The President and Fellows of Harvard College. All rights reserved.  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by Harvard University.  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Aaron Brown and  *	Harvard University.  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright (c) 2001 by Thomas Moestl<tmm@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	from: @(#)cache.c	8.2 (Berkeley) 10/30/93  *	from: NetBSD: cache.c,v 1.5 2000/12/06 01:47:50 mrg Exp  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * Cache routines.  *  * UltraSPARCs have a virtually indexed, physically tagged (VIPT) level 1 data  * cache (D$) and physically indexed, physically tagged (PIPT) level 1  * instruction (I$) and Level 2 (E$) caches.  * D$ is directly mapped, I$ is pseudo 2-way associative. The Level 2 cache (E$)  * is documented to be directly mapped on the UltraSPARC IIi, but there are  * apparently models (using the IIe version) that have a 4-way associative E$.  *  * D$ uses a write-through model, while E$ uses write-back and is  * write-allocating. The lines present in D$ are forced to be a subset of those  * in E$.  * This means that lines that are present in D$ always have an identical  * corresponding (sub-) line in E$.  *  * The term "main memory" is used in the following to refer to the non-cache  * memory as well as to memory-mapped device i/o space.  *  * There are 3 documented ways to flush the D$ and E$ caches:  * - displacement flushing (a sequence of loads of addresses that alias to  *   to-be-flushed ones in the caches). This only works for directly mapped  *   caches, and is recommended to flush D$ and E$ in the IIi manual. It is not  *   used to flush E$ because of the aforementioned models that have a  *   multiple-associative E$. Displacement flushing invalidates the cache  *   entries and writes modified lines back to main memory.  * - diagnostic acceses can be used to invalidate cache pages. All lines  *   are discarded, which means that changes in D$/E$ that have not been  *   committed to main memory are lost.  * - block-commit stores. Those use the block transfer ASIs to load a  *   64-byte block to a set of FP registers and store them back using a  *   special ASI that will cause the data to be immediately committed to main  *   memory. This method has the same properties as the first method, but  *   (hopefully) works regardless of the associativity of the caches. It is  *   expected to be slow.  *  * I$ can be handled using the flush instruction.  *  * Some usage guidelines:  *  * The inval functions are variants of the flush ones that discard modified  * cache lines.  * PCI DMA transactions are cache-coherent and do not require flushing  * before DMA reads or after DMA writes. It is unclear from the manual  * how far this applies to UPA transactions.  *  * icache_flush(): needed before code that has been written to memory is  *	executed, because I$ is not necessarily consistent with D$, E$, or  *	main memory. An exception is that I$ snoops DMA transfers, so no  *	flush is required after to-be-executed data has been fetched this way.  * icache_inval_phys(): has roughly same effect as icache_flush() since there  *	are no writes to I$.  *  * dcache_flush(): required when a page mapping is changed from cacheable to  *	noncacheable, or to resolve illegal aliases. Both cases should happen  *	seldom. Mapping address changes do not require this, since D$ is VIPT.  * dcache_inval(): has roughly same effect as dcache_flush() since D$ is  *	write-through.  * dcache_blast(): discards all lines in D$.  *  * ecache_flush(): needed to commit modified lines to main memory, and to make  *	sure that no stale data is used when the main memory has changed without  *	the cache controller noticing. This is e.g. needed for device i/o space.  *	It is usually better to use a non-cacheable mapping in this case.  *	ecache_flush() is guaranteed to also flush the relevant addresses out of  *	D$.  * ecache_inval_phys():  like ecache_flush(), but invalidates a physical range  *	in the cache. This function is usually dangerous and should not be used.  *  * All operations have a line size granularity!  *  * All flush methods tend to be expensive, so unnecessary flushes should be  * avoided.  */
end_comment

begin_include
include|#
directive|include
file|"opt_pmap.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/cache.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/fp.h>
end_include

begin_include
include|#
directive|include
file|<machine/fsr.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/smp.h>
end_include

begin_include
include|#
directive|include
file|<machine/tte.h>
end_include

begin_include
include|#
directive|include
file|<machine/ver.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_decl_stmt
name|struct
name|cacheinfo
name|cache
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PMAP_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|long
name|dcache_npage_inval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|dcache_npage_inval_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|dcache_npage_inval_match
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|icache_npage_inval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|icache_npage_inval_line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|icache_npage_inval_match
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_debug_pmap_stats
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|dcache_npage_inval
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|dcache_npage_inval
argument_list|,
literal|0
argument_list|,
literal|"Number of calls to dcache_page_inval"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|dcache_npage_inval_line
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|dcache_npage_inval_line
argument_list|,
literal|0
argument_list|,
literal|"Number of lines checked"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|dcache_npage_inval_match
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|dcache_npage_inval_match
argument_list|,
literal|0
argument_list|,
literal|"Number of matching lines"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|icache_npage_inval
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|icache_npage_inval
argument_list|,
literal|0
argument_list|,
literal|"Number of calls to icache_page_inval"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|icache_npage_inval_line
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|icache_npage_inval_line
argument_list|,
literal|0
argument_list|,
literal|"Number of lines checked"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_LONG
argument_list|(
name|_debug_pmap_stats
argument_list|,
name|OID_AUTO
argument_list|,
name|icache_npage_inval_match
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|icache_npage_inval_match
argument_list|,
literal|0
argument_list|,
literal|"Number of matching lines"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|PMAP_STATS_INC
parameter_list|(
name|var
parameter_list|)
value|atomic_add_long(&var, 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PMAP_STATS_INC
parameter_list|(
name|var
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Read to %g0, needed for E$ access. */
end_comment

begin_define
define|#
directive|define
name|CDIAG_RDG0
parameter_list|(
name|asi
parameter_list|,
name|addr
parameter_list|)
define|\
value|__asm __volatile("ldxa [%0] %1, %%g0" : : "r" (addr), "I" (asi))
end_define

begin_comment
comment|/* Sigh. I$ diagnostic registers want ldda. */
end_comment

begin_define
define|#
directive|define
name|ICDIAG_RD
parameter_list|(
name|asi
parameter_list|,
name|addr
parameter_list|,
name|r
parameter_list|)
define|\
value|__asm __volatile("ldda [%1] %2, %%o4; mov %%o5, %0" : "=r" (r) :\ 	"r" (addr), "I" (asi) :	"%o4", "%o5");
end_define

begin_define
define|#
directive|define
name|OF_GET
parameter_list|(
name|h
parameter_list|,
name|n
parameter_list|,
name|v
parameter_list|)
value|OF_getprop((h), (n),&(v), sizeof(v))
end_define

begin_comment
comment|/*  * Fill in the cache parameters using the cpu node.  */
end_comment

begin_function
name|void
name|cache_init
parameter_list|(
name|phandle_t
name|node
parameter_list|)
block|{
name|u_long
name|set
decl_stmt|;
if|if
condition|(
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"icache-size"
argument_list|,
name|cache
operator|.
name|ic_size
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"icache-line-size"
argument_list|,
name|cache
operator|.
name|ic_linesize
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"icache-associativity"
argument_list|,
name|cache
operator|.
name|ic_assoc
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"dcache-size"
argument_list|,
name|cache
operator|.
name|dc_size
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"dcache-line-size"
argument_list|,
name|cache
operator|.
name|dc_linesize
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"dcache-associativity"
argument_list|,
name|cache
operator|.
name|dc_assoc
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"ecache-size"
argument_list|,
name|cache
operator|.
name|ec_size
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"ecache-line-size"
argument_list|,
name|cache
operator|.
name|ec_linesize
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|OF_GET
argument_list|(
name|node
argument_list|,
literal|"ecache-associativity"
argument_list|,
name|cache
operator|.
name|ec_assoc
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|panic
argument_list|(
literal|"cache_init: could not retrieve cache parameters"
argument_list|)
expr_stmt|;
name|cache
operator|.
name|ic_set
operator|=
name|cache
operator|.
name|ic_size
operator|/
name|cache
operator|.
name|ic_assoc
expr_stmt|;
name|cache
operator|.
name|ic_l2set
operator|=
name|ffs
argument_list|(
name|cache
operator|.
name|ic_set
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cache
operator|.
name|ic_set
operator|&
operator|~
operator|(
literal|1UL
operator|<<
name|cache
operator|.
name|ic_l2set
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"cache_init: I$ set size not a power of 2"
argument_list|)
expr_stmt|;
name|cache
operator|.
name|dc_l2size
operator|=
name|ffs
argument_list|(
name|cache
operator|.
name|dc_size
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|cache
operator|.
name|dc_size
operator|&
operator|~
operator|(
literal|1UL
operator|<<
name|cache
operator|.
name|dc_l2size
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"cache_init: D$ size not a power of 2"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|cache
operator|.
name|dc_size
operator|/
name|cache
operator|.
name|dc_assoc
operator|)
operator|/
name|PAGE_SIZE
operator|)
operator|!=
name|DCACHE_COLORS
condition|)
name|panic
argument_list|(
literal|"cache_init: too many D$ colors"
argument_list|)
expr_stmt|;
name|set
operator|=
name|cache
operator|.
name|ec_size
operator|/
name|cache
operator|.
name|ec_assoc
expr_stmt|;
name|cache
operator|.
name|ec_l2set
operator|=
name|ffs
argument_list|(
name|set
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|set
operator|&
operator|~
operator|(
literal|1UL
operator|<<
name|cache
operator|.
name|ec_l2set
operator|)
operator|)
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"cache_init: E$ set size not a power of 2"
argument_list|)
expr_stmt|;
name|cache
operator|.
name|c_enabled
operator|=
literal|1
expr_stmt|;
comment|/* enable cache flushing */
block|}
end_function

begin_function
name|void
name|dcache_page_inval
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
name|u_long
name|target
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
name|u_long
name|tag
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"dcache_page_inval: pa not page aligned"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
name|PMAP_STATS_INC
argument_list|(
name|dcache_npage_inval
argument_list|)
expr_stmt|;
name|target
operator|=
name|pa
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|DC_TAG_SHIFT
operator|)
expr_stmt|;
name|cookie
operator|=
name|ipi_dcache_page_inval
argument_list|(
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|cache
operator|.
name|dc_size
condition|;
name|addr
operator|+=
name|cache
operator|.
name|dc_linesize
control|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|dcache_npage_inval_line
argument_list|)
expr_stmt|;
name|tag
operator|=
name|ldxa
argument_list|(
name|addr
argument_list|,
name|ASI_DCACHE_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|tag
operator|>>
name|DC_VALID_SHIFT
operator|)
operator|&
name|DC_VALID_MASK
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|tag
operator|&=
name|DC_TAG_MASK
operator|<<
name|DC_TAG_SHIFT
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|target
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|dcache_npage_inval_match
argument_list|)
expr_stmt|;
name|stxa_sync
argument_list|(
name|addr
argument_list|,
name|ASI_DCACHE_TAG
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
name|ipi_wait
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|icache_page_inval
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|)
block|{
specifier|register
name|u_long
name|tag
asm|__asm("%g1");
name|u_long
name|target
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|u_long
name|addr
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|pa
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"icache_page_inval: pa not page aligned"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
name|PMAP_STATS_INC
argument_list|(
name|icache_npage_inval
argument_list|)
expr_stmt|;
name|target
operator|=
name|pa
operator|>>
operator|(
name|PAGE_SHIFT
operator|-
name|IC_TAG_SHIFT
operator|)
expr_stmt|;
name|cookie
operator|=
name|ipi_icache_page_inval
argument_list|(
name|pa
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
literal|0
init|;
name|addr
operator|<
name|cache
operator|.
name|ic_size
condition|;
name|addr
operator|+=
name|cache
operator|.
name|ic_linesize
control|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|icache_npage_inval_line
argument_list|)
expr_stmt|;
asm|__asm __volatile("ldda [%1] %2, %%g0"
comment|/*, %g1 */
block|:
literal|"=r"
operator|(
name|tag
operator|)
operator|:
literal|"r"
operator|(
name|addr
operator|)
operator|,
literal|"n"
operator|(
name|ASI_ICACHE_TAG
operator|)
block|)
empty_stmt|;
if|if
condition|(
operator|(
operator|(
name|tag
operator|>>
name|IC_VALID_SHIFT
operator|)
operator|&
name|IC_VALID_MASK
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|tag
operator|&=
name|IC_TAG_MASK
operator|<<
name|IC_TAG_SHIFT
expr_stmt|;
if|if
condition|(
name|tag
operator|==
name|target
condition|)
block|{
name|PMAP_STATS_INC
argument_list|(
name|icache_npage_inval_match
argument_list|)
expr_stmt|;
name|stxa_sync
argument_list|(
name|addr
argument_list|,
name|ASI_ICACHE_TAG
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|ipi_wait
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/* Flush a range of addresses from I$ using the flush instruction. */
end_comment

begin_macro
unit|void
name|icache_flush
argument_list|(
argument|vm_offset_t start
argument_list|,
argument|vm_offset_t end
argument_list|)
end_macro

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|ls
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
name|ls
operator|=
name|cache
operator|.
name|ic_linesize
expr_stmt|;
name|ep
operator|=
operator|(
name|char
operator|*
operator|)
name|ulmin
argument_list|(
name|end
argument_list|,
name|start
operator|+
name|cache
operator|.
name|ic_size
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|start
init|;
name|p
operator|<
name|ep
condition|;
name|p
operator|+=
name|ls
control|)
name|flush
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Invalidate a I$ physical range using diagnostic accesses.  * NOTE: there is a race between checking the tag and invalidating it. It  * cannot be closed by disabling interrupts, since the fetch for the next  * instruction may be in that line, so we don't even bother.  * Since blasting a line does not discard data, this has no ill effect except  * a minor slowdown.  */
end_comment

begin_function
name|void
name|icache_inval_phys
parameter_list|(
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|,
name|ica
decl_stmt|;
name|u_long
name|tag
decl_stmt|;
name|u_long
name|j
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
for|for
control|(
name|addr
operator|=
name|start
operator|&
operator|~
operator|(
name|cache
operator|.
name|ic_linesize
operator|-
literal|1
operator|)
init|;
name|addr
operator|<=
name|end
condition|;
name|addr
operator|+=
name|cache
operator|.
name|ic_linesize
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|ica
operator|=
operator|(
name|addr
operator|&
operator|(
name|cache
operator|.
name|ic_set
operator|-
literal|1
operator|)
operator|)
operator||
name|ICDA_SET
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|ICDIAG_RD
argument_list|(
name|ASI_ICACHE_TAG
argument_list|,
name|ica
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tag
operator|&
name|ICDT_VALID
operator|)
operator|==
literal|0
operator|||
name|ICDT_TAG
argument_list|(
name|tag
argument_list|)
operator|!=
name|addr
operator|>>
name|cache
operator|.
name|ic_l2set
condition|)
continue|continue;
name|stxa_sync
argument_list|(
name|ica
argument_list|,
name|ASI_ICACHE_TAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Flush a range of addresses from D$ using displacement flushes. This does  * not necessarily flush E$, because we do not take care of flushing the  * correct physical colors and E$ may not be directly mapped.  */
end_comment

begin_function
name|void
name|dcache_flush
parameter_list|(
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|int
name|j
decl_stmt|;
name|vm_offset_t
name|baseoff
decl_stmt|;
name|u_long
name|i
decl_stmt|,
name|mask
decl_stmt|;
name|char
modifier|*
name|kp
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
name|mask
operator|=
name|cache
operator|.
name|dc_size
operator|-
literal|1
expr_stmt|;
comment|/* No need to flush lines more than once. */
name|baseoff
operator|=
name|start
operator|&
name|mask
expr_stmt|;
comment|/* 	 * Use a locked page for flushing. D$ should be smaller than 4M, which 	 * is somewhat likely... 	 */
name|kp
operator|=
operator|(
name|char
operator|*
operator|)
name|KERNBASE
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|ulmin
argument_list|(
operator|(
name|end
operator|-
name|start
operator|)
argument_list|,
name|cache
operator|.
name|dc_size
argument_list|)
condition|;
name|i
operator|+=
name|cache
operator|.
name|dc_linesize
control|)
name|j
operator|+=
name|kp
index|[
operator|(
name|baseoff
operator|+
name|i
operator|)
operator|&
name|mask
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invalidate a D$ range using diagnostic accesses.  * This has the same (harmless) races as icache_blast().  */
end_comment

begin_function
name|void
name|dcache_inval
parameter_list|(
name|pmap_t
name|pmap
parameter_list|,
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_offset_t
name|va
decl_stmt|,
name|pa
decl_stmt|,
name|offs
decl_stmt|,
name|dca
decl_stmt|;
name|u_long
name|tag
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
for|for
control|(
name|va
operator|=
name|start
operator|&
operator|~
operator|(
name|cache
operator|.
name|dc_linesize
operator|-
literal|1
operator|)
init|;
name|va
operator|<=
name|end
condition|;
name|va
operator|=
operator|(
name|va
operator|+
name|PAGE_SIZE_MIN
operator|)
operator|&
operator|~
name|PAGE_MASK_MIN
control|)
block|{
if|if
condition|(
operator|(
name|pa
operator|=
name|pmap_extract
argument_list|(
name|pmap
argument_list|,
name|va
argument_list|)
operator|)
operator|==
literal|0
condition|)
continue|continue;
for|for
control|(
name|offs
operator|=
name|start
operator|&
name|PAGE_MASK_MIN
init|;
name|offs
operator|<
name|ulmin
argument_list|(
name|PAGE_SIZE_MIN
argument_list|,
name|end
operator|-
name|va
operator|+
literal|1
argument_list|)
condition|;
name|offs
operator|+=
name|cache
operator|.
name|dc_linesize
control|)
block|{
name|dca
operator|=
operator|(
name|va
operator|+
name|offs
operator|)
operator|&
operator|(
name|cache
operator|.
name|dc_size
operator|-
literal|1
operator|)
expr_stmt|;
name|tag
operator|=
name|ldxa
argument_list|(
name|dca
argument_list|,
name|ASI_DCACHE_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|DCDT_TAG
argument_list|(
name|tag
argument_list|)
operator|!=
operator|(
name|pa
operator|+
name|offs
operator|)
operator|>>
name|PAGE_SHIFT_MIN
condition|)
continue|continue;
name|stxa_sync
argument_list|(
name|dca
argument_list|,
name|ASI_DCACHE_TAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Invalidate a physical D$ range using diagnostic accesses.  * This has the same (harmless) races as icache_blast().  */
end_comment

begin_function
name|void
name|dcache_inval_phys
parameter_list|(
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_offset_t
name|pa
decl_stmt|,
name|dca
decl_stmt|;
name|u_long
name|tag
decl_stmt|,
name|color
decl_stmt|,
name|ncolors
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
name|ncolors
operator|=
literal|1
operator|<<
operator|(
name|cache
operator|.
name|dc_l2size
operator|-
name|PAGE_SHIFT_MIN
operator|)
expr_stmt|;
for|for
control|(
name|pa
operator|=
name|start
operator|&
operator|~
operator|(
name|cache
operator|.
name|dc_linesize
operator|-
literal|1
operator|)
init|;
name|pa
operator|<=
name|end
condition|;
name|pa
operator|+=
name|cache
operator|.
name|dc_linesize
control|)
block|{
for|for
control|(
name|color
operator|=
literal|0
init|;
name|color
operator|<
name|ncolors
condition|;
name|color
operator|++
control|)
block|{
name|dca
operator|=
operator|(
name|color
operator|<<
name|PAGE_SHIFT_MIN
operator|)
operator||
operator|(
name|pa
operator|&
name|PAGE_MASK_MIN
operator|)
expr_stmt|;
name|tag
operator|=
name|ldxa
argument_list|(
name|dca
argument_list|,
name|ASI_DCACHE_TAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|DCDT_TAG
argument_list|(
name|tag
argument_list|)
operator|==
name|pa
operator|>>
name|PAGE_SHIFT_MIN
condition|)
block|{
name|stxa_sync
argument_list|(
name|dca
argument_list|,
name|ASI_DCACHE_TAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Discard all lines in D$. */
end_comment

begin_function
name|void
name|dcache_blast
parameter_list|()
block|{
name|vm_offset_t
name|dca
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
for|for
control|(
name|dca
operator|=
literal|0
init|;
name|dca
operator|<
name|cache
operator|.
name|dc_size
condition|;
name|dca
operator|+=
name|cache
operator|.
name|dc_linesize
control|)
name|stxa_sync
argument_list|(
name|dca
argument_list|,
name|ASI_DCACHE_TAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Flush a E$ physical range using block commit stores. */
end_comment

begin_function
name|void
name|ecache_flush
parameter_list|(
name|vm_offset_t
name|start
parameter_list|,
name|vm_offset_t
name|end
parameter_list|)
block|{
name|vm_offset_t
name|addr
decl_stmt|;
if|if
condition|(
operator|!
name|cache
operator|.
name|c_enabled
condition|)
return|return;
comment|/* XXX: not needed in all cases, provide a wrapper in fp.c */
name|savefpctx
argument_list|(
operator|&
name|curthread
operator|->
name|td_pcb
operator|->
name|pcb_fpstate
argument_list|)
expr_stmt|;
name|wr
argument_list|(
name|fprs
argument_list|,
literal|0
argument_list|,
name|FPRS_FEF
argument_list|)
expr_stmt|;
for|for
control|(
name|addr
operator|=
name|start
operator|&
operator|~
operator|(
name|cache
operator|.
name|ec_linesize
operator|-
literal|1
operator|)
init|;
name|addr
operator|<=
name|end
condition|;
name|addr
operator|+=
name|cache
operator|.
name|ec_linesize
control|)
block|{
asm|__asm __volatile("ldda [%0] %1, %%f0; membar #Sync; "
literal|"stda %%f0, [%0] %2"
operator|:
operator|:
literal|"r"
operator|(
name|addr
operator|)
operator|,
literal|"I"
operator|(
name|ASI_BLK_S
operator|)
operator|,
literal|"I"
operator|(
name|ASI_BLK_COMMIT_S
operator|)
block|)
empty_stmt|;
block|}
end_function

begin_expr_stmt
name|membar
argument_list|(
name|Sync
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|restorefpctx
argument_list|(
operator|&
name|curthread
operator|->
name|td_pcb
operator|->
name|pcb_fpstate
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
unit|}
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Invalidate a E$ range using diagnostic accesses.  * This is disabled: it suffers from the same races as dcache_blast() and  * icache_blast_phys(), but they may be fatal here because blasting an E$ line  * can discard modified data.  * There is no really use for this anyway.  */
end_comment

begin_comment
unit|void ecache_inval_phys(vm_offset_t start, vm_offset_t end) { 	vm_offset_t addr, eca; 	u_long tag, j;  	if (!cache.c_enabled) 		return;  	for (addr = start& ~(cache.ec_linesize - 1); addr<= end; 	     addr += cache.ec_linesize) { 		for (j = 0; j< cache.ec_assoc; j++) {
comment|/* XXX: guesswork... */
end_comment

begin_comment
unit|eca = (addr& (cache.ec_size - 1)) | 			    (j<< (cache.ec_l2set));
comment|/* 			 * Retrieve the tag: 			 * A read from the appropriate VA in ASI_ECACHE_R 			 * will transfer the tag from the tag RAM to the 			 * data register (ASI_ECACHE_TAG_DATA, VA 0). 			 */
end_comment

begin_comment
unit|CDIAG_RDG0(ASI_ECACHE_R, ECDA_TAG | eca); 			tag = ldxa(0, ASI_ECACHE_TAG_DATA); 			if ((addr& ~cache.ec_size)>> cache.ec_l2set == 			    (tag& ECDT_TAG_MASK)) {
comment|/* 				 * Clear. Works like retrieving the tag, but 				 * the other way round. 				 */
end_comment

begin_endif
unit|stxa_sync(0, ASI_ECACHE_TAG_DATA, 0); 				stxa_sync(ECDA_TAG | eca, ASI_ECACHE_W, 0); 			} 		} 	} }
endif|#
directive|endif
end_endif

end_unit

