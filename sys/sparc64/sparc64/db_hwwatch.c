begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Jake Burkholder.  * All rights reserved.  * Copyright 2001 by Thomas Moestl<tmm@FreeBSD.org>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<machine/asi.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/lsu.h>
end_include

begin_include
include|#
directive|include
file|<machine/watch.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_variables.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_watch.h>
end_include

begin_function_decl
name|int
name|db_md_set_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|db_md_clr_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|db_md_list_watchpoints
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_watch_print
parameter_list|(
name|vm_offset_t
name|wp
parameter_list|,
name|int
name|bm
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|watch_phys_set_mask
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa_sync
argument_list|(
name|AA_DMMU_PWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|pa
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|38
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_PW
operator|)
operator|&
operator|~
name|LSU_PM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_PM_SHIFT
operator|)
expr_stmt|;
name|stxa_sync
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|watch_phys_set
parameter_list|(
name|vm_offset_t
name|pa
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|pa
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_phys_set_mask
argument_list|(
name|pa
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|watch_phys_get
parameter_list|(
name|int
modifier|*
name|bm
parameter_list|)
block|{
name|u_long
name|pa
decl_stmt|;
name|u_long
name|lsucr
decl_stmt|;
if|if
condition|(
operator|!
name|watch_phys_active
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|pa
operator|=
name|ldxa
argument_list|(
name|AA_DMMU_PWPR
argument_list|,
name|ASI_DMMU
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
operator|*
name|bm
operator|=
operator|(
name|lsucr
operator|&
name|LSU_PM_MASK
operator|)
operator|>>
name|LSU_PM_SHIFT
expr_stmt|;
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|pa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|watch_phys_clear
parameter_list|()
block|{
name|stxa_sync
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
operator|&
operator|~
name|LSU_PW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|watch_phys_active
parameter_list|()
block|{
return|return
operator|(
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
operator|&
name|LSU_PW
operator|)
return|;
block|}
end_function

begin_function
name|int
name|watch_virt_set_mask
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|u_long
name|mask
parameter_list|)
block|{
name|u_long
name|lsucr
decl_stmt|;
name|stxa_sync
argument_list|(
name|AA_DMMU_VWPR
argument_list|,
name|ASI_DMMU
argument_list|,
name|va
operator|&
operator|(
operator|(
operator|(
literal|2UL
operator|<<
literal|41
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|3
operator|)
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
name|lsucr
operator|=
operator|(
operator|(
name|lsucr
operator||
name|LSU_VW
operator|)
operator|&
operator|~
name|LSU_VM_MASK
operator|)
operator||
operator|(
name|mask
operator|<<
name|LSU_VM_SHIFT
operator|)
expr_stmt|;
name|stxa_sync
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|lsucr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|watch_virt_set
parameter_list|(
name|vm_offset_t
name|va
parameter_list|,
name|int
name|sz
parameter_list|)
block|{
name|u_long
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|u_long
operator|)
name|va
operator|&
literal|7
expr_stmt|;
comment|/* Test for misaligned watch points. */
if|if
condition|(
name|off
operator|+
name|sz
operator|>
literal|8
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|watch_virt_set_mask
argument_list|(
name|va
argument_list|,
operator|(
operator|(
literal|1
operator|<<
name|sz
operator|)
operator|-
literal|1
operator|)
operator|<<
name|off
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|vm_offset_t
name|watch_virt_get
parameter_list|(
name|int
modifier|*
name|bm
parameter_list|)
block|{
name|u_long
name|va
decl_stmt|;
name|u_long
name|lsucr
decl_stmt|;
if|if
condition|(
operator|!
name|watch_virt_active
argument_list|()
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|va
operator|=
name|ldxa
argument_list|(
name|AA_DMMU_VWPR
argument_list|,
name|ASI_DMMU
argument_list|)
expr_stmt|;
name|lsucr
operator|=
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
expr_stmt|;
operator|*
name|bm
operator|=
operator|(
name|lsucr
operator|&
name|LSU_VM_MASK
operator|)
operator|>>
name|LSU_VM_SHIFT
expr_stmt|;
return|return
operator|(
operator|(
name|vm_offset_t
operator|)
name|va
operator|)
return|;
block|}
end_function

begin_function
name|void
name|watch_virt_clear
parameter_list|()
block|{
name|stxa_sync
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|,
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
operator|&
operator|~
name|LSU_VW
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|watch_virt_active
parameter_list|()
block|{
return|return
operator|(
name|ldxa
argument_list|(
literal|0
argument_list|,
name|ASI_LSU_CTL_REG
argument_list|)
operator|&
name|LSU_VW
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_md_set_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
name|int
name|dummy
decl_stmt|;
if|if
condition|(
name|watch_virt_active
argument_list|()
condition|)
block|{
name|db_printf
argument_list|(
literal|"Overwriting previously active watch point at "
literal|"0x%lx\n"
argument_list|,
name|watch_virt_get
argument_list|(
operator|&
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|watch_virt_set
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_md_clr_watchpoint
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
name|size
parameter_list|)
block|{
name|watch_virt_clear
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_watch_print
parameter_list|(
name|vm_offset_t
name|wp
parameter_list|,
name|int
name|bm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|db_printf
argument_list|(
literal|"\tat 0x%lx, active bytes: "
argument_list|,
operator|(
name|u_long
operator|)
name|wp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|bm
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
operator|)
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"%d "
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bm
operator|==
literal|0
condition|)
name|db_printf
argument_list|(
literal|"none"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_md_list_watchpoints
parameter_list|(
name|void
parameter_list|)
block|{
name|vm_offset_t
name|wp
decl_stmt|;
name|int
name|bm
decl_stmt|;
name|db_printf
argument_list|(
literal|"Physical address watchpoint:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|watch_phys_active
argument_list|()
condition|)
block|{
name|wp
operator|=
name|watch_phys_get
argument_list|(
operator|&
name|bm
argument_list|)
expr_stmt|;
name|db_watch_print
argument_list|(
name|wp
argument_list|,
name|bm
argument_list|)
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"\tnot active.\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Virtual address watchpoint:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|watch_virt_active
argument_list|()
condition|)
block|{
name|wp
operator|=
name|watch_virt_get
argument_list|(
operator|&
name|bm
argument_list|)
expr_stmt|;
name|db_watch_print
argument_list|(
name|wp
argument_list|,
name|bm
argument_list|)
expr_stmt|;
block|}
else|else
name|db_printf
argument_list|(
literal|"\tnot active.\n"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

