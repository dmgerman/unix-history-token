begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 by Thomas Moestl<tmm@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktr.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/emul.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/instr.h>
end_include

begin_comment
comment|/*  * Alpha-compatible sysctls to control the alignment fixup.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unaligned_print
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* warn about unaligned accesses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unaligned_fix
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fix up unaligned accesses */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unaligned_sigbus
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't SIGBUS on fixed-up accesses */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|unaligned_print
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unaligned_print
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|unaligned_fix
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unaligned_fix
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_machdep
argument_list|,
name|OID_AUTO
argument_list|,
name|unaligned_sigbus
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|unaligned_sigbus
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|emul_fetch_reg
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_long
modifier|*
name|val
parameter_list|)
block|{
name|u_long
name|offs
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"emul_fetch_reg: register %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|IREG_G0
condition|)
operator|*
name|val
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<
name|IREG_O0
condition|)
comment|/* global */
operator|*
name|val
operator|=
name|tf
operator|->
name|tf_global
index|[
name|reg
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<
name|IREG_L0
condition|)
comment|/* out */
operator|*
name|val
operator|=
name|tf
operator|->
name|tf_out
index|[
name|reg
operator|-
name|IREG_O0
index|]
expr_stmt|;
else|else
block|{
comment|/* local, in */
comment|/* 		 * The in registers are immediately after the locals in 		 * the frame. 		 */
name|offs
operator|=
name|offsetof
argument_list|(
expr|struct
name|frame
argument_list|,
name|fr_local
index|[
name|reg
operator|-
name|IREG_L0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|tf
operator|->
name|tf_sp
operator|+
name|SPOFF
operator|+
name|offs
operator|)
argument_list|,
name|val
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|val
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|emul_store_reg
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|int
name|reg
parameter_list|,
name|u_long
name|val
parameter_list|)
block|{
name|u_long
name|offs
decl_stmt|;
name|CTR1
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"emul_store_reg: register %d"
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|IREG_G0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|reg
operator|<
name|IREG_O0
condition|)
comment|/* global */
name|tf
operator|->
name|tf_global
index|[
name|reg
index|]
operator|=
name|val
expr_stmt|;
elseif|else
if|if
condition|(
name|reg
operator|<
name|IREG_L0
condition|)
comment|/* out */
name|tf
operator|->
name|tf_out
index|[
name|reg
operator|-
name|IREG_O0
index|]
operator|=
name|val
expr_stmt|;
else|else
block|{
comment|/* local, in */
comment|/* 		 * The in registers are immediately after the locals in 		 * the frame. 		 */
name|offs
operator|=
name|offsetof
argument_list|(
expr|struct
name|frame
argument_list|,
name|fr_local
index|[
name|reg
operator|-
name|IREG_L0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|val
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|tf
operator|->
name|tf_sp
operator|+
name|SPOFF
operator|+
name|offs
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|val
argument_list|)
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve rs2 or use the immediate value from the instruction */
end_comment

begin_function
specifier|static
name|int
name|f3_op2
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|u_int
name|insn
parameter_list|,
name|u_long
modifier|*
name|op2
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|IF_F3_I
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|op2
operator|=
name|IF_SIMM
argument_list|(
name|insn
argument_list|,
literal|13
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|emul_fetch_reg
argument_list|(
name|tf
argument_list|,
name|IF_F3_RS2
argument_list|(
name|insn
argument_list|)
argument_list|,
name|op2
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX: should the addr from the sfar be used instead of decoding the  * instruction?  */
end_comment

begin_function
specifier|static
name|int
name|f3_memop_addr
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|u_int
name|insn
parameter_list|,
name|u_long
modifier|*
name|addr
parameter_list|)
block|{
name|u_long
name|addr1
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|f3_op2
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
operator|&
name|addr1
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|CTR2
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"f3_memop_addr: addr1: %#lx (imm %d)"
argument_list|,
name|addr1
argument_list|,
name|IF_F3_I
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|emul_fetch_reg
argument_list|(
name|tf
argument_list|,
name|IF_F3_RS1
argument_list|(
name|insn
argument_list|)
argument_list|,
name|addr
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|+=
name|addr1
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fixup_st
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|u_int
name|insn
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|u_long
name|addr
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|f3_memop_addr
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|emul_fetch_reg
argument_list|(
name|tf
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|,
operator|&
name|reg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|reg
operator|<<=
literal|8
operator|*
operator|(
literal|8
operator|-
name|size
operator|)
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"fixup_st: writing to %#lx"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
return|return
operator|(
name|copyout
argument_list|(
operator|&
name|reg
argument_list|,
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fixup_ld
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|u_int
name|insn
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|u_long
name|addr
decl_stmt|,
name|reg
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|f3_memop_addr
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
operator|&
name|addr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|reg
operator|=
literal|0
expr_stmt|;
name|CTR1
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"fixup_ld: reading from %#lx"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|reg
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|reg
operator|>>=
literal|8
operator|*
operator|(
literal|8
operator|-
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|sign
operator|&&
name|size
operator|<
literal|8
condition|)
block|{
comment|/* Need to sign-extend. */
name|reg
operator|=
name|IF_SEXT
argument_list|(
name|reg
argument_list|,
name|size
operator|*
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|emul_store_reg
argument_list|(
name|tf
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|,
name|reg
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * NOTE: fixed up loads and stores are not atomical any more (in some cases,  * they could be made, though, but that is not implemented yet). This means  * that in some sorts of programs, this emulation could cause bugs.  * XXX: this is still very incomplete!  */
end_comment

begin_function
name|int
name|unaligned_fixup
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|u_int
name|insn
decl_stmt|;
name|int
name|fixed
decl_stmt|,
name|error
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
name|rwindow_save
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The process will need to be killed without sending a 		 * signal; let the signal code do that. 		 */
return|return
operator|(
name|SIGBUS
operator|)
return|;
block|}
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tf
operator|->
name|tf_tpc
argument_list|,
operator|&
name|insn
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SIGBUS
operator|)
return|;
name|CTR1
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"unaligned_fixup: insn %x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
name|fixed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|unaligned_fix
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IF_OP
argument_list|(
name|insn
argument_list|)
operator|==
name|IOP_LDST
condition|)
block|{
name|fixed
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|IF_F3_OP3
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INS3_LDUH
case|:
name|error
operator|=
name|fixup_ld
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_LDUW
case|:
name|error
operator|=
name|fixup_ld
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_LDX
case|:
name|error
operator|=
name|fixup_ld
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_LDSH
case|:
name|error
operator|=
name|fixup_ld
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_LDSW
case|:
name|error
operator|=
name|fixup_ld
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_STH
case|:
name|error
operator|=
name|fixup_st
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_STW
case|:
name|error
operator|=
name|fixup_st
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
case|case
name|INS3_STX
case|:
name|error
operator|=
name|fixup_st
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
literal|8
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fixed
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|SIGBUS
operator|)
return|;
block|}
name|CTR5
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"unaligned_fixup: pid %d, va=%#lx pc=%#lx "
literal|"npc=%#lx, fixed=%d"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|tf
operator|->
name|tf_sfar
argument_list|,
name|tf
operator|->
name|tf_tpc
argument_list|,
name|tf
operator|->
name|tf_tnpc
argument_list|,
name|fixed
argument_list|)
expr_stmt|;
if|if
condition|(
name|unaligned_print
operator|||
operator|!
name|fixed
condition|)
block|{
name|uprintf
argument_list|(
literal|"pid %d (%s): unaligned access: va=%#lx pc=%#lx "
literal|"npc=%#lx %s\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|tf
operator|->
name|tf_sfar
argument_list|,
name|tf
operator|->
name|tf_tpc
argument_list|,
name|tf
operator|->
name|tf_tnpc
argument_list|,
name|fixed
condition|?
literal|"(fixed)"
else|:
literal|"(unfixable)"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fixed
operator|&&
operator|!
name|unaligned_sigbus
condition|?
literal|0
else|:
name|SIGBUS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|emul_popc
parameter_list|(
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|,
name|u_int
name|insn
parameter_list|)
block|{
name|u_long
name|reg
decl_stmt|,
name|res
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|IF_F3_RS1
argument_list|(
name|insn
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SIGILL
operator|)
return|;
if|if
condition|(
name|f3_op2
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|,
operator|&
name|reg
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SIGBUS
operator|)
return|;
name|res
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|res
operator|+=
operator|(
name|reg
operator|>>
name|i
operator|)
operator|&
literal|1
expr_stmt|;
if|if
condition|(
name|emul_store_reg
argument_list|(
name|tf
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|,
name|res
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SIGBUS
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Emulate unimplemented instructions, if applicable.  * Only handles popc right now.  */
end_comment

begin_function
name|int
name|emul_insn
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|trapframe
modifier|*
name|tf
parameter_list|)
block|{
name|u_int
name|insn
decl_stmt|;
if|if
condition|(
name|rwindow_save
argument_list|(
name|td
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * The process will need to be killed without sending a 		 * signal; let the signal code do that. 		 */
return|return
operator|(
name|SIGBUS
operator|)
return|;
block|}
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|tf
operator|->
name|tf_tpc
argument_list|,
operator|&
name|insn
argument_list|,
sizeof|sizeof
argument_list|(
name|insn
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SIGBUS
operator|)
return|;
name|CTR1
argument_list|(
name|KTR_TRAP
argument_list|,
literal|"emulate_insn: insn %x"
argument_list|,
name|insn
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|IF_OP
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|IOP_MISC
case|:
switch|switch
condition|(
name|IF_F3_OP3
argument_list|(
name|insn
argument_list|)
condition|)
block|{
case|case
name|INS2_POPC
case|:
return|return
operator|(
name|emul_popc
argument_list|(
name|tf
argument_list|,
name|insn
argument_list|)
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|SIGILL
operator|)
return|;
block|}
end_function

end_unit

