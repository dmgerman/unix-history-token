begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 Scott Long  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*	$NetBSD: lsi64854.c,v 1.25 2005/02/27 00:27:02 perry Exp $ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1998 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Paul Kranenburg.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD  *        Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/rman.h>
end_include

begin_include
include|#
directive|include
file|<machine/bus.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/sbus/lsi64854reg.h>
end_include

begin_include
include|#
directive|include
file|<sparc64/sbus/lsi64854var.h>
end_include

begin_include
include|#
directive|include
file|<dev/esp/ncr53c9xreg.h>
end_include

begin_include
include|#
directive|include
file|<dev/esp/ncr53c9xvar.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|LDB_SCSI
value|1
end_define

begin_define
define|#
directive|define
name|LDB_ENET
value|2
end_define

begin_define
define|#
directive|define
name|LDB_PP
value|4
end_define

begin_define
define|#
directive|define
name|LDB_ANY
value|0xff
end_define

begin_decl_stmt
name|int
name|lsi64854debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|)
value|do { if (lsi64854debug& (a)) printf x ; } while (0)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINTF
parameter_list|(
name|a
parameter_list|,
name|x
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_DMA_SZ
value|(16*1024*1024)
end_define

begin_function_decl
specifier|static
name|void
name|lsi64854_reset
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lsi64854_map_scsi
parameter_list|(
name|void
modifier|*
parameter_list|,
name|bus_dma_segment_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lsi64854_setup
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lsi64854_scsi_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lsi64854_enet_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lsi64854_setup_pp
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|lsi64854_pp_intr
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Finish attaching this DMA device.  * Front-end must fill in these fields:  *	sc_res  *	sc_burst  *	sc_channel (one of SCSI, ENET, PP)  *	sc_client (one of SCSI, ENET, PP `soft_c' pointers)  */
end_comment

begin_function
name|int
name|lsi64854_attach
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
name|sc
parameter_list|)
block|{
name|bus_dma_lock_t
modifier|*
name|lockfunc
decl_stmt|;
name|struct
name|ncr53c9x_softc
modifier|*
name|nsc
decl_stmt|;
name|void
modifier|*
name|lockfuncarg
decl_stmt|;
name|uint32_t
name|csr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|lockfunc
operator|=
name|NULL
expr_stmt|;
name|lockfuncarg
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_channel
condition|)
block|{
case|case
name|L64854_CHANNEL_SCSI
case|:
name|nsc
operator|=
name|sc
operator|->
name|sc_client
expr_stmt|;
if|if
condition|(
name|NCR_LOCK_INITIALIZED
argument_list|(
name|nsc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"mutex not initialized\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|lockfunc
operator|=
name|busdma_lock_mutex
expr_stmt|;
name|lockfuncarg
operator|=
operator|&
name|nsc
operator|->
name|sc_lock
expr_stmt|;
name|sc
operator|->
name|intr
operator|=
name|lsi64854_scsi_intr
expr_stmt|;
name|sc
operator|->
name|setup
operator|=
name|lsi64854_setup
expr_stmt|;
break|break;
case|case
name|L64854_CHANNEL_ENET
case|:
name|sc
operator|->
name|intr
operator|=
name|lsi64854_enet_intr
expr_stmt|;
break|break;
case|case
name|L64854_CHANNEL_PP
case|:
name|sc
operator|->
name|intr
operator|=
name|lsi64854_pp_intr
expr_stmt|;
name|sc
operator|->
name|setup
operator|=
name|lsi64854_setup_pp
expr_stmt|;
break|break;
default|default:
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"unknown channel\n"
argument_list|)
expr_stmt|;
block|}
name|sc
operator|->
name|reset
operator|=
name|lsi64854_reset
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|setup
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|bus_dma_tag_create
argument_list|(
name|sc
operator|->
name|sc_parent_dmat
argument_list|,
comment|/* parent */
literal|1
argument_list|,
literal|0
argument_list|,
comment|/* alignment, boundary */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* lowaddr */
name|BUS_SPACE_MAXADDR
argument_list|,
comment|/* highaddr */
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* filter, filterarg */
name|MAX_DMA_SZ
argument_list|,
comment|/* maxsize */
literal|1
argument_list|,
comment|/* nsegments */
name|MAX_DMA_SZ
argument_list|,
comment|/* maxsegsize */
name|BUS_DMA_ALLOCNOW
argument_list|,
comment|/* flags */
name|lockfunc
argument_list|,
name|lockfuncarg
argument_list|,
comment|/* lockfunc, lockfuncarg */
operator|&
name|sc
operator|->
name|sc_buffer_dmat
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"cannot allocate buffer DMA tag\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|bus_dmamap_create
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
literal|0
argument_list|,
operator|&
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA map create failed\n"
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_rev
operator|=
name|csr
operator|&
name|L64854_DEVID
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_HME
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"DMA rev. "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sc
operator|->
name|sc_rev
condition|)
block|{
case|case
name|DMAREV_0
case|:
name|printf
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMAREV_ESC
case|:
name|printf
argument_list|(
literal|"ESC"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMAREV_1
case|:
name|printf
argument_list|(
literal|"1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMAREV_PLUS
case|:
name|printf
argument_list|(
literal|"1+"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DMAREV_2
case|:
name|printf
argument_list|(
literal|"2"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"unknown (0x%x)"
argument_list|,
name|sc
operator|->
name|sc_rev
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|LDB_ANY
argument_list|,
operator|(
literal|", burst 0x%x, csr 0x%x"
operator|,
name|sc
operator|->
name|sc_burst
operator|,
name|csr
operator|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lsi64854_detach
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
name|sc
parameter_list|)
block|{
if|if
condition|(
name|sc
operator|->
name|setup
operator|!=
name|NULL
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
operator|(
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
operator|&
name|L64854_WRITE
operator|)
operator|!=
literal|0
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dmamap_destroy
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
name|bus_dma_tag_destroy
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DMAWAIT waits while condition is true.  */
end_comment

begin_define
define|#
directive|define
name|DMAWAIT
parameter_list|(
name|SC
parameter_list|,
name|COND
parameter_list|,
name|MSG
parameter_list|,
name|DONTPANIC
parameter_list|)
value|do if (COND) {		\ 	int count = 500000;						\ 	while ((COND)&& --count> 0) DELAY(1);				\ 	if (count == 0) {						\ 		printf("%s: line %d: CSR = 0x%lx\n", __FILE__, __LINE__, \ 			(u_long)L64854_GCSR(SC));			\ 		if (DONTPANIC)						\ 			printf(MSG);					\ 		else							\ 			panic(MSG);					\ 	}								\ } while (0)
end_define

begin_define
define|#
directive|define
name|DMA_DRAIN
parameter_list|(
name|sc
parameter_list|,
name|dontpanic
parameter_list|)
value|do {					\ 	uint32_t csr;							\
comment|/*								\ 	 * DMA rev0& rev1: we are not allowed to touch the DMA "flush"	\ 	 *     and "drain" bits while it is still thinking about a	\ 	 *     request.							\ 	 * other revs: D_ESC_R_PEND bit reads as 0			\ 	 */
value|\ 	DMAWAIT(sc, L64854_GCSR(sc)& D_ESC_R_PEND, "R_PEND", dontpanic);\ 	if (sc->sc_rev != DMAREV_HME) {                                 \
comment|/*							\ 	         * Select drain bit based on revision			\ 	         * also clears errors and D_TC flag			\ 	         */
value|\ 	        csr = L64854_GCSR(sc);					\ 	        if (sc->sc_rev == DMAREV_1 || sc->sc_rev == DMAREV_0)	\ 		        csr |= D_ESC_DRAIN;				\ 	        else							\ 		        csr |= L64854_INVALIDATE;			\ 									\ 	        L64854_SCSR(sc,csr);					\ 	}								\
comment|/*								\ 	 * Wait for draining to finish					\ 	 * rev0& rev1 call this PACKCNT				\ 	 */
value|\ 	DMAWAIT(sc, L64854_GCSR(sc)& L64854_DRAINING, "DRAINING", dontpanic);\ } while(0)
end_define

begin_define
define|#
directive|define
name|DMA_FLUSH
parameter_list|(
name|sc
parameter_list|,
name|dontpanic
parameter_list|)
value|do {					\ 	uint32_t csr;							\
comment|/*								\ 	 * DMA rev0& rev1: we are not allowed to touch the DMA "flush"	\ 	 *     and "drain" bits while it is still thinking about a	\ 	 *     request.							\ 	 * other revs: D_ESC_R_PEND bit reads as 0			\ 	 */
value|\ 	DMAWAIT(sc, L64854_GCSR(sc)& D_ESC_R_PEND, "R_PEND", dontpanic);\ 	csr = L64854_GCSR(sc);					\ 	csr&= ~(L64854_WRITE|L64854_EN_DMA);
comment|/* no-ops on ENET */
value|\ 	csr |= L64854_INVALIDATE;
comment|/* XXX FAS ? */
value|\ 	L64854_SCSR(sc,csr);						\ } while(0)
end_define

begin_function
specifier|static
name|void
name|lsi64854_reset
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
name|sc
parameter_list|)
block|{
name|uint32_t
name|csr
decl_stmt|;
name|DMA_FLUSH
argument_list|(
name|sc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_ANY
argument_list|,
operator|(
literal|"%s: csr 0x%x\n"
operator|,
name|__func__
operator|,
name|csr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
operator|(
name|csr
operator|&
name|D_WRITE
operator|)
operator|!=
literal|0
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_HME
condition|)
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
operator||
name|D_HW_RESET_FAS366
argument_list|)
expr_stmt|;
name|csr
operator||=
name|L64854_RESET
expr_stmt|;
comment|/* reset DMA */
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/*> 10 Sbus clocks(?) */
comment|/*DMAWAIT1(sc); why was this here? */
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|L64854_RESET
expr_stmt|;
comment|/* de-assert reset line */
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|DELAY
argument_list|(
literal|5
argument_list|)
expr_stmt|;
comment|/* allow a few ticks to settle */
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator||=
name|L64854_INT_EN
expr_stmt|;
comment|/* enable interrupts */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|>
name|DMAREV_1
operator|&&
name|sc
operator|->
name|sc_channel
operator|==
name|L64854_CHANNEL_SCSI
condition|)
block|{
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_HME
condition|)
name|csr
operator||=
name|D_TWO_CYCLE
expr_stmt|;
else|else
name|csr
operator||=
name|D_FASTER
expr_stmt|;
block|}
comment|/* Set burst */
switch|switch
condition|(
name|sc
operator|->
name|sc_rev
condition|)
block|{
case|case
name|DMAREV_HME
case|:
case|case
name|DMAREV_2
case|:
name|csr
operator|&=
operator|~
name|L64854_BURST_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_burst
operator|==
literal|32
condition|)
name|csr
operator||=
name|L64854_BURST_32
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_burst
operator|==
literal|16
condition|)
name|csr
operator||=
name|L64854_BURST_16
expr_stmt|;
else|else
name|csr
operator||=
name|L64854_BURST_0
expr_stmt|;
break|break;
case|case
name|DMAREV_ESC
case|:
name|csr
operator||=
name|D_ESC_AUTODRAIN
expr_stmt|;
comment|/* Auto-drain */
if|if
condition|(
name|sc
operator|->
name|sc_burst
operator|==
literal|32
condition|)
name|csr
operator|&=
operator|~
name|D_ESC_BURST
expr_stmt|;
else|else
name|csr
operator||=
name|D_ESC_BURST
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_HME
condition|)
block|{
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmactl
operator|=
name|csr
expr_stmt|;
block|}
name|sc
operator|->
name|sc_active
operator|=
literal|0
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_ANY
argument_list|,
operator|(
literal|"%s: done, csr 0x%x\n"
operator|,
name|__func__
operator|,
name|csr
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lsi64854_map_scsi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nseg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|lsi64854_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|lsi64854_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|nseg
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: cannot map %d segments\n"
argument_list|,
name|__func__
argument_list|,
name|nseg
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|sc
operator|->
name|sc_datain
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_ADDR
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DMAMAX
parameter_list|(
name|a
parameter_list|)
value|(MAX_DMA_SZ - ((a)& (MAX_DMA_SZ - 1)))
end_define

begin_comment
comment|/*  * setup a DMA transfer  */
end_comment

begin_function
specifier|static
name|int
name|lsi64854_setup
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
modifier|*
name|addr
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
name|datain
parameter_list|,
name|size_t
modifier|*
name|dmasize
parameter_list|)
block|{
name|long
name|bcnt
decl_stmt|;
name|uint32_t
name|csr
decl_stmt|;
name|DMA_FLUSH
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|DMACSR(sc)&= ~D_INT_EN;
endif|#
directive|endif
name|sc
operator|->
name|sc_dmaaddr
operator|=
name|addr
expr_stmt|;
name|sc
operator|->
name|sc_dmalen
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_datain
operator|=
name|datain
expr_stmt|;
comment|/* 	 * The rules say we cannot transfer more than the limit 	 * of this DMA chip (64k for old and 16Mb for new), 	 * and we cannot cross a 16Mb boundary. 	 */
operator|*
name|dmasize
operator|=
name|sc
operator|->
name|sc_dmasize
operator|=
name|ulmin
argument_list|(
operator|*
name|dmasize
argument_list|,
name|DMAMAX
argument_list|(
operator|(
name|size_t
operator|)
operator|*
name|sc
operator|->
name|sc_dmaaddr
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_ANY
argument_list|,
operator|(
literal|"%s: dmasize=%ld\n"
operator|,
name|__func__
operator|,
operator|(
name|long
operator|)
name|sc
operator|->
name|sc_dmasize
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX what length? 	 */
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_HME
condition|)
block|{
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_dmactl
operator||
name|L64854_RESET
argument_list|)
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|sc
operator|->
name|sc_dmactl
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_CNT
argument_list|,
operator|*
name|dmasize
argument_list|)
expr_stmt|;
block|}
comment|/* Program the DMA address */
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|!=
literal|0
condition|)
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
operator|*
name|sc
operator|->
name|sc_dmaaddr
argument_list|,
name|sc
operator|->
name|sc_dmasize
argument_list|,
name|lsi64854_map_scsi
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: cannot allocate DVMA address"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_ESC
condition|)
block|{
comment|/* DMA ESC chip bug work-around */
name|bcnt
operator|=
name|sc
operator|->
name|sc_dmasize
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|bcnt
operator|+
operator|(
name|long
operator|)
operator|*
name|sc
operator|->
name|sc_dmaaddr
operator|)
operator|&
name|PAGE_MASK_8K
operator|)
operator|!=
literal|0
condition|)
name|bcnt
operator|=
name|roundup
argument_list|(
name|bcnt
argument_list|,
name|PAGE_SIZE_8K
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_CNT
argument_list|,
name|bcnt
argument_list|)
expr_stmt|;
block|}
comment|/* Setup DMA control register */
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
if|if
condition|(
name|datain
condition|)
name|csr
operator||=
name|L64854_WRITE
expr_stmt|;
else|else
name|csr
operator|&=
operator|~
name|L64854_WRITE
expr_stmt|;
name|csr
operator||=
name|L64854_INT_EN
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_rev
operator|==
name|DMAREV_HME
condition|)
name|csr
operator||=
operator|(
name|D_DSBL_SCSI_DRN
operator||
name|D_EN_DMA
operator|)
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pseudo (chained) interrupt from the esp driver to kick the  * current running DMA transfer. Called from ncr53c9x_intr()  * for now.  *  * return 1 if it was a DMA continue.  */
end_comment

begin_function
specifier|static
name|int
name|lsi64854_scsi_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lsi64854_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|struct
name|ncr53c9x_softc
modifier|*
name|nsc
init|=
name|sc
operator|->
name|sc_client
decl_stmt|;
name|int
name|trans
decl_stmt|,
name|resid
decl_stmt|;
name|uint32_t
name|csr
decl_stmt|;
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_SCSI
argument_list|,
operator|(
literal|"%s: addr 0x%x, csr %b\n"
operator|,
name|__func__
operator|,
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_ADDR
argument_list|)
operator|,
name|csr
operator|,
name|DDMACSR_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|D_ERR_PEND
operator||
name|D_SLAVE_ERR
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"error: csr=%b\n"
argument_list|,
name|csr
argument_list|,
name|DDMACSR_BITS
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|D_EN_DMA
expr_stmt|;
comment|/* Stop DMA */
comment|/* Invalidate the queue; SLAVE_ERR bit is write-to-clear */
name|csr
operator||=
name|D_INVALIDATE
operator||
name|D_SLAVE_ERR
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* This is an "assertion" :) */
if|if
condition|(
name|sc
operator|->
name|sc_active
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"%s: DMA wasn't active"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|DMA_DRAIN
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* DMA has stopped */
name|csr
operator|&=
operator|~
name|D_EN_DMA
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|==
literal|0
condition|)
block|{
comment|/* A "Transfer Pad" operation completed */
name|DPRINTF
argument_list|(
name|LDB_SCSI
argument_list|,
operator|(
literal|"%s: discarded %d bytes (tcl=%d, tcm=%d)\n"
operator|,
name|__func__
operator|,
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCL
argument_list|)
operator||
operator|(
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCM
argument_list|)
operator|<<
literal|8
operator|)
operator|,
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCL
argument_list|)
operator|,
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCM
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If a transfer onto the SCSI bus gets interrupted by the device 	 * (e.g. for a SAVEPOINTER message), the data in the FIFO counts 	 * as residual since the NCR53C9X counter registers get decremented 	 * as bytes are clocked into the FIFO. 	 */
if|if
condition|(
operator|!
operator|(
name|csr
operator|&
name|D_WRITE
operator|)
operator|&&
operator|(
name|resid
operator|=
operator|(
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_FFLAG
argument_list|)
operator|&
name|NCRFIFO_FF
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|DPRINTF
argument_list|(
name|LDB_SCSI
argument_list|,
operator|(
literal|"%s: empty esp FIFO of %d "
operator|,
name|__func__
operator|,
name|resid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsc
operator|->
name|sc_rev
operator|==
name|NCR_VARIANT_FAS366
operator|&&
operator|(
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_CFG3
argument_list|)
operator|&
name|NCRFASCFG3_EWIDE
operator|)
condition|)
name|resid
operator|<<=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nsc
operator|->
name|sc_espstat
operator|&
name|NCRSTAT_TC
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * `Terminal count' is off, so read the residue 		 * out of the NCR53C9X counter registers. 		 */
name|resid
operator|+=
operator|(
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCL
argument_list|)
operator||
operator|(
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCM
argument_list|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|nsc
operator|->
name|sc_cfg2
operator|&
name|NCRCFG2_FE
operator|)
condition|?
operator|(
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCH
argument_list|)
operator|<<
literal|16
operator|)
else|:
literal|0
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|resid
operator|==
literal|0
operator|&&
name|sc
operator|->
name|sc_dmasize
operator|==
literal|65536
operator|&&
operator|(
name|nsc
operator|->
name|sc_cfg2
operator|&
name|NCRCFG2_FE
operator|)
operator|==
literal|0
condition|)
comment|/* A transfer of 64K is encoded as `TCL=TCM=0' */
name|resid
operator|=
literal|65536
expr_stmt|;
block|}
name|trans
operator|=
name|sc
operator|->
name|sc_dmasize
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|trans
operator|<
literal|0
condition|)
block|{
comment|/* transfered< 0? */
if|#
directive|if
literal|0
comment|/* 		 * This situation can happen in perfectly normal operation 		 * if the ESP is reselected while using DMA to select 		 * another target.  As such, don't print the warning. 		 */
block|device_printf(sc->sc_dev, "xfer (%d)> req (%d)\n", trans, 		    sc->sc_dmasize);
endif|#
directive|endif
name|trans
operator|=
name|sc
operator|->
name|sc_dmasize
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|LDB_SCSI
argument_list|,
operator|(
literal|"%s: tcl=%d, tcm=%d, tch=%d; trans=%d, resid=%d\n"
operator|,
name|__func__
operator|,
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCL
argument_list|)
operator|,
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCM
argument_list|)
operator|,
operator|(
name|nsc
operator|->
name|sc_cfg2
operator|&
name|NCRCFG2_FE
operator|)
condition|?
name|NCR_READ_REG
argument_list|(
name|nsc
argument_list|,
name|NCR_TCH
argument_list|)
else|:
literal|0
operator|,
name|trans
operator|,
name|resid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
operator|(
name|csr
operator|&
name|D_WRITE
operator|)
operator|!=
literal|0
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
block|}
operator|*
name|sc
operator|->
name|sc_dmalen
operator|-=
name|trans
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_dmaaddr
operator|+=
name|trans
expr_stmt|;
if|#
directive|if
literal|0
comment|/* this is not normal operation just yet */
block|if (*sc->sc_dmalen == 0 || nsc->sc_phase != nsc->sc_prevphase) 		return (0);
comment|/* and again */
block|dma_start(sc, sc->sc_dmaaddr, sc->sc_dmalen, DMACSR(sc)& D_WRITE); 	return (1);
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pseudo (chained) interrupt to le driver to handle DMA errors.  */
end_comment

begin_function
specifier|static
name|int
name|lsi64854_enet_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lsi64854_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|uint32_t
name|csr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rv
decl_stmt|;
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
comment|/* If the DMA logic shows an interrupt, claim it */
name|rv
operator|=
operator|(
operator|(
name|csr
operator|&
name|E_INT_PEND
operator|)
operator|!=
literal|0
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|E_ERR_PEND
operator||
name|E_SLAVE_ERR
operator|)
condition|)
block|{
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"error: csr=%b\n"
argument_list|,
name|csr
argument_list|,
name|EDMACSR_BITS
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|L64854_EN_DMA
expr_stmt|;
comment|/* Stop DMA */
comment|/* Invalidate the queue; SLAVE_ERR bit is write-to-clear */
name|csr
operator||=
name|E_INVALIDATE
operator||
name|E_SLAVE_ERR
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
comment|/* Will be drained with the LE_C0_IDON interrupt. */
name|sc
operator|->
name|sc_dodrain
operator|=
literal|1
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* XXX - is this necessary with E_DSBL_WR_INVAL on? */
if|if
condition|(
name|sc
operator|->
name|sc_dodrain
condition|)
block|{
name|i
operator|=
literal|10
expr_stmt|;
name|csr
operator||=
name|E_DRAIN
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
operator|&&
operator|(
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
operator|&
name|E_DRAINING
operator|)
condition|)
name|DELAY
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dodrain
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|lsi64854_map_pp
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|bus_dma_segment_t
modifier|*
name|segs
parameter_list|,
name|int
name|nsegs
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|lsi64854_softc
modifier|*
name|sc
decl_stmt|;
name|sc
operator|=
operator|(
expr|struct
name|lsi64854_softc
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
name|nsegs
operator|!=
literal|1
condition|)
name|panic
argument_list|(
literal|"%s: cannot map %d segments\n"
argument_list|,
name|__func__
argument_list|,
name|nsegs
argument_list|)
expr_stmt|;
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
name|sc
operator|->
name|sc_datain
condition|?
name|BUS_DMASYNC_PREREAD
else|:
name|BUS_DMASYNC_PREWRITE
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_ADDR
argument_list|,
name|segs
index|[
literal|0
index|]
operator|.
name|ds_addr
argument_list|)
expr_stmt|;
name|bus_write_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_CNT
argument_list|,
name|sc
operator|->
name|sc_dmasize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setup a DMA transfer  */
end_comment

begin_function
specifier|static
name|int
name|lsi64854_setup_pp
parameter_list|(
name|struct
name|lsi64854_softc
modifier|*
name|sc
parameter_list|,
name|caddr_t
modifier|*
name|addr
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|,
name|int
name|datain
parameter_list|,
name|size_t
modifier|*
name|dmasize
parameter_list|)
block|{
name|uint32_t
name|csr
decl_stmt|;
name|DMA_FLUSH
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_dmaaddr
operator|=
name|addr
expr_stmt|;
name|sc
operator|->
name|sc_dmalen
operator|=
name|len
expr_stmt|;
name|sc
operator|->
name|sc_datain
operator|=
name|datain
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_PP
argument_list|,
operator|(
literal|"%s: pp start %ld@%p,%d\n"
operator|,
name|__func__
operator|,
operator|(
name|long
operator|)
operator|*
name|sc
operator|->
name|sc_dmalen
operator|,
operator|*
name|sc
operator|->
name|sc_dmaaddr
operator|,
name|datain
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * the rules say we cannot transfer more than the limit 	 * of this DMA chip (64k for old and 16Mb for new), 	 * and we cannot cross a 16Mb boundary. 	 */
operator|*
name|dmasize
operator|=
name|sc
operator|->
name|sc_dmasize
operator|=
name|ulmin
argument_list|(
operator|*
name|dmasize
argument_list|,
name|DMAMAX
argument_list|(
operator|(
name|size_t
operator|)
operator|*
name|sc
operator|->
name|sc_dmaaddr
argument_list|)
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_PP
argument_list|,
operator|(
literal|"%s: dmasize=%ld\n"
operator|,
name|__func__
operator|,
operator|(
name|long
operator|)
name|sc
operator|->
name|sc_dmasize
operator|)
argument_list|)
expr_stmt|;
comment|/* Program the DMA address */
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|!=
literal|0
condition|)
if|if
condition|(
name|bus_dmamap_load
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
operator|*
name|sc
operator|->
name|sc_dmaaddr
argument_list|,
name|sc
operator|->
name|sc_dmasize
argument_list|,
name|lsi64854_map_pp
argument_list|,
name|sc
argument_list|,
literal|0
argument_list|)
condition|)
name|panic
argument_list|(
literal|"%s: pp cannot allocate DVMA address"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* Setup DMA control register */
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|L64854_BURST_SIZE
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_burst
operator|==
literal|32
condition|)
name|csr
operator||=
name|L64854_BURST_32
expr_stmt|;
elseif|else
if|if
condition|(
name|sc
operator|->
name|sc_burst
operator|==
literal|16
condition|)
name|csr
operator||=
name|L64854_BURST_16
expr_stmt|;
else|else
name|csr
operator||=
name|L64854_BURST_0
expr_stmt|;
name|csr
operator||=
name|P_EN_DMA
operator||
name|P_INT_EN
operator||
name|P_EN_CNT
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This bit is read-only in PP csr register */
block|if (datain) 		csr |= P_WRITE; 	else 		csr&= ~P_WRITE;
endif|#
directive|endif
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parallel port DMA interrupt.  */
end_comment

begin_function
specifier|static
name|int
name|lsi64854_pp_intr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|lsi64854_softc
modifier|*
name|sc
init|=
name|arg
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|trans
decl_stmt|,
name|resid
init|=
literal|0
decl_stmt|;
name|uint32_t
name|csr
decl_stmt|;
name|csr
operator|=
name|L64854_GCSR
argument_list|(
name|sc
argument_list|)
expr_stmt|;
name|DPRINTF
argument_list|(
name|LDB_PP
argument_list|,
operator|(
literal|"%s: addr 0x%x, csr %b\n"
operator|,
name|__func__
operator|,
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_ADDR
argument_list|)
operator|,
name|csr
operator|,
name|PDMACSR_BITS
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|csr
operator|&
operator|(
name|P_ERR_PEND
operator||
name|P_SLAVE_ERR
operator|)
condition|)
block|{
name|resid
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_CNT
argument_list|)
expr_stmt|;
name|device_printf
argument_list|(
name|sc
operator|->
name|sc_dev
argument_list|,
literal|"error: resid %d csr=%b\n"
argument_list|,
name|resid
argument_list|,
name|csr
argument_list|,
name|PDMACSR_BITS
argument_list|)
expr_stmt|;
name|csr
operator|&=
operator|~
name|P_EN_DMA
expr_stmt|;
comment|/* Stop DMA */
comment|/* Invalidate the queue; SLAVE_ERR bit is write-to-clear */
name|csr
operator||=
name|P_INVALIDATE
operator||
name|P_SLAVE_ERR
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ret
operator|=
operator|(
name|csr
operator|&
name|P_INT_PEND
operator|)
operator|!=
literal|0
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_active
operator|!=
literal|0
condition|)
block|{
name|DMA_DRAIN
argument_list|(
name|sc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|resid
operator|=
name|bus_read_4
argument_list|(
name|sc
operator|->
name|sc_res
argument_list|,
name|L64854_REG_CNT
argument_list|)
expr_stmt|;
block|}
comment|/* DMA has stopped */
name|csr
operator|&=
operator|~
name|D_EN_DMA
expr_stmt|;
name|L64854_SCSR
argument_list|(
name|sc
argument_list|,
name|csr
argument_list|)
expr_stmt|;
name|sc
operator|->
name|sc_active
operator|=
literal|0
expr_stmt|;
name|trans
operator|=
name|sc
operator|->
name|sc_dmasize
operator|-
name|resid
expr_stmt|;
if|if
condition|(
name|trans
operator|<
literal|0
condition|)
comment|/* transfered< 0? */
name|trans
operator|=
name|sc
operator|->
name|sc_dmasize
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_dmalen
operator|-=
name|trans
expr_stmt|;
operator|*
name|sc
operator|->
name|sc_dmaaddr
operator|+=
name|trans
expr_stmt|;
if|if
condition|(
name|sc
operator|->
name|sc_dmasize
operator|!=
literal|0
condition|)
block|{
name|bus_dmamap_sync
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|,
operator|(
name|csr
operator|&
name|D_WRITE
operator|)
operator|!=
literal|0
condition|?
name|BUS_DMASYNC_POSTREAD
else|:
name|BUS_DMASYNC_POSTWRITE
argument_list|)
expr_stmt|;
name|bus_dmamap_unload
argument_list|(
name|sc
operator|->
name|sc_buffer_dmat
argument_list|,
name|sc
operator|->
name|sc_dmamap
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|!=
literal|0
operator|)
return|;
block|}
end_function

end_unit

