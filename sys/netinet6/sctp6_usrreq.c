begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2007, by Cisco Systems, Inc. All rights reserved.  * Copyright (c) 2008-2012, by Randall Stewart. All rights reserved.  * Copyright (c) 2008-2012, by Michael Tuexen. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *    this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet6/sctp6_var.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/sctp_sysctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_indata.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_timer.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_auth.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_crc32.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netipsec/ipsec.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netipsec/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INET6 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|protosw
name|inetsw
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp6_input
parameter_list|(
name|struct
name|mbuf
modifier|*
modifier|*
name|i_pak
parameter_list|,
name|int
modifier|*
name|offp
parameter_list|,
name|int
name|proto
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|iphlen
decl_stmt|;
name|uint32_t
name|vrf_id
init|=
literal|0
decl_stmt|;
name|uint8_t
name|ecn_bits
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|int
name|refcount_up
init|=
literal|0
decl_stmt|;
name|int
name|length
decl_stmt|,
name|offset
decl_stmt|;
name|uint32_t
name|mflowid
decl_stmt|;
name|uint8_t
name|use_mflowid
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|uint32_t
name|check
decl_stmt|,
name|calc_check
decl_stmt|;
endif|#
directive|endif
name|uint16_t
name|port
init|=
literal|0
decl_stmt|;
name|iphlen
operator|=
operator|*
name|offp
expr_stmt|;
if|if
condition|(
name|SCTP_GET_PKT_VRFID
argument_list|(
operator|*
name|i_pak
argument_list|,
name|vrf_id
argument_list|)
condition|)
block|{
name|SCTP_RELEASE_PKT
argument_list|(
operator|*
name|i_pak
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|m
operator|=
name|SCTP_HEADER_TO_CHAIN
argument_list|(
operator|*
name|i_pak
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_MBUF_LOGGING
comment|/* Log in any input mbufs */
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_MBUF_LOGGING_ENABLE
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|mat
decl_stmt|;
for|for
control|(
name|mat
operator|=
name|m
init|;
name|mat
condition|;
name|mat
operator|=
name|SCTP_BUF_NEXT
argument_list|(
name|mat
argument_list|)
control|)
block|{
if|if
condition|(
name|SCTP_BUF_IS_EXTENDED
argument_list|(
name|mat
argument_list|)
condition|)
block|{
name|sctp_log_mb
argument_list|(
name|mat
argument_list|,
name|SCTP_MBUF_INPUT
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SCTP_PACKET_LOGGING
if|if
condition|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_logging_level
argument_list|)
operator|&
name|SCTP_LAST_PACKET_TRACING
condition|)
block|{
name|sctp_packet_log
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_FLOWID
condition|)
block|{
name|mflowid
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|flowid
expr_stmt|;
name|use_mflowid
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|mflowid
operator|=
literal|0
expr_stmt|;
name|use_mflowid
operator|=
literal|0
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inpackets
argument_list|)
expr_stmt|;
comment|/* Get IP, SCTP, and first chunk header together in the first mbuf. */
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
name|IP6_EXTHDR_GET
argument_list|(
name|sh
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
name|offset
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_chunkhdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|faithprefix_p
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|faithprefix_p
call|)
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* XXX send icmp6 host/port unreach? */
goto|goto
name|bad
goto|;
block|}
name|length
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|+
name|iphlen
expr_stmt|;
comment|/* Validate mbuf chain length with IP payload length. */
if|if
condition|(
name|SCTP_HEADER_LEN
argument_list|(
operator|*
name|i_pak
argument_list|)
operator|!=
name|length
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"sctp6_input() length:%d reported length:%d\n"
argument_list|,
name|length
argument_list|,
name|SCTP_HEADER_LEN
argument_list|(
operator|*
name|i_pak
argument_list|)
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"sctp6_input() length:%d iphlen:%d\n"
argument_list|,
name|length
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_CRCOFFLOAD
argument_list|,
literal|"sctp6_input(): Packet of length %d received on %s with csum_flags 0x%x.\n"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
name|if_name
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
argument_list|)
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCTP_WITH_NO_CSUM
argument_list|)
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvnocrc
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|csum_flags
operator|&
name|CSUM_SCTP_VALID
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvhwcrc
argument_list|)
expr_stmt|;
goto|goto
name|sctp_skip_csum
goto|;
block|}
name|check
operator|=
name|sh
operator|->
name|checksum
expr_stmt|;
name|sh
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
name|calc_check
operator|=
name|sctp_calculate_cksum
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
name|sh
operator|->
name|checksum
operator|=
name|check
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvswcrc
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_check
operator|!=
name|check
condition|)
block|{
name|SCTPDBG
argument_list|(
name|SCTP_DEBUG_INPUT1
argument_list|,
literal|"Bad CSUM on SCTP packet calc_check:%x check:%x  m:%p mlen:%d iphlen:%d\n"
argument_list|,
name|calc_check
argument_list|,
name|check
argument_list|,
name|m
argument_list|,
name|length
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|)
operator|&&
operator|(
name|port
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|port
operator|==
literal|0
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|use_mflowid
operator|!=
literal|0
operator|)
condition|)
block|{
name|net
operator|->
name|flowid
operator|=
name|mflowid
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|net
operator|->
name|flowidset
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|inp
operator|)
operator|&&
operator|(
name|stcb
operator|)
condition|)
block|{
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|m
argument_list|,
name|length
argument_list|,
name|iphlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_OUTPUT_FROM_INPUT_ERROR
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
name|refcount_up
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_checksumerrors
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sctp_skip_csum
label|:
endif|#
directive|endif
comment|/* destination port of 0 is illegal, based on RFC2960. */
if|if
condition|(
name|sh
operator|->
name|dest_port
operator|==
literal|0
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|offset
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|net
operator|)
operator|&&
operator|(
name|port
operator|)
condition|)
block|{
if|if
condition|(
name|net
operator|->
name|port
operator|==
literal|0
condition|)
block|{
name|sctp_pathmtu_adjustment
argument_list|(
name|stcb
argument_list|,
name|net
operator|->
name|mtu
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|net
operator|->
name|port
operator|=
name|port
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|net
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|use_mflowid
operator|!=
literal|0
operator|)
condition|)
block|{
name|net
operator|->
name|flowid
operator|=
name|mflowid
expr_stmt|;
ifdef|#
directive|ifdef
name|INVARIANTS
name|net
operator|->
name|flowidset
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_noport
argument_list|)
expr_stmt|;
if|if
condition|(
name|badport_bandlim
argument_list|(
name|BANDLIM_SCTP_OOTB
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_ACK
condition|)
block|{
name|sctp_send_shutdown_complete2
argument_list|(
name|m
argument_list|,
name|sh
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_ABORT_ASSOCIATION
condition|)
block|{
if|if
condition|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_blackhole
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_INIT
operator|)
operator|)
condition|)
block|{
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
block|}
block|}
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|refcount_up
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IPSEC
comment|/*- 	 * I very much doubt any of the IPSEC stuff will work but I have no 	 * idea, so I will leave it in place. 	 */
if|if
condition|(
name|inp
operator|&&
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
operator|&
name|inp
operator|->
name|ip_inp
operator|.
name|inp
argument_list|)
condition|)
block|{
name|MODULE_GLOBAL
argument_list|(
name|ipsec6stat
argument_list|)
operator|.
name|in_polvio
operator|++
expr_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
name|ecn_bits
operator|=
operator|(
operator|(
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
comment|/* sa_ignore NO_NULL_CHK */
name|sctp_common_input_processing
argument_list|(
operator|&
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ecn_bits
argument_list|,
name|use_mflowid
argument_list|,
name|mflowid
argument_list|,
name|vrf_id
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|)
operator|&&
operator|(
name|refcount_up
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|)
operator|&&
operator|(
name|refcount_up
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
block|{
name|sctp_m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|IPPROTO_DONE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp6_notify_mbuf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|uint32_t
name|nxtsz
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|icmp6
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* First do we even look at it? */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|icmp6
operator|->
name|icmp6_type
operator|!=
name|ICMP6_PACKET_TOO_BIG
condition|)
block|{
comment|/* not PACKET TO BIG */
goto|goto
name|out
goto|;
block|}
comment|/* 	 * ok we need to look closely. We could even get smarter and look at 	 * anyone that we sent to in case we get a different ICMP that tells 	 * us there is no way to reach a host, but for this impl, all we 	 * care about is MTU discovery. 	 */
name|nxtsz
operator|=
name|ntohl
argument_list|(
name|icmp6
operator|->
name|icmp6_mtu
argument_list|)
expr_stmt|;
comment|/* Stop any PMTU timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
comment|/* Adjust destination size limit */
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
name|nxtsz
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|nxtsz
expr_stmt|;
if|if
condition|(
name|net
operator|->
name|port
condition|)
block|{
name|net
operator|->
name|mtu
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|udphdr
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* now what about the ep? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|nxtsz
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
comment|/* Adjust that too */
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|nxtsz
expr_stmt|;
comment|/* now off to subtract IP_DF flag if needed */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
call|(
name|uint32_t
call|)
argument_list|(
name|chk
operator|->
name|send_size
operator|+
name|IP_HDR_SIZE
argument_list|)
operator|>
name|nxtsz
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
call|(
name|uint32_t
call|)
argument_list|(
name|chk
operator|->
name|send_size
operator|+
name|IP_HDR_SIZE
argument_list|)
operator|>
name|nxtsz
condition|)
block|{
comment|/* 				 * For this guy we also mark for immediate 				 * resend since we sent to big of chunk 				 */
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
comment|/* Clear any time so NO RTT is being done */
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|net
operator|->
name|flight_size
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
block|}
block|}
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp6_notify
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|icmp6_hdr
modifier|*
name|icmph
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|to
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
endif|#
directive|endif
comment|/* protection */
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
operator|||
operator|(
name|to
operator|==
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* First job is to verify the vtag matches what I would send */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|icmph
operator|->
name|icmp6_type
operator|!=
name|ICMP_UNREACH
condition|)
block|{
comment|/* We only care about unreachable */
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_NET
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_HOST
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_NET_UNKNOWN
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_HOST_UNKNOWN
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_ISOLATED
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_NET_PROHIB
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_HOST_PROHIB
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_FILTER_PROHIB
operator|)
condition|)
block|{
comment|/* 		 * Hmm reachablity problems we must examine closely. If its 		 * not reachable, we may have lost a network. Or if there is 		 * NO protocol at the other end named SCTP. well we consider 		 * it a OOTB abort. 		 */
if|if
condition|(
name|net
operator|->
name|dest_state
operator|&
name|SCTP_ADDR_REACHABLE
condition|)
block|{
comment|/* Ok that destination is NOT reachable */
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_REACHABLE
expr_stmt|;
name|net
operator|->
name|dest_state
operator|&=
operator|~
name|SCTP_ADDR_PF
expr_stmt|;
name|sctp_ulp_notify
argument_list|(
name|SCTP_NOTIFY_INTERFACE_DOWN
argument_list|,
name|stcb
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
name|net
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_PROTOCOL
operator|)
operator|||
operator|(
name|icmph
operator|->
name|icmp6_code
operator|==
name|ICMP_UNREACH_PORT
operator|)
condition|)
block|{
comment|/* 		 * Here the peer is either playing tricks on us, including 		 * an address that belongs to someone who does not support 		 * SCTP OR was a userland implementation that shutdown and 		 * now is dead. In either case treat it like a OOTB abort 		 * with no TCB 		 */
name|sctp_abort_notification
argument_list|(
name|stcb
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|SCTP_SO_NOT_LOCKED
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|so
operator|=
name|SCTP_INP_SO
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_SOCKET_LOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|atomic_subtract_int
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_NORMAL_PROC
argument_list|,
name|SCTP_FROM_SCTP_USRREQ
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__APPLE__
argument_list|)
operator|||
name|defined
argument_list|(
name|SCTP_SO_LOCK_TESTING
argument_list|)
name|SCTP_SOCKET_UNLOCK
argument_list|(
name|so
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* SCTP_TCB_UNLOCK(stcb); MT: I think this is not needed. */
endif|#
directive|endif
comment|/* no need to unlock here, since the TCB is gone */
block|}
else|else
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|sctp6_ctlinput
parameter_list|(
name|int
name|cmd
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|pktdst
parameter_list|,
name|void
modifier|*
name|d
parameter_list|)
block|{
name|struct
name|sctphdr
name|sh
decl_stmt|;
name|struct
name|ip6ctlparam
modifier|*
name|ip6cp
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
if|if
condition|(
name|pktdst
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|pktdst
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cmd
operator|>=
name|PRC_NCMDS
condition|)
return|return;
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|d
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inet6ctlerrmap
index|[
name|cmd
index|]
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* if the parameter is from icmp6, decode it. */
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|ip6cp
operator|=
operator|(
expr|struct
name|ip6ctlparam
operator|*
operator|)
name|d
expr_stmt|;
block|}
else|else
block|{
name|ip6cp
operator|=
operator|(
expr|struct
name|ip6ctlparam
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ip6cp
condition|)
block|{
comment|/* 		 * XXX: We assume that when IPV6 is non NULL, M and OFF are 		 * valid. 		 */
comment|/* check if we can safely examine src and dst ports */
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in6
name|final
decl_stmt|;
if|if
condition|(
name|ip6cp
operator|->
name|ip6c_m
operator|==
name|NULL
condition|)
return|return;
name|bzero
argument_list|(
operator|&
name|sh
argument_list|,
sizeof|sizeof
argument_list|(
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|final
argument_list|,
sizeof|sizeof
argument_list|(
name|final
argument_list|)
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|ip6cp
operator|->
name|ip6c_m
argument_list|,
name|ip6cp
operator|->
name|ip6c_off
argument_list|,
sizeof|sizeof
argument_list|(
name|sh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sh
argument_list|)
expr_stmt|;
name|ip6cp
operator|->
name|ip6c_src
operator|->
name|sin6_port
operator|=
name|sh
operator|.
name|src_port
expr_stmt|;
name|final
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|final
argument_list|)
expr_stmt|;
name|final
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|final
operator|.
name|sin6_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|pktdst
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|final
operator|.
name|sin6_port
operator|=
name|sh
operator|.
name|dest_port
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ip6cp
operator|->
name|ip6c_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|final
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
comment|/* inp's ref-count increased&& stcb locked */
if|if
condition|(
name|stcb
operator|!=
name|NULL
operator|&&
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|PRC_MSGSIZE
condition|)
block|{
name|sctp6_notify_mbuf
argument_list|(
name|inp
argument_list|,
name|ip6cp
operator|->
name|ip6c_icmp6
argument_list|,
operator|&
name|sh
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* inp's ref-count reduced&& stcb unlocked */
block|}
else|else
block|{
name|sctp6_notify
argument_list|(
name|inp
argument_list|,
name|ip6cp
operator|->
name|ip6c_icmp6
argument_list|,
operator|&
name|sh
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|final
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* inp's ref-count reduced&& stcb unlocked */
block|}
block|}
else|else
block|{
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
operator|&&
name|inp
condition|)
block|{
name|in6_rtchange
argument_list|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
argument_list|,
name|inet6ctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp
condition|)
block|{
comment|/* reduce inp's ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * this routine can probably be collasped into the one in sctp_userreq.c  * since they do the same thing and now we lookup with a sockaddr  */
end_comment

begin_function
specifier|static
name|int
name|sctp6_getcred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|xucred
name|xuc
decl_stmt|;
name|struct
name|sockaddr_in6
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|vrf_id
operator|=
name|SCTP_DEFAULT_VRFID
expr_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|req
operator|->
name|td
argument_list|,
name|PRIV_NETINET_GETCRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|newlen
operator|!=
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|req
operator|->
name|oldlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ucred
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|sin6tosa
argument_list|(
operator|&
name|addrs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sin6tosa
argument_list|(
operator|&
name|addrs
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
operator|||
name|inp
operator|==
name|NULL
operator|||
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|cred_can_cont
goto|;
block|}
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 	 * We use the write lock here, only since in the error leg we need 	 * it. If we used RLOCK, then we would have to 	 * wlock/decr/unlock/rlock. Which in theory could create a hole. 	 * Better to use higher wlock. 	 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|cred_can_cont
label|:
name|error
operator|=
name|cr_canseesocket
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cru2x
argument_list|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_cred
argument_list|,
operator|&
name|xuc
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xuc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xucred
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet6_sctp6
argument_list|,
name|OID_AUTO
argument_list|,
name|getcred
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sctp6_getcred
argument_list|,
literal|"S,ucred"
argument_list|,
literal|"Get the ucred of a SCTP6 connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This is the same as the sctp_abort() could be made common */
end_comment

begin_function
specifier|static
name|void
name|sctp6_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return;
block|}
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
name|SCTP_FREE_SHOULD_USE_ABORT
argument_list|,
name|SCTP_CALLED_AFTER_CMPSET_OFCLOSE
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_snd
argument_list|)
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|SCTP_SB_CLEAR
argument_list|(
name|so
operator|->
name|so_rcv
argument_list|)
expr_stmt|;
comment|/* Now null out the reference, we are completely detached. */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
name|SCTP_UNUSED
parameter_list|,
name|struct
name|thread
modifier|*
name|p
name|SCTP_UNUSED
parameter_list|)
block|{
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|vrf_id
init|=
name|SCTP_DEFAULT_VRFID
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|SCTP_SORESERVE
argument_list|(
name|so
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_sendspace
argument_list|)
argument_list|,
name|SCTP_BASE_SYSCTL
argument_list|(
name|sctp_recvspace
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|sctp_inpcb_alloc
argument_list|(
name|so
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_BOUND_V6
expr_stmt|;
comment|/* I'm v6! */
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
name|inp6
operator|->
name|in6p_hops
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use kernel default */
name|inp6
operator|->
name|in6p_cksum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* just to be sure */
ifdef|#
directive|ifdef
name|INET
comment|/* 	 * XXX: ugly!! IPv4 TTL initialization is necessary for an IPv6 	 * socket as well, because the socket may be bound to an IPv6 	 * wildcard address, which may match an IPv4-mapped IPv6 address. 	 */
name|inp6
operator|->
name|inp_ip_ttl
operator|=
name|MODULE_GLOBAL
argument_list|(
name|ip_defttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Hmm what about the IPSEC stuff that is missing here but in 	 * sctp_attach()? 	 */
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|int
name|error
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|addr
condition|)
block|{
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV4
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
if|if
condition|(
operator|(
name|addr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
comment|/* binding v4 addr to v6 socket, so reset flags */
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV6
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6_p
decl_stmt|;
name|sin6_p
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6_p
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6_p
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6_p
argument_list|)
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV6
expr_stmt|;
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
break|break;
block|}
endif|#
directive|endif
default|default:
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6_p
decl_stmt|;
comment|/* IPV6_V6ONLY socket */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* can't bind v4 addr to v6 only socket! */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
name|sin6_p
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6_p
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* can't bind v4-mapped addrs either! */
comment|/* NOTE: we don't support SIIT */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp6_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|sctp_close
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This could be made common with sctp_detach() since they are identical */
end_comment

begin_function
specifier|static
name|int
name|sctp6_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
return|return
operator|(
name|sctp_disconnect
argument_list|(
name|so
argument_list|)
operator|)
return|;
block|}
end_function

begin_function_decl
name|int
name|sctp_sendm
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sctp6_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
comment|/* No SPL needed since sctp_output does this */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|control
condition|)
block|{
name|SCTP_RELEASE_PKT
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_RELEASE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
comment|/* 	 * For the TCP model we may get a NULL addr, if we are a connected 	 * socket thats ok. 	 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|&&
operator|(
name|addr
operator|==
name|NULL
operator|)
condition|)
block|{
goto|goto
name|connected_type
goto|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|SCTP_RELEASE_PKT
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|SCTP_RELEASE_PKT
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EDESTADDRREQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|EDESTADDRREQ
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
comment|/* 		 * if IPV6_V6ONLY flag, we discard datagrams destined to a 		 * v4 addr or v4-mapped addr 		 */
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MODULE_GLOBAL
argument_list|(
name|ip6_v6only
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
comment|/* convert v4-mapped into v4 addr and send */
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
return|return
operator|(
name|sctp_sendm
argument_list|(
name|so
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|control
argument_list|,
name|p
argument_list|)
operator|)
return|;
block|}
else|else
block|{
comment|/* mapped addresses aren't enabled */
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* INET */
name|connected_type
label|:
comment|/* now what about control */
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|control
condition|)
block|{
name|SCTP_PRINTF
argument_list|(
literal|"huh? control set?\n"
argument_list|)
expr_stmt|;
name|SCTP_RELEASE_PKT
argument_list|(
name|inp
operator|->
name|control
argument_list|)
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|inp
operator|->
name|control
operator|=
name|control
expr_stmt|;
block|}
comment|/* Place the data */
if|if
condition|(
name|inp
operator|->
name|pkt
condition|)
block|{
name|SCTP_BUF_NEXT
argument_list|(
name|inp
operator|->
name|pkt_last
argument_list|)
operator|=
name|m
expr_stmt|;
name|inp
operator|->
name|pkt_last
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|pkt_last
operator|=
name|inp
operator|->
name|pkt
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
comment|/* FreeBSD and MacOSX uses a flag passed */
operator|(
operator|(
name|flags
operator|&
name|PRUS_MORETOCOME
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * note with the current version this code will only be used 		 * by OpenBSD, NetBSD and FreeBSD have methods for 		 * re-defining sosend() to use sctp_sosend().  One can 		 * optionaly switch back to this code (by changing back the 		 * defininitions but this is not advisable. 		 */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_output
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|pkt
argument_list|,
name|addr
argument_list|,
name|inp
operator|->
name|control
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|inp
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|vrf_id
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
endif|#
directive|endif
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
comment|/* I made the same as TCP since we are 					 * not setup? */
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET
case|case
name|AF_INET
case|:
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|addr
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* Bind a ephemeral port */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sctp6_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EADDRINUSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
comment|/* 		 * if IPV6_V6ONLY flag, ignore connections destined to a v4 		 * addr or v4-mapped addr 		 */
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|MODULE_GLOBAL
argument_list|(
name|ip6_v6only
argument_list|)
condition|)
block|{
comment|/* convert v4-mapped into v4 addr */
name|in6_sin6_2_sin
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
block|}
else|else
block|{
comment|/* mapped addresses aren't enabled */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* INET */
comment|/* Now do we connect? */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EALREADY
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
comment|/* We are GOOD to go */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Gak! no memory */
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
operator|(
name|void
operator|)
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* initialize authentication parameters for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_SO_LOCKED
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_getaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|vrf_id
decl_stmt|;
name|struct
name|sctp_ifa
modifier|*
name|sctp_ifa
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Do the malloc first in case it blocks. 	 */
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin6
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* For the bound all case you get back 0 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin_a6
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
goto|goto
name|notConn6
goto|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|sin_a6
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a6
operator|==
name|NULL
condition|)
comment|/* this will make coverity happy */
continue|continue;
if|if
condition|(
name|sin_a6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fnd
operator|)
operator|||
operator|(
name|sin_a6
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* punt */
goto|goto
name|notConn6
goto|;
block|}
name|vrf_id
operator|=
name|inp
operator|->
name|def_vrf_id
expr_stmt|;
name|sctp_ifa
operator|=
name|sctp_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
name|sctp_route_t
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|,
name|vrf_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|sctp_ifa
condition|)
block|{
name|sin6
operator|->
name|sin6_addr
operator|=
name|sctp_ifa
operator|->
name|address
operator|.
name|sin6
operator|.
name|sin6_addr
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* For the bound all case you get back 0 */
name|notConn6
label|:
name|memset
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Take the first IPv6 address in the list */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin_a
decl_stmt|;
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|laddr
operator|->
name|ifa
operator|->
name|address
operator|.
name|sin6
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|sin_a
operator|->
name|sin6_addr
expr_stmt|;
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Scoping things for v6 */
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
operator|*
name|addr
operator|)
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin_a6
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* Do the malloc first in case it blocks. */
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin6
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin6
argument_list|)
expr_stmt|;
if|if
condition|(
name|sin6
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* UDP type and listeners will drop out here */
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ENOTCONN
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
block|{
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ECONNRESET
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|sin_a6
operator|->
name|sin6_addr
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
comment|/* No IPv4 address */
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_in6getaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
endif|#
directive|endif
name|struct
name|in6pcb
modifier|*
name|inp6
init|=
name|sotoin6pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|inp6
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* allow v6 addresses precedence */
name|error
operator|=
name|sctp6_getaddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|error
condition|)
block|{
comment|/* try v4 next if v6 failed */
name|error
operator|=
name|sctp_ingetaddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|addr
operator|=
operator|*
name|nam
expr_stmt|;
comment|/* if I'm V6ONLY, convert it to v4-mapped */
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_getpeeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
endif|#
directive|endif
name|struct
name|in6pcb
modifier|*
name|inp6
init|=
name|sotoin6pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|inp6
operator|==
name|NULL
condition|)
block|{
name|SCTP_LTRACE_ERR_RET
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
argument_list|,
name|EINVAL
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* allow v6 addresses precedence */
name|error
operator|=
name|sctp6_peeraddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|error
condition|)
block|{
comment|/* try v4 next if v6 failed */
name|error
operator|=
name|sctp_peeraddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
name|addr
operator|=
operator|*
name|nam
expr_stmt|;
comment|/* if I'm V6ONLY, convert it to v4-mapped */
if|if
condition|(
name|SCTP_IPV6_V6ONLY
argument_list|(
name|inp6
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pr_usrreqs
name|sctp6_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|sctp6_abort
block|,
operator|.
name|pru_accept
operator|=
name|sctp_accept
block|,
operator|.
name|pru_attach
operator|=
name|sctp6_attach
block|,
operator|.
name|pru_bind
operator|=
name|sctp6_bind
block|,
operator|.
name|pru_connect
operator|=
name|sctp6_connect
block|,
operator|.
name|pru_control
operator|=
name|in6_control
block|,
operator|.
name|pru_close
operator|=
name|sctp6_close
block|,
operator|.
name|pru_detach
operator|=
name|sctp6_close
block|,
operator|.
name|pru_sopoll
operator|=
name|sopoll_generic
block|,
operator|.
name|pru_flush
operator|=
name|sctp_flush
block|,
operator|.
name|pru_disconnect
operator|=
name|sctp6_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|sctp_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|sctp6_getpeeraddr
block|,
operator|.
name|pru_send
operator|=
name|sctp6_send
block|,
operator|.
name|pru_shutdown
operator|=
name|sctp_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|sctp6_in6getaddr
block|,
operator|.
name|pru_sosend
operator|=
name|sctp_sosend
block|,
operator|.
name|pru_soreceive
operator|=
name|sctp_soreceive
block|}
decl_stmt|;
end_decl_stmt

end_unit

