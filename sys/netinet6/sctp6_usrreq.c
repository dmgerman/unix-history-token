begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001-2006, Cisco Systems, Inc. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are met:  *  * a) Redistributions of source code must retain the above copyright notice,  *   this list of conditions and the following disclaimer.  *  * b) Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in  *   the documentation and/or other materials provided with the distribution.  *  * c) Neither the name of Cisco Systems, Inc. nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF  * THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*	$KAME: sctp6_usrreq.c,v 1.38 2005/08/24 08:08:56 suz Exp $	*/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_ipsec.h"
end_include

begin_include
include|#
directive|include
file|"opt_sctp.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/domain.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_os.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_header.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctputil.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_output.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_input.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_asconf.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/scope6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp_bsd_addr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_pcb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/sctp6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6protosw.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPSEC
end_ifdef

begin_include
include|#
directive|include
file|<netinet6/ipsec.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ipsec6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IPSEC */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NFAITH
argument_list|)
operator|&&
name|NFAITH
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|<net/if_faith.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|struct
name|protosw
name|inetsw
index|[]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|in6pcb
end_ifndef

begin_define
define|#
directive|define
name|in6pcb
value|inpcb
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|sotoin6pcb
end_ifndef

begin_define
define|#
directive|define
name|sotoin6pcb
value|sotoinpcb
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SCTP_DEBUG
end_ifdef

begin_decl_stmt
specifier|extern
name|u_int32_t
name|sctp_debug_on
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|sctp_no_csum_on_loopback
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|sctp6_input
parameter_list|(
name|mp
parameter_list|,
name|offp
parameter_list|,
name|proto
parameter_list|)
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
modifier|*
name|offp
decl_stmt|;
name|int
name|proto
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
operator|*
name|mp
decl_stmt|;
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
name|struct
name|sctphdr
modifier|*
name|sh
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|in6p
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|refcount_up
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|check
decl_stmt|,
name|calc_check
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|in6p_ip
decl_stmt|;
name|struct
name|sctp_chunkhdr
modifier|*
name|ch
decl_stmt|;
name|int
name|length
decl_stmt|,
name|mlen
decl_stmt|,
name|offset
decl_stmt|,
name|iphlen
decl_stmt|;
name|u_int8_t
name|ecn_bits
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|int
name|off
init|=
operator|*
name|offp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ip6
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ip6_hdr
operator|*
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|PULLDOWN_TEST
comment|/* If PULLDOWN_TEST off, must be in a single mbuf. */
name|IP6_EXTHDR_CHECK
argument_list|(
name|m
argument_list|,
name|off
argument_list|,
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|)
argument_list|,
name|IPPROTO_DONE
argument_list|)
expr_stmt|;
name|sh
operator|=
operator|(
expr|struct
name|sctphdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|ip6
operator|+
name|off
operator|)
expr_stmt|;
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sh
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* Ensure that (sctphdr + sctp_chunkhdr) in a row. */
name|IP6_EXTHDR_GET
argument_list|(
name|sh
argument_list|,
expr|struct
name|sctphdr
operator|*
argument_list|,
name|m
argument_list|,
name|off
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
block|{
name|SCTP_STAT_INCR
argument_list|(
name|sctps_hdrops
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
name|ch
operator|=
operator|(
expr|struct
name|sctp_chunkhdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|sh
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|sctphdr
argument_list|)
operator|)
expr_stmt|;
endif|#
directive|endif
name|iphlen
operator|=
name|off
expr_stmt|;
name|offset
operator|=
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NFAITH
argument_list|)
operator|&&
name|NFAITH
operator|>
literal|0
if|if
condition|(
name|faithprefix_p
operator|!=
name|NULL
operator|&&
call|(
modifier|*
name|faithprefix_p
call|)
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* XXX send icmp6 host/port unreach? */
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* NFAITH defined and> 0 */
name|SCTP_STAT_INCR
argument_list|(
name|sctps_recvpackets
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER64
argument_list|(
name|sctps_inpackets
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"V6 input gets a packet iphlen:%d pktlen:%d\n"
argument_list|,
name|iphlen
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
block|{
comment|/* No multi-cast support in SCTP */
goto|goto
name|bad
goto|;
block|}
comment|/* destination port of 0 is illegal, based on RFC2960. */
if|if
condition|(
name|sh
operator|->
name|dest_port
operator|==
literal|0
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
operator|(
name|sctp_no_csum_on_loopback
operator|==
literal|0
operator|)
operator|||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
operator|)
operator|||
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|->
name|if_type
operator|!=
name|IFT_LOOP
operator|)
condition|)
block|{
comment|/* 		 * we do NOT validate things from the loopback if the sysctl 		 * is set to 1. 		 */
name|check
operator|=
name|sh
operator|->
name|checksum
expr_stmt|;
comment|/* save incoming checksum */
if|if
condition|(
operator|(
name|check
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sctp_no_csum_on_loopback
operator|)
condition|)
block|{
comment|/* 			 * special hook for where we got a local address 			 * somehow routed across a non IFT_LOOP type 			 * interface 			 */
if|if
condition|(
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
goto|goto
name|sctp_skip_csum
goto|;
block|}
name|sh
operator|->
name|checksum
operator|=
literal|0
expr_stmt|;
comment|/* prepare for calc */
name|calc_check
operator|=
name|sctp_calculate_sum
argument_list|(
name|m
argument_list|,
operator|&
name|mlen
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|calc_check
operator|!=
name|check
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_DEBUG
if|if
condition|(
name|sctp_debug_on
operator|&
name|SCTP_DEBUG_INPUT1
condition|)
block|{
name|printf
argument_list|(
literal|"Bad CSUM on SCTP packet calc_check:%x check:%x  m:%p mlen:%d iphlen:%d\n"
argument_list|,
name|calc_check
argument_list|,
name|check
argument_list|,
name|m
argument_list|,
name|mlen
argument_list|,
name|iphlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|in6p
argument_list|,
operator|&
name|net
argument_list|)
expr_stmt|;
comment|/* in6p's ref-count increased&& stcb locked */
if|if
condition|(
operator|(
name|in6p
operator|)
operator|&&
operator|(
name|stcb
operator|)
condition|)
block|{
name|sctp_send_packet_dropped
argument_list|(
name|stcb
argument_list|,
name|net
argument_list|,
name|m
argument_list|,
name|iphlen
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|in6p
argument_list|,
name|stcb
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|in6p
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
name|refcount_up
operator|=
literal|1
expr_stmt|;
block|}
name|SCTP_STAT_INCR
argument_list|(
name|sctps_badsum
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_checksumerrors
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|sh
operator|->
name|checksum
operator|=
name|calc_check
expr_stmt|;
block|}
else|else
block|{
name|sctp_skip_csum
label|:
name|mlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
name|net
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Locate pcb and tcb for datagram sctp_findassociation_addr() wants 	 * IP/SCTP/first chunk header... 	 */
name|stcb
operator|=
name|sctp_findassociation_addr
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
operator|&
name|in6p
argument_list|,
operator|&
name|net
argument_list|)
expr_stmt|;
comment|/* in6p's ref-count increased */
if|if
condition|(
name|in6p
operator|==
name|NULL
condition|)
block|{
name|struct
name|sctp_init_chunk
modifier|*
name|init_chk
decl_stmt|,
name|chunk_buf
decl_stmt|;
name|SCTP_STAT_INCR
argument_list|(
name|sctps_noport
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_INITIATION
condition|)
block|{
comment|/* 			 * we do a trick here to get the INIT tag, dig in 			 * and get the tag from the INIT and put it in the 			 * common header. 			 */
name|init_chk
operator|=
operator|(
expr|struct
name|sctp_init_chunk
operator|*
operator|)
name|sctp_m_getptr
argument_list|(
name|m
argument_list|,
name|iphlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|sh
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|init_chk
argument_list|)
argument_list|,
operator|(
name|u_int8_t
operator|*
operator|)
operator|&
name|chunk_buf
argument_list|)
expr_stmt|;
name|sh
operator|->
name|v_tag
operator|=
name|init_chk
operator|->
name|init
operator|.
name|initiate_tag
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_ACK
condition|)
block|{
name|sctp_send_shutdown_complete2
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|==
name|SCTP_SHUTDOWN_COMPLETE
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|ch
operator|->
name|chunk_type
operator|!=
name|SCTP_ABORT_ASSOCIATION
condition|)
name|sctp_send_abort
argument_list|(
name|m
argument_list|,
name|iphlen
argument_list|,
name|sh
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
elseif|else
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|refcount_up
operator|=
literal|1
expr_stmt|;
block|}
name|in6p_ip
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|in6p
expr_stmt|;
ifdef|#
directive|ifdef
name|IPSEC
comment|/* 	 * Check AH/ESP integrity. 	 */
if|if
condition|(
name|in6p_ip
operator|&&
operator|(
name|ipsec6_in_reject
argument_list|(
name|m
argument_list|,
name|in6p_ip
argument_list|)
operator|)
condition|)
block|{
comment|/* XXX */
name|ipsec6stat
operator|.
name|in_polvio
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
endif|#
directive|endif
comment|/* IPSEC */
comment|/* 	 * CONTROL chunk processing 	 */
name|length
operator|=
name|ntohs
argument_list|(
name|ip6
operator|->
name|ip6_plen
argument_list|)
operator|+
name|iphlen
expr_stmt|;
name|offset
operator|-=
sizeof|sizeof
argument_list|(
operator|*
name|ch
argument_list|)
expr_stmt|;
name|ecn_bits
operator|=
operator|(
operator|(
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
argument_list|)
operator|>>
literal|20
operator|)
operator|&
literal|0x000000ff
operator|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|sctp_common_input_processing
argument_list|(
operator|&
name|m
argument_list|,
name|iphlen
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|sh
argument_list|,
name|ch
argument_list|,
name|in6p
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|,
name|ecn_bits
argument_list|)
expr_stmt|;
comment|/* inp's ref-count reduced&& stcb unlocked */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* XXX this stuff below gets moved to appropriate parts later... */
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in6p
operator|)
operator|&&
name|refcount_up
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
block|}
return|return
name|IPPROTO_DONE
return|;
name|bad
label|:
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|in6p
operator|)
operator|&&
name|refcount_up
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|in6p
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|IPPROTO_DONE
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp6_notify_mbuf
parameter_list|(
name|struct
name|sctp_inpcb
modifier|*
name|inp
parameter_list|,
name|struct
name|icmp6_hdr
modifier|*
name|icmp6
parameter_list|,
name|struct
name|sctphdr
modifier|*
name|sh
parameter_list|,
name|struct
name|sctp_tcb
modifier|*
name|stcb
parameter_list|,
name|struct
name|sctp_nets
modifier|*
name|net
parameter_list|)
block|{
name|u_int32_t
name|nxtsz
decl_stmt|;
if|if
condition|(
operator|(
name|inp
operator|==
name|NULL
operator|)
operator|||
operator|(
name|stcb
operator|==
name|NULL
operator|)
operator|||
operator|(
name|net
operator|==
name|NULL
operator|)
operator|||
operator|(
name|icmp6
operator|==
name|NULL
operator|)
operator|||
operator|(
name|sh
operator|==
name|NULL
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* First do we even look at it? */
if|if
condition|(
name|ntohl
argument_list|(
name|sh
operator|->
name|v_tag
argument_list|)
operator|!=
operator|(
name|stcb
operator|->
name|asoc
operator|.
name|peer_vtag
operator|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|icmp6
operator|->
name|icmp6_type
operator|!=
name|ICMP6_PACKET_TOO_BIG
condition|)
block|{
comment|/* not PACKET TO BIG */
goto|goto
name|out
goto|;
block|}
comment|/* 	 * ok we need to look closely. We could even get smarter and look at 	 * anyone that we sent to in case we get a different ICMP that tells 	 * us there is no way to reach a host, but for this impl, all we 	 * care about is MTU discovery. 	 */
name|nxtsz
operator|=
name|ntohl
argument_list|(
name|icmp6
operator|->
name|icmp6_mtu
argument_list|)
expr_stmt|;
comment|/* Stop any PMTU timer */
name|sctp_timer_stop
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
operator|+
name|SCTP_LOC_1
argument_list|)
expr_stmt|;
comment|/* Adjust destination size limit */
if|if
condition|(
name|net
operator|->
name|mtu
operator|>
name|nxtsz
condition|)
block|{
name|net
operator|->
name|mtu
operator|=
name|nxtsz
expr_stmt|;
block|}
comment|/* now what about the ep? */
if|if
condition|(
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|>
name|nxtsz
condition|)
block|{
name|struct
name|sctp_tmit_chunk
modifier|*
name|chk
decl_stmt|;
comment|/* Adjust that too */
name|stcb
operator|->
name|asoc
operator|.
name|smallest_mtu
operator|=
name|nxtsz
expr_stmt|;
comment|/* now off to subtract IP_DF flag if needed */
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.send_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
call|(
name|u_int32_t
call|)
argument_list|(
name|chk
operator|->
name|send_size
operator|+
name|IP_HDR_SIZE
argument_list|)
operator|>
name|nxtsz
condition|)
block|{
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
block|}
block|}
name|TAILQ_FOREACH
argument_list|(
argument|chk
argument_list|,
argument|&stcb->asoc.sent_queue
argument_list|,
argument|sctp_next
argument_list|)
block|{
if|if
condition|(
call|(
name|u_int32_t
call|)
argument_list|(
name|chk
operator|->
name|send_size
operator|+
name|IP_HDR_SIZE
argument_list|)
operator|>
name|nxtsz
condition|)
block|{
comment|/* 				 * For this guy we also mark for immediate 				 * resend since we sent to big of chunk 				 */
name|chk
operator|->
name|flags
operator||=
name|CHUNK_FLAGS_FRAGMENT_OK
expr_stmt|;
if|if
condition|(
name|chk
operator|->
name|sent
operator|!=
name|SCTP_DATAGRAM_RESEND
condition|)
name|stcb
operator|->
name|asoc
operator|.
name|sent_queue_retran_cnt
operator|++
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
name|chk
operator|->
name|rec
operator|.
name|data
operator|.
name|doing_fast_retransmit
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent
operator|=
name|SCTP_DATAGRAM_RESEND
expr_stmt|;
comment|/* Clear any time so NO RTT is being done */
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|chk
operator|->
name|sent_rcv_time
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|stcb
operator|->
name|asoc
operator|.
name|total_flight
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
name|net
operator|->
name|flight_size
operator|-=
name|chk
operator|->
name|send_size
expr_stmt|;
block|}
block|}
block|}
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_PATHMTURAISE
argument_list|,
name|inp
argument_list|,
name|stcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sctp6_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|pktdst
parameter_list|,
name|d
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|pktdst
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|;
block|{
name|struct
name|sctphdr
name|sh
decl_stmt|;
name|struct
name|ip6ctlparam
modifier|*
name|ip6cp
init|=
name|NULL
decl_stmt|;
name|int
name|s
decl_stmt|,
name|cm
decl_stmt|;
if|if
condition|(
name|pktdst
operator|->
name|sa_family
operator|!=
name|AF_INET6
operator|||
name|pktdst
operator|->
name|sa_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|cmd
operator|>=
name|PRC_NCMDS
condition|)
return|return;
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
condition|)
block|{
name|d
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|inet6ctlerrmap
index|[
name|cmd
index|]
operator|==
literal|0
condition|)
block|{
return|return;
block|}
comment|/* if the parameter is from icmp6, decode it. */
if|if
condition|(
name|d
operator|!=
name|NULL
condition|)
block|{
name|ip6cp
operator|=
operator|(
expr|struct
name|ip6ctlparam
operator|*
operator|)
name|d
expr_stmt|;
block|}
else|else
block|{
name|ip6cp
operator|=
operator|(
expr|struct
name|ip6ctlparam
operator|*
operator|)
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ip6cp
condition|)
block|{
comment|/* 		 * XXX: We assume that when IPV6 is non NULL, M and OFF are 		 * valid. 		 */
comment|/* check if we can safely examine src and dst ports */
name|struct
name|sctp_inpcb
modifier|*
name|inp
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
init|=
name|NULL
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
init|=
name|NULL
decl_stmt|;
name|struct
name|sockaddr_in6
name|final
decl_stmt|;
if|if
condition|(
name|ip6cp
operator|->
name|ip6c_m
operator|==
name|NULL
operator|||
operator|(
name|size_t
operator|)
name|ip6cp
operator|->
name|ip6c_m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
operator|(
name|ip6cp
operator|->
name|ip6c_off
operator|+
sizeof|sizeof
argument_list|(
name|sh
argument_list|)
operator|)
condition|)
return|return;
name|bzero
argument_list|(
operator|&
name|sh
argument_list|,
sizeof|sizeof
argument_list|(
name|sh
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|final
argument_list|,
sizeof|sizeof
argument_list|(
name|final
argument_list|)
argument_list|)
expr_stmt|;
name|inp
operator|=
name|NULL
expr_stmt|;
name|net
operator|=
name|NULL
expr_stmt|;
name|m_copydata
argument_list|(
name|ip6cp
operator|->
name|ip6c_m
argument_list|,
name|ip6cp
operator|->
name|ip6c_off
argument_list|,
sizeof|sizeof
argument_list|(
name|sh
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|sh
argument_list|)
expr_stmt|;
name|ip6cp
operator|->
name|ip6c_src
operator|->
name|sin6_port
operator|=
name|sh
operator|.
name|src_port
expr_stmt|;
name|final
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|final
argument_list|)
expr_stmt|;
name|final
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|final
operator|.
name|sin6_addr
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|pktdst
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|final
operator|.
name|sin6_port
operator|=
name|sh
operator|.
name|dest_port
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|ip6cp
operator|->
name|ip6c_src
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|final
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* inp's ref-count increased&& stcb locked */
if|if
condition|(
name|stcb
operator|!=
name|NULL
operator|&&
name|inp
operator|&&
operator|(
name|inp
operator|->
name|sctp_socket
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|cmd
operator|==
name|PRC_MSGSIZE
condition|)
block|{
name|sctp6_notify_mbuf
argument_list|(
name|inp
argument_list|,
name|ip6cp
operator|->
name|ip6c_icmp6
argument_list|,
operator|&
name|sh
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* inp's ref-count reduced&& stcb unlocked */
block|}
else|else
block|{
if|if
condition|(
name|cmd
operator|==
name|PRC_HOSTDEAD
condition|)
block|{
name|cm
operator|=
name|EHOSTUNREACH
expr_stmt|;
block|}
else|else
block|{
name|cm
operator|=
name|inet6ctlerrmap
index|[
name|cmd
index|]
expr_stmt|;
block|}
name|sctp_notify
argument_list|(
name|inp
argument_list|,
name|cm
argument_list|,
operator|&
name|sh
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|final
argument_list|,
name|stcb
argument_list|,
name|net
argument_list|)
expr_stmt|;
comment|/* inp's ref-count reduced&& stcb unlocked */
block|}
block|}
else|else
block|{
if|if
condition|(
name|PRC_IS_REDIRECT
argument_list|(
name|cmd
argument_list|)
operator|&&
name|inp
condition|)
block|{
name|in6_rtchange
argument_list|(
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
argument_list|,
name|inet6ctlerrmap
index|[
name|cmd
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inp
condition|)
block|{
comment|/* reduce inp's ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * this routine can probably be collasped into the one in sctp_userreq.c  * since they do the same thing and now we lookup with a sockaddr  */
end_comment

begin_function
specifier|static
name|int
name|sctp6_getcred
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|xucred
name|xuc
decl_stmt|;
name|struct
name|sockaddr_in6
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * XXXRW: Other instances of getcred use SUSER_ALLOWJAIL, as socket 	 * visibility is scoped using cr_canseesocket(), which it is not 	 * here. 	 */
name|error
operator|=
name|priv_check_cred
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|PRIV_NETINET_RESERVEDPORT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|newlen
operator|!=
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|req
operator|->
name|oldlen
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|ucred
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
name|addrs
argument_list|,
sizeof|sizeof
argument_list|(
name|addrs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|stcb
operator|=
name|sctp_findassociation_addr_sa
argument_list|(
name|sin6tosa
argument_list|(
operator|&
name|addrs
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|sin6tosa
argument_list|(
operator|&
name|addrs
index|[
literal|1
index|]
argument_list|)
argument_list|,
operator|&
name|inp
argument_list|,
operator|&
name|net
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
operator|||
name|inp
operator|==
name|NULL
operator|||
name|inp
operator|->
name|sctp_socket
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|inp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|stcb
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* reduce ref-count */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|cred_can_cont
goto|;
block|}
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
comment|/* 	 * We use the write lock here, only since in the error leg we need 	 * it. If we used RLOCK, then we would have to 	 * wlock/decr/unlock/rlock. Which in theory could create a hole. 	 * Better to use higher wlock. 	 */
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|cred_can_cont
label|:
name|error
operator|=
name|cr_canseesocket
argument_list|(
name|req
operator|->
name|td
operator|->
name|td_ucred
argument_list|,
name|inp
operator|->
name|sctp_socket
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|cru2x
argument_list|(
name|inp
operator|->
name|sctp_socket
operator|->
name|so_cred
argument_list|,
operator|&
name|xuc
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|xuc
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|xucred
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_inet6_sctp6
argument_list|,
name|OID_AUTO
argument_list|,
name|getcred
argument_list|,
name|CTLTYPE_OPAQUE
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sctp6_getcred
argument_list|,
literal|"S,ucred"
argument_list|,
literal|"Get the ucred of a SCTP6 connection"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* This is the same as the sctp_abort() could be made common */
end_comment

begin_function
specifier|static
name|void
name|sctp6_abort
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|16
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mbcnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Now null out the reference, we are completely detached. 		 */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_attach
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|proto
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|!=
name|NULL
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|so
operator|->
name|so_snd
operator|.
name|sb_hiwat
operator|==
literal|0
operator|||
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|soreserve
argument_list|(
name|so
argument_list|,
name|sctp_sendspace
argument_list|,
name|sctp_recvspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|sctp_inpcb_alloc
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|inp
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_BOUND_V6
expr_stmt|;
comment|/* I'm v6! */
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
name|inp6
operator|->
name|in6p_hops
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* use kernel default */
name|inp6
operator|->
name|in6p_cksum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* just to be sure */
ifdef|#
directive|ifdef
name|INET
comment|/* 	 * XXX: ugly!! IPv4 TTL initialization is necessary for an IPv6 	 * socket as well, because the socket may be bound to an IPv6 	 * wildcard address, which may match an IPv4-mapped IPv6 address. 	 */
name|inp6
operator|->
name|inp_ip_ttl
operator|=
name|ip_defttl
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Hmm what about the IPSEC stuff that is missing here but in 	 * sctp_attach()? 	 */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_bind
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return
name|EINVAL
return|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV4
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV6
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
operator|(
name|inp6
operator|->
name|inp_flags
operator|&
name|IN6P_IPV6_V6ONLY
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* binding v4 addr to v6 socket, so reset flags */
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV6
expr_stmt|;
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6_p
decl_stmt|;
name|sin6_p
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|sin6_p
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6_p
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6_p
argument_list|)
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator||=
name|INP_IPV4
expr_stmt|;
name|inp6
operator|->
name|inp_vflag
operator|&=
operator|~
name|INP_IPV6
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|addr
operator|!=
name|NULL
condition|)
block|{
comment|/* IPV6_V6ONLY socket */
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
comment|/* can't bind v4 addr to v6 only socket! */
return|return
name|EINVAL
return|;
block|}
else|else
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6_p
decl_stmt|;
name|sin6_p
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6_p
operator|->
name|sin6_addr
argument_list|)
condition|)
comment|/* can't bind v4-mapped addrs either! */
comment|/* NOTE: we don't support SIIT */
return|return
name|EINVAL
return|;
block|}
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|error
operator|=
name|sctp_inpcb_bind
argument_list|(
name|so
argument_list|,
name|addr
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sctp6_close
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Inform all the lower layer assoc that we are done. 	 */
name|sctp_must_try_again
label|:
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|17
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|atomic_cmpset_int
argument_list|(
operator|&
name|inp
operator|->
name|sctp_flags
argument_list|,
name|flags
argument_list|,
operator|(
name|flags
operator||
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator||
name|SCTP_PCB_FLAGS_CLOSE_IP
operator|)
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_linger
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|13
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|SCTP_LOG_CLOSING
name|sctp_log_closing
argument_list|(
name|inp
argument_list|,
name|NULL
argument_list|,
literal|14
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sctp_inpcb_free
argument_list|(
name|inp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * The socket is now detached, no matter what the state of 		 * the SCTP association. 		 */
name|SOCK_LOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_snd
operator|.
name|sb_mbcnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * same for the rcv ones, they are only here for the 		 * accounting/select. 		 */
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|=
literal|0
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mb
operator|=
name|NULL
expr_stmt|;
name|so
operator|->
name|so_rcv
operator|.
name|sb_mbcnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Now null out the reference, we are completely detached. 		 */
name|so
operator|->
name|so_pcb
operator|=
name|NULL
expr_stmt|;
name|SOCK_UNLOCK
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|inp
operator|->
name|sctp_flags
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|SCTP_PCB_FLAGS_SOCKET_GONE
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|sctp_must_try_again
goto|;
block|}
block|}
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_disconnect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* XXX */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
condition|)
block|{
comment|/* No connection */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
else|else
block|{
name|int
name|some_on_streamwheel
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_association
modifier|*
name|asoc
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|asoc
operator|=
operator|&
name|stcb
operator|->
name|asoc
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|so
operator|->
name|so_options
operator|&
name|SO_LINGER
operator|)
operator|&&
operator|(
name|so
operator|->
name|so_linger
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
name|so
operator|->
name|so_rcv
operator|.
name|sb_cc
operator|>
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_COOKIE_WAIT
condition|)
block|{
comment|/* Left with Data unread */
name|struct
name|mbuf
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|MGET
argument_list|(
name|err
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 						 * Fill in the user 						 * initiated abort 						 */
name|struct
name|sctp_paramhdr
modifier|*
name|ph
decl_stmt|;
name|ph
operator|=
name|mtod
argument_list|(
name|err
argument_list|,
expr|struct
name|sctp_paramhdr
operator|*
argument_list|)
expr_stmt|;
name|err
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sctp_paramhdr
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_type
operator|=
name|htons
argument_list|(
name|SCTP_CAUSE_USER_INITIATED_ABT
argument_list|)
expr_stmt|;
name|ph
operator|->
name|param_length
operator|=
name|htons
argument_list|(
name|err
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|sctp_send_abort_tcb
argument_list|(
name|stcb
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|SCTP_STAT_INCR_COUNTER32
argument_list|(
name|sctps_aborted
argument_list|)
expr_stmt|;
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_OPEN
operator|)
operator|||
operator|(
name|SCTP_GET_STATE
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
argument_list|)
operator|==
name|SCTP_STATE_SHUTDOWN_RECEIVED
operator|)
condition|)
block|{
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
block|}
name|sctp_free_assoc
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
name|SCTP_DONOT_SETSCOPE
argument_list|,
name|SCTP_FROM_SCTP6_USRREQ
operator|+
name|SCTP_LOC_2
argument_list|)
expr_stmt|;
comment|/* No unlock tcb assoc is gone */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|out_wheel
argument_list|)
condition|)
block|{
comment|/* Check to see if some data queued */
name|struct
name|sctp_stream_out
modifier|*
name|outs
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|outs
argument_list|,
argument|&asoc->out_wheel
argument_list|,
argument|next_spoke
argument_list|)
block|{
if|if
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|outs
operator|->
name|outqueue
argument_list|)
condition|)
block|{
name|some_on_streamwheel
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|send_queue
argument_list|)
operator|&&
name|TAILQ_EMPTY
argument_list|(
operator|&
name|asoc
operator|->
name|sent_queue
argument_list|)
operator|&&
operator|(
name|some_on_streamwheel
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* nothing queued to send, so I'm done... */
if|if
condition|(
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_SENT
operator|)
operator|&&
operator|(
name|SCTP_GET_STATE
argument_list|(
name|asoc
argument_list|)
operator|!=
name|SCTP_STATE_SHUTDOWN_ACK_SENT
operator|)
condition|)
block|{
comment|/* only send SHUTDOWN the first time */
name|sctp_send_shutdown
argument_list|(
name|stcb
argument_list|,
name|stcb
operator|->
name|asoc
operator|.
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_chunk_output
argument_list|(
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|asoc
operator|->
name|state
operator|=
name|SCTP_STATE_SHUTDOWN_SENT
expr_stmt|;
name|SCTP_STAT_DECR_GAUGE32
argument_list|(
name|sctps_currestab
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWN
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
name|sctp_timer_start
argument_list|(
name|SCTP_TIMER_TYPE_SHUTDOWNGUARD
argument_list|,
name|stcb
operator|->
name|sctp_ep
argument_list|,
name|stcb
argument_list|,
name|asoc
operator|->
name|primary_destination
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 				 * we still got (or just got) data to send, 				 * so set SHUTDOWN_PENDING 				 */
comment|/* 				 * XXX sockets draft says that MSG_EOF 				 * should be sent with no data.  currently, 				 * we will allow user data to be sent first 				 * and move to SHUTDOWN-PENDING 				 */
name|asoc
operator|->
name|state
operator||=
name|SCTP_STATE_SHUTDOWN_PENDING
expr_stmt|;
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* UDP model does not support this */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
block|}
end_function

begin_function_decl
name|int
name|sctp_sendm
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|sctp6_send
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|mbuf
modifier|*
name|control
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|inpcb
modifier|*
name|in_inp
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
comment|/* No SPL needed since sctp_output does this */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|control
condition|)
block|{
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|in_inp
operator|=
operator|(
expr|struct
name|inpcb
operator|*
operator|)
name|inp
expr_stmt|;
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|inp
expr_stmt|;
comment|/* 	 * For the TCP model we may get a NULL addr, if we are a connected 	 * socket thats ok. 	 */
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|&&
operator|(
name|addr
operator|==
name|NULL
operator|)
condition|)
block|{
goto|goto
name|connected_type
goto|;
block|}
if|if
condition|(
name|addr
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|control
condition|)
block|{
name|m_freem
argument_list|(
name|control
argument_list|)
expr_stmt|;
name|control
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|EDESTADDRREQ
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|inp6
operator|->
name|inp_flags
operator|&
name|IN6P_IPV6_V6ONLY
operator|)
condition|)
block|{
comment|/* 		 * if IPV6_V6ONLY flag, we discard datagrams destined to a 		 * v4 addr or v4-mapped addr 		 */
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ip6_v6only
condition|)
block|{
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
comment|/* convert v4-mapped into v4 addr and send */
name|in6_sin6_2_sin
argument_list|(
operator|&
name|sin
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
return|return
name|sctp_sendm
argument_list|(
name|so
argument_list|,
name|flags
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|control
argument_list|,
name|p
argument_list|)
return|;
block|}
else|else
block|{
comment|/* mapped addresses aren't enabled */
return|return
name|EINVAL
return|;
block|}
block|}
endif|#
directive|endif
comment|/* INET */
name|connected_type
label|:
comment|/* now what about control */
if|if
condition|(
name|control
condition|)
block|{
if|if
condition|(
name|inp
operator|->
name|control
condition|)
block|{
name|printf
argument_list|(
literal|"huh? control set?\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|inp
operator|->
name|control
argument_list|)
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
block|}
name|inp
operator|->
name|control
operator|=
name|control
expr_stmt|;
block|}
comment|/* add it in possibly */
if|if
condition|(
operator|(
name|inp
operator|->
name|pkt
operator|)
operator|&&
operator|(
name|inp
operator|->
name|pkt
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|x
decl_stmt|;
name|int
name|c_len
decl_stmt|;
name|c_len
operator|=
literal|0
expr_stmt|;
comment|/* How big is it */
for|for
control|(
name|x
operator|=
name|m
init|;
name|x
condition|;
name|x
operator|=
name|x
operator|->
name|m_next
control|)
block|{
name|c_len
operator|+=
name|x
operator|->
name|m_len
expr_stmt|;
block|}
name|inp
operator|->
name|pkt
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|c_len
expr_stmt|;
block|}
comment|/* Place the data */
if|if
condition|(
name|inp
operator|->
name|pkt
condition|)
block|{
name|inp
operator|->
name|pkt_last
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|inp
operator|->
name|pkt_last
operator|=
name|m
expr_stmt|;
block|}
else|else
block|{
name|inp
operator|->
name|pkt_last
operator|=
name|inp
operator|->
name|pkt
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
comment|/* FreeBSD and MacOSX uses a flag passed */
operator|(
operator|(
name|flags
operator|&
name|PRUS_MORETOCOME
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * note with the current version this code will only be used 		 * by OpenBSD, NetBSD and FreeBSD have methods for 		 * re-defining sosend() to use sctp_sosend().  One can 		 * optionaly switch back to this code (by changing back the 		 * defininitions but this is not advisable. 		 */
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|sctp_output
argument_list|(
name|inp
argument_list|,
name|inp
operator|->
name|pkt
argument_list|,
name|addr
argument_list|,
name|inp
operator|->
name|control
argument_list|,
name|p
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|inp
operator|->
name|pkt
operator|=
name|NULL
expr_stmt|;
name|inp
operator|->
name|control
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_connect
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|thread
modifier|*
name|p
parameter_list|)
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
endif|#
directive|endif
comment|/* INET */
name|inp6
operator|=
operator|(
expr|struct
name|in6pcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
literal|0
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ECONNRESET
operator|)
return|;
comment|/* I made the same as TCP since we are 					 * not setup? */
block|}
name|SCTP_ASOC_CREATE_LOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_UNBOUND
operator|)
operator|==
name|SCTP_PCB_FLAGS_UNBOUND
condition|)
block|{
comment|/* Bind a ephemeral port */
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|error
operator|=
name|sctp6_bind
argument_list|(
name|so
argument_list|,
name|NULL
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
operator|)
operator|&&
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
condition|)
block|{
comment|/* We are already connected AND the TCP model */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
operator|(
name|EADDRINUSE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|INET
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|inp6
operator|->
name|inp_flags
operator|&
name|IN6P_IPV6_V6ONLY
operator|)
condition|)
block|{
comment|/* 		 * if IPV6_V6ONLY flag, ignore connections destined to a v4 		 * addr or v4-mapped addr 		 */
if|if
condition|(
name|addr
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|ip6_v6only
condition|)
block|{
comment|/* convert v4-mapped into v4 addr */
name|in6_sin6_2_sin
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|sin6
argument_list|)
expr_stmt|;
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
block|}
else|else
block|{
comment|/* mapped addresses aren't enabled */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
else|else
endif|#
directive|endif
comment|/* INET */
name|addr
operator|=
name|addr
expr_stmt|;
comment|/* for true v6 address case */
comment|/* Now do we connect? */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_INCR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|sctp_findassociation_ep_addr
argument_list|(
operator|&
name|inp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_INP_WLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_DECR_REF
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_INP_WUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|stcb
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have or am bring up an association */
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|EALREADY
operator|)
return|;
block|}
comment|/* We are GOOD to go */
name|stcb
operator|=
name|sctp_aloc_assoc
argument_list|(
name|inp
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|,
operator|&
name|error
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SCTP_ASOC_CREATE_UNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
comment|/* Gak! no memory */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_TCPTYPE
condition|)
block|{
name|stcb
operator|->
name|sctp_ep
operator|->
name|sctp_flags
operator||=
name|SCTP_PCB_FLAGS_CONNECTED
expr_stmt|;
comment|/* Set the connected flag so we can queue data */
name|soisconnecting
argument_list|(
name|so
argument_list|)
expr_stmt|;
block|}
name|stcb
operator|->
name|asoc
operator|.
name|state
operator|=
name|SCTP_STATE_COOKIE_WAIT
expr_stmt|;
name|SCTP_GETTIME_TIMEVAL
argument_list|(
operator|&
name|stcb
operator|->
name|asoc
operator|.
name|time_entered
argument_list|)
expr_stmt|;
comment|/* initialize authentication parameters for the assoc */
name|sctp_initialize_auth_params
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|sctp_send_initiate
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_getaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Do the malloc first in case it blocks. 	 */
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin6
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|inp
operator|->
name|sctp_lport
expr_stmt|;
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_BOUNDALL
condition|)
block|{
comment|/* For the bound all case you get back 0 */
if|if
condition|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
condition|)
block|{
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin_a6
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
goto|goto
name|notConn6
goto|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|sin_a6
operator|=
name|NULL
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a6
operator|==
name|NULL
condition|)
comment|/* this will make coverity happy */
continue|continue;
if|if
condition|(
name|sin_a6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
operator|!
name|fnd
operator|)
operator|||
operator|(
name|sin_a6
operator|==
name|NULL
operator|)
condition|)
block|{
comment|/* punt */
goto|goto
name|notConn6
goto|;
block|}
name|sin6
operator|->
name|sin6_addr
operator|=
name|sctp_ipv6_source_address_selection
argument_list|(
name|inp
argument_list|,
name|stcb
argument_list|,
operator|(
expr|struct
name|route
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
argument_list|,
name|net
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* For the bound all case you get back 0 */
name|notConn6
label|:
name|memset
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Take the first IPv6 address in the list */
name|struct
name|sctp_laddr
modifier|*
name|laddr
decl_stmt|;
name|int
name|fnd
init|=
literal|0
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|laddr
argument_list|,
argument|&inp->sctp_addr_list
argument_list|,
argument|sctp_nxt_addr
argument_list|)
block|{
if|if
condition|(
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin_a
decl_stmt|;
name|sin_a
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|laddr
operator|->
name|ifa
operator|->
name|ifa_addr
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|sin_a
operator|->
name|sin6_addr
expr_stmt|;
name|fnd
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
block|}
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
comment|/* Scoping things for v6 */
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
operator|*
name|addr
operator|)
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_peeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|addr
parameter_list|)
block|{
name|struct
name|sockaddr_in6
modifier|*
name|sin6
init|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|*
name|addr
decl_stmt|;
name|int
name|fnd
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin_a6
decl_stmt|;
name|struct
name|sctp_inpcb
modifier|*
name|inp
decl_stmt|;
name|struct
name|sctp_tcb
modifier|*
name|stcb
decl_stmt|;
name|struct
name|sctp_nets
modifier|*
name|net
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Do the malloc first in case it blocks. 	 */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
operator|(
name|inp
operator|->
name|sctp_flags
operator|&
name|SCTP_PCB_FLAGS_CONNECTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* UDP type and listeners will drop out here */
return|return
operator|(
name|ENOTCONN
operator|)
return|;
block|}
name|SCTP_MALLOC_SONAME
argument_list|(
name|sin6
argument_list|,
expr|struct
name|sockaddr_in6
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|sin6
argument_list|)
expr_stmt|;
comment|/* We must recapture incase we blocked */
name|inp
operator|=
operator|(
expr|struct
name|sctp_inpcb
operator|*
operator|)
name|so
operator|->
name|so_pcb
expr_stmt|;
if|if
condition|(
name|inp
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|SCTP_INP_RLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
name|stcb
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|inp
operator|->
name|sctp_asoc_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
condition|)
name|SCTP_TCB_LOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
name|SCTP_INP_RUNLOCK
argument_list|(
name|inp
argument_list|)
expr_stmt|;
if|if
condition|(
name|stcb
operator|==
name|NULL
condition|)
block|{
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
name|ECONNRESET
return|;
block|}
name|fnd
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|net
argument_list|,
argument|&stcb->asoc.nets
argument_list|,
argument|sctp_next
argument_list|)
block|{
name|sin_a6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|net
operator|->
name|ro
operator|.
name|_l_addr
expr_stmt|;
if|if
condition|(
name|sin_a6
operator|->
name|sin6_family
operator|==
name|AF_INET6
condition|)
block|{
name|fnd
operator|=
literal|1
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
name|stcb
operator|->
name|rport
expr_stmt|;
name|sin6
operator|->
name|sin6_addr
operator|=
name|sin_a6
operator|->
name|sin6_addr
expr_stmt|;
break|break;
block|}
block|}
name|SCTP_TCB_UNLOCK
argument_list|(
name|stcb
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fnd
condition|)
block|{
comment|/* No IPv4 address */
name|SCTP_FREE_SONAME
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
return|return
name|ENOENT
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|sa6_recoverscope
argument_list|(
name|sin6
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin6
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_in6getaddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
init|=
name|sotoin6pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|inp6
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* allow v6 addresses precedence */
name|error
operator|=
name|sctp6_getaddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* try v4 next if v6 failed */
name|error
operator|=
name|sctp_ingetaddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|addr
operator|=
operator|*
name|nam
expr_stmt|;
comment|/* if I'm V6ONLY, convert it to v4-mapped */
if|if
condition|(
operator|(
name|inp6
operator|->
name|inp_flags
operator|&
name|IN6P_IPV6_V6ONLY
operator|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sctp6_getpeeraddr
parameter_list|(
name|struct
name|socket
modifier|*
name|so
parameter_list|,
name|struct
name|sockaddr
modifier|*
modifier|*
name|nam
parameter_list|)
block|{
name|struct
name|sockaddr
modifier|*
name|addr
init|=
operator|*
name|nam
decl_stmt|;
name|struct
name|in6pcb
modifier|*
name|inp6
init|=
name|sotoin6pcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|inp6
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
comment|/* allow v6 addresses precedence */
name|error
operator|=
name|sctp6_peeraddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* try v4 next if v6 failed */
name|error
operator|=
name|sctp_peeraddr
argument_list|(
name|so
argument_list|,
name|nam
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* if I'm V6ONLY, convert it to v4-mapped */
if|if
condition|(
operator|(
name|inp6
operator|->
name|inp_flags
operator|&
name|IN6P_IPV6_V6ONLY
operator|)
condition|)
block|{
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|in6_sin_2_v4mapsin6
argument_list|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
argument_list|,
operator|&
name|sin6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
name|struct
name|pr_usrreqs
name|sctp6_usrreqs
init|=
block|{
operator|.
name|pru_abort
operator|=
name|sctp6_abort
block|,
operator|.
name|pru_accept
operator|=
name|sctp_accept
block|,
operator|.
name|pru_attach
operator|=
name|sctp6_attach
block|,
operator|.
name|pru_bind
operator|=
name|sctp6_bind
block|,
operator|.
name|pru_connect
operator|=
name|sctp6_connect
block|,
operator|.
name|pru_control
operator|=
name|in6_control
block|,
operator|.
name|pru_close
operator|=
name|sctp6_close
block|,
operator|.
name|pru_detach
operator|=
name|sctp6_close
block|,
operator|.
name|pru_sopoll
operator|=
name|sopoll_generic
block|,
operator|.
name|pru_disconnect
operator|=
name|sctp6_disconnect
block|,
operator|.
name|pru_listen
operator|=
name|sctp_listen
block|,
operator|.
name|pru_peeraddr
operator|=
name|sctp6_getpeeraddr
block|,
operator|.
name|pru_send
operator|=
name|sctp6_send
block|,
operator|.
name|pru_shutdown
operator|=
name|sctp_shutdown
block|,
operator|.
name|pru_sockaddr
operator|=
name|sctp6_in6getaddr
block|,
operator|.
name|pru_sosend
operator|=
name|sctp_sosend
block|,
operator|.
name|pru_soreceive
operator|=
name|sctp_soreceive
block|}
decl_stmt|;
end_decl_stmt

end_unit

