begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * XXX  * KAME 970409 note:  * BSD/OS version heavily modifies this code, related to llinfo.  * Since we don't have BSD/OS version of net/route.c in our hand,  * I left the code mostly as it was in 970310.  -- itojun  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/if_atm.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_fddi.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/ip6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_prefix.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/icmp6.h>
end_include

begin_include
include|#
directive|include
file|"loop.h"
end_include

begin_include
include|#
directive|include
file|<net/net_osdep.h>
end_include

begin_define
define|#
directive|define
name|ND6_SLOWTIMER_INTERVAL
value|(60 * 60)
end_define

begin_comment
comment|/* 1 hour */
end_comment

begin_define
define|#
directive|define
name|ND6_RECALC_REACHTM_INTERVAL
value|(60 * 120)
end_define

begin_comment
comment|/* 2 hours */
end_comment

begin_define
define|#
directive|define
name|SIN6
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_in6 *)s)
end_define

begin_define
define|#
directive|define
name|SDL
parameter_list|(
name|s
parameter_list|)
value|((struct sockaddr_dl *)s)
end_define

begin_comment
comment|/* timer values */
end_comment

begin_decl_stmt
name|int
name|nd6_prune
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* walk list every 1 seconds */
end_comment

begin_decl_stmt
name|int
name|nd6_delay
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delay first probe time 5 second */
end_comment

begin_decl_stmt
name|int
name|nd6_umaxtries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum unicast query */
end_comment

begin_decl_stmt
name|int
name|nd6_mmaxtries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum multicast query */
end_comment

begin_decl_stmt
name|int
name|nd6_useloopback
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use loopback interface for local traffic */
end_comment

begin_decl_stmt
name|int
name|nd6_proxyall
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* enable Proxy Neighbor Advertisement */
end_comment

begin_comment
comment|/* for debugging? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nd6_inuse
decl_stmt|,
name|nd6_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|llinfo_nd6
name|llinfo_nd6
init|=
block|{
operator|&
name|llinfo_nd6
block|,
operator|&
name|llinfo_nd6
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nd_ifinfo
modifier|*
name|nd_ifinfo
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nd_drhead
name|nd_defrouter
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nd_prhead
name|nd_prefix
init|=
block|{
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nd6_recalc_reachtm_interval
init|=
name|ND6_RECALC_REACHTM_INTERVAL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in6
name|all1_sa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|nd6_slowtimo
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|nd6_init
parameter_list|()
block|{
specifier|static
name|int
name|nd6_init_done
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|nd6_init_done
condition|)
block|{
name|log
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"nd6_init called more than once(ignored)\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|all1_sa
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|all1_sa
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|all1_sa
operator|.
name|sin6_addr
argument_list|)
condition|;
name|i
operator|++
control|)
name|all1_sa
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
name|i
index|]
operator|=
literal|0xff
expr_stmt|;
name|nd6_init_done
operator|=
literal|1
expr_stmt|;
comment|/* start timer */
name|timeout
argument_list|(
name|nd6_slowtimo
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nd6_ifattach
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|static
name|size_t
name|if_indexlim
init|=
literal|8
decl_stmt|;
comment|/* 	 * We have some arrays that should be indexed by if_index. 	 * since if_index will grow dynamically, they should grow too. 	 */
if|if
condition|(
name|nd_ifinfo
operator|==
name|NULL
operator|||
name|if_index
operator|>=
name|if_indexlim
condition|)
block|{
name|size_t
name|n
decl_stmt|;
name|caddr_t
name|q
decl_stmt|;
while|while
condition|(
name|if_index
operator|>=
name|if_indexlim
condition|)
name|if_indexlim
operator|<<=
literal|1
expr_stmt|;
comment|/* grow nd_ifinfo */
name|n
operator|=
name|if_indexlim
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|nd_ifinfo
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|caddr_t
operator|)
name|malloc
argument_list|(
name|n
argument_list|,
name|M_IP6NDP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|q
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|nd_ifinfo
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd_ifinfo
argument_list|,
name|q
argument_list|,
name|n
operator|/
literal|2
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|caddr_t
operator|)
name|nd_ifinfo
argument_list|,
name|M_IP6NDP
argument_list|)
expr_stmt|;
block|}
name|nd_ifinfo
operator|=
operator|(
expr|struct
name|nd_ifinfo
operator|*
operator|)
name|q
expr_stmt|;
block|}
define|#
directive|define
name|ND
value|nd_ifinfo[ifp->if_index]
name|ND
operator|.
name|linkmtu
operator|=
name|ifindex2ifnet
index|[
name|ifp
operator|->
name|if_index
index|]
operator|->
name|if_mtu
expr_stmt|;
name|ND
operator|.
name|chlim
operator|=
name|IPV6_DEFHLIM
expr_stmt|;
name|ND
operator|.
name|basereachable
operator|=
name|REACHABLE_TIME
expr_stmt|;
name|ND
operator|.
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|ND
operator|.
name|basereachable
argument_list|)
expr_stmt|;
name|ND
operator|.
name|retrans
operator|=
name|RETRANS_TIMER
expr_stmt|;
name|ND
operator|.
name|receivedra
operator|=
literal|0
expr_stmt|;
name|nd6_setmtu
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ND
block|}
end_function

begin_comment
comment|/*  * Reset ND level link MTU. This function is called when the physical MTU  * changes, which means we might have to adjust the ND level MTU.  */
end_comment

begin_function
name|void
name|nd6_setmtu
parameter_list|(
name|ifp
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
name|struct
name|nd_ifinfo
modifier|*
name|ndi
init|=
operator|&
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
decl_stmt|;
name|u_long
name|oldmaxmtu
init|=
name|ndi
operator|->
name|maxmtu
decl_stmt|;
name|u_long
name|oldlinkmtu
init|=
name|ndi
operator|->
name|linkmtu
decl_stmt|;
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
comment|/* XXX MTU handling needs more work */
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
literal|60480
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFT_ETHER
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ETHERMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFT_FDDI
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|FDDIIPMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFT_ATM
case|:
name|ndi
operator|->
name|maxmtu
operator|=
name|MIN
argument_list|(
name|ATMMTU
argument_list|,
name|ifp
operator|->
name|if_mtu
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ndi
operator|->
name|maxmtu
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|oldmaxmtu
operator|!=
name|ndi
operator|->
name|maxmtu
condition|)
block|{
comment|/* 		 * If the ND level MTU is not set yet, or if the maxmtu 		 * is reset to a smaller value than the ND level MTU, 		 * also reset the ND level MTU. 		 */
if|if
condition|(
name|ndi
operator|->
name|linkmtu
operator|==
literal|0
operator|||
name|ndi
operator|->
name|maxmtu
operator|<
name|ndi
operator|->
name|linkmtu
condition|)
block|{
name|ndi
operator|->
name|linkmtu
operator|=
name|ndi
operator|->
name|maxmtu
expr_stmt|;
comment|/* also adjust in6_maxmtu if necessary. */
if|if
condition|(
name|oldlinkmtu
operator|==
literal|0
condition|)
block|{
comment|/* 				 * XXX: the case analysis is grotty, but 				 * it is not efficient to call in6_setmaxmtu() 				 * here when we are during the initialization 				 * procedure. 				 */
if|if
condition|(
name|in6_maxmtu
operator|<
name|ndi
operator|->
name|linkmtu
condition|)
name|in6_maxmtu
operator|=
name|ndi
operator|->
name|linkmtu
expr_stmt|;
block|}
else|else
name|in6_setmaxmtu
argument_list|()
expr_stmt|;
block|}
block|}
undef|#
directive|undef
name|MIN
block|}
end_function

begin_function
name|void
name|nd6_option_init
parameter_list|(
name|opt
parameter_list|,
name|icmp6len
parameter_list|,
name|ndopts
parameter_list|)
name|void
modifier|*
name|opt
decl_stmt|;
name|int
name|icmp6len
decl_stmt|;
name|union
name|nd_opts
modifier|*
name|ndopts
decl_stmt|;
block|{
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
name|opt
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_last
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
name|opt
operator|)
operator|+
name|icmp6len
operator|)
expr_stmt|;
if|if
condition|(
name|icmp6len
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take one ND option.  */
end_comment

begin_function
name|struct
name|nd_opt_hdr
modifier|*
name|nd6_option
parameter_list|(
name|ndopts
parameter_list|)
name|union
name|nd_opts
modifier|*
name|ndopts
decl_stmt|;
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|olen
decl_stmt|;
if|if
condition|(
operator|!
name|ndopts
condition|)
name|panic
argument_list|(
literal|"ndopts == NULL in nd6_option\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndopts
operator|->
name|nd_opts_last
condition|)
name|panic
argument_list|(
literal|"uninitialized ndopts in nd6_option\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndopts
operator|->
name|nd_opts_search
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
return|return
name|NULL
return|;
name|nd_opt
operator|=
name|ndopts
operator|->
name|nd_opts_search
expr_stmt|;
name|olen
operator|=
name|nd_opt
operator|->
name|nd_opt_len
operator|<<
literal|3
expr_stmt|;
if|if
condition|(
name|olen
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Message validation requires that all included 		 * options have a length that is greater than zero. 		 */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ndopts
operator|->
name|nd_opts_search
operator|=
operator|(
expr|struct
name|nd_opt_hdr
operator|*
operator|)
operator|(
operator|(
name|caddr_t
operator|)
name|nd_opt
operator|+
name|olen
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|ndopts
operator|->
name|nd_opts_search
operator|<
name|ndopts
operator|->
name|nd_opts_last
operator|)
condition|)
block|{
name|ndopts
operator|->
name|nd_opts_done
operator|=
literal|1
expr_stmt|;
name|ndopts
operator|->
name|nd_opts_search
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|nd_opt
return|;
block|}
end_function

begin_comment
comment|/*  * Parse multiple ND options.  * This function is much easier to use, for ND routines that do not need  * multiple options of the same type.  */
end_comment

begin_function
name|int
name|nd6_options
parameter_list|(
name|ndopts
parameter_list|)
name|union
name|nd_opts
modifier|*
name|ndopts
decl_stmt|;
block|{
name|struct
name|nd_opt_hdr
modifier|*
name|nd_opt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ndopts
condition|)
name|panic
argument_list|(
literal|"ndopts == NULL in nd6_options\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndopts
operator|->
name|nd_opts_last
condition|)
name|panic
argument_list|(
literal|"uninitialized ndopts in nd6_options\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ndopts
operator|->
name|nd_opts_search
condition|)
return|return
literal|0
return|;
while|while
condition|(
literal|1
condition|)
block|{
name|nd_opt
operator|=
name|nd6_option
argument_list|(
name|ndopts
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nd_opt
operator|&&
operator|!
name|ndopts
operator|->
name|nd_opts_last
condition|)
block|{
comment|/* 			 * Message validation requires that all included 			 * options have a length that is greater than zero. 			 */
name|bzero
argument_list|(
name|ndopts
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndopts
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|nd_opt
condition|)
goto|goto
name|skip1
goto|;
switch|switch
condition|(
name|nd_opt
operator|->
name|nd_opt_type
condition|)
block|{
case|case
name|ND_OPT_SOURCE_LINKADDR
case|:
case|case
name|ND_OPT_TARGET_LINKADDR
case|:
case|case
name|ND_OPT_MTU
case|:
case|case
name|ND_OPT_REDIRECTED_HEADER
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"duplicated ND6 option found "
literal|"(type=%d)\n"
argument_list|,
name|nd_opt
operator|->
name|nd_opt_type
argument_list|)
expr_stmt|;
comment|/* XXX bark? */
block|}
else|else
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
break|break;
case|case
name|ND_OPT_PREFIX_INFORMATION
case|:
if|if
condition|(
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|==
literal|0
condition|)
block|{
name|ndopts
operator|->
name|nd_opt_array
index|[
name|nd_opt
operator|->
name|nd_opt_type
index|]
operator|=
name|nd_opt
expr_stmt|;
block|}
name|ndopts
operator|->
name|nd_opts_pi_end
operator|=
operator|(
expr|struct
name|nd_opt_prefix_info
operator|*
operator|)
name|nd_opt
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Unknown options must be silently ignored, 			 * to accomodate future extension to the protocol. 			 */
name|log
argument_list|(
name|LOG_INFO
argument_list|,
literal|"nd6_options: unsupported option %d - "
literal|"option ignored\n"
argument_list|,
name|nd_opt
operator|->
name|nd_opt_type
argument_list|)
expr_stmt|;
block|}
name|skip1
label|:
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|10
condition|)
block|{
name|printf
argument_list|(
literal|"too many loop in nd opt\n"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ndopts
operator|->
name|nd_opts_done
condition|)
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * ND6 timer routine to expire default route list and prefix list  */
end_comment

begin_function
name|void
name|nd6_timer
parameter_list|(
name|ignored_arg
parameter_list|)
name|void
modifier|*
name|ignored_arg
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
specifier|register
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
specifier|register
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
specifier|register
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|timeout
argument_list|(
name|nd6_timer
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|nd6_prune
operator|*
name|hz
argument_list|)
expr_stmt|;
name|ln
operator|=
name|llinfo_nd6
operator|.
name|ln_next
expr_stmt|;
comment|/* XXX BSD/OS separates this code -- itojun */
while|while
condition|(
name|ln
operator|&&
name|ln
operator|!=
operator|&
name|llinfo_nd6
condition|)
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|next
init|=
name|ln
operator|->
name|ln_next
decl_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|ln
operator|->
name|ln_rt
operator|)
operator|==
name|NULL
condition|)
block|{
name|ln
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|ifp
operator|=
name|rt
operator|->
name|rt_ifp
operator|)
operator|==
name|NULL
condition|)
block|{
name|ln
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
name|dst
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_expire
operator|>
name|time_second
condition|)
block|{
name|ln
operator|=
name|next
expr_stmt|;
continue|continue;
block|}
comment|/* sanity check */
if|if
condition|(
operator|!
name|rt
condition|)
name|panic
argument_list|(
literal|"rt=0 in nd6_timer(ln=%p)\n"
argument_list|,
name|ln
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst
condition|)
name|panic
argument_list|(
literal|"dst=0 in nd6_timer(ln=%p)\n"
argument_list|,
name|ln
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ln
operator|->
name|ln_state
condition|)
block|{
case|case
name|ND6_LLINFO_INCOMPLETE
case|:
if|if
condition|(
name|ln
operator|->
name|ln_asked
operator|<
name|nd6_mmaxtries
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|++
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
operator|.
name|retrans
operator|/
literal|1000
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|m
init|=
name|ln
operator|->
name|ln_hold
decl_stmt|;
if|if
condition|(
name|m
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_ifp
condition|)
block|{
comment|/* 						 * Fake rcvif to make ICMP error 						 * more helpful in diagnosing 						 * for the receiver. 						 * XXX: should we consider 						 * older rcvif? 						 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|rt
operator|->
name|rt_ifp
expr_stmt|;
block|}
name|icmp6_error
argument_list|(
name|m
argument_list|,
name|ICMP6_DST_UNREACH
argument_list|,
name|ICMP6_DST_UNREACH_ADDR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_hold
operator|=
name|NULL
expr_stmt|;
block|}
name|nd6_free
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_REACHABLE
case|:
if|if
condition|(
name|ln
operator|->
name|ln_expire
condition|)
block|{
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
break|break;
comment|/* 		 * ND6_LLINFO_STALE state requires nothing for timer 		 * routine. 		 */
case|case
name|ND6_LLINFO_DELAY
case|:
name|ln
operator|->
name|ln_asked
operator|=
literal|1
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_PROBE
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
operator|.
name|retrans
operator|/
literal|1000
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ND6_LLINFO_PROBE
case|:
if|if
condition|(
name|ln
operator|->
name|ln_asked
operator|<
name|nd6_umaxtries
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|++
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
operator|.
name|retrans
operator|/
literal|1000
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nd6_free
argument_list|(
name|rt
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ND6_LLINFO_WAITDELETE
case|:
name|nd6_free
argument_list|(
name|rt
argument_list|)
expr_stmt|;
break|break;
block|}
name|ln
operator|=
name|next
expr_stmt|;
block|}
comment|/* expire */
name|dr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
expr_stmt|;
while|while
condition|(
name|dr
condition|)
block|{
if|if
condition|(
name|dr
operator|->
name|expire
operator|&&
name|dr
operator|->
name|expire
operator|<
name|time_second
condition|)
block|{
name|struct
name|nd_defrouter
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|LIST_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
name|dr
operator|=
name|t
expr_stmt|;
block|}
else|else
name|dr
operator|=
name|LIST_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
block|}
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nd_prefix
argument_list|)
expr_stmt|;
while|while
condition|(
name|pr
condition|)
block|{
name|struct
name|in6_ifaddr
modifier|*
name|ia6
decl_stmt|;
name|struct
name|in6_addrlifetime
modifier|*
name|lt6
decl_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_addr
argument_list|)
condition|)
name|ia6
operator|=
name|NULL
expr_stmt|;
else|else
name|ia6
operator|=
name|in6ifa_ifpwithaddr
argument_list|(
name|pr
operator|->
name|ndpr_ifp
argument_list|,
operator|&
name|pr
operator|->
name|ndpr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ia6
condition|)
block|{
comment|/* check address lifetime */
name|lt6
operator|=
operator|&
name|ia6
operator|->
name|ia6_lifetime
expr_stmt|;
if|if
condition|(
name|lt6
operator|->
name|ia6t_preferred
operator|&&
name|lt6
operator|->
name|ia6t_preferred
operator|<
name|time_second
condition|)
name|ia6
operator|->
name|ia6_flags
operator||=
name|IN6_IFF_DEPRECATED
expr_stmt|;
if|if
condition|(
name|lt6
operator|->
name|ia6t_expire
operator|&&
name|lt6
operator|->
name|ia6t_expire
operator|<
name|time_second
condition|)
block|{
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_addr
argument_list|)
condition|)
name|in6_ifdel
argument_list|(
name|pr
operator|->
name|ndpr_ifp
argument_list|,
operator|&
name|pr
operator|->
name|ndpr_addr
argument_list|)
expr_stmt|;
comment|/* xxx ND_OPT_PI_FLAG_ONLINK processing */
block|}
block|}
comment|/* 		 * check prefix lifetime. 		 * since pltime is just for autoconf, pltime processing for 		 * prefix is not necessary. 		 * 		 * we offset expire time by NDPR_KEEP_EXPIRE, so that we 		 * can use the old prefix information to validate the 		 * next prefix information to come.  See prelist_update() 		 * for actual validation. 		 */
if|if
condition|(
name|pr
operator|->
name|ndpr_expire
operator|&&
name|pr
operator|->
name|ndpr_expire
operator|+
name|NDPR_KEEP_EXPIRED
operator|<
name|time_second
condition|)
block|{
name|struct
name|nd_prefix
modifier|*
name|t
decl_stmt|;
name|t
operator|=
name|LIST_NEXT
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
comment|/* 			 * address expiration and prefix expiration are 			 * separate.  NEVER perform in6_ifdel here. 			 */
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
name|pr
operator|=
name|t
expr_stmt|;
block|}
else|else
name|pr
operator|=
name|LIST_NEXT
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|rtentry
modifier|*
name|nd6_lookup
parameter_list|(
name|addr6
parameter_list|,
name|create
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|in6_addr
modifier|*
name|addr6
decl_stmt|;
name|int
name|create
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|sin6
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr6
expr_stmt|;
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|create
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is the case for the default route. 		 * If we want to create a neighbor cache for the address, we 		 * should free the route for the destination and allocate an 		 * interface route. 		 */
if|if
condition|(
name|create
condition|)
block|{
name|RTFREE
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|rt
condition|)
block|{
if|if
condition|(
name|create
operator|&&
name|ifp
condition|)
block|{
comment|/* 			 * If no route is available and create is set, 			 * we allocate a host route for the destination 			 * and treat it like an interface route. 			 * This hack is necessary for a neighbor which can't 			 * be covered by our own prefix. 			 */
name|struct
name|ifaddr
modifier|*
name|ifa
init|=
name|ifaof_ifpforaddr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|ifp
argument_list|)
decl_stmt|;
if|if
condition|(
name|ifa
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 			 * Create a new route. RTF_LLINFO is necessary 			 * to create a Neighbor Cache entry for the 			 * destination in nd6_rtrequest which will be 			 * called in rtequest via ifa->ifa_rtrequest. 			 */
if|if
condition|(
name|rtrequest
argument_list|(
name|RTM_ADD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|ifa
operator|->
name|ifa_addr
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|all1_sa
argument_list|,
operator|(
name|ifa
operator|->
name|ifa_flags
operator||
name|RTF_HOST
operator||
name|RTF_LLINFO
operator|)
operator|&
operator|~
name|RTF_CLONING
argument_list|,
operator|&
name|rt
argument_list|)
condition|)
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"nd6_lookup: failed to add route for a "
literal|"neighbor(%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|addr6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|rt
operator|->
name|rt_llinfo
condition|)
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
block|}
block|}
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
comment|/* 	 * Validation for the entry. 	 * XXX: we can't use rt->rt_ifp to check for the interface, since 	 *      it might be the loopback interface if the entry is for our 	 *      own address on a non-loopback interface. Instead, we should 	 *      use rt->rt_ifa->ifa_ifp, which would specify the REAL interface. 	 */
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
operator|||
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|||
operator|(
name|ifp
operator|&&
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_ifp
operator|!=
name|ifp
operator|)
condition|)
block|{
if|if
condition|(
name|create
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_lookup: failed to lookup %s (if = %s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
name|addr6
argument_list|)
argument_list|,
name|ifp
condition|?
name|if_name
argument_list|(
name|ifp
argument_list|)
else|:
literal|"unspec"
argument_list|)
expr_stmt|;
comment|/* xxx more logs... kazu */
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|rt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detect if a given IPv6 address identifies a neighbor on a given link.  * XXX: should take care of the destination of a p2p link?  */
end_comment

begin_function
name|int
name|nd6_is_addr_neighbor
parameter_list|(
name|addr
parameter_list|,
name|ifp
parameter_list|)
name|struct
name|in6_addr
modifier|*
name|addr
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
specifier|register
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
name|int
name|i
decl_stmt|;
define|#
directive|define
name|IFADDR6
parameter_list|(
name|a
parameter_list|)
value|((((struct in6_ifaddr *)(a))->ia_addr).sin6_addr)
define|#
directive|define
name|IFMASK6
parameter_list|(
name|a
parameter_list|)
value|((((struct in6_ifaddr *)(a))->ia_prefixmask).sin6_addr)
comment|/* A link-local address is always a neighbor. */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * If the address matches one of our addresses, 	 * it should be a neighbor. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|ifa
argument_list|,
argument|&ifp->if_addrlist
argument_list|,
argument|ifa_list
argument_list|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|AF_INET6
condition|)
name|next
label|:
continue|continue;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|IFADDR6
argument_list|(
name|ifa
argument_list|)
operator|.
name|s6_addr32
index|[
name|i
index|]
operator|^
name|addr
operator|->
name|s6_addr32
index|[
name|i
index|]
operator|)
operator|&
name|IFMASK6
argument_list|(
name|ifa
argument_list|)
operator|.
name|s6_addr32
index|[
name|i
index|]
condition|)
goto|goto
name|next
goto|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Even if the address matches none of our addresses, it might be 	 * in the neighbor cache. 	 */
if|if
condition|(
name|nd6_lookup
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|IFADDR6
undef|#
directive|undef
name|IFMASK6
block|}
end_function

begin_comment
comment|/*  * Free an nd6 llinfo entry.  */
end_comment

begin_function
name|void
name|nd6_free
parameter_list|(
name|rt
parameter_list|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_router
condition|)
block|{
comment|/* remove from default router list */
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|in6
decl_stmt|;
name|int
name|s
decl_stmt|;
name|in6
operator|=
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|dr
operator|=
name|defrouter_lookup
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
operator|)
operator|->
name|sin6_addr
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dr
condition|)
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ip6_forwarding
operator|&&
name|ip6_accept_rtadv
condition|)
block|{
comment|/* 			 * rt6_flush must be called in any case. 			 * see the comment in nd6_na_input(). 			 */
name|rt6_flush
argument_list|(
name|in6
argument_list|,
name|rt
operator|->
name|rt_ifp
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_refcnt
operator|>
literal|0
operator|&&
operator|(
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
operator|)
operator|&&
name|sdl
operator|->
name|sdl_family
operator|==
name|AF_LINK
condition|)
block|{
name|sdl
operator|->
name|sdl_alen
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_WAITDELETE
expr_stmt|;
name|ln
operator|->
name|ln_asked
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REJECT
expr_stmt|;
return|return;
block|}
name|rtrequest
argument_list|(
name|RTM_DELETE
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
literal|0
argument_list|,
name|rt_mask
argument_list|(
name|rt
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rtentry
operator|*
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Upper-layer reachability hint for Neighbor Unreachability Detection.  *  * XXX cost-effective metods?  */
end_comment

begin_function
name|void
name|nd6_nud_hint
parameter_list|(
name|rt
parameter_list|,
name|dst6
parameter_list|)
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|dst6
decl_stmt|;
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
comment|/* 	 * If the caller specified "rt", use that.  Otherwise, resolve the 	 * routing table by supplied "dst6". 	 */
if|if
condition|(
operator|!
name|rt
condition|)
block|{
if|if
condition|(
operator|!
name|dst6
condition|)
return|return;
if|if
condition|(
operator|!
operator|(
name|rt
operator|=
name|nd6_lookup
argument_list|(
name|dst6
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
return|return;
block|}
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
operator|)
operator|||
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|==
literal|0
operator|||
operator|!
name|rt
operator|->
name|rt_llinfo
operator|||
operator|!
name|rt
operator|->
name|rt_gateway
operator|||
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
comment|/* This is not a host route. */
return|return;
block|}
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_INCOMPLETE
condition|)
return|return;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_expire
condition|)
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|nd_ifinfo
index|[
name|rt
operator|->
name|rt_ifp
operator|->
name|if_index
index|]
operator|.
name|reachable
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nd6_rtrequest
parameter_list|(
name|req
parameter_list|,
name|rt
parameter_list|,
name|sa
parameter_list|)
name|int
name|req
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
comment|/* xxx unused */
block|{
name|struct
name|sockaddr
modifier|*
name|gate
init|=
name|rt
operator|->
name|rt_gateway
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
decl_stmt|;
specifier|static
name|struct
name|sockaddr_dl
name|null_sdl
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
return|return;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
comment|/* 		 * There is no backward compatibility :) 		 * 		 * if ((rt->rt_flags& RTF_HOST) == 0&& 		 *     SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff) 		 *	   rt->rt_flags |= RTF_CLONING; 		 */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
operator|||
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
condition|)
block|{
comment|/* 			 * Case 1: This route should come from 			 * a route to interface. RTF_LLINFO flag is set 			 * for a host route whose destination should be 			 * treated as on-link. 			 */
name|rt_setgate
argument_list|(
name|rt
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|null_sdl
argument_list|)
expr_stmt|;
name|gate
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|ln
condition|)
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
expr_stmt|;
if|if
condition|(
name|ln
operator|&&
name|ln
operator|->
name|ln_expire
operator|==
literal|0
condition|)
block|{
comment|/* cludge for desktops */
name|ln
operator|->
name|ln_expire
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
condition|)
break|break;
block|}
comment|/* Announce a new entry if requested. */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_ANNOUNCE
condition|)
name|nd6_na_output
argument_list|(
name|ifp
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|ip6_forwarding
condition|?
name|ND_NA_FLAG_ROUTER
else|:
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RTM_RESOLVE
case|:
if|if
condition|(
name|gate
operator|->
name|sa_family
operator|!=
name|AF_LINK
operator|||
name|gate
operator|->
name|sa_len
operator|<
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_rtrequest: bad gateway value\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
if|if
condition|(
name|ln
operator|!=
literal|0
condition|)
break|break;
comment|/* This happens on a route change */
comment|/* 		 * Case 2: This route may come from cloning, or a manual route 		 * add with a LL address. 		 */
name|R_Malloc
argument_list|(
name|ln
argument_list|,
expr|struct
name|llinfo_nd6
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ln
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
operator|(
name|caddr_t
operator|)
name|ln
expr_stmt|;
if|if
condition|(
operator|!
name|ln
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_rtrequest: malloc failed\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|nd6_inuse
operator|++
expr_stmt|;
name|nd6_allocated
operator|++
expr_stmt|;
name|Bzero
argument_list|(
name|ln
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ln
argument_list|)
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_rt
operator|=
name|rt
expr_stmt|;
comment|/* this is required for "ndp" command. - shin */
if|if
condition|(
name|req
operator|==
name|RTM_ADD
condition|)
block|{
comment|/* 			 * gate should have some valid AF_LINK entry, 			 * and ln->ln_expire should have some lifetime 			 * which is specified by ndp command. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * When req == RTM_RESOLVE, rt is created and 			 * initialized in rtrequest(), so rt_expire is 0. 			 */
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
expr_stmt|;
block|}
name|rt
operator|->
name|rt_flags
operator||=
name|RTF_LLINFO
expr_stmt|;
name|ln
operator|->
name|ln_next
operator|=
name|llinfo_nd6
operator|.
name|ln_next
expr_stmt|;
name|llinfo_nd6
operator|.
name|ln_next
operator|=
name|ln
expr_stmt|;
name|ln
operator|->
name|ln_prev
operator|=
operator|&
name|llinfo_nd6
expr_stmt|;
name|ln
operator|->
name|ln_next
operator|->
name|ln_prev
operator|=
name|ln
expr_stmt|;
comment|/* 		 * check if rt_key(rt) is one of my address assigned 		 * to the interface. 		 */
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|in6ifa_ifpwithaddr
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
block|{
name|caddr_t
name|macp
init|=
name|nd6_ifptomac
argument_list|(
name|ifp
argument_list|)
decl_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_REACHABLE
expr_stmt|;
if|if
condition|(
name|macp
condition|)
block|{
name|Bcopy
argument_list|(
name|macp
argument_list|,
name|LLADDR
argument_list|(
name|SDL
argument_list|(
name|gate
argument_list|)
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
block|}
if|if
condition|(
name|nd6_useloopback
condition|)
block|{
name|rt
operator|->
name|rt_ifp
operator|=
operator|&
name|loif
index|[
literal|0
index|]
expr_stmt|;
comment|/*XXX*/
comment|/* 				 * Make sure rt_ifa be equal to the ifaddr 				 * corresponding to the address. 				 * We need this because when we refer 				 * rt_ifa->ia6_flags in ip6_input, we assume 				 * that the rt_ifa points to the address instead 				 * of the loopback address. 				 */
if|if
condition|(
name|ifa
operator|!=
name|rt
operator|->
name|rt_ifa
condition|)
block|{
name|rt
operator|->
name|rt_ifa
operator|->
name|ifa_refcnt
operator|--
expr_stmt|;
name|ifa
operator|->
name|ifa_refcnt
operator|++
expr_stmt|;
name|rt
operator|->
name|rt_ifa
operator|=
name|ifa
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|RTM_DELETE
case|:
if|if
condition|(
operator|!
name|ln
condition|)
break|break;
name|nd6_inuse
operator|--
expr_stmt|;
name|ln
operator|->
name|ln_next
operator|->
name|ln_prev
operator|=
name|ln
operator|->
name|ln_prev
expr_stmt|;
name|ln
operator|->
name|ln_prev
operator|->
name|ln_next
operator|=
name|ln
operator|->
name|ln_next
expr_stmt|;
name|ln
operator|->
name|ln_prev
operator|=
name|NULL
expr_stmt|;
name|rt
operator|->
name|rt_llinfo
operator|=
literal|0
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_LLINFO
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_hold
condition|)
name|m_freem
argument_list|(
name|ln
operator|->
name|ln_hold
argument_list|)
expr_stmt|;
name|Free
argument_list|(
operator|(
name|caddr_t
operator|)
name|ln
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|nd6_p2p_rtrequest
parameter_list|(
name|req
parameter_list|,
name|rt
parameter_list|,
name|sa
parameter_list|)
name|int
name|req
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
comment|/* xxx unused */
block|{
name|struct
name|sockaddr
modifier|*
name|gate
init|=
name|rt
operator|->
name|rt_gateway
decl_stmt|;
specifier|static
name|struct
name|sockaddr_dl
name|null_sdl
init|=
block|{
sizeof|sizeof
argument_list|(
name|null_sdl
argument_list|)
block|,
name|AF_LINK
block|}
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|rt
operator|->
name|rt_ifp
decl_stmt|;
name|struct
name|ifaddr
modifier|*
name|ifa
decl_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
return|return;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|RTM_ADD
case|:
comment|/* 		 * There is no backward compatibility :) 		 * 		 * if ((rt->rt_flags& RTF_HOST) == 0&& 		 *     SIN(rt_mask(rt))->sin_addr.s_addr != 0xffffffff) 		 *	   rt->rt_flags |= RTF_CLONING; 		 */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_CLONING
condition|)
block|{
comment|/* 			 * Case 1: This route should come from 			 * a route to interface. 			 */
name|rt_setgate
argument_list|(
name|rt
argument_list|,
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|null_sdl
argument_list|)
expr_stmt|;
name|gate
operator|=
name|rt
operator|->
name|rt_gateway
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_type
operator|=
name|ifp
operator|->
name|if_type
expr_stmt|;
name|SDL
argument_list|(
name|gate
argument_list|)
operator|->
name|sdl_index
operator|=
name|ifp
operator|->
name|if_index
expr_stmt|;
break|break;
block|}
comment|/* Announce a new entry if requested. */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_ANNOUNCE
condition|)
name|nd6_na_output
argument_list|(
name|ifp
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|ip6_forwarding
condition|?
name|ND_NA_FLAG_ROUTER
else|:
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|RTM_RESOLVE
case|:
comment|/* 		 * check if rt_key(rt) is one of my address assigned 		 * to the interface. 		 */
name|ifa
operator|=
operator|(
expr|struct
name|ifaddr
operator|*
operator|)
name|in6ifa_ifpwithaddr
argument_list|(
name|rt
operator|->
name|rt_ifp
argument_list|,
operator|&
name|SIN6
argument_list|(
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|)
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifa
condition|)
block|{
if|if
condition|(
name|nd6_useloopback
condition|)
block|{
name|rt
operator|->
name|rt_ifp
operator|=
operator|&
name|loif
index|[
literal|0
index|]
expr_stmt|;
comment|/*XXX*/
block|}
block|}
break|break;
block|}
block|}
end_function

begin_function
name|int
name|nd6_ioctl
parameter_list|(
name|cmd
parameter_list|,
name|data
parameter_list|,
name|ifp
parameter_list|)
name|u_long
name|cmd
decl_stmt|;
name|caddr_t
name|data
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
block|{
name|struct
name|in6_drlist
modifier|*
name|drl
init|=
operator|(
expr|struct
name|in6_drlist
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_prlist
modifier|*
name|prl
init|=
operator|(
expr|struct
name|in6_prlist
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_ndireq
modifier|*
name|ndi
init|=
operator|(
expr|struct
name|in6_ndireq
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|in6_nbrinfo
modifier|*
name|nbi
init|=
operator|(
expr|struct
name|in6_nbrinfo
operator|*
operator|)
name|data
decl_stmt|;
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
name|any
decl_stmt|;
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|SIOCGDRLST_IN6
case|:
name|bzero
argument_list|(
name|drl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drl
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|dr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
expr_stmt|;
while|while
condition|(
name|dr
operator|&&
name|i
operator|<
name|DRLSTSIZ
condition|)
block|{
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
operator|=
name|dr
operator|->
name|rtaddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
argument_list|)
condition|)
block|{
comment|/* XXX: need to this hack for KAME stack */
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"default router list contains a "
literal|"non-linklocal address(%s)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtaddr
argument_list|)
argument_list|)
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|dr
operator|->
name|flags
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|rtlifetime
operator|=
name|dr
operator|->
name|rtlifetime
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|dr
operator|->
name|expire
expr_stmt|;
name|drl
operator|->
name|defrouter
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|dr
operator|->
name|ifp
operator|->
name|if_index
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|dr
operator|=
name|LIST_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIOCGPRLST_IN6
case|:
name|bzero
argument_list|(
name|prl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prl
argument_list|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nd_prefix
argument_list|)
expr_stmt|;
while|while
condition|(
name|pr
operator|&&
name|i
operator|<
name|PRLSTSIZ
condition|)
block|{
name|struct
name|nd_pfxrouter
modifier|*
name|pfr
decl_stmt|;
name|int
name|j
decl_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefix
operator|=
name|pr
operator|->
name|ndpr_prefix
operator|.
name|sin6_addr
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|raflags
operator|=
name|pr
operator|->
name|ndpr_raf
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefixlen
operator|=
name|pr
operator|->
name|ndpr_plen
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|vltime
operator|=
name|pr
operator|->
name|ndpr_vltime
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|pltime
operator|=
name|pr
operator|->
name|ndpr_pltime
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|pr
operator|->
name|ndpr_ifp
operator|->
name|if_index
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|pr
operator|->
name|ndpr_expire
expr_stmt|;
name|pfr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_advrtrs
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pfr
condition|)
block|{
if|if
condition|(
name|j
operator|<
name|DRLSTSIZ
condition|)
block|{
define|#
directive|define
name|RTRADDR
value|prl->prefix[i].advrtr[j]
name|RTRADDR
operator|=
name|pfr
operator|->
name|router
operator|->
name|rtaddr
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|RTRADDR
argument_list|)
condition|)
block|{
comment|/* XXX: hack for KAME */
name|RTRADDR
operator|.
name|s6_addr16
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|log
argument_list|(
name|LOG_ERR
argument_list|,
literal|"a router(%s) advertises "
literal|"a prefix with "
literal|"non-link local address\n"
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|RTRADDR
argument_list|)
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|RTRADDR
block|}
name|j
operator|++
expr_stmt|;
name|pfr
operator|=
name|LIST_NEXT
argument_list|(
name|pfr
argument_list|,
name|pfr_entry
argument_list|)
expr_stmt|;
block|}
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|advrtrs
operator|=
name|j
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|pr
operator|=
name|LIST_NEXT
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|{
name|struct
name|rr_prefix
modifier|*
name|rpp
decl_stmt|;
for|for
control|(
name|rpp
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|rr_prefix
argument_list|)
init|;
name|rpp
condition|;
name|rpp
operator|=
name|LIST_NEXT
argument_list|(
name|rpp
argument_list|,
name|rp_entry
argument_list|)
control|)
block|{
if|if
condition|(
name|i
operator|>=
name|PRLSTSIZ
condition|)
break|break;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefix
operator|=
name|rpp
operator|->
name|rp_prefix
operator|.
name|sin6_addr
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|raflags
operator|=
name|rpp
operator|->
name|rp_raf
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|prefixlen
operator|=
name|rpp
operator|->
name|rp_plen
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|vltime
operator|=
name|rpp
operator|->
name|rp_vltime
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|pltime
operator|=
name|rpp
operator|->
name|rp_pltime
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|if_index
operator|=
name|rpp
operator|->
name|rp_ifp
operator|->
name|if_index
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|expire
operator|=
name|rpp
operator|->
name|rp_expire
expr_stmt|;
name|prl
operator|->
name|prefix
index|[
name|i
index|]
operator|.
name|advrtrs
operator|=
literal|0
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SIOCGIFINFO_IN6
case|:
name|ndi
operator|->
name|ndi
operator|=
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
expr_stmt|;
break|break;
case|case
name|SIOCSNDFLUSH_IN6
case|:
comment|/* flush default router list */
comment|/* 		 * xxx sumikawa: should not delete route if default 		 * route equals to the top of default router list 		 */
name|bzero
argument_list|(
operator|&
name|any
argument_list|,
sizeof|sizeof
argument_list|(
name|any
argument_list|)
argument_list|)
expr_stmt|;
name|defrouter_delreq
argument_list|(
operator|&
name|any
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* xxx sumikawa: flush prefix list */
break|break;
case|case
name|SIOCSPFXFLUSH_IN6
case|:
block|{
comment|/* flush all the prefix advertised by routers */
name|struct
name|nd_prefix
modifier|*
name|pr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
for|for
control|(
name|pr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nd_prefix
argument_list|)
init|;
name|pr
condition|;
name|pr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|pr
argument_list|,
name|ndpr_entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|&
name|pr
operator|->
name|ndpr_addr
argument_list|)
condition|)
name|in6_ifdel
argument_list|(
name|pr
operator|->
name|ndpr_ifp
argument_list|,
operator|&
name|pr
operator|->
name|ndpr_addr
argument_list|)
expr_stmt|;
name|prelist_remove
argument_list|(
name|pr
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCSRTRFLUSH_IN6
case|:
block|{
comment|/* flush all the default routers */
name|struct
name|nd_defrouter
modifier|*
name|dr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|dr
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * The first entry of the list may be stored in 			 * the routing table, so we'll delete it later. 			 */
for|for
control|(
name|dr
operator|=
name|LIST_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
init|;
name|dr
condition|;
name|dr
operator|=
name|next
control|)
block|{
name|next
operator|=
name|LIST_NEXT
argument_list|(
name|dr
argument_list|,
name|dr_entry
argument_list|)
expr_stmt|;
name|defrtrlist_del
argument_list|(
name|dr
argument_list|)
expr_stmt|;
block|}
name|defrtrlist_del
argument_list|(
name|LIST_FIRST
argument_list|(
operator|&
name|nd_defrouter
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|SIOCGNBRINFO_IN6
case|:
block|{
name|struct
name|llinfo_nd6
modifier|*
name|ln
decl_stmt|;
name|struct
name|in6_addr
name|nb_addr
init|=
name|nbi
operator|->
name|addr
decl_stmt|;
comment|/* make local for safety */
comment|/* 		 * XXX: KAME specific hack for scoped addresses 		 *      XXXX: for other scopes than link-local? 		 */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|nbi
operator|->
name|addr
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
operator|&
name|nbi
operator|->
name|addr
argument_list|)
condition|)
block|{
name|u_int16_t
modifier|*
name|idp
init|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|nb_addr
operator|.
name|s6_addr
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|*
name|idp
operator|==
literal|0
condition|)
operator|*
name|idp
operator|=
name|htons
argument_list|(
name|ifp
operator|->
name|if_index
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|nb_addr
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
name|nbi
operator|->
name|state
operator|=
name|ln
operator|->
name|ln_state
expr_stmt|;
name|nbi
operator|->
name|asked
operator|=
name|ln
operator|->
name|ln_asked
expr_stmt|;
name|nbi
operator|->
name|isrouter
operator|=
name|ln
operator|->
name|ln_router
expr_stmt|;
name|nbi
operator|->
name|expire
operator|=
name|ln
operator|->
name|ln_expire
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create neighbor cache entry and cache link-layer address,  * on reception of inbound ND6 packets. (RS/RA/NS/redirect)  */
end_comment

begin_function
name|struct
name|rtentry
modifier|*
name|nd6_cache_lladdr
parameter_list|(
name|ifp
parameter_list|,
name|from
parameter_list|,
name|lladdr
parameter_list|,
name|lladdrlen
parameter_list|,
name|type
parameter_list|,
name|code
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|from
decl_stmt|;
name|char
modifier|*
name|lladdr
decl_stmt|;
name|int
name|lladdrlen
decl_stmt|;
name|int
name|type
decl_stmt|;
comment|/* ICMP6 type */
name|int
name|code
decl_stmt|;
comment|/* type dependent information */
block|{
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
name|int
name|is_newentry
decl_stmt|;
name|struct
name|sockaddr_dl
modifier|*
name|sdl
init|=
name|NULL
decl_stmt|;
name|int
name|do_update
decl_stmt|;
name|int
name|olladdr
decl_stmt|;
name|int
name|llchange
decl_stmt|;
name|int
name|newstate
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|ifp
condition|)
name|panic
argument_list|(
literal|"ifp == NULL in nd6_cache_lladdr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|from
condition|)
name|panic
argument_list|(
literal|"from == NULL in nd6_cache_lladdr"
argument_list|)
expr_stmt|;
comment|/* nothing must be updated for unspecified address */
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
name|from
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* 	 * Validation about ifp->if_addrlen and lladdrlen must be done in 	 * the caller. 	 * 	 * XXX If the link does not have link-layer adderss, what should 	 * we do? (ifp->if_addrlen == 0) 	 * Spec says nothing in sections for RA, RS and NA.  There's small 	 * description on it in NS section (RFC 2461 7.2.3). 	 */
name|rt
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
literal|0
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rt
condition|)
block|{
name|rt
operator|=
name|nd6_lookup
argument_list|(
name|from
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|is_newentry
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|is_newentry
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|rt
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
operator|(
name|RTF_GATEWAY
operator||
name|RTF_LLINFO
operator|)
operator|)
operator|!=
name|RTF_LLINFO
condition|)
block|{
name|fail
label|:
name|nd6_free
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
if|if
condition|(
operator|!
name|ln
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
operator|!
name|rt
operator|->
name|rt_gateway
condition|)
goto|goto
name|fail
goto|;
if|if
condition|(
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
goto|goto
name|fail
goto|;
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
name|olladdr
operator|=
operator|(
name|sdl
operator|->
name|sdl_alen
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|olladdr
operator|&&
name|lladdr
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|lladdr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
condition|)
name|llchange
operator|=
literal|1
expr_stmt|;
else|else
name|llchange
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|llchange
operator|=
literal|0
expr_stmt|;
comment|/* 	 * newentry olladdr  lladdr  llchange	(*=record) 	 *	0	n	n	--	(1) 	 *	0	y	n	--	(2) 	 *	0	n	y	--	(3) * STALE 	 *	0	y	y	n	(4) * 	 *	0	y	y	y	(5) * STALE 	 *	1	--	n	--	(6)   NOSTATE(= PASSIVE) 	 *	1	--	y	--	(7) * STALE 	 */
if|if
condition|(
name|lladdr
condition|)
block|{
comment|/*(3-5) and (7)*/
comment|/* 		 * Record source link-layer address 		 * XXX is it dependent to ifp->if_type? 		 */
name|sdl
operator|->
name|sdl_alen
operator|=
name|ifp
operator|->
name|if_addrlen
expr_stmt|;
name|bcopy
argument_list|(
name|lladdr
argument_list|,
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|ifp
operator|->
name|if_addrlen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_newentry
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|olladdr
operator|&&
name|lladdr
operator|)
comment|/*(3)*/
operator|||
operator|(
name|olladdr
operator|&&
name|lladdr
operator|&&
name|llchange
operator|)
condition|)
block|{
comment|/*(5)*/
name|do_update
operator|=
literal|1
expr_stmt|;
name|newstate
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
else|else
comment|/*(1-2,4)*/
name|do_update
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|do_update
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|lladdr
condition|)
comment|/*(6)*/
name|newstate
operator|=
name|ND6_LLINFO_NOSTATE
expr_stmt|;
else|else
comment|/*(7)*/
name|newstate
operator|=
name|ND6_LLINFO_STALE
expr_stmt|;
block|}
if|if
condition|(
name|do_update
condition|)
block|{
comment|/* 		 * Update the state of the neighbor cache. 		 */
name|ln
operator|->
name|ln_state
operator|=
name|newstate
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REJECT
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_hold
condition|)
block|{
name|nd6_output
argument_list|(
name|ifp
argument_list|,
name|ln
operator|->
name|ln_hold
argument_list|,
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|rt_key
argument_list|(
name|rt
argument_list|)
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_hold
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_INCOMPLETE
condition|)
block|{
comment|/* probe right away */
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
expr_stmt|;
block|}
block|}
comment|/* 	 * ICMP6 type dependent behavior. 	 * 	 * NS: clear IsRouter if new entry 	 * RS: clear IsRouter 	 * RA: set IsRouter if there's lladdr 	 * redir: clear IsRouter if new entry 	 * 	 * RA case, (1): 	 * The spec says that we must set IsRouter in the following cases: 	 * - If lladdr exist, set IsRouter.  This means (1-5). 	 * - If it is old entry (!newentry), set IsRouter.  This means (7). 	 * So, based on the spec, in (1-5) and (7) cases we must set IsRouter. 	 * A quetion arises for (1) case.  (1) case has no lladdr in the 	 * neighbor cache, this is similar to (6). 	 * This case is rare but we figured that we MUST NOT set IsRouter. 	 * 	 * newentry olladdr  lladdr  llchange	    NS  RS  RA	redir 	 *							D R 	 *	0	n	n	--	(1)	c   ?     s 	 *	0	y	n	--	(2)	c   s     s 	 *	0	n	y	--	(3)	c   s     s 	 *	0	y	y	n	(4)	c   s     s 	 *	0	y	y	y	(5)	c   s     s 	 *	1	--	n	--	(6) c	c 	c s 	 *	1	--	y	--	(7) c	c   s	c s 	 * 	 *					(c=clear s=set) 	 */
switch|switch
condition|(
name|type
operator|&
literal|0xff
condition|)
block|{
case|case
name|ND_NEIGHBOR_SOLICIT
case|:
comment|/* 		 * New entry must have is_router flag cleared. 		 */
if|if
condition|(
name|is_newentry
condition|)
comment|/*(6-7)*/
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_REDIRECT
case|:
comment|/* 		 * If the icmp is a redirect to a better router, always set the 		 * is_router flag. Otherwise, if the entry is newly created, 		 * clear the flag. [RFC 2461, sec 8.3] 		 * 		 */
if|if
condition|(
name|code
operator|==
name|ND_REDIRECT_ROUTER
condition|)
name|ln
operator|->
name|ln_router
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|is_newentry
condition|)
comment|/*(6-7)*/
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_SOLICIT
case|:
comment|/* 		 * is_router flag must always be cleared. 		 */
name|ln
operator|->
name|ln_router
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ND_ROUTER_ADVERT
case|:
comment|/* 		 * Mark an entry with lladdr as a router. 		 */
if|if
condition|(
operator|(
operator|!
name|is_newentry
operator|&&
operator|(
name|olladdr
operator|||
name|lladdr
operator|)
operator|)
comment|/*(2-5)*/
operator|||
operator|(
name|is_newentry
operator|&&
name|lladdr
operator|)
condition|)
block|{
comment|/*(7)*/
name|ln
operator|->
name|ln_router
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
return|return
name|rt
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nd6_slowtimo
parameter_list|(
name|ignored_arg
parameter_list|)
name|void
modifier|*
name|ignored_arg
decl_stmt|;
block|{
name|int
name|s
init|=
name|splnet
argument_list|()
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|struct
name|nd_ifinfo
modifier|*
name|nd6if
decl_stmt|;
name|timeout
argument_list|(
name|nd6_slowtimo
argument_list|,
operator|(
name|caddr_t
operator|)
literal|0
argument_list|,
name|ND6_SLOWTIMER_INTERVAL
operator|*
name|hz
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|if_index
operator|+
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|nd6if
operator|=
operator|&
name|nd_ifinfo
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|nd6if
operator|->
name|basereachable
operator|&&
comment|/* already initialized */
operator|(
name|nd6if
operator|->
name|recalctm
operator|-=
name|ND6_SLOWTIMER_INTERVAL
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* 			 * Since reachable time rarely changes by router 			 * advertisements, we SHOULD insure that a new random 			 * value gets recomputed at least once every few hours. 			 * (RFC 2461, 6.3.4) 			 */
name|nd6if
operator|->
name|recalctm
operator|=
name|nd6_recalc_reachtm_interval
expr_stmt|;
name|nd6if
operator|->
name|reachable
operator|=
name|ND_COMPUTE_RTIME
argument_list|(
name|nd6if
operator|->
name|basereachable
argument_list|)
expr_stmt|;
block|}
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|{ error = (e); goto bad;}
end_define

begin_function
name|int
name|nd6_output
parameter_list|(
name|ifp
parameter_list|,
name|m0
parameter_list|,
name|dst
parameter_list|,
name|rt0
parameter_list|)
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|dst
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt0
decl_stmt|;
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
specifier|register
name|struct
name|rtentry
modifier|*
name|rt
init|=
name|rt0
decl_stmt|;
name|struct
name|llinfo_nd6
modifier|*
name|ln
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
condition|)
goto|goto
name|sendpkt
goto|;
comment|/* 	 * XXX: we currently do not make neighbor cache on any interface 	 * other than ARCnet, Ethernet and FDDI. 	 */
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ARCNET
case|:
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
break|break;
default|default:
goto|goto
name|sendpkt
goto|;
block|}
comment|/* 	 * next hop determination. This routine is derived from ether_outpout. 	 */
if|if
condition|(
name|rt
condition|)
block|{
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|rt0
operator|=
name|rt
operator|=
name|rtalloc1
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|rt
operator|->
name|rt_refcnt
operator|--
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_ifp
operator|!=
name|ifp
condition|)
return|return
name|nd6_output
argument_list|(
name|ifp
argument_list|,
name|m0
argument_list|,
name|dst
argument_list|,
name|rt
argument_list|)
return|;
comment|/* XXX: loop care? */
block|}
else|else
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_GATEWAY
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_gwroute
operator|==
literal|0
condition|)
goto|goto
name|lookup
goto|;
if|if
condition|(
operator|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
operator|)
operator|->
name|rt_flags
operator|&
name|RTF_UP
operator|)
operator|==
literal|0
condition|)
block|{
name|rtfree
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|rt
operator|=
name|rt0
expr_stmt|;
name|lookup
label|:
name|rt
operator|->
name|rt_gwroute
operator|=
name|rtalloc1
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|,
literal|1
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|=
name|rt
operator|->
name|rt_gwroute
operator|)
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_REJECT
condition|)
name|senderr
argument_list|(
name|rt
operator|==
name|rt0
condition|?
name|EHOSTDOWN
else|:
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Address resolution or Neighbor Unreachability Detection 	 * for the next hop. 	 * At this point, the destination of the packet must be a unicast 	 * or an anycast address(i.e. not a multicast). 	 */
comment|/* Look up the neighbor cache for the nexthop */
if|if
condition|(
name|rt
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|RTF_LLINFO
operator|)
operator|!=
literal|0
condition|)
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|rt
operator|=
name|nd6_lookup
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
literal|1
argument_list|,
name|ifp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ln
operator|=
operator|(
expr|struct
name|llinfo_nd6
operator|*
operator|)
name|rt
operator|->
name|rt_llinfo
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ln
operator|||
operator|!
name|rt
condition|)
block|{
name|log
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"nd6_output: can't allocate llinfo for %s "
literal|"(ln=%p, rt=%p)\n"
argument_list|,
name|ip6_sprintf
argument_list|(
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|)
argument_list|,
name|ln
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX: good error? */
block|}
comment|/* 	 * The first time we send a packet to a neighbor whose entry is 	 * STALE, we have to change the state to DELAY and a sets a timer to 	 * expire in DELAY_FIRST_PROBE_TIME seconds to ensure do 	 * neighbor unreachability detection on expiration. 	 * (RFC 2461 7.3.3) 	 */
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_STALE
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|=
literal|0
expr_stmt|;
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_DELAY
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|nd6_delay
expr_stmt|;
block|}
comment|/* 	 * If the neighbor cache entry has a state other than INCOMPLETE 	 * (i.e. its link-layer address is already reloved), just 	 * send the packet. 	 */
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|>
name|ND6_LLINFO_INCOMPLETE
condition|)
goto|goto
name|sendpkt
goto|;
comment|/* 	 * There is a neighbor cache entry, but no ethernet address 	 * response yet. Replace the held mbuf (if any) with this 	 * latest one. 	 * 	 * XXX Does the code conform to rate-limiting rule? 	 * (RFC 2461 7.2.2) 	 */
if|if
condition|(
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_WAITDELETE
operator|||
name|ln
operator|->
name|ln_state
operator|==
name|ND6_LLINFO_NOSTATE
condition|)
name|ln
operator|->
name|ln_state
operator|=
name|ND6_LLINFO_INCOMPLETE
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_hold
condition|)
name|m_freem
argument_list|(
name|ln
operator|->
name|ln_hold
argument_list|)
expr_stmt|;
name|ln
operator|->
name|ln_hold
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_expire
condition|)
block|{
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|RTF_REJECT
expr_stmt|;
if|if
condition|(
name|ln
operator|->
name|ln_asked
operator|<
name|nd6_mmaxtries
operator|&&
name|ln
operator|->
name|ln_expire
operator|<
name|time_second
condition|)
block|{
name|ln
operator|->
name|ln_asked
operator|++
expr_stmt|;
name|ln
operator|->
name|ln_expire
operator|=
name|time_second
operator|+
name|nd_ifinfo
index|[
name|ifp
operator|->
name|if_index
index|]
operator|.
name|retrans
operator|/
literal|1000
expr_stmt|;
name|nd6_ns_output
argument_list|(
name|ifp
argument_list|,
name|NULL
argument_list|,
operator|&
name|dst
operator|->
name|sin6_addr
argument_list|,
name|ln
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|sendpkt
label|:
return|return
operator|(
call|(
modifier|*
name|ifp
operator|->
name|if_output
call|)
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|dst
argument_list|,
name|rt
argument_list|)
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|senderr
end_undef

begin_function
name|int
name|nd6_storelladdr
parameter_list|(
name|ifp
parameter_list|,
name|rt
parameter_list|,
name|m
parameter_list|,
name|dst
parameter_list|,
name|desten
parameter_list|)
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|struct
name|rtentry
modifier|*
name|rt
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|dst
decl_stmt|;
name|u_char
modifier|*
name|desten
decl_stmt|;
block|{
name|struct
name|sockaddr_dl
modifier|*
name|sdl
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
block|{
switch|switch
condition|(
name|ifp
operator|->
name|if_type
condition|)
block|{
case|case
name|IFT_ETHER
case|:
case|case
name|IFT_FDDI
case|:
name|ETHER_MAP_IPV6_MULTICAST
argument_list|(
operator|&
name|SIN6
argument_list|(
name|dst
argument_list|)
operator|->
name|sin6_addr
argument_list|,
name|desten
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
break|break;
case|case
name|IFT_ARCNET
case|:
operator|*
name|desten
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rt
operator|==
name|NULL
operator|||
name|rt
operator|->
name|rt_gateway
operator|->
name|sa_family
operator|!=
name|AF_LINK
condition|)
block|{
name|printf
argument_list|(
literal|"nd6_storelladdr: something odd happens\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|sdl
operator|=
name|SDL
argument_list|(
name|rt
operator|->
name|rt_gateway
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdl
operator|->
name|sdl_alen
operator|!=
literal|0
condition|)
name|bcopy
argument_list|(
name|LLADDR
argument_list|(
name|sdl
argument_list|)
argument_list|,
name|desten
argument_list|,
name|sdl
operator|->
name|sdl_alen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

